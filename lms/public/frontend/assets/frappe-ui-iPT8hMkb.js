var nb = Object.defineProperty,
	rb = Object.defineProperties;
var ob = Object.getOwnPropertyDescriptors;
var sl = Object.getOwnPropertySymbols;
var Jh = Object.prototype.hasOwnProperty,
	Gh = Object.prototype.propertyIsEnumerable;
var qh = (t, e, n) =>
		e in t
			? nb(t, e, {
					enumerable: !0,
					configurable: !0,
					writable: !0,
					value: n,
			  })
			: (t[e] = n),
	z = (t, e) => {
		for (var n in e || (e = {})) Jh.call(e, n) && qh(t, n, e[n]);
		if (sl) for (var n of sl(e)) Gh.call(e, n) && qh(t, n, e[n]);
		return t;
	},
	ye = (t, e) => rb(t, ob(e));
var et = (t, e) => {
	var n = {};
	for (var r in t) Jh.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
	if (t != null && sl)
		for (var r of sl(t)) e.indexOf(r) < 0 && Gh.call(t, r) && (n[r] = t[r]);
	return n;
};
var hr = (t, e, n) =>
	new Promise((r, o) => {
		var i = (a) => {
				try {
					l(n.next(a));
				} catch (u) {
					o(u);
				}
			},
			s = (a) => {
				try {
					l(n.throw(a));
				} catch (u) {
					o(u);
				}
			},
			l = (a) =>
				a.done ? r(a.value) : Promise.resolve(a.value).then(i, s);
		l((n = n.apply(t, e)).next());
	});
/**
 * @vue/shared v3.4.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function mf(t, e) {
	const n = new Set(t.split(","));
	return e ? (r) => n.has(r.toLowerCase()) : (r) => n.has(r);
}
const lt = {},
	ui = [],
	Mn = () => {},
	ib = () => !1,
	lu = (t) =>
		t.charCodeAt(0) === 111 &&
		t.charCodeAt(1) === 110 &&
		(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
	gf = (t) => t.startsWith("onUpdate:"),
	kt = Object.assign,
	yf = (t, e) => {
		const n = t.indexOf(e);
		n > -1 && t.splice(n, 1);
	},
	sb = Object.prototype.hasOwnProperty,
	Ye = (t, e) => sb.call(t, e),
	xe = Array.isArray,
	ci = (t) => au(t) === "[object Map]",
	v1 = (t) => au(t) === "[object Set]",
	Ee = (t) => typeof t == "function",
	mt = (t) => typeof t == "string",
	Ni = (t) => typeof t == "symbol",
	dt = (t) => t !== null && typeof t == "object",
	b1 = (t) => (dt(t) || Ee(t)) && Ee(t.then) && Ee(t.catch),
	w1 = Object.prototype.toString,
	au = (t) => w1.call(t),
	lb = (t) => au(t).slice(8, -1),
	x1 = (t) => au(t) === "[object Object]",
	vf = (t) =>
		mt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
	zl = mf(
		",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
	),
	uu = (t) => {
		const e = Object.create(null);
		return (n) => e[n] || (e[n] = t(n));
	},
	ab = /-(\w)/g,
	Fn = uu((t) => t.replace(ab, (e, n) => (n ? n.toUpperCase() : ""))),
	ub = /\B([A-Z])/g,
	lo = uu((t) => t.replace(ub, "-$1").toLowerCase()),
	cu = uu((t) => t.charAt(0).toUpperCase() + t.slice(1)),
	Xu = uu((t) => (t ? `on${cu(t)}` : "")),
	ir = (t, e) => !Object.is(t, e),
	Zu = (t, e) => {
		for (let n = 0; n < t.length; n++) t[n](e);
	},
	ra = (t, e, n) => {
		Object.defineProperty(t, e, {
			configurable: !0,
			enumerable: !1,
			value: n,
		});
	},
	cb = (t) => {
		const e = parseFloat(t);
		return isNaN(e) ? t : e;
	},
	db = (t) => {
		const e = mt(t) ? Number(t) : NaN;
		return isNaN(e) ? t : e;
	};
let Yh;
const bf = () =>
	Yh ||
	(Yh =
		typeof globalThis != "undefined"
			? globalThis
			: typeof self != "undefined"
			? self
			: typeof window != "undefined"
			? window
			: typeof global != "undefined"
			? global
			: {});
function ao(t) {
	if (xe(t)) {
		const e = {};
		for (let n = 0; n < t.length; n++) {
			const r = t[n],
				o = mt(r) ? mb(r) : ao(r);
			if (o) for (const i in o) e[i] = o[i];
		}
		return e;
	} else if (mt(t) || dt(t)) return t;
}
const fb = /;(?![^(]*\))/g,
	hb = /:([^]+)/,
	pb = /\/\*[^]*?\*\//g;
function mb(t) {
	const e = {};
	return (
		t
			.replace(pb, "")
			.split(fb)
			.forEach((n) => {
				if (n) {
					const r = n.split(hb);
					r.length > 1 && (e[r[0].trim()] = r[1].trim());
				}
			}),
		e
	);
}
function we(t) {
	let e = "";
	if (mt(t)) e = t;
	else if (xe(t))
		for (let n = 0; n < t.length; n++) {
			const r = we(t[n]);
			r && (e += r + " ");
		}
	else if (dt(t)) for (const n in t) t[n] && (e += n + " ");
	return e.trim();
}
function Ut(t) {
	if (!t) return null;
	let { class: e, style: n } = t;
	return e && !mt(e) && (t.class = we(e)), n && (t.style = ao(n)), t;
}
const gb =
		"itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
	yb = mf(gb);
function k1(t) {
	return !!t || t === "";
}
const Qe = (t) =>
		mt(t)
			? t
			: t == null
			? ""
			: xe(t) || (dt(t) && (t.toString === w1 || !Ee(t.toString)))
			? JSON.stringify(t, S1, 2)
			: String(t),
	S1 = (t, e) =>
		e && e.__v_isRef
			? S1(t, e.value)
			: ci(e)
			? {
					[`Map(${e.size})`]: [...e.entries()].reduce(
						(n, [r, o], i) => ((n[ec(r, i) + " =>"] = o), n),
						{}
					),
			  }
			: v1(e)
			? { [`Set(${e.size})`]: [...e.values()].map((n) => ec(n)) }
			: Ni(e)
			? ec(e)
			: dt(e) && !xe(e) && !x1(e)
			? String(e)
			: e,
	ec = (t, e = "") => {
		var n;
		return Ni(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t;
	};
/**
 * @vue/reactivity v3.4.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let pn;
class _1 {
	constructor(e = !1) {
		(this.detached = e),
			(this._active = !0),
			(this.effects = []),
			(this.cleanups = []),
			(this.parent = pn),
			!e &&
				pn &&
				(this.index = (pn.scopes || (pn.scopes = [])).push(this) - 1);
	}
	get active() {
		return this._active;
	}
	run(e) {
		if (this._active) {
			const n = pn;
			try {
				return (pn = this), e();
			} finally {
				pn = n;
			}
		}
	}
	on() {
		pn = this;
	}
	off() {
		pn = this.parent;
	}
	stop(e) {
		if (this._active) {
			let n, r;
			for (n = 0, r = this.effects.length; n < r; n++)
				this.effects[n].stop();
			for (n = 0, r = this.cleanups.length; n < r; n++)
				this.cleanups[n]();
			if (this.scopes)
				for (n = 0, r = this.scopes.length; n < r; n++)
					this.scopes[n].stop(!0);
			if (!this.detached && this.parent && !e) {
				const o = this.parent.scopes.pop();
				o &&
					o !== this &&
					((this.parent.scopes[this.index] = o),
					(o.index = this.index));
			}
			(this.parent = void 0), (this._active = !1);
		}
	}
}
function Cj(t) {
	return new _1(t);
}
function vb(t, e = pn) {
	e && e.active && e.effects.push(t);
}
function C1() {
	return pn;
}
function M1(t) {
	pn && pn.cleanups.push(t);
}
let Ao;
class wf {
	constructor(e, n, r, o) {
		(this.fn = e),
			(this.trigger = n),
			(this.scheduler = r),
			(this.active = !0),
			(this.deps = []),
			(this._dirtyLevel = 2),
			(this._trackId = 0),
			(this._runnings = 0),
			(this._shouldSchedule = !1),
			(this._depsLength = 0),
			vb(this, o);
	}
	get dirty() {
		if (this._dirtyLevel === 1) {
			Wo();
			for (let e = 0; e < this._depsLength; e++) {
				const n = this.deps[e];
				if (n.computed && (bb(n.computed), this._dirtyLevel >= 2))
					break;
			}
			this._dirtyLevel < 2 && (this._dirtyLevel = 0), Uo();
		}
		return this._dirtyLevel >= 2;
	}
	set dirty(e) {
		this._dirtyLevel = e ? 2 : 0;
	}
	run() {
		if (((this._dirtyLevel = 0), !this.active)) return this.fn();
		let e = Qr,
			n = Ao;
		try {
			return (
				(Qr = !0), (Ao = this), this._runnings++, Qh(this), this.fn()
			);
		} finally {
			Xh(this), this._runnings--, (Ao = n), (Qr = e);
		}
	}
	stop() {
		var e;
		this.active &&
			(Qh(this),
			Xh(this),
			(e = this.onStop) == null || e.call(this),
			(this.active = !1));
	}
}
function bb(t) {
	return t.value;
}
function Qh(t) {
	t._trackId++, (t._depsLength = 0);
}
function Xh(t) {
	if (t.deps && t.deps.length > t._depsLength) {
		for (let e = t._depsLength; e < t.deps.length; e++) E1(t.deps[e], t);
		t.deps.length = t._depsLength;
	}
}
function E1(t, e) {
	const n = t.get(e);
	n !== void 0 &&
		e._trackId !== n &&
		(t.delete(e), t.size === 0 && t.cleanup());
}
let Qr = !0,
	Qc = 0;
const T1 = [];
function Wo() {
	T1.push(Qr), (Qr = !1);
}
function Uo() {
	const t = T1.pop();
	Qr = t === void 0 ? !0 : t;
}
function xf() {
	Qc++;
}
function kf() {
	for (Qc--; !Qc && Xc.length; ) Xc.shift()();
}
function A1(t, e, n) {
	if (e.get(t) !== t._trackId) {
		e.set(t, t._trackId);
		const r = t.deps[t._depsLength];
		r !== e
			? (r && E1(r, t), (t.deps[t._depsLength++] = e))
			: t._depsLength++;
	}
}
const Xc = [];
function O1(t, e, n) {
	xf();
	for (const r of t.keys())
		if (t.get(r) === r._trackId) {
			if (r._dirtyLevel < e) {
				const o = r._dirtyLevel;
				(r._dirtyLevel = e),
					o === 0 && ((r._shouldSchedule = !0), r.trigger());
			}
			r.scheduler &&
				r._shouldSchedule &&
				(!r._runnings || r.allowRecurse) &&
				((r._shouldSchedule = !1), Xc.push(r.scheduler));
		}
	kf();
}
const R1 = (t, e) => {
		const n = new Map();
		return (n.cleanup = t), (n.computed = e), n;
	},
	oa = new WeakMap(),
	Oo = Symbol(""),
	Zc = Symbol("");
function cn(t, e, n) {
	if (Qr && Ao) {
		let r = oa.get(t);
		r || oa.set(t, (r = new Map()));
		let o = r.get(n);
		o || r.set(n, (o = R1(() => r.delete(n)))), A1(Ao, o);
	}
}
function kr(t, e, n, r, o, i) {
	const s = oa.get(t);
	if (!s) return;
	let l = [];
	if (e === "clear") l = [...s.values()];
	else if (n === "length" && xe(t)) {
		const a = Number(r);
		s.forEach((u, c) => {
			(c === "length" || (!Ni(c) && c >= a)) && l.push(u);
		});
	} else
		switch ((n !== void 0 && l.push(s.get(n)), e)) {
			case "add":
				xe(t)
					? vf(n) && l.push(s.get("length"))
					: (l.push(s.get(Oo)), ci(t) && l.push(s.get(Zc)));
				break;
			case "delete":
				xe(t) || (l.push(s.get(Oo)), ci(t) && l.push(s.get(Zc)));
				break;
			case "set":
				ci(t) && l.push(s.get(Oo));
				break;
		}
	xf();
	for (const a of l) a && O1(a, 2);
	kf();
}
function wb(t, e) {
	var n;
	return (n = oa.get(t)) == null ? void 0 : n.get(e);
}
const xb = mf("__proto__,__v_isRef,__isVue"),
	P1 = new Set(
		Object.getOwnPropertyNames(Symbol)
			.filter((t) => t !== "arguments" && t !== "caller")
			.map((t) => Symbol[t])
			.filter(Ni)
	),
	Zh = kb();
function kb() {
	const t = {};
	return (
		["includes", "indexOf", "lastIndexOf"].forEach((e) => {
			t[e] = function (...n) {
				const r = Oe(this);
				for (let i = 0, s = this.length; i < s; i++)
					cn(r, "get", i + "");
				const o = r[e](...n);
				return o === -1 || o === !1 ? r[e](...n.map(Oe)) : o;
			};
		}),
		["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
			t[e] = function (...n) {
				Wo(), xf();
				const r = Oe(this)[e].apply(this, n);
				return kf(), Uo(), r;
			};
		}),
		t
	);
}
function Sb(t) {
	const e = Oe(this);
	return cn(e, "has", t), e.hasOwnProperty(t);
}
class I1 {
	constructor(e = !1, n = !1) {
		(this._isReadonly = e), (this._shallow = n);
	}
	get(e, n, r) {
		const o = this._isReadonly,
			i = this._shallow;
		if (n === "__v_isReactive") return !o;
		if (n === "__v_isReadonly") return o;
		if (n === "__v_isShallow") return i;
		if (n === "__v_raw")
			return r === (o ? (i ? jb : L1) : i ? j1 : D1).get(e) ||
				Object.getPrototypeOf(e) === Object.getPrototypeOf(r)
				? e
				: void 0;
		const s = xe(e);
		if (!o) {
			if (s && Ye(Zh, n)) return Reflect.get(Zh, n, r);
			if (n === "hasOwnProperty") return Sb;
		}
		const l = Reflect.get(e, n, r);
		return (Ni(n) ? P1.has(n) : xb(n)) || (o || cn(e, "get", n), i)
			? l
			: qt(l)
			? s && vf(n)
				? l
				: l.value
			: dt(l)
			? o
				? fu(l)
				: Gt(l)
			: l;
	}
}
class N1 extends I1 {
	constructor(e = !1) {
		super(!1, e);
	}
	set(e, n, r, o) {
		let i = e[n];
		if (!this._shallow) {
			const a = vi(i);
			if (
				(!ia(r) && !vi(r) && ((i = Oe(i)), (r = Oe(r))),
				!xe(e) && qt(i) && !qt(r))
			)
				return a ? !1 : ((i.value = r), !0);
		}
		const s = xe(e) && vf(n) ? Number(n) < e.length : Ye(e, n),
			l = Reflect.set(e, n, r, o);
		return (
			e === Oe(o) &&
				(s ? ir(r, i) && kr(e, "set", n, r) : kr(e, "add", n, r)),
			l
		);
	}
	deleteProperty(e, n) {
		const r = Ye(e, n);
		e[n];
		const o = Reflect.deleteProperty(e, n);
		return o && r && kr(e, "delete", n, void 0), o;
	}
	has(e, n) {
		const r = Reflect.has(e, n);
		return (!Ni(n) || !P1.has(n)) && cn(e, "has", n), r;
	}
	ownKeys(e) {
		return cn(e, "iterate", xe(e) ? "length" : Oo), Reflect.ownKeys(e);
	}
}
class _b extends I1 {
	constructor(e = !1) {
		super(!0, e);
	}
	set(e, n) {
		return !0;
	}
	deleteProperty(e, n) {
		return !0;
	}
}
const Cb = new N1(),
	Mb = new _b(),
	Eb = new N1(!0),
	Sf = (t) => t,
	du = (t) => Reflect.getPrototypeOf(t);
function ll(t, e, n = !1, r = !1) {
	t = t.__v_raw;
	const o = Oe(t),
		i = Oe(e);
	n || (ir(e, i) && cn(o, "get", e), cn(o, "get", i));
	const { has: s } = du(o),
		l = r ? Sf : n ? Mf : bs;
	if (s.call(o, e)) return l(t.get(e));
	if (s.call(o, i)) return l(t.get(i));
	t !== o && t.get(e);
}
function al(t, e = !1) {
	const n = this.__v_raw,
		r = Oe(n),
		o = Oe(t);
	return (
		e || (ir(t, o) && cn(r, "has", t), cn(r, "has", o)),
		t === o ? n.has(t) : n.has(t) || n.has(o)
	);
}
function ul(t, e = !1) {
	return (
		(t = t.__v_raw),
		!e && cn(Oe(t), "iterate", Oo),
		Reflect.get(t, "size", t)
	);
}
function ep(t) {
	t = Oe(t);
	const e = Oe(this);
	return du(e).has.call(e, t) || (e.add(t), kr(e, "add", t, t)), this;
}
function tp(t, e) {
	e = Oe(e);
	const n = Oe(this),
		{ has: r, get: o } = du(n);
	let i = r.call(n, t);
	i || ((t = Oe(t)), (i = r.call(n, t)));
	const s = o.call(n, t);
	return (
		n.set(t, e),
		i ? ir(e, s) && kr(n, "set", t, e) : kr(n, "add", t, e),
		this
	);
}
function np(t) {
	const e = Oe(this),
		{ has: n, get: r } = du(e);
	let o = n.call(e, t);
	o || ((t = Oe(t)), (o = n.call(e, t))), r && r.call(e, t);
	const i = e.delete(t);
	return o && kr(e, "delete", t, void 0), i;
}
function rp() {
	const t = Oe(this),
		e = t.size !== 0,
		n = t.clear();
	return e && kr(t, "clear", void 0, void 0), n;
}
function cl(t, e) {
	return function (r, o) {
		const i = this,
			s = i.__v_raw,
			l = Oe(s),
			a = e ? Sf : t ? Mf : bs;
		return (
			!t && cn(l, "iterate", Oo),
			s.forEach((u, c) => r.call(o, a(u), a(c), i))
		);
	};
}
function dl(t, e, n) {
	return function (...r) {
		const o = this.__v_raw,
			i = Oe(o),
			s = ci(i),
			l = t === "entries" || (t === Symbol.iterator && s),
			a = t === "keys" && s,
			u = o[t](...r),
			c = n ? Sf : e ? Mf : bs;
		return (
			!e && cn(i, "iterate", a ? Zc : Oo),
			{
				next() {
					const { value: d, done: h } = u.next();
					return h
						? { value: d, done: h }
						: { value: l ? [c(d[0]), c(d[1])] : c(d), done: h };
				},
				[Symbol.iterator]() {
					return this;
				},
			}
		);
	};
}
function Ar(t) {
	return function (...e) {
		return t === "delete" ? !1 : t === "clear" ? void 0 : this;
	};
}
function Tb() {
	const t = {
			get(i) {
				return ll(this, i);
			},
			get size() {
				return ul(this);
			},
			has: al,
			add: ep,
			set: tp,
			delete: np,
			clear: rp,
			forEach: cl(!1, !1),
		},
		e = {
			get(i) {
				return ll(this, i, !1, !0);
			},
			get size() {
				return ul(this);
			},
			has: al,
			add: ep,
			set: tp,
			delete: np,
			clear: rp,
			forEach: cl(!1, !0),
		},
		n = {
			get(i) {
				return ll(this, i, !0);
			},
			get size() {
				return ul(this, !0);
			},
			has(i) {
				return al.call(this, i, !0);
			},
			add: Ar("add"),
			set: Ar("set"),
			delete: Ar("delete"),
			clear: Ar("clear"),
			forEach: cl(!0, !1),
		},
		r = {
			get(i) {
				return ll(this, i, !0, !0);
			},
			get size() {
				return ul(this, !0);
			},
			has(i) {
				return al.call(this, i, !0);
			},
			add: Ar("add"),
			set: Ar("set"),
			delete: Ar("delete"),
			clear: Ar("clear"),
			forEach: cl(!0, !0),
		};
	return (
		["keys", "values", "entries", Symbol.iterator].forEach((i) => {
			(t[i] = dl(i, !1, !1)),
				(n[i] = dl(i, !0, !1)),
				(e[i] = dl(i, !1, !0)),
				(r[i] = dl(i, !0, !0));
		}),
		[t, n, e, r]
	);
}
const [Ab, Ob, Rb, Pb] = Tb();
function _f(t, e) {
	const n = e ? (t ? Pb : Rb) : t ? Ob : Ab;
	return (r, o, i) =>
		o === "__v_isReactive"
			? !t
			: o === "__v_isReadonly"
			? t
			: o === "__v_raw"
			? r
			: Reflect.get(Ye(n, o) && o in r ? n : r, o, i);
}
const Ib = { get: _f(!1, !1) },
	Nb = { get: _f(!1, !0) },
	Db = { get: _f(!0, !1) },
	D1 = new WeakMap(),
	j1 = new WeakMap(),
	L1 = new WeakMap(),
	jb = new WeakMap();
function Lb(t) {
	switch (t) {
		case "Object":
		case "Array":
			return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet":
			return 2;
		default:
			return 0;
	}
}
function $b(t) {
	return t.__v_skip || !Object.isExtensible(t) ? 0 : Lb(lb(t));
}
function Gt(t) {
	return vi(t) ? t : Cf(t, !1, Cb, Ib, D1);
}
function $1(t) {
	return Cf(t, !1, Eb, Nb, j1);
}
function fu(t) {
	return Cf(t, !0, Mb, Db, L1);
}
function Cf(t, e, n, r, o) {
	if (!dt(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t;
	const i = o.get(t);
	if (i) return i;
	const s = $b(t);
	if (s === 0) return t;
	const l = new Proxy(t, s === 2 ? r : n);
	return o.set(t, l), l;
}
function di(t) {
	return vi(t) ? di(t.__v_raw) : !!(t && t.__v_isReactive);
}
function vi(t) {
	return !!(t && t.__v_isReadonly);
}
function ia(t) {
	return !!(t && t.__v_isShallow);
}
function B1(t) {
	return di(t) || vi(t);
}
function Oe(t) {
	const e = t && t.__v_raw;
	return e ? Oe(e) : t;
}
function hu(t) {
	return ra(t, "__v_skip", !0), t;
}
const bs = (t) => (dt(t) ? Gt(t) : t),
	Mf = (t) => (dt(t) ? fu(t) : t);
class z1 {
	constructor(e, n, r, o) {
		(this._setter = n),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this.__v_isReadonly = !1),
			(this.effect = new wf(
				() => e(this._value),
				() => ws(this, 1)
			)),
			(this.effect.computed = this),
			(this.effect.active = this._cacheable = !o),
			(this.__v_isReadonly = r);
	}
	get value() {
		const e = Oe(this);
		return (
			(!e._cacheable || e.effect.dirty) &&
				ir(e._value, (e._value = e.effect.run())) &&
				ws(e, 2),
			Ef(e),
			e._value
		);
	}
	set value(e) {
		this._setter(e);
	}
	get _dirty() {
		return this.effect.dirty;
	}
	set _dirty(e) {
		this.effect.dirty = e;
	}
}
function H1(t, e, n = !1) {
	let r, o;
	const i = Ee(t);
	return (
		i ? ((r = t), (o = Mn)) : ((r = t.get), (o = t.set)),
		new z1(r, o, i || !o, n)
	);
}
function Ef(t) {
	Qr &&
		Ao &&
		((t = Oe(t)),
		A1(
			Ao,
			t.dep ||
				(t.dep = R1(
					() => (t.dep = void 0),
					t instanceof z1 ? t : void 0
				))
		));
}
function ws(t, e = 2, n) {
	t = Oe(t);
	const r = t.dep;
	r && O1(r, e);
}
function qt(t) {
	return !!(t && t.__v_isRef === !0);
}
function X(t) {
	return F1(t, !1);
}
function pu(t) {
	return F1(t, !0);
}
function F1(t, e) {
	return qt(t) ? t : new Bb(t, e);
}
class Bb {
	constructor(e, n) {
		(this.__v_isShallow = n),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this._rawValue = n ? e : Oe(e)),
			(this._value = n ? e : bs(e));
	}
	get value() {
		return Ef(this), this._value;
	}
	set value(e) {
		const n = this.__v_isShallow || ia(e) || vi(e);
		(e = n ? e : Oe(e)),
			ir(e, this._rawValue) &&
				((this._rawValue = e),
				(this._value = n ? e : bs(e)),
				ws(this, 2));
	}
}
function op(t) {
	ws(t, 2);
}
function ue(t) {
	return qt(t) ? t.value : t;
}
const zb = {
	get: (t, e, n) => ue(Reflect.get(t, e, n)),
	set: (t, e, n, r) => {
		const o = t[e];
		return qt(o) && !qt(n) ? ((o.value = n), !0) : Reflect.set(t, e, n, r);
	},
};
function V1(t) {
	return di(t) ? t : new Proxy(t, zb);
}
class Hb {
	constructor(e) {
		(this.dep = void 0), (this.__v_isRef = !0);
		const { get: n, set: r } = e(
			() => Ef(this),
			() => ws(this)
		);
		(this._get = n), (this._set = r);
	}
	get value() {
		return this._get();
	}
	set value(e) {
		this._set(e);
	}
}
function W1(t) {
	return new Hb(t);
}
function Mj(t) {
	const e = xe(t) ? new Array(t.length) : {};
	for (const n in t) e[n] = Vb(t, n);
	return e;
}
class Fb {
	constructor(e, n, r) {
		(this._object = e),
			(this._key = n),
			(this._defaultValue = r),
			(this.__v_isRef = !0);
	}
	get value() {
		const e = this._object[this._key];
		return e === void 0 ? this._defaultValue : e;
	}
	set value(e) {
		this._object[this._key] = e;
	}
	get dep() {
		return wb(Oe(this._object), this._key);
	}
}
function Vb(t, e, n) {
	const r = t[e];
	return qt(r) ? r : new Fb(t, e, n);
}
/**
 * @vue/runtime-core v3.4.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Xr(t, e, n, r) {
	let o;
	try {
		o = r ? t(...r) : t();
	} catch (i) {
		Vs(i, e, n);
	}
	return o;
}
function En(t, e, n, r) {
	if (Ee(t)) {
		const i = Xr(t, e, n, r);
		return (
			i &&
				b1(i) &&
				i.catch((s) => {
					Vs(s, e, n);
				}),
			i
		);
	}
	const o = [];
	for (let i = 0; i < t.length; i++) o.push(En(t[i], e, n, r));
	return o;
}
function Vs(t, e, n, r = !0) {
	const o = e ? e.vnode : null;
	if (e) {
		let i = e.parent;
		const s = e.proxy,
			l = `https://vuejs.org/errors/#runtime-${n}`;
		for (; i; ) {
			const u = i.ec;
			if (u) {
				for (let c = 0; c < u.length; c++)
					if (u[c](t, s, l) === !1) return;
			}
			i = i.parent;
		}
		const a = e.appContext.config.errorHandler;
		if (a) {
			Xr(a, null, 10, [t, s, l]);
			return;
		}
	}
	Wb(t, n, o, r);
}
function Wb(t, e, n, r = !0) {
	console.error(t);
}
let xs = !1,
	ed = !1;
const Vt = [];
let Zn = 0;
const fi = [];
let Dr = null,
	xo = 0;
const U1 = Promise.resolve();
let Tf = null;
function zt(t) {
	const e = Tf || U1;
	return t ? e.then(this ? t.bind(this) : t) : e;
}
function Ub(t) {
	let e = Zn + 1,
		n = Vt.length;
	for (; e < n; ) {
		const r = (e + n) >>> 1,
			o = Vt[r],
			i = ks(o);
		i < t || (i === t && o.pre) ? (e = r + 1) : (n = r);
	}
	return e;
}
function mu(t) {
	(!Vt.length || !Vt.includes(t, xs && t.allowRecurse ? Zn + 1 : Zn)) &&
		(t.id == null ? Vt.push(t) : Vt.splice(Ub(t.id), 0, t), K1());
}
function K1() {
	!xs && !ed && ((ed = !0), (Tf = U1.then(J1)));
}
function Kb(t) {
	const e = Vt.indexOf(t);
	e > Zn && Vt.splice(e, 1);
}
function qb(t) {
	xe(t)
		? fi.push(...t)
		: (!Dr || !Dr.includes(t, t.allowRecurse ? xo + 1 : xo)) && fi.push(t),
		K1();
}
function ip(t, e, n = xs ? Zn + 1 : 0) {
	for (; n < Vt.length; n++) {
		const r = Vt[n];
		if (r && r.pre) {
			if (t && r.id !== t.uid) continue;
			Vt.splice(n, 1), n--, r();
		}
	}
}
function q1(t) {
	if (fi.length) {
		const e = [...new Set(fi)].sort((n, r) => ks(n) - ks(r));
		if (((fi.length = 0), Dr)) {
			Dr.push(...e);
			return;
		}
		for (Dr = e, xo = 0; xo < Dr.length; xo++) Dr[xo]();
		(Dr = null), (xo = 0);
	}
}
const ks = (t) => (t.id == null ? 1 / 0 : t.id),
	Jb = (t, e) => {
		const n = ks(t) - ks(e);
		if (n === 0) {
			if (t.pre && !e.pre) return -1;
			if (e.pre && !t.pre) return 1;
		}
		return n;
	};
function J1(t) {
	(ed = !1), (xs = !0), Vt.sort(Jb);
	try {
		for (Zn = 0; Zn < Vt.length; Zn++) {
			const e = Vt[Zn];
			e && e.active !== !1 && Xr(e, null, 14);
		}
	} finally {
		(Zn = 0),
			(Vt.length = 0),
			q1(),
			(xs = !1),
			(Tf = null),
			(Vt.length || fi.length) && J1();
	}
}
function Gb(t, e, ...n) {
	if (t.isUnmounted) return;
	const r = t.vnode.props || lt;
	let o = n;
	const i = e.startsWith("update:"),
		s = i && e.slice(7);
	if (s && s in r) {
		const c = `${s === "modelValue" ? "model" : s}Modifiers`,
			{ number: d, trim: h } = r[c] || lt;
		h && (o = n.map((p) => (mt(p) ? p.trim() : p))), d && (o = n.map(cb));
	}
	let l,
		a = r[(l = Xu(e))] || r[(l = Xu(Fn(e)))];
	!a && i && (a = r[(l = Xu(lo(e)))]), a && En(a, t, 6, o);
	const u = r[l + "Once"];
	if (u) {
		if (!t.emitted) t.emitted = {};
		else if (t.emitted[l]) return;
		(t.emitted[l] = !0), En(u, t, 6, o);
	}
}
function G1(t, e, n = !1) {
	const r = e.emitsCache,
		o = r.get(t);
	if (o !== void 0) return o;
	const i = t.emits;
	let s = {},
		l = !1;
	if (!Ee(t)) {
		const a = (u) => {
			const c = G1(u, e, !0);
			c && ((l = !0), kt(s, c));
		};
		!n && e.mixins.length && e.mixins.forEach(a),
			t.extends && a(t.extends),
			t.mixins && t.mixins.forEach(a);
	}
	return !i && !l
		? (dt(t) && r.set(t, null), null)
		: (xe(i) ? i.forEach((a) => (s[a] = null)) : kt(s, i),
		  dt(t) && r.set(t, s),
		  s);
}
function gu(t, e) {
	return !t || !lu(e)
		? !1
		: ((e = e.slice(2).replace(/Once$/, "")),
		  Ye(t, e[0].toLowerCase() + e.slice(1)) || Ye(t, lo(e)) || Ye(t, e));
}
let Ct = null,
	Y1 = null;
function sa(t) {
	const e = Ct;
	return (Ct = t), (Y1 = (t && t.type.__scopeId) || null), e;
}
function He(t, e = Ct, n) {
	if (!e || t._n) return t;
	const r = (...o) => {
		r._d && vp(-1);
		const i = sa(e);
		let s;
		try {
			s = t(...o);
		} finally {
			sa(i), r._d && vp(1);
		}
		return s;
	};
	return (r._n = !0), (r._c = !0), (r._d = !0), r;
}
function tc(t) {
	const {
		type: e,
		vnode: n,
		proxy: r,
		withProxy: o,
		props: i,
		propsOptions: [s],
		slots: l,
		attrs: a,
		emit: u,
		render: c,
		renderCache: d,
		data: h,
		setupState: p,
		ctx: g,
		inheritAttrs: y,
	} = t;
	let b, w;
	const S = sa(t);
	try {
		if (n.shapeFlag & 4) {
			const f = o || r,
				v = f;
			(b = Qn(c.call(v, f, d, i, p, h, g))), (w = a);
		} else {
			const f = e;
			(b = Qn(
				f.length > 1
					? f(i, { attrs: a, slots: l, emit: u })
					: f(i, null)
			)),
				(w = e.props ? a : Yb(a));
		}
	} catch (f) {
		(is.length = 0), Vs(f, t, 1), (b = be(Tn));
	}
	let E = b;
	if (w && y !== !1) {
		const f = Object.keys(w),
			{ shapeFlag: v } = E;
		f.length &&
			v & 7 &&
			(s && f.some(gf) && (w = Qb(w, s)), (E = sr(E, w)));
	}
	return (
		n.dirs &&
			((E = sr(E)), (E.dirs = E.dirs ? E.dirs.concat(n.dirs) : n.dirs)),
		n.transition && (E.transition = n.transition),
		(b = E),
		sa(S),
		b
	);
}
const Yb = (t) => {
		let e;
		for (const n in t)
			(n === "class" || n === "style" || lu(n)) &&
				((e || (e = {}))[n] = t[n]);
		return e;
	},
	Qb = (t, e) => {
		const n = {};
		for (const r in t) (!gf(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
		return n;
	};
function Xb(t, e, n) {
	const { props: r, children: o, component: i } = t,
		{ props: s, children: l, patchFlag: a } = e,
		u = i.emitsOptions;
	if (e.dirs || e.transition) return !0;
	if (n && a >= 0) {
		if (a & 1024) return !0;
		if (a & 16) return r ? sp(r, s, u) : !!s;
		if (a & 8) {
			const c = e.dynamicProps;
			for (let d = 0; d < c.length; d++) {
				const h = c[d];
				if (s[h] !== r[h] && !gu(u, h)) return !0;
			}
		}
	} else
		return (o || l) && (!l || !l.$stable)
			? !0
			: r === s
			? !1
			: r
			? s
				? sp(r, s, u)
				: !0
			: !!s;
	return !1;
}
function sp(t, e, n) {
	const r = Object.keys(e);
	if (r.length !== Object.keys(t).length) return !0;
	for (let o = 0; o < r.length; o++) {
		const i = r[o];
		if (e[i] !== t[i] && !gu(n, i)) return !0;
	}
	return !1;
}
function Zb({ vnode: t, parent: e }, n) {
	for (; e; ) {
		const r = e.subTree;
		if (
			(r.suspense && r.suspense.activeBranch === t && (r.el = t.el),
			r === t)
		)
			((t = e.vnode).el = n), (e = e.parent);
		else break;
	}
}
const Af = "components";
function nt(t, e) {
	return X1(Af, t, !0, e) || t;
}
const Q1 = Symbol.for("v-ndc");
function zn(t) {
	return mt(t) ? X1(Af, t, !1) || t : t || Q1;
}
function X1(t, e, n = !0, r = !1) {
	const o = Ct || At;
	if (o) {
		const i = o.type;
		if (t === Af) {
			const l = Kw(i, !1);
			if (l && (l === e || l === Fn(e) || l === cu(Fn(e)))) return i;
		}
		const s = lp(o[t] || i[t], e) || lp(o.appContext[t], e);
		return !s && r ? i : s;
	}
}
function lp(t, e) {
	return t && (t[e] || t[Fn(e)] || t[cu(Fn(e))]);
}
const ew = (t) => t.__isSuspense;
function tw(t, e) {
	e && e.pendingBranch
		? xe(t)
			? e.effects.push(...t)
			: e.effects.push(t)
		: qb(t);
}
const nw = Symbol.for("v-scx"),
	rw = () => qe(nw);
function bt(t, e) {
	return yu(t, null, e);
}
function ow(t, e) {
	return yu(t, null, { flush: "sync" });
}
const fl = {};
function it(t, e, n) {
	return yu(t, e, n);
}
function yu(
	t,
	e,
	{ immediate: n, deep: r, flush: o, once: i, onTrack: s, onTrigger: l } = lt
) {
	if (e && i) {
		const m = e;
		e = (...x) => {
			m(...x), v();
		};
	}
	const a = At,
		u = (m) => (r === !0 ? m : _o(m, r === !1 ? 1 : void 0));
	let c,
		d = !1,
		h = !1;
	if (
		(qt(t)
			? ((c = () => t.value), (d = ia(t)))
			: di(t)
			? ((c = () => u(t)), (d = !0))
			: xe(t)
			? ((h = !0),
			  (d = t.some((m) => di(m) || ia(m))),
			  (c = () =>
					t.map((m) => {
						if (qt(m)) return m.value;
						if (di(m)) return u(m);
						if (Ee(m)) return Xr(m, a, 2);
					})))
			: Ee(t)
			? e
				? (c = () => Xr(t, a, 2))
				: (c = () => (p && p(), En(t, a, 3, [g])))
			: (c = Mn),
		e && r)
	) {
		const m = c;
		c = () => _o(m());
	}
	let p,
		g = (m) => {
			p = E.onStop = () => {
				Xr(m, a, 4), (p = E.onStop = void 0);
			};
		},
		y;
	if (qs)
		if (
			((g = Mn),
			e ? n && En(e, a, 3, [c(), h ? [] : void 0, g]) : c(),
			o === "sync")
		) {
			const m = rw();
			y = m.__watcherHandles || (m.__watcherHandles = []);
		} else return Mn;
	let b = h ? new Array(t.length).fill(fl) : fl;
	const w = () => {
		if (!(!E.active || !E.dirty))
			if (e) {
				const m = E.run();
				(r || d || (h ? m.some((x, k) => ir(x, b[k])) : ir(m, b))) &&
					(p && p(),
					En(e, a, 3, [
						m,
						b === fl ? void 0 : h && b[0] === fl ? [] : b,
						g,
					]),
					(b = m));
			} else E.run();
	};
	w.allowRecurse = !!e;
	let S;
	o === "sync"
		? (S = w)
		: o === "post"
		? (S = () => on(w, a && a.suspense))
		: ((w.pre = !0), a && (w.id = a.uid), (S = () => mu(w)));
	const E = new wf(c, Mn, S),
		f = C1(),
		v = () => {
			E.stop(), f && yf(f.effects, E);
		};
	return (
		e
			? n
				? w()
				: (b = E.run())
			: o === "post"
			? on(E.run.bind(E), a && a.suspense)
			: E.run(),
		y && y.push(v),
		v
	);
}
function iw(t, e, n) {
	const r = this.proxy,
		o = mt(t) ? (t.includes(".") ? Z1(r, t) : () => r[t]) : t.bind(r, r);
	let i;
	Ee(e) ? (i = e) : ((i = e.handler), (n = e));
	const s = Ks(this),
		l = yu(o, i.bind(r), n);
	return s(), l;
}
function Z1(t, e) {
	const n = e.split(".");
	return () => {
		let r = t;
		for (let o = 0; o < n.length && r; o++) r = r[n[o]];
		return r;
	};
}
function _o(t, e, n = 0, r) {
	if (!dt(t) || t.__v_skip) return t;
	if (e && e > 0) {
		if (n >= e) return t;
		n++;
	}
	if (((r = r || new Set()), r.has(t))) return t;
	if ((r.add(t), qt(t))) _o(t.value, e, n, r);
	else if (xe(t)) for (let o = 0; o < t.length; o++) _o(t[o], e, n, r);
	else if (v1(t) || ci(t))
		t.forEach((o) => {
			_o(o, e, n, r);
		});
	else if (x1(t)) for (const o in t) _o(t[o], e, n, r);
	return t;
}
function e0(t, e) {
	if (Ct === null) return t;
	const n = ku(Ct) || Ct.proxy,
		r = t.dirs || (t.dirs = []);
	for (let o = 0; o < e.length; o++) {
		let [i, s, l, a = lt] = e[o];
		i &&
			(Ee(i) && (i = { mounted: i, updated: i }),
			i.deep && _o(s),
			r.push({
				dir: i,
				instance: n,
				value: s,
				oldValue: void 0,
				arg: l,
				modifiers: a,
			}));
	}
	return t;
}
function go(t, e, n, r) {
	const o = t.dirs,
		i = e && e.dirs;
	for (let s = 0; s < o.length; s++) {
		const l = o[s];
		i && (l.oldValue = i[s].value);
		let a = l.dir[r];
		a && (Wo(), En(a, n, 8, [t.el, l, t, e]), Uo());
	}
}
const jr = Symbol("_leaveCb"),
	hl = Symbol("_enterCb");
function t0() {
	const t = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map(),
	};
	return (
		Xe(() => {
			t.isMounted = !0;
		}),
		Us(() => {
			t.isUnmounting = !0;
		}),
		t
	);
}
const wn = [Function, Array],
	n0 = {
		mode: String,
		appear: Boolean,
		persisted: Boolean,
		onBeforeEnter: wn,
		onEnter: wn,
		onAfterEnter: wn,
		onEnterCancelled: wn,
		onBeforeLeave: wn,
		onLeave: wn,
		onAfterLeave: wn,
		onLeaveCancelled: wn,
		onBeforeAppear: wn,
		onAppear: wn,
		onAfterAppear: wn,
		onAppearCancelled: wn,
	},
	sw = {
		name: "BaseTransition",
		props: n0,
		setup(t, { slots: e }) {
			const n = uo(),
				r = t0();
			let o;
			return () => {
				const i = e.default && Of(e.default(), !0);
				if (!i || !i.length) return;
				let s = i[0];
				if (i.length > 1) {
					for (const y of i)
						if (y.type !== Tn) {
							s = y;
							break;
						}
				}
				const l = Oe(t),
					{ mode: a } = l;
				if (r.isLeaving) return nc(s);
				const u = ap(s);
				if (!u) return nc(s);
				const c = Ss(u, l, r, n);
				_s(u, c);
				const d = n.subTree,
					h = d && ap(d);
				let p = !1;
				const { getTransitionKey: g } = u.type;
				if (g) {
					const y = g();
					o === void 0 ? (o = y) : y !== o && ((o = y), (p = !0));
				}
				if (h && h.type !== Tn && (!ko(u, h) || p)) {
					const y = Ss(h, l, r, n);
					if ((_s(h, y), a === "out-in"))
						return (
							(r.isLeaving = !0),
							(y.afterLeave = () => {
								(r.isLeaving = !1),
									n.update.active !== !1 &&
										((n.effect.dirty = !0), n.update());
							}),
							nc(s)
						);
					a === "in-out" &&
						u.type !== Tn &&
						(y.delayLeave = (b, w, S) => {
							const E = r0(r, h);
							(E[String(h.key)] = h),
								(b[jr] = () => {
									w(),
										(b[jr] = void 0),
										delete c.delayedLeave;
								}),
								(c.delayedLeave = S);
						});
				}
				return s;
			};
		},
	},
	lw = sw;
function r0(t, e) {
	const { leavingVNodes: n } = t;
	let r = n.get(e.type);
	return r || ((r = Object.create(null)), n.set(e.type, r)), r;
}
function Ss(t, e, n, r) {
	const {
			appear: o,
			mode: i,
			persisted: s = !1,
			onBeforeEnter: l,
			onEnter: a,
			onAfterEnter: u,
			onEnterCancelled: c,
			onBeforeLeave: d,
			onLeave: h,
			onAfterLeave: p,
			onLeaveCancelled: g,
			onBeforeAppear: y,
			onAppear: b,
			onAfterAppear: w,
			onAppearCancelled: S,
		} = e,
		E = String(t.key),
		f = r0(n, t),
		v = (k, C) => {
			k && En(k, r, 9, C);
		},
		m = (k, C) => {
			const _ = C[1];
			v(k, C),
				xe(k)
					? k.every((T) => T.length <= 1) && _()
					: k.length <= 1 && _();
		},
		x = {
			mode: i,
			persisted: s,
			beforeEnter(k) {
				let C = l;
				if (!n.isMounted)
					if (o) C = y || l;
					else return;
				k[jr] && k[jr](!0);
				const _ = f[E];
				_ && ko(t, _) && _.el[jr] && _.el[jr](), v(C, [k]);
			},
			enter(k) {
				let C = a,
					_ = u,
					T = c;
				if (!n.isMounted)
					if (o) (C = b || a), (_ = w || u), (T = S || c);
					else return;
				let R = !1;
				const P = (k[hl] = (N) => {
					R ||
						((R = !0),
						N ? v(T, [k]) : v(_, [k]),
						x.delayedLeave && x.delayedLeave(),
						(k[hl] = void 0));
				});
				C ? m(C, [k, P]) : P();
			},
			leave(k, C) {
				const _ = String(t.key);
				if ((k[hl] && k[hl](!0), n.isUnmounting)) return C();
				v(d, [k]);
				let T = !1;
				const R = (k[jr] = (P) => {
					T ||
						((T = !0),
						C(),
						P ? v(g, [k]) : v(p, [k]),
						(k[jr] = void 0),
						f[_] === t && delete f[_]);
				});
				(f[_] = t), h ? m(h, [k, R]) : R();
			},
			clone(k) {
				return Ss(k, e, n, r);
			},
		};
	return x;
}
function nc(t) {
	if (Ws(t)) return (t = sr(t)), (t.children = null), t;
}
function ap(t) {
	return Ws(t) ? (t.children ? t.children[0] : void 0) : t;
}
function _s(t, e) {
	t.shapeFlag & 6 && t.component
		? _s(t.component.subTree, e)
		: t.shapeFlag & 128
		? ((t.ssContent.transition = e.clone(t.ssContent)),
		  (t.ssFallback.transition = e.clone(t.ssFallback)))
		: (t.transition = e);
}
function Of(t, e = !1, n) {
	let r = [],
		o = 0;
	for (let i = 0; i < t.length; i++) {
		let s = t[i];
		const l =
			n == null ? s.key : String(n) + String(s.key != null ? s.key : i);
		s.type === Ne
			? (s.patchFlag & 128 && o++, (r = r.concat(Of(s.children, e, l))))
			: (e || s.type !== Tn) && r.push(l != null ? sr(s, { key: l }) : s);
	}
	if (o > 1) for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
	return r;
}
/*! #__NO_SIDE_EFFECTS__ */ function Re(t, e) {
	return Ee(t) ? kt({ name: t.name }, e, { setup: t }) : t;
}
const ts = (t) => !!t.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */ function pl(t) {
	Ee(t) && (t = { loader: t });
	const {
		loader: e,
		loadingComponent: n,
		errorComponent: r,
		delay: o = 200,
		timeout: i,
		suspensible: s = !0,
		onError: l,
	} = t;
	let a = null,
		u,
		c = 0;
	const d = () => (c++, (a = null), h()),
		h = () => {
			let p;
			return (
				a ||
				(p = a =
					e()
						.catch((g) => {
							if (
								((g =
									g instanceof Error
										? g
										: new Error(String(g))),
								l)
							)
								return new Promise((y, b) => {
									l(
										g,
										() => y(d()),
										() => b(g),
										c + 1
									);
								});
							throw g;
						})
						.then((g) =>
							p !== a && a
								? a
								: (g &&
										(g.__esModule ||
											g[Symbol.toStringTag] ===
												"Module") &&
										(g = g.default),
								  (u = g),
								  g)
						))
			);
		};
	return Re({
		name: "AsyncComponentWrapper",
		__asyncLoader: h,
		get __asyncResolved() {
			return u;
		},
		setup() {
			const p = At;
			if (u) return () => rc(u, p);
			const g = (S) => {
				(a = null), Vs(S, p, 13, !r);
			};
			if ((s && p.suspense) || qs)
				return h()
					.then((S) => () => rc(S, p))
					.catch(
						(S) => (g(S), () => (r ? be(r, { error: S }) : null))
					);
			const y = X(!1),
				b = X(),
				w = X(!!o);
			return (
				o &&
					setTimeout(() => {
						w.value = !1;
					}, o),
				i != null &&
					setTimeout(() => {
						if (!y.value && !b.value) {
							const S = new Error(
								`Async component timed out after ${i}ms.`
							);
							g(S), (b.value = S);
						}
					}, i),
				h()
					.then(() => {
						(y.value = !0),
							p.parent &&
								Ws(p.parent.vnode) &&
								((p.parent.effect.dirty = !0),
								mu(p.parent.update));
					})
					.catch((S) => {
						g(S), (b.value = S);
					}),
				() => {
					if (y.value && u) return rc(u, p);
					if (b.value && r) return be(r, { error: b.value });
					if (n && !w.value) return be(n);
				}
			);
		},
	});
}
function rc(t, e) {
	const { ref: n, props: r, children: o, ce: i } = e.vnode,
		s = be(t, r, o);
	return (s.ref = n), (s.ce = i), delete e.vnode.ce, s;
}
const Ws = (t) => t.type.__isKeepAlive;
function aw(t, e) {
	o0(t, "a", e);
}
function uw(t, e) {
	o0(t, "da", e);
}
function o0(t, e, n = At) {
	const r =
		t.__wdc ||
		(t.__wdc = () => {
			let o = n;
			for (; o; ) {
				if (o.isDeactivated) return;
				o = o.parent;
			}
			return t();
		});
	if ((vu(e, r, n), n)) {
		let o = n.parent;
		for (; o && o.parent; )
			Ws(o.parent.vnode) && cw(r, e, n, o), (o = o.parent);
	}
}
function cw(t, e, n, r) {
	const o = vu(e, t, r, !0);
	Dt(() => {
		yf(r[e], o);
	}, n);
}
function vu(t, e, n = At, r = !1) {
	if (n) {
		const o = n[t] || (n[t] = []),
			i =
				e.__weh ||
				(e.__weh = (...s) => {
					if (n.isUnmounted) return;
					Wo();
					const l = Ks(n),
						a = En(e, n, t, s);
					return l(), Uo(), a;
				});
		return r ? o.unshift(i) : o.push(i), i;
	}
}
const Er =
		(t) =>
		(e, n = At) =>
			(!qs || t === "sp") && vu(t, (...r) => e(...r), n),
	dw = Er("bm"),
	Xe = Er("m"),
	fw = Er("bu"),
	i0 = Er("u"),
	Us = Er("bum"),
	Dt = Er("um"),
	hw = Er("sp"),
	pw = Er("rtg"),
	mw = Er("rtc");
function gw(t, e = At) {
	vu("ec", t, e);
}
function Pt(t, e, n, r) {
	let o;
	const i = n && n[r];
	if (xe(t) || mt(t)) {
		o = new Array(t.length);
		for (let s = 0, l = t.length; s < l; s++)
			o[s] = e(t[s], s, void 0, i && i[s]);
	} else if (typeof t == "number") {
		o = new Array(t);
		for (let s = 0; s < t; s++) o[s] = e(s + 1, s, void 0, i && i[s]);
	} else if (dt(t))
		if (t[Symbol.iterator])
			o = Array.from(t, (s, l) => e(s, l, void 0, i && i[l]));
		else {
			const s = Object.keys(t);
			o = new Array(s.length);
			for (let l = 0, a = s.length; l < a; l++) {
				const u = s[l];
				o[l] = e(t[u], u, l, i && i[l]);
			}
		}
	else o = [];
	return n && (n[r] = o), o;
}
function Ej(t, e) {
	for (let n = 0; n < e.length; n++) {
		const r = e[n];
		if (xe(r)) for (let o = 0; o < r.length; o++) t[r[o].name] = r[o].fn;
		else
			r &&
				(t[r.name] = r.key
					? (...o) => {
							const i = r.fn(...o);
							return i && (i.key = r.key), i;
					  }
					: r.fn);
	}
	return t;
}
function De(t, e, n = {}, r, o) {
	if (Ct.isCE || (Ct.parent && ts(Ct.parent) && Ct.parent.isCE))
		return e !== "default" && (n.name = e), be("slot", n, r && r());
	let i = t[e];
	i && i._c && (i._d = !1), j();
	const s = i && s0(i(n)),
		l = Fe(
			Ne,
			{ key: n.key || (s && s.key) || `_${e}` },
			s || (r ? r() : []),
			s && t._ === 1 ? 64 : -2
		);
	return (
		!o && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]),
		i && i._c && (i._d = !0),
		l
	);
}
function s0(t) {
	return t.some((e) =>
		ua(e) ? !(e.type === Tn || (e.type === Ne && !s0(e.children))) : !0
	)
		? t
		: null;
}
const td = (t) => (t ? (w0(t) ? ku(t) || t.proxy : td(t.parent)) : null),
	ns = kt(Object.create(null), {
		$: (t) => t,
		$el: (t) => t.vnode.el,
		$data: (t) => t.data,
		$props: (t) => t.props,
		$attrs: (t) => t.attrs,
		$slots: (t) => t.slots,
		$refs: (t) => t.refs,
		$parent: (t) => td(t.parent),
		$root: (t) => td(t.root),
		$emit: (t) => t.emit,
		$options: (t) => Pf(t),
		$forceUpdate: (t) =>
			t.f ||
			(t.f = () => {
				(t.effect.dirty = !0), mu(t.update);
			}),
		$nextTick: (t) => t.n || (t.n = zt.bind(t.proxy)),
		$watch: (t) => iw.bind(t),
	}),
	oc = (t, e) => t !== lt && !t.__isScriptSetup && Ye(t, e),
	yw = {
		get({ _: t }, e) {
			const {
				ctx: n,
				setupState: r,
				data: o,
				props: i,
				accessCache: s,
				type: l,
				appContext: a,
			} = t;
			let u;
			if (e[0] !== "$") {
				const p = s[e];
				if (p !== void 0)
					switch (p) {
						case 1:
							return r[e];
						case 2:
							return o[e];
						case 4:
							return n[e];
						case 3:
							return i[e];
					}
				else {
					if (oc(r, e)) return (s[e] = 1), r[e];
					if (o !== lt && Ye(o, e)) return (s[e] = 2), o[e];
					if ((u = t.propsOptions[0]) && Ye(u, e))
						return (s[e] = 3), i[e];
					if (n !== lt && Ye(n, e)) return (s[e] = 4), n[e];
					nd && (s[e] = 0);
				}
			}
			const c = ns[e];
			let d, h;
			if (c) return e === "$attrs" && cn(t, "get", e), c(t);
			if ((d = l.__cssModules) && (d = d[e])) return d;
			if (n !== lt && Ye(n, e)) return (s[e] = 4), n[e];
			if (((h = a.config.globalProperties), Ye(h, e))) return h[e];
		},
		set({ _: t }, e, n) {
			const { data: r, setupState: o, ctx: i } = t;
			return oc(o, e)
				? ((o[e] = n), !0)
				: r !== lt && Ye(r, e)
				? ((r[e] = n), !0)
				: Ye(t.props, e) || (e[0] === "$" && e.slice(1) in t)
				? !1
				: ((i[e] = n), !0);
		},
		has(
			{
				_: {
					data: t,
					setupState: e,
					accessCache: n,
					ctx: r,
					appContext: o,
					propsOptions: i,
				},
			},
			s
		) {
			let l;
			return (
				!!n[s] ||
				(t !== lt && Ye(t, s)) ||
				oc(e, s) ||
				((l = i[0]) && Ye(l, s)) ||
				Ye(r, s) ||
				Ye(ns, s) ||
				Ye(o.config.globalProperties, s)
			);
		},
		defineProperty(t, e, n) {
			return (
				n.get != null
					? (t._.accessCache[e] = 0)
					: Ye(n, "value") && this.set(t, e, n.value, null),
				Reflect.defineProperty(t, e, n)
			);
		},
	};
function l0() {
	return a0().slots;
}
function Rf() {
	return a0().attrs;
}
function a0() {
	const t = uo();
	return t.setupContext || (t.setupContext = k0(t));
}
function la(t) {
	return xe(t) ? t.reduce((e, n) => ((e[n] = null), e), {}) : t;
}
function Tj(t, e) {
	return !t || !e
		? t || e
		: xe(t) && xe(e)
		? t.concat(e)
		: kt({}, la(t), la(e));
}
let nd = !0;
function vw(t) {
	const e = Pf(t),
		n = t.proxy,
		r = t.ctx;
	(nd = !1), e.beforeCreate && up(e.beforeCreate, t, "bc");
	const {
		data: o,
		computed: i,
		methods: s,
		watch: l,
		provide: a,
		inject: u,
		created: c,
		beforeMount: d,
		mounted: h,
		beforeUpdate: p,
		updated: g,
		activated: y,
		deactivated: b,
		beforeDestroy: w,
		beforeUnmount: S,
		destroyed: E,
		unmounted: f,
		render: v,
		renderTracked: m,
		renderTriggered: x,
		errorCaptured: k,
		serverPrefetch: C,
		expose: _,
		inheritAttrs: T,
		components: R,
		directives: P,
		filters: N,
	} = e;
	if ((u && bw(u, r, null), s))
		for (const I in s) {
			const $ = s[I];
			Ee($) && (r[I] = $.bind(n));
		}
	if (o) {
		const I = o.call(n, n);
		dt(I) && (t.data = Gt(I));
	}
	if (((nd = !0), i))
		for (const I in i) {
			const $ = i[I],
				V = Ee($) ? $.bind(n, n) : Ee($.get) ? $.get.bind(n, n) : Mn,
				ie = !Ee($) && Ee($.set) ? $.set.bind(n) : Mn,
				Y = H({ get: V, set: ie });
			Object.defineProperty(r, I, {
				enumerable: !0,
				configurable: !0,
				get: () => Y.value,
				set: (he) => (Y.value = he),
			});
		}
	if (l) for (const I in l) u0(l[I], r, n, I);
	if (a) {
		const I = Ee(a) ? a.call(n) : a;
		Reflect.ownKeys(I).forEach(($) => {
			vt($, I[$]);
		});
	}
	c && up(c, t, "c");
	function M(I, $) {
		xe($) ? $.forEach((V) => I(V.bind(n))) : $ && I($.bind(n));
	}
	if (
		(M(dw, d),
		M(Xe, h),
		M(fw, p),
		M(i0, g),
		M(aw, y),
		M(uw, b),
		M(gw, k),
		M(mw, m),
		M(pw, x),
		M(Us, S),
		M(Dt, f),
		M(hw, C),
		xe(_))
	)
		if (_.length) {
			const I = t.exposed || (t.exposed = {});
			_.forEach(($) => {
				Object.defineProperty(I, $, {
					get: () => n[$],
					set: (V) => (n[$] = V),
				});
			});
		} else t.exposed || (t.exposed = {});
	v && t.render === Mn && (t.render = v),
		T != null && (t.inheritAttrs = T),
		R && (t.components = R),
		P && (t.directives = P);
}
function bw(t, e, n = Mn) {
	xe(t) && (t = rd(t));
	for (const r in t) {
		const o = t[r];
		let i;
		dt(o)
			? "default" in o
				? (i = qe(o.from || r, o.default, !0))
				: (i = qe(o.from || r))
			: (i = qe(o)),
			qt(i)
				? Object.defineProperty(e, r, {
						enumerable: !0,
						configurable: !0,
						get: () => i.value,
						set: (s) => (i.value = s),
				  })
				: (e[r] = i);
	}
}
function up(t, e, n) {
	En(xe(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function u0(t, e, n, r) {
	const o = r.includes(".") ? Z1(n, r) : () => n[r];
	if (mt(t)) {
		const i = e[t];
		Ee(i) && it(o, i);
	} else if (Ee(t)) it(o, t.bind(n));
	else if (dt(t))
		if (xe(t)) t.forEach((i) => u0(i, e, n, r));
		else {
			const i = Ee(t.handler) ? t.handler.bind(n) : e[t.handler];
			Ee(i) && it(o, i, t);
		}
}
function Pf(t) {
	const e = t.type,
		{ mixins: n, extends: r } = e,
		{
			mixins: o,
			optionsCache: i,
			config: { optionMergeStrategies: s },
		} = t.appContext,
		l = i.get(e);
	let a;
	return (
		l
			? (a = l)
			: !o.length && !n && !r
			? (a = e)
			: ((a = {}),
			  o.length && o.forEach((u) => aa(a, u, s, !0)),
			  aa(a, e, s)),
		dt(e) && i.set(e, a),
		a
	);
}
function aa(t, e, n, r = !1) {
	const { mixins: o, extends: i } = e;
	i && aa(t, i, n, !0), o && o.forEach((s) => aa(t, s, n, !0));
	for (const s in e)
		if (!(r && s === "expose")) {
			const l = ww[s] || (n && n[s]);
			t[s] = l ? l(t[s], e[s]) : e[s];
		}
	return t;
}
const ww = {
	data: cp,
	props: dp,
	emits: dp,
	methods: Gi,
	computed: Gi,
	beforeCreate: Xt,
	created: Xt,
	beforeMount: Xt,
	mounted: Xt,
	beforeUpdate: Xt,
	updated: Xt,
	beforeDestroy: Xt,
	beforeUnmount: Xt,
	destroyed: Xt,
	unmounted: Xt,
	activated: Xt,
	deactivated: Xt,
	errorCaptured: Xt,
	serverPrefetch: Xt,
	components: Gi,
	directives: Gi,
	watch: kw,
	provide: cp,
	inject: xw,
};
function cp(t, e) {
	return e
		? t
			? function () {
					return kt(
						Ee(t) ? t.call(this, this) : t,
						Ee(e) ? e.call(this, this) : e
					);
			  }
			: e
		: t;
}
function xw(t, e) {
	return Gi(rd(t), rd(e));
}
function rd(t) {
	if (xe(t)) {
		const e = {};
		for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
		return e;
	}
	return t;
}
function Xt(t, e) {
	return t ? [...new Set([].concat(t, e))] : e;
}
function Gi(t, e) {
	return t ? kt(Object.create(null), t, e) : e;
}
function dp(t, e) {
	return t
		? xe(t) && xe(e)
			? [...new Set([...t, ...e])]
			: kt(Object.create(null), la(t), la(e != null ? e : {}))
		: e;
}
function kw(t, e) {
	if (!t) return e;
	if (!e) return t;
	const n = kt(Object.create(null), t);
	for (const r in e) n[r] = Xt(t[r], e[r]);
	return n;
}
function c0() {
	return {
		app: null,
		config: {
			isNativeTag: ib,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {},
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap(),
		propsCache: new WeakMap(),
		emitsCache: new WeakMap(),
	};
}
let Sw = 0;
function _w(t, e) {
	return function (r, o = null) {
		Ee(r) || (r = kt({}, r)), o != null && !dt(o) && (o = null);
		const i = c0(),
			s = new WeakSet();
		let l = !1;
		const a = (i.app = {
			_uid: Sw++,
			_component: r,
			_props: o,
			_container: null,
			_context: i,
			_instance: null,
			version: Jw,
			get config() {
				return i.config;
			},
			set config(u) {},
			use(u, ...c) {
				return (
					s.has(u) ||
						(u && Ee(u.install)
							? (s.add(u), u.install(a, ...c))
							: Ee(u) && (s.add(u), u(a, ...c))),
					a
				);
			},
			mixin(u) {
				return i.mixins.includes(u) || i.mixins.push(u), a;
			},
			component(u, c) {
				return c ? ((i.components[u] = c), a) : i.components[u];
			},
			directive(u, c) {
				return c ? ((i.directives[u] = c), a) : i.directives[u];
			},
			mount(u, c, d) {
				if (!l) {
					const h = be(r, o);
					return (
						(h.appContext = i),
						d === !0 ? (d = "svg") : d === !1 && (d = void 0),
						c && e ? e(h, u) : t(h, u, d),
						(l = !0),
						(a._container = u),
						(u.__vue_app__ = a),
						ku(h.component) || h.component.proxy
					);
				}
			},
			unmount() {
				l && (t(null, a._container), delete a._container.__vue_app__);
			},
			provide(u, c) {
				return (i.provides[u] = c), a;
			},
			runWithContext(u) {
				Cs = a;
				try {
					return u();
				} finally {
					Cs = null;
				}
			},
		});
		return a;
	};
}
let Cs = null;
function vt(t, e) {
	if (At) {
		let n = At.provides;
		const r = At.parent && At.parent.provides;
		r === n && (n = At.provides = Object.create(r)), (n[t] = e);
	}
}
function qe(t, e, n = !1) {
	const r = At || Ct;
	if (r || Cs) {
		const o = r
			? r.parent == null
				? r.vnode.appContext && r.vnode.appContext.provides
				: r.parent.provides
			: Cs._context.provides;
		if (o && t in o) return o[t];
		if (arguments.length > 1) return n && Ee(e) ? e.call(r && r.proxy) : e;
	}
}
function Aj() {
	return !!(At || Ct || Cs);
}
function Cw(t, e, n, r = !1) {
	const o = {},
		i = {};
	ra(i, xu, 1), (t.propsDefaults = Object.create(null)), d0(t, e, o, i);
	for (const s in t.propsOptions[0]) s in o || (o[s] = void 0);
	n
		? (t.props = r ? o : $1(o))
		: t.type.props
		? (t.props = o)
		: (t.props = i),
		(t.attrs = i);
}
function Mw(t, e, n, r) {
	const {
			props: o,
			attrs: i,
			vnode: { patchFlag: s },
		} = t,
		l = Oe(o),
		[a] = t.propsOptions;
	let u = !1;
	if ((r || s > 0) && !(s & 16)) {
		if (s & 8) {
			const c = t.vnode.dynamicProps;
			for (let d = 0; d < c.length; d++) {
				let h = c[d];
				if (gu(t.emitsOptions, h)) continue;
				const p = e[h];
				if (a)
					if (Ye(i, h)) p !== i[h] && ((i[h] = p), (u = !0));
					else {
						const g = Fn(h);
						o[g] = od(a, l, g, p, t, !1);
					}
				else p !== i[h] && ((i[h] = p), (u = !0));
			}
		}
	} else {
		d0(t, e, o, i) && (u = !0);
		let c;
		for (const d in l)
			(!e || (!Ye(e, d) && ((c = lo(d)) === d || !Ye(e, c)))) &&
				(a
					? n &&
					  (n[d] !== void 0 || n[c] !== void 0) &&
					  (o[d] = od(a, l, d, void 0, t, !0))
					: delete o[d]);
		if (i !== l)
			for (const d in i) (!e || !Ye(e, d)) && (delete i[d], (u = !0));
	}
	u && kr(t, "set", "$attrs");
}
function d0(t, e, n, r) {
	const [o, i] = t.propsOptions;
	let s = !1,
		l;
	if (e)
		for (let a in e) {
			if (zl(a)) continue;
			const u = e[a];
			let c;
			o && Ye(o, (c = Fn(a)))
				? !i || !i.includes(c)
					? (n[c] = u)
					: ((l || (l = {}))[c] = u)
				: gu(t.emitsOptions, a) ||
				  ((!(a in r) || u !== r[a]) && ((r[a] = u), (s = !0)));
		}
	if (i) {
		const a = Oe(n),
			u = l || lt;
		for (let c = 0; c < i.length; c++) {
			const d = i[c];
			n[d] = od(o, a, d, u[d], t, !Ye(u, d));
		}
	}
	return s;
}
function od(t, e, n, r, o, i) {
	const s = t[n];
	if (s != null) {
		const l = Ye(s, "default");
		if (l && r === void 0) {
			const a = s.default;
			if (s.type !== Function && !s.skipFactory && Ee(a)) {
				const { propsDefaults: u } = o;
				if (n in u) r = u[n];
				else {
					const c = Ks(o);
					(r = u[n] = a.call(null, e)), c();
				}
			} else r = a;
		}
		s[0] &&
			(i && !l
				? (r = !1)
				: s[1] && (r === "" || r === lo(n)) && (r = !0));
	}
	return r;
}
function f0(t, e, n = !1) {
	const r = e.propsCache,
		o = r.get(t);
	if (o) return o;
	const i = t.props,
		s = {},
		l = [];
	let a = !1;
	if (!Ee(t)) {
		const c = (d) => {
			a = !0;
			const [h, p] = f0(d, e, !0);
			kt(s, h), p && l.push(...p);
		};
		!n && e.mixins.length && e.mixins.forEach(c),
			t.extends && c(t.extends),
			t.mixins && t.mixins.forEach(c);
	}
	if (!i && !a) return dt(t) && r.set(t, ui), ui;
	if (xe(i))
		for (let c = 0; c < i.length; c++) {
			const d = Fn(i[c]);
			fp(d) && (s[d] = lt);
		}
	else if (i)
		for (const c in i) {
			const d = Fn(c);
			if (fp(d)) {
				const h = i[c],
					p = (s[d] = xe(h) || Ee(h) ? { type: h } : kt({}, h));
				if (p) {
					const g = mp(Boolean, p.type),
						y = mp(String, p.type);
					(p[0] = g > -1),
						(p[1] = y < 0 || g < y),
						(g > -1 || Ye(p, "default")) && l.push(d);
				}
			}
		}
	const u = [s, l];
	return dt(t) && r.set(t, u), u;
}
function fp(t) {
	return t[0] !== "$";
}
function hp(t) {
	const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
	return e ? e[2] : t === null ? "null" : "";
}
function pp(t, e) {
	return hp(t) === hp(e);
}
function mp(t, e) {
	return xe(e) ? e.findIndex((n) => pp(n, t)) : Ee(e) && pp(e, t) ? 0 : -1;
}
const h0 = (t) => t[0] === "_" || t === "$stable",
	If = (t) => (xe(t) ? t.map(Qn) : [Qn(t)]),
	Ew = (t, e, n) => {
		if (e._n) return e;
		const r = He((...o) => If(e(...o)), n);
		return (r._c = !1), r;
	},
	p0 = (t, e, n) => {
		const r = t._ctx;
		for (const o in t) {
			if (h0(o)) continue;
			const i = t[o];
			if (Ee(i)) e[o] = Ew(o, i, r);
			else if (i != null) {
				const s = If(i);
				e[o] = () => s;
			}
		}
	},
	m0 = (t, e) => {
		const n = If(e);
		t.slots.default = () => n;
	},
	Tw = (t, e) => {
		if (t.vnode.shapeFlag & 32) {
			const n = e._;
			n ? ((t.slots = Oe(e)), ra(e, "_", n)) : p0(e, (t.slots = {}));
		} else (t.slots = {}), e && m0(t, e);
		ra(t.slots, xu, 1);
	},
	Aw = (t, e, n) => {
		const { vnode: r, slots: o } = t;
		let i = !0,
			s = lt;
		if (r.shapeFlag & 32) {
			const l = e._;
			l
				? n && l === 1
					? (i = !1)
					: (kt(o, e), !n && l === 1 && delete o._)
				: ((i = !e.$stable), p0(e, o)),
				(s = e);
		} else e && (m0(t, e), (s = { default: 1 }));
		if (i) for (const l in o) !h0(l) && s[l] == null && delete o[l];
	};
function id(t, e, n, r, o = !1) {
	if (xe(t)) {
		t.forEach((h, p) => id(h, e && (xe(e) ? e[p] : e), n, r, o));
		return;
	}
	if (ts(r) && !o) return;
	const i = r.shapeFlag & 4 ? ku(r.component) || r.component.proxy : r.el,
		s = o ? null : i,
		{ i: l, r: a } = t,
		u = e && e.r,
		c = l.refs === lt ? (l.refs = {}) : l.refs,
		d = l.setupState;
	if (
		(u != null &&
			u !== a &&
			(mt(u)
				? ((c[u] = null), Ye(d, u) && (d[u] = null))
				: qt(u) && (u.value = null)),
		Ee(a))
	)
		Xr(a, l, 12, [s, c]);
	else {
		const h = mt(a),
			p = qt(a);
		if (h || p) {
			const g = () => {
				if (t.f) {
					const y = h ? (Ye(d, a) ? d[a] : c[a]) : a.value;
					o
						? xe(y) && yf(y, i)
						: xe(y)
						? y.includes(i) || y.push(i)
						: h
						? ((c[a] = [i]), Ye(d, a) && (d[a] = c[a]))
						: ((a.value = [i]), t.k && (c[t.k] = a.value));
				} else
					h
						? ((c[a] = s), Ye(d, a) && (d[a] = s))
						: p && ((a.value = s), t.k && (c[t.k] = s));
			};
			s ? ((g.id = -1), on(g, n)) : g();
		}
	}
}
function Ow() {
	typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" &&
		(bf().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1);
}
const on = tw;
function Rw(t) {
	return Pw(t);
}
function Pw(t, e) {
	Ow();
	const n = bf();
	n.__VUE__ = !0;
	const {
			insert: r,
			remove: o,
			patchProp: i,
			createElement: s,
			createText: l,
			createComment: a,
			setText: u,
			setElementText: c,
			parentNode: d,
			nextSibling: h,
			setScopeId: p = Mn,
			insertStaticContent: g,
		} = t,
		y = (
			A,
			O,
			L,
			K = null,
			W = null,
			ee = null,
			le = void 0,
			Q = null,
			te = !!O.dynamicChildren
		) => {
			if (A === O) return;
			A && !ko(A, O) && ((K = B(A)), he(A, W, ee, !0), (A = null)),
				O.patchFlag === -2 && ((te = !1), (O.dynamicChildren = null));
			const { type: G, ref: ae, shapeFlag: ge } = O;
			switch (G) {
				case wu:
					b(A, O, L, K);
					break;
				case Tn:
					w(A, O, L, K);
					break;
				case Hl:
					A == null && S(O, L, K, le);
					break;
				case Ne:
					R(A, O, L, K, W, ee, le, Q, te);
					break;
				default:
					ge & 1
						? v(A, O, L, K, W, ee, le, Q, te)
						: ge & 6
						? P(A, O, L, K, W, ee, le, Q, te)
						: (ge & 64 || ge & 128) &&
						  G.process(A, O, L, K, W, ee, le, Q, te, ce);
			}
			ae != null && W && id(ae, A && A.ref, ee, O || A, !O);
		},
		b = (A, O, L, K) => {
			if (A == null) r((O.el = l(O.children)), L, K);
			else {
				const W = (O.el = A.el);
				O.children !== A.children && u(W, O.children);
			}
		},
		w = (A, O, L, K) => {
			A == null ? r((O.el = a(O.children || "")), L, K) : (O.el = A.el);
		},
		S = (A, O, L, K) => {
			[A.el, A.anchor] = g(A.children, O, L, K, A.el, A.anchor);
		},
		E = ({ el: A, anchor: O }, L, K) => {
			let W;
			for (; A && A !== O; ) (W = h(A)), r(A, L, K), (A = W);
			r(O, L, K);
		},
		f = ({ el: A, anchor: O }) => {
			let L;
			for (; A && A !== O; ) (L = h(A)), o(A), (A = L);
			o(O);
		},
		v = (A, O, L, K, W, ee, le, Q, te) => {
			O.type === "svg"
				? (le = "svg")
				: O.type === "math" && (le = "mathml"),
				A == null
					? m(O, L, K, W, ee, le, Q, te)
					: C(A, O, W, ee, le, Q, te);
		},
		m = (A, O, L, K, W, ee, le, Q) => {
			let te, G;
			const { props: ae, shapeFlag: ge, transition: me, dirs: Se } = A;
			if (
				((te = A.el = s(A.type, ee, ae && ae.is, ae)),
				ge & 8
					? c(te, A.children)
					: ge & 16 &&
					  k(A.children, te, null, K, W, ic(A, ee), le, Q),
				Se && go(A, null, K, "created"),
				x(te, A, A.scopeId, le, K),
				ae)
			) {
				for (const Ge in ae)
					Ge !== "value" &&
						!zl(Ge) &&
						i(te, Ge, null, ae[Ge], ee, A.children, K, W, Te);
				"value" in ae && i(te, "value", null, ae.value, ee),
					(G = ae.onVnodeBeforeMount) && Kn(G, K, A);
			}
			Se && go(A, null, K, "beforeMount");
			const Pe = Iw(W, me);
			Pe && me.beforeEnter(te),
				r(te, O, L),
				((G = ae && ae.onVnodeMounted) || Pe || Se) &&
					on(() => {
						G && Kn(G, K, A),
							Pe && me.enter(te),
							Se && go(A, null, K, "mounted");
					}, W);
		},
		x = (A, O, L, K, W) => {
			if ((L && p(A, L), K))
				for (let ee = 0; ee < K.length; ee++) p(A, K[ee]);
			if (W) {
				let ee = W.subTree;
				if (O === ee) {
					const le = W.vnode;
					x(A, le, le.scopeId, le.slotScopeIds, W.parent);
				}
			}
		},
		k = (A, O, L, K, W, ee, le, Q, te = 0) => {
			for (let G = te; G < A.length; G++) {
				const ae = (A[G] = Q ? Lr(A[G]) : Qn(A[G]));
				y(null, ae, O, L, K, W, ee, le, Q);
			}
		},
		C = (A, O, L, K, W, ee, le) => {
			const Q = (O.el = A.el);
			let { patchFlag: te, dynamicChildren: G, dirs: ae } = O;
			te |= A.patchFlag & 16;
			const ge = A.props || lt,
				me = O.props || lt;
			let Se;
			if (
				(L && yo(L, !1),
				(Se = me.onVnodeBeforeUpdate) && Kn(Se, L, O, A),
				ae && go(O, A, L, "beforeUpdate"),
				L && yo(L, !0),
				G
					? _(A.dynamicChildren, G, Q, L, K, ic(O, W), ee)
					: le || $(A, O, Q, null, L, K, ic(O, W), ee, !1),
				te > 0)
			) {
				if (te & 16) T(Q, O, ge, me, L, K, W);
				else if (
					(te & 2 &&
						ge.class !== me.class &&
						i(Q, "class", null, me.class, W),
					te & 4 && i(Q, "style", ge.style, me.style, W),
					te & 8)
				) {
					const Pe = O.dynamicProps;
					for (let Ge = 0; Ge < Pe.length; Ge++) {
						const st = Pe[Ge],
							St = ge[st],
							hn = me[st];
						(hn !== St || st === "value") &&
							i(Q, st, St, hn, W, A.children, L, K, Te);
					}
				}
				te & 1 && A.children !== O.children && c(Q, O.children);
			} else !le && G == null && T(Q, O, ge, me, L, K, W);
			((Se = me.onVnodeUpdated) || ae) &&
				on(() => {
					Se && Kn(Se, L, O, A), ae && go(O, A, L, "updated");
				}, K);
		},
		_ = (A, O, L, K, W, ee, le) => {
			for (let Q = 0; Q < O.length; Q++) {
				const te = A[Q],
					G = O[Q],
					ae =
						te.el &&
						(te.type === Ne || !ko(te, G) || te.shapeFlag & 70)
							? d(te.el)
							: L;
				y(te, G, ae, null, K, W, ee, le, !0);
			}
		},
		T = (A, O, L, K, W, ee, le) => {
			if (L !== K) {
				if (L !== lt)
					for (const Q in L)
						!zl(Q) &&
							!(Q in K) &&
							i(A, Q, L[Q], null, le, O.children, W, ee, Te);
				for (const Q in K) {
					if (zl(Q)) continue;
					const te = K[Q],
						G = L[Q];
					te !== G &&
						Q !== "value" &&
						i(A, Q, G, te, le, O.children, W, ee, Te);
				}
				"value" in K && i(A, "value", L.value, K.value, le);
			}
		},
		R = (A, O, L, K, W, ee, le, Q, te) => {
			const G = (O.el = A ? A.el : l("")),
				ae = (O.anchor = A ? A.anchor : l(""));
			let { patchFlag: ge, dynamicChildren: me, slotScopeIds: Se } = O;
			Se && (Q = Q ? Q.concat(Se) : Se),
				A == null
					? (r(G, L, K),
					  r(ae, L, K),
					  k(O.children || [], L, ae, W, ee, le, Q, te))
					: ge > 0 && ge & 64 && me && A.dynamicChildren
					? (_(A.dynamicChildren, me, L, W, ee, le, Q),
					  (O.key != null || (W && O === W.subTree)) && Nf(A, O, !0))
					: $(A, O, L, ae, W, ee, le, Q, te);
		},
		P = (A, O, L, K, W, ee, le, Q, te) => {
			(O.slotScopeIds = Q),
				A == null
					? O.shapeFlag & 512
						? W.ctx.activate(O, L, K, le, te)
						: N(O, L, K, W, ee, le, te)
					: D(A, O, te);
		},
		N = (A, O, L, K, W, ee, le) => {
			const Q = (A.component = Fw(A, K, W));
			if ((Ws(A) && (Q.ctx.renderer = ce), Vw(Q), Q.asyncDep)) {
				if ((W && W.registerDep(Q, M), !A.el)) {
					const te = (Q.subTree = be(Tn));
					w(null, te, O, L);
				}
			} else M(Q, A, O, L, W, ee, le);
		},
		D = (A, O, L) => {
			const K = (O.component = A.component);
			if (Xb(A, O, L))
				if (K.asyncDep && !K.asyncResolved) {
					I(K, O, L);
					return;
				} else
					(K.next = O),
						Kb(K.update),
						(K.effect.dirty = !0),
						K.update();
			else (O.el = A.el), (K.vnode = O);
		},
		M = (A, O, L, K, W, ee, le) => {
			const Q = () => {
					if (A.isMounted) {
						let {
							next: ae,
							bu: ge,
							u: me,
							parent: Se,
							vnode: Pe,
						} = A;
						{
							const Tr = g0(A);
							if (Tr) {
								ae && ((ae.el = Pe.el), I(A, ae, le)),
									Tr.asyncDep.then(() => {
										A.isUnmounted || Q();
									});
								return;
							}
						}
						let Ge = ae,
							st;
						yo(A, !1),
							ae ? ((ae.el = Pe.el), I(A, ae, le)) : (ae = Pe),
							ge && Zu(ge),
							(st = ae.props && ae.props.onVnodeBeforeUpdate) &&
								Kn(st, Se, ae, Pe),
							yo(A, !0);
						const St = tc(A),
							hn = A.subTree;
						(A.subTree = St),
							y(hn, St, d(hn.el), B(hn), A, W, ee),
							(ae.el = St.el),
							Ge === null && Zb(A, St.el),
							me && on(me, W),
							(st = ae.props && ae.props.onVnodeUpdated) &&
								on(() => Kn(st, Se, ae, Pe), W);
					} else {
						let ae;
						const { el: ge, props: me } = O,
							{ bm: Se, m: Pe, parent: Ge } = A,
							st = ts(O);
						if (
							(yo(A, !1),
							Se && Zu(Se),
							!st &&
								(ae = me && me.onVnodeBeforeMount) &&
								Kn(ae, Ge, O),
							yo(A, !0),
							ge && Je)
						) {
							const St = () => {
								(A.subTree = tc(A)),
									Je(ge, A.subTree, A, W, null);
							};
							st
								? O.type
										.__asyncLoader()
										.then(() => !A.isUnmounted && St())
								: St();
						} else {
							const St = (A.subTree = tc(A));
							y(null, St, L, K, A, W, ee), (O.el = St.el);
						}
						if (
							(Pe && on(Pe, W),
							!st && (ae = me && me.onVnodeMounted))
						) {
							const St = O;
							on(() => Kn(ae, Ge, St), W);
						}
						(O.shapeFlag & 256 ||
							(Ge && ts(Ge.vnode) && Ge.vnode.shapeFlag & 256)) &&
							A.a &&
							on(A.a, W),
							(A.isMounted = !0),
							(O = L = K = null);
					}
				},
				te = (A.effect = new wf(Q, Mn, () => mu(G), A.scope)),
				G = (A.update = () => {
					te.dirty && te.run();
				});
			(G.id = A.uid), yo(A, !0), G();
		},
		I = (A, O, L) => {
			O.component = A;
			const K = A.vnode.props;
			(A.vnode = O),
				(A.next = null),
				Mw(A, O.props, K, L),
				Aw(A, O.children, L),
				Wo(),
				ip(A),
				Uo();
		},
		$ = (A, O, L, K, W, ee, le, Q, te = !1) => {
			const G = A && A.children,
				ae = A ? A.shapeFlag : 0,
				ge = O.children,
				{ patchFlag: me, shapeFlag: Se } = O;
			if (me > 0) {
				if (me & 128) {
					ie(G, ge, L, K, W, ee, le, Q, te);
					return;
				} else if (me & 256) {
					V(G, ge, L, K, W, ee, le, Q, te);
					return;
				}
			}
			Se & 8
				? (ae & 16 && Te(G, W, ee), ge !== G && c(L, ge))
				: ae & 16
				? Se & 16
					? ie(G, ge, L, K, W, ee, le, Q, te)
					: Te(G, W, ee, !0)
				: (ae & 8 && c(L, ""),
				  Se & 16 && k(ge, L, K, W, ee, le, Q, te));
		},
		V = (A, O, L, K, W, ee, le, Q, te) => {
			(A = A || ui), (O = O || ui);
			const G = A.length,
				ae = O.length,
				ge = Math.min(G, ae);
			let me;
			for (me = 0; me < ge; me++) {
				const Se = (O[me] = te ? Lr(O[me]) : Qn(O[me]));
				y(A[me], Se, L, null, W, ee, le, Q, te);
			}
			G > ae
				? Te(A, W, ee, !0, !1, ge)
				: k(O, L, K, W, ee, le, Q, te, ge);
		},
		ie = (A, O, L, K, W, ee, le, Q, te) => {
			let G = 0;
			const ae = O.length;
			let ge = A.length - 1,
				me = ae - 1;
			for (; G <= ge && G <= me; ) {
				const Se = A[G],
					Pe = (O[G] = te ? Lr(O[G]) : Qn(O[G]));
				if (ko(Se, Pe)) y(Se, Pe, L, null, W, ee, le, Q, te);
				else break;
				G++;
			}
			for (; G <= ge && G <= me; ) {
				const Se = A[ge],
					Pe = (O[me] = te ? Lr(O[me]) : Qn(O[me]));
				if (ko(Se, Pe)) y(Se, Pe, L, null, W, ee, le, Q, te);
				else break;
				ge--, me--;
			}
			if (G > ge) {
				if (G <= me) {
					const Se = me + 1,
						Pe = Se < ae ? O[Se].el : K;
					for (; G <= me; )
						y(
							null,
							(O[G] = te ? Lr(O[G]) : Qn(O[G])),
							L,
							Pe,
							W,
							ee,
							le,
							Q,
							te
						),
							G++;
				}
			} else if (G > me) for (; G <= ge; ) he(A[G], W, ee, !0), G++;
			else {
				const Se = G,
					Pe = G,
					Ge = new Map();
				for (G = Pe; G <= me; G++) {
					const pe = (O[G] = te ? Lr(O[G]) : Qn(O[G]));
					pe.key != null && Ge.set(pe.key, G);
				}
				let st,
					St = 0;
				const hn = me - Pe + 1;
				let Tr = !1,
					rl = 0;
				const F = new Array(hn);
				for (G = 0; G < hn; G++) F[G] = 0;
				for (G = Se; G <= ge; G++) {
					const pe = A[G];
					if (St >= hn) {
						he(pe, W, ee, !0);
						continue;
					}
					let Be;
					if (pe.key != null) Be = Ge.get(pe.key);
					else
						for (st = Pe; st <= me; st++)
							if (F[st - Pe] === 0 && ko(pe, O[st])) {
								Be = st;
								break;
							}
					Be === void 0
						? he(pe, W, ee, !0)
						: ((F[Be - Pe] = G + 1),
						  Be >= rl ? (rl = Be) : (Tr = !0),
						  y(pe, O[Be], L, null, W, ee, le, Q, te),
						  St++);
				}
				const fe = Tr ? Nw(F) : ui;
				for (st = fe.length - 1, G = hn - 1; G >= 0; G--) {
					const pe = Pe + G,
						Be = O[pe],
						We = pe + 1 < ae ? O[pe + 1].el : K;
					F[G] === 0
						? y(null, Be, L, We, W, ee, le, Q, te)
						: Tr &&
						  (st < 0 || G !== fe[st] ? Y(Be, L, We, 2) : st--);
				}
			}
		},
		Y = (A, O, L, K, W = null) => {
			const {
				el: ee,
				type: le,
				transition: Q,
				children: te,
				shapeFlag: G,
			} = A;
			if (G & 6) {
				Y(A.component.subTree, O, L, K);
				return;
			}
			if (G & 128) {
				A.suspense.move(O, L, K);
				return;
			}
			if (G & 64) {
				le.move(A, O, L, ce);
				return;
			}
			if (le === Ne) {
				r(ee, O, L);
				for (let ge = 0; ge < te.length; ge++) Y(te[ge], O, L, K);
				r(A.anchor, O, L);
				return;
			}
			if (le === Hl) {
				E(A, O, L);
				return;
			}
			if (K !== 2 && G & 1 && Q)
				if (K === 0)
					Q.beforeEnter(ee), r(ee, O, L), on(() => Q.enter(ee), W);
				else {
					const { leave: ge, delayLeave: me, afterLeave: Se } = Q,
						Pe = () => r(ee, O, L),
						Ge = () => {
							ge(ee, () => {
								Pe(), Se && Se();
							});
						};
					me ? me(ee, Pe, Ge) : Ge();
				}
			else r(ee, O, L);
		},
		he = (A, O, L, K = !1, W = !1) => {
			const {
				type: ee,
				props: le,
				ref: Q,
				children: te,
				dynamicChildren: G,
				shapeFlag: ae,
				patchFlag: ge,
				dirs: me,
			} = A;
			if ((Q != null && id(Q, null, L, A, !0), ae & 256)) {
				O.ctx.deactivate(A);
				return;
			}
			const Se = ae & 1 && me,
				Pe = !ts(A);
			let Ge;
			if (
				(Pe && (Ge = le && le.onVnodeBeforeUnmount) && Kn(Ge, O, A),
				ae & 6)
			)
				Me(A.component, L, K);
			else {
				if (ae & 128) {
					A.suspense.unmount(L, K);
					return;
				}
				Se && go(A, null, O, "beforeUnmount"),
					ae & 64
						? A.type.remove(A, O, L, W, ce, K)
						: G && (ee !== Ne || (ge > 0 && ge & 64))
						? Te(G, O, L, !1, !0)
						: ((ee === Ne && ge & 384) || (!W && ae & 16)) &&
						  Te(te, O, L),
					K && Le(A);
			}
			((Pe && (Ge = le && le.onVnodeUnmounted)) || Se) &&
				on(() => {
					Ge && Kn(Ge, O, A), Se && go(A, null, O, "unmounted");
				}, L);
		},
		Le = (A) => {
			const { type: O, el: L, anchor: K, transition: W } = A;
			if (O === Ne) {
				Ce(L, K);
				return;
			}
			if (O === Hl) {
				f(A);
				return;
			}
			const ee = () => {
				o(L), W && !W.persisted && W.afterLeave && W.afterLeave();
			};
			if (A.shapeFlag & 1 && W && !W.persisted) {
				const { leave: le, delayLeave: Q } = W,
					te = () => le(L, ee);
				Q ? Q(A.el, ee, te) : te();
			} else ee();
		},
		Ce = (A, O) => {
			let L;
			for (; A !== O; ) (L = h(A)), o(A), (A = L);
			o(O);
		},
		Me = (A, O, L) => {
			const { bum: K, scope: W, update: ee, subTree: le, um: Q } = A;
			K && Zu(K),
				W.stop(),
				ee && ((ee.active = !1), he(le, A, O, L)),
				Q && on(Q, O),
				on(() => {
					A.isUnmounted = !0;
				}, O),
				O &&
					O.pendingBranch &&
					!O.isUnmounted &&
					A.asyncDep &&
					!A.asyncResolved &&
					A.suspenseId === O.pendingId &&
					(O.deps--, O.deps === 0 && O.resolve());
		},
		Te = (A, O, L, K = !1, W = !1, ee = 0) => {
			for (let le = ee; le < A.length; le++) he(A[le], O, L, K, W);
		},
		B = (A) =>
			A.shapeFlag & 6
				? B(A.component.subTree)
				: A.shapeFlag & 128
				? A.suspense.next()
				: h(A.anchor || A.el);
	let Z = !1;
	const ne = (A, O, L) => {
			A == null
				? O._vnode && he(O._vnode, null, null, !0)
				: y(O._vnode || null, A, O, null, null, null, L),
				Z || ((Z = !0), ip(), q1(), (Z = !1)),
				(O._vnode = A);
		},
		ce = {
			p: y,
			um: he,
			m: Y,
			r: Le,
			mt: N,
			mc: k,
			pc: $,
			pbc: _,
			n: B,
			o: t,
		};
	let $e, Je;
	return (
		e && ([$e, Je] = e(ce)),
		{ render: ne, hydrate: $e, createApp: _w(ne, $e) }
	);
}
function ic({ type: t, props: e }, n) {
	return (n === "svg" && t === "foreignObject") ||
		(n === "mathml" &&
			t === "annotation-xml" &&
			e &&
			e.encoding &&
			e.encoding.includes("html"))
		? void 0
		: n;
}
function yo({ effect: t, update: e }, n) {
	t.allowRecurse = e.allowRecurse = n;
}
function Iw(t, e) {
	return (!t || (t && !t.pendingBranch)) && e && !e.persisted;
}
function Nf(t, e, n = !1) {
	const r = t.children,
		o = e.children;
	if (xe(r) && xe(o))
		for (let i = 0; i < r.length; i++) {
			const s = r[i];
			let l = o[i];
			l.shapeFlag & 1 &&
				!l.dynamicChildren &&
				((l.patchFlag <= 0 || l.patchFlag === 32) &&
					((l = o[i] = Lr(o[i])), (l.el = s.el)),
				n || Nf(s, l)),
				l.type === wu && (l.el = s.el);
		}
}
function Nw(t) {
	const e = t.slice(),
		n = [0];
	let r, o, i, s, l;
	const a = t.length;
	for (r = 0; r < a; r++) {
		const u = t[r];
		if (u !== 0) {
			if (((o = n[n.length - 1]), t[o] < u)) {
				(e[r] = o), n.push(r);
				continue;
			}
			for (i = 0, s = n.length - 1; i < s; )
				(l = (i + s) >> 1), t[n[l]] < u ? (i = l + 1) : (s = l);
			u < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), (n[i] = r));
		}
	}
	for (i = n.length, s = n[i - 1]; i-- > 0; ) (n[i] = s), (s = e[s]);
	return n;
}
function g0(t) {
	const e = t.subTree.component;
	if (e) return e.asyncDep && !e.asyncResolved ? e : g0(e);
}
const Dw = (t) => t.__isTeleport,
	rs = (t) => t && (t.disabled || t.disabled === ""),
	gp = (t) => typeof SVGElement != "undefined" && t instanceof SVGElement,
	yp = (t) =>
		typeof MathMLElement == "function" && t instanceof MathMLElement,
	sd = (t, e) => {
		const n = t && t.to;
		return mt(n) ? (e ? e(n) : null) : n;
	},
	jw = {
		name: "Teleport",
		__isTeleport: !0,
		process(t, e, n, r, o, i, s, l, a, u) {
			const {
					mc: c,
					pc: d,
					pbc: h,
					o: {
						insert: p,
						querySelector: g,
						createText: y,
						createComment: b,
					},
				} = u,
				w = rs(e.props);
			let { shapeFlag: S, children: E, dynamicChildren: f } = e;
			if (t == null) {
				const v = (e.el = y("")),
					m = (e.anchor = y(""));
				p(v, n, r), p(m, n, r);
				const x = (e.target = sd(e.props, g)),
					k = (e.targetAnchor = y(""));
				x &&
					(p(k, x),
					s === "svg" || gp(x)
						? (s = "svg")
						: (s === "mathml" || yp(x)) && (s = "mathml"));
				const C = (_, T) => {
					S & 16 && c(E, _, T, o, i, s, l, a);
				};
				w ? C(n, m) : x && C(x, k);
			} else {
				e.el = t.el;
				const v = (e.anchor = t.anchor),
					m = (e.target = t.target),
					x = (e.targetAnchor = t.targetAnchor),
					k = rs(t.props),
					C = k ? n : m,
					_ = k ? v : x;
				if (
					(s === "svg" || gp(m)
						? (s = "svg")
						: (s === "mathml" || yp(m)) && (s = "mathml"),
					f
						? (h(t.dynamicChildren, f, C, o, i, s, l), Nf(t, e, !0))
						: a || d(t, e, C, _, o, i, s, l, !1),
					w)
				)
					k
						? e.props &&
						  t.props &&
						  e.props.to !== t.props.to &&
						  (e.props.to = t.props.to)
						: ml(e, n, v, u, 1);
				else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
					const T = (e.target = sd(e.props, g));
					T && ml(e, T, null, u, 0);
				} else k && ml(e, m, x, u, 1);
			}
			y0(e);
		},
		remove(t, e, n, r, { um: o, o: { remove: i } }, s) {
			const {
				shapeFlag: l,
				children: a,
				anchor: u,
				targetAnchor: c,
				target: d,
				props: h,
			} = t;
			if ((d && i(c), s && i(u), l & 16)) {
				const p = s || !rs(h);
				for (let g = 0; g < a.length; g++) {
					const y = a[g];
					o(y, e, n, p, !!y.dynamicChildren);
				}
			}
		},
		move: ml,
		hydrate: Lw,
	};
function ml(t, e, n, { o: { insert: r }, m: o }, i = 2) {
	i === 0 && r(t.targetAnchor, e, n);
	const { el: s, anchor: l, shapeFlag: a, children: u, props: c } = t,
		d = i === 2;
	if ((d && r(s, e, n), (!d || rs(c)) && a & 16))
		for (let h = 0; h < u.length; h++) o(u[h], e, n, 2);
	d && r(l, e, n);
}
function Lw(
	t,
	e,
	n,
	r,
	o,
	i,
	{ o: { nextSibling: s, parentNode: l, querySelector: a } },
	u
) {
	const c = (e.target = sd(e.props, a));
	if (c) {
		const d = c._lpa || c.firstChild;
		if (e.shapeFlag & 16)
			if (rs(e.props))
				(e.anchor = u(s(t), e, l(t), n, r, o, i)), (e.targetAnchor = d);
			else {
				e.anchor = s(t);
				let h = d;
				for (; h; )
					if (
						((h = s(h)),
						h && h.nodeType === 8 && h.data === "teleport anchor")
					) {
						(e.targetAnchor = h),
							(c._lpa = e.targetAnchor && s(e.targetAnchor));
						break;
					}
				u(d, e, c, n, r, o, i);
			}
		y0(e);
	}
	return e.anchor && s(e.anchor);
}
const bu = jw;
function y0(t) {
	const e = t.ctx;
	if (e && e.ut) {
		let n = t.children[0].el;
		for (; n && n !== t.targetAnchor; )
			n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid),
				(n = n.nextSibling);
		e.ut();
	}
}
const Ne = Symbol.for("v-fgt"),
	wu = Symbol.for("v-txt"),
	Tn = Symbol.for("v-cmt"),
	Hl = Symbol.for("v-stc"),
	is = [];
let $n = null;
function j(t = !1) {
	is.push(($n = t ? null : []));
}
function $w() {
	is.pop(), ($n = is[is.length - 1] || null);
}
let Ms = 1;
function vp(t) {
	Ms += t;
}
function v0(t) {
	return (
		(t.dynamicChildren = Ms > 0 ? $n || ui : null),
		$w(),
		Ms > 0 && $n && $n.push(t),
		t
	);
}
function q(t, e, n, r, o, i) {
	return v0(U(t, e, n, r, o, i, !0));
}
function Fe(t, e, n, r, o) {
	return v0(be(t, e, n, r, o, !0));
}
function ua(t) {
	return t ? t.__v_isVNode === !0 : !1;
}
function ko(t, e) {
	return t.type === e.type && t.key === e.key;
}
const xu = "__vInternal",
	b0 = ({ key: t }) => (t != null ? t : null),
	Fl = ({ ref: t, ref_key: e, ref_for: n }) => (
		typeof t == "number" && (t = "" + t),
		t != null
			? mt(t) || qt(t) || Ee(t)
				? { i: Ct, r: t, k: e, f: !!n }
				: t
			: null
	);
function U(
	t,
	e = null,
	n = null,
	r = 0,
	o = null,
	i = t === Ne ? 0 : 1,
	s = !1,
	l = !1
) {
	const a = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: t,
		props: e,
		key: e && b0(e),
		ref: e && Fl(e),
		scopeId: Y1,
		slotScopeIds: null,
		children: n,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: i,
		patchFlag: r,
		dynamicProps: o,
		dynamicChildren: null,
		appContext: null,
		ctx: Ct,
	};
	return (
		l
			? (Df(a, n), i & 128 && t.normalize(a))
			: n && (a.shapeFlag |= mt(n) ? 8 : 16),
		Ms > 0 &&
			!s &&
			$n &&
			(a.patchFlag > 0 || i & 6) &&
			a.patchFlag !== 32 &&
			$n.push(a),
		a
	);
}
const be = Bw;
function Bw(t, e = null, n = null, r = 0, o = null, i = !1) {
	if (((!t || t === Q1) && (t = Tn), ua(t))) {
		const l = sr(t, e, !0);
		return (
			n && Df(l, n),
			Ms > 0 &&
				!i &&
				$n &&
				(l.shapeFlag & 6 ? ($n[$n.indexOf(t)] = l) : $n.push(l)),
			(l.patchFlag |= -2),
			l
		);
	}
	if ((qw(t) && (t = t.__vccOpts), e)) {
		e = en(e);
		let { class: l, style: a } = e;
		l && !mt(l) && (e.class = we(l)),
			dt(a) && (B1(a) && !xe(a) && (a = kt({}, a)), (e.style = ao(a)));
	}
	const s = mt(t) ? 1 : ew(t) ? 128 : Dw(t) ? 64 : dt(t) ? 4 : Ee(t) ? 2 : 0;
	return U(t, e, n, r, o, s, i, !0);
}
function en(t) {
	return t ? (B1(t) || xu in t ? kt({}, t) : t) : null;
}
function sr(t, e, n = !1) {
	const { props: r, ref: o, patchFlag: i, children: s } = t,
		l = e ? Ht(r || {}, e) : r;
	return {
		__v_isVNode: !0,
		__v_skip: !0,
		type: t.type,
		props: l,
		key: l && b0(l),
		ref:
			e && e.ref
				? n && o
					? xe(o)
						? o.concat(Fl(e))
						: [o, Fl(e)]
					: Fl(e)
				: o,
		scopeId: t.scopeId,
		slotScopeIds: t.slotScopeIds,
		children: s,
		target: t.target,
		targetAnchor: t.targetAnchor,
		staticCount: t.staticCount,
		shapeFlag: t.shapeFlag,
		patchFlag: e && t.type !== Ne ? (i === -1 ? 16 : i | 16) : i,
		dynamicProps: t.dynamicProps,
		dynamicChildren: t.dynamicChildren,
		appContext: t.appContext,
		dirs: t.dirs,
		transition: t.transition,
		component: t.component,
		suspense: t.suspense,
		ssContent: t.ssContent && sr(t.ssContent),
		ssFallback: t.ssFallback && sr(t.ssFallback),
		el: t.el,
		anchor: t.anchor,
		ctx: t.ctx,
		ce: t.ce,
	};
}
function _r(t = " ", e = 0) {
	return be(wu, null, t, e);
}
function Oj(t, e) {
	const n = be(Hl, null, t);
	return (n.staticCount = e), n;
}
function Ve(t = "", e = !1) {
	return e ? (j(), Fe(Tn, null, t)) : be(Tn, null, t);
}
function Qn(t) {
	return t == null || typeof t == "boolean"
		? be(Tn)
		: xe(t)
		? be(Ne, null, t.slice())
		: typeof t == "object"
		? Lr(t)
		: be(wu, null, String(t));
}
function Lr(t) {
	return (t.el === null && t.patchFlag !== -1) || t.memo ? t : sr(t);
}
function Df(t, e) {
	let n = 0;
	const { shapeFlag: r } = t;
	if (e == null) e = null;
	else if (xe(e)) n = 16;
	else if (typeof e == "object")
		if (r & 65) {
			const o = e.default;
			o && (o._c && (o._d = !1), Df(t, o()), o._c && (o._d = !0));
			return;
		} else {
			n = 32;
			const o = e._;
			!o && !(xu in e)
				? (e._ctx = Ct)
				: o === 3 &&
				  Ct &&
				  (Ct.slots._ === 1
						? (e._ = 1)
						: ((e._ = 2), (t.patchFlag |= 1024)));
		}
	else
		Ee(e)
			? ((e = { default: e, _ctx: Ct }), (n = 32))
			: ((e = String(e)), r & 64 ? ((n = 16), (e = [_r(e)])) : (n = 8));
	(t.children = e), (t.shapeFlag |= n);
}
function Ht(...t) {
	const e = {};
	for (let n = 0; n < t.length; n++) {
		const r = t[n];
		for (const o in r)
			if (o === "class")
				e.class !== r.class && (e.class = we([e.class, r.class]));
			else if (o === "style") e.style = ao([e.style, r.style]);
			else if (lu(o)) {
				const i = e[o],
					s = r[o];
				s &&
					i !== s &&
					!(xe(i) && i.includes(s)) &&
					(e[o] = i ? [].concat(i, s) : s);
			} else o !== "" && (e[o] = r[o]);
	}
	return e;
}
function Kn(t, e, n, r = null) {
	En(t, e, 7, [n, r]);
}
const zw = c0();
let Hw = 0;
function Fw(t, e, n) {
	const r = t.type,
		o = (e ? e.appContext : t.appContext) || zw,
		i = {
			uid: Hw++,
			vnode: t,
			type: r,
			parent: e,
			appContext: o,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			scope: new _1(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: e ? e.provides : Object.create(o.provides),
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: f0(r, o),
			emitsOptions: G1(r, o),
			emit: null,
			emitted: null,
			propsDefaults: lt,
			inheritAttrs: r.inheritAttrs,
			ctx: lt,
			data: lt,
			props: lt,
			attrs: lt,
			slots: lt,
			refs: lt,
			setupState: lt,
			setupContext: null,
			attrsProxy: null,
			slotsProxy: null,
			suspense: n,
			suspenseId: n ? n.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null,
		};
	return (
		(i.ctx = { _: i }),
		(i.root = e ? e.root : i),
		(i.emit = Gb.bind(null, i)),
		t.ce && t.ce(i),
		i
	);
}
let At = null;
const uo = () => At || Ct;
let ca, ld;
{
	const t = bf(),
		e = (n, r) => {
			let o;
			return (
				(o = t[n]) || (o = t[n] = []),
				o.push(r),
				(i) => {
					o.length > 1 ? o.forEach((s) => s(i)) : o[0](i);
				}
			);
		};
	(ca = e("__VUE_INSTANCE_SETTERS__", (n) => (At = n))),
		(ld = e("__VUE_SSR_SETTERS__", (n) => (qs = n)));
}
const Ks = (t) => {
		const e = At;
		return (
			ca(t),
			t.scope.on(),
			() => {
				t.scope.off(), ca(e);
			}
		);
	},
	bp = () => {
		At && At.scope.off(), ca(null);
	};
function w0(t) {
	return t.vnode.shapeFlag & 4;
}
let qs = !1;
function Vw(t, e = !1) {
	e && ld(e);
	const { props: n, children: r } = t.vnode,
		o = w0(t);
	Cw(t, n, o, e), Tw(t, r);
	const i = o ? Ww(t, e) : void 0;
	return e && ld(!1), i;
}
function Ww(t, e) {
	const n = t.type;
	(t.accessCache = Object.create(null)), (t.proxy = hu(new Proxy(t.ctx, yw)));
	const { setup: r } = n;
	if (r) {
		const o = (t.setupContext = r.length > 1 ? k0(t) : null),
			i = Ks(t);
		Wo();
		const s = Xr(r, t, 0, [t.props, o]);
		if ((Uo(), i(), b1(s))) {
			if ((s.then(bp, bp), e))
				return s
					.then((l) => {
						wp(t, l, e);
					})
					.catch((l) => {
						Vs(l, t, 0);
					});
			t.asyncDep = s;
		} else wp(t, s, e);
	} else x0(t, e);
}
function wp(t, e, n) {
	Ee(e)
		? t.type.__ssrInlineRender
			? (t.ssrRender = e)
			: (t.render = e)
		: dt(e) && (t.setupState = V1(e)),
		x0(t, n);
}
let xp;
function x0(t, e, n) {
	const r = t.type;
	if (!t.render) {
		if (!e && xp && !r.render) {
			const o = r.template || Pf(t).template;
			if (o) {
				const { isCustomElement: i, compilerOptions: s } =
						t.appContext.config,
					{ delimiters: l, compilerOptions: a } = r,
					u = kt(kt({ isCustomElement: i, delimiters: l }, s), a);
				r.render = xp(o, u);
			}
		}
		t.render = r.render || Mn;
	}
	{
		const o = Ks(t);
		Wo();
		try {
			vw(t);
		} finally {
			Uo(), o();
		}
	}
}
function Uw(t) {
	return (
		t.attrsProxy ||
		(t.attrsProxy = new Proxy(t.attrs, {
			get(e, n) {
				return cn(t, "get", "$attrs"), e[n];
			},
		}))
	);
}
function k0(t) {
	const e = (n) => {
		t.exposed = n || {};
	};
	return {
		get attrs() {
			return Uw(t);
		},
		slots: t.slots,
		emit: t.emit,
		expose: e,
	};
}
function ku(t) {
	if (t.exposed)
		return (
			t.exposeProxy ||
			(t.exposeProxy = new Proxy(V1(hu(t.exposed)), {
				get(e, n) {
					if (n in e) return e[n];
					if (n in ns) return ns[n](t);
				},
				has(e, n) {
					return n in e || n in ns;
				},
			}))
		);
}
function Kw(t, e = !0) {
	return Ee(t) ? t.displayName || t.name : t.name || (e && t.__name);
}
function qw(t) {
	return Ee(t) && "__vccOpts" in t;
}
const H = (t, e) => H1(t, e, qs);
function Rj(t, e, n = lt) {
	const r = uo(),
		o = Fn(e),
		i = lo(e),
		s = W1((a, u) => {
			let c;
			return (
				ow(() => {
					const d = t[e];
					ir(c, d) && ((c = d), u());
				}),
				{
					get() {
						return a(), n.get ? n.get(c) : c;
					},
					set(d) {
						const h = r.vnode.props;
						!(
							h &&
							(e in h || o in h || i in h) &&
							(`onUpdate:${e}` in h ||
								`onUpdate:${o}` in h ||
								`onUpdate:${i}` in h)
						) &&
							ir(d, c) &&
							((c = d), u()),
							r.emit(`update:${e}`, n.set ? n.set(d) : d);
					},
				}
			);
		}),
		l = e === "modelValue" ? "modelModifiers" : `${e}Modifiers`;
	return (
		(s[Symbol.iterator] = () => {
			let a = 0;
			return {
				next() {
					return a < 2
						? { value: a++ ? t[l] || {} : s, done: !1 }
						: { done: !0 };
				},
			};
		}),
		s
	);
}
function Ue(t, e, n) {
	const r = arguments.length;
	return r === 2
		? dt(e) && !xe(e)
			? ua(e)
				? be(t, null, [e])
				: be(t, e)
			: be(t, null, e)
		: (r > 3
				? (n = Array.prototype.slice.call(arguments, 2))
				: r === 3 && ua(n) && (n = [n]),
		  be(t, e, n));
}
const Jw = "3.4.13";
/**
 * @vue/runtime-dom v3.4.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const Gw = "http://www.w3.org/2000/svg",
	Yw = "http://www.w3.org/1998/Math/MathML",
	$r = typeof document != "undefined" ? document : null,
	kp = $r && $r.createElement("template"),
	Qw = {
		insert: (t, e, n) => {
			e.insertBefore(t, n || null);
		},
		remove: (t) => {
			const e = t.parentNode;
			e && e.removeChild(t);
		},
		createElement: (t, e, n, r) => {
			const o =
				e === "svg"
					? $r.createElementNS(Gw, t)
					: e === "mathml"
					? $r.createElementNS(Yw, t)
					: $r.createElement(t, n ? { is: n } : void 0);
			return (
				t === "select" &&
					r &&
					r.multiple != null &&
					o.setAttribute("multiple", r.multiple),
				o
			);
		},
		createText: (t) => $r.createTextNode(t),
		createComment: (t) => $r.createComment(t),
		setText: (t, e) => {
			t.nodeValue = e;
		},
		setElementText: (t, e) => {
			t.textContent = e;
		},
		parentNode: (t) => t.parentNode,
		nextSibling: (t) => t.nextSibling,
		querySelector: (t) => $r.querySelector(t),
		setScopeId(t, e) {
			t.setAttribute(e, "");
		},
		insertStaticContent(t, e, n, r, o, i) {
			const s = n ? n.previousSibling : e.lastChild;
			if (o && (o === i || o.nextSibling))
				for (
					;
					e.insertBefore(o.cloneNode(!0), n),
						!(o === i || !(o = o.nextSibling));

				);
			else {
				kp.innerHTML =
					r === "svg"
						? `<svg>${t}</svg>`
						: r === "mathml"
						? `<math>${t}</math>`
						: t;
				const l = kp.content;
				if (r === "svg" || r === "mathml") {
					const a = l.firstChild;
					for (; a.firstChild; ) l.appendChild(a.firstChild);
					l.removeChild(a);
				}
				e.insertBefore(l, n);
			}
			return [
				s ? s.nextSibling : e.firstChild,
				n ? n.previousSibling : e.lastChild,
			];
		},
	},
	Or = "transition",
	Hi = "animation",
	bi = Symbol("_vtc"),
	Su = (t, { slots: e }) => Ue(lw, _0(t), e);
Su.displayName = "Transition";
const S0 = {
		name: String,
		type: String,
		css: { type: Boolean, default: !0 },
		duration: [String, Number, Object],
		enterFromClass: String,
		enterActiveClass: String,
		enterToClass: String,
		appearFromClass: String,
		appearActiveClass: String,
		appearToClass: String,
		leaveFromClass: String,
		leaveActiveClass: String,
		leaveToClass: String,
	},
	Xw = (Su.props = kt({}, n0, S0)),
	vo = (t, e = []) => {
		xe(t) ? t.forEach((n) => n(...e)) : t && t(...e);
	},
	Sp = (t) => (t ? (xe(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1);
function _0(t) {
	const e = {};
	for (const R in t) R in S0 || (e[R] = t[R]);
	if (t.css === !1) return e;
	const {
			name: n = "v",
			type: r,
			duration: o,
			enterFromClass: i = `${n}-enter-from`,
			enterActiveClass: s = `${n}-enter-active`,
			enterToClass: l = `${n}-enter-to`,
			appearFromClass: a = i,
			appearActiveClass: u = s,
			appearToClass: c = l,
			leaveFromClass: d = `${n}-leave-from`,
			leaveActiveClass: h = `${n}-leave-active`,
			leaveToClass: p = `${n}-leave-to`,
		} = t,
		g = Zw(o),
		y = g && g[0],
		b = g && g[1],
		{
			onBeforeEnter: w,
			onEnter: S,
			onEnterCancelled: E,
			onLeave: f,
			onLeaveCancelled: v,
			onBeforeAppear: m = w,
			onAppear: x = S,
			onAppearCancelled: k = E,
		} = e,
		C = (R, P, N) => {
			Ir(R, P ? c : l), Ir(R, P ? u : s), N && N();
		},
		_ = (R, P) => {
			(R._isLeaving = !1), Ir(R, d), Ir(R, p), Ir(R, h), P && P();
		},
		T = (R) => (P, N) => {
			const D = R ? x : S,
				M = () => C(P, R, N);
			vo(D, [P, M]),
				_p(() => {
					Ir(P, R ? a : i), gr(P, R ? c : l), Sp(D) || Cp(P, r, y, M);
				});
		};
	return kt(e, {
		onBeforeEnter(R) {
			vo(w, [R]), gr(R, i), gr(R, s);
		},
		onBeforeAppear(R) {
			vo(m, [R]), gr(R, a), gr(R, u);
		},
		onEnter: T(!1),
		onAppear: T(!0),
		onLeave(R, P) {
			R._isLeaving = !0;
			const N = () => _(R, P);
			gr(R, d),
				M0(),
				gr(R, h),
				_p(() => {
					R._isLeaving &&
						(Ir(R, d), gr(R, p), Sp(f) || Cp(R, r, b, N));
				}),
				vo(f, [R, N]);
		},
		onEnterCancelled(R) {
			C(R, !1), vo(E, [R]);
		},
		onAppearCancelled(R) {
			C(R, !0), vo(k, [R]);
		},
		onLeaveCancelled(R) {
			_(R), vo(v, [R]);
		},
	});
}
function Zw(t) {
	if (t == null) return null;
	if (dt(t)) return [sc(t.enter), sc(t.leave)];
	{
		const e = sc(t);
		return [e, e];
	}
}
function sc(t) {
	return db(t);
}
function gr(t, e) {
	e.split(/\s+/).forEach((n) => n && t.classList.add(n)),
		(t[bi] || (t[bi] = new Set())).add(e);
}
function Ir(t, e) {
	e.split(/\s+/).forEach((r) => r && t.classList.remove(r));
	const n = t[bi];
	n && (n.delete(e), n.size || (t[bi] = void 0));
}
function _p(t) {
	requestAnimationFrame(() => {
		requestAnimationFrame(t);
	});
}
let ex = 0;
function Cp(t, e, n, r) {
	const o = (t._endId = ++ex),
		i = () => {
			o === t._endId && r();
		};
	if (n) return setTimeout(i, n);
	const { type: s, timeout: l, propCount: a } = C0(t, e);
	if (!s) return r();
	const u = s + "end";
	let c = 0;
	const d = () => {
			t.removeEventListener(u, h), i();
		},
		h = (p) => {
			p.target === t && ++c >= a && d();
		};
	setTimeout(() => {
		c < a && d();
	}, l + 1),
		t.addEventListener(u, h);
}
function C0(t, e) {
	const n = window.getComputedStyle(t),
		r = (g) => (n[g] || "").split(", "),
		o = r(`${Or}Delay`),
		i = r(`${Or}Duration`),
		s = Mp(o, i),
		l = r(`${Hi}Delay`),
		a = r(`${Hi}Duration`),
		u = Mp(l, a);
	let c = null,
		d = 0,
		h = 0;
	e === Or
		? s > 0 && ((c = Or), (d = s), (h = i.length))
		: e === Hi
		? u > 0 && ((c = Hi), (d = u), (h = a.length))
		: ((d = Math.max(s, u)),
		  (c = d > 0 ? (s > u ? Or : Hi) : null),
		  (h = c ? (c === Or ? i.length : a.length) : 0));
	const p =
		c === Or &&
		/\b(transform|all)(,|$)/.test(r(`${Or}Property`).toString());
	return { type: c, timeout: d, propCount: h, hasTransform: p };
}
function Mp(t, e) {
	for (; t.length < e.length; ) t = t.concat(t);
	return Math.max(...e.map((n, r) => Ep(n) + Ep(t[r])));
}
function Ep(t) {
	return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function M0() {
	return document.body.offsetHeight;
}
function tx(t, e, n) {
	const r = t[bi];
	r && (e = (e ? [e, ...r] : [...r]).join(" ")),
		e == null
			? t.removeAttribute("class")
			: n
			? t.setAttribute("class", e)
			: (t.className = e);
}
const jf = Symbol("_vod"),
	E0 = {
		beforeMount(t, { value: e }, { transition: n }) {
			(t[jf] = t.style.display === "none" ? "" : t.style.display),
				n && e ? n.beforeEnter(t) : Fi(t, e);
		},
		mounted(t, { value: e }, { transition: n }) {
			n && e && n.enter(t);
		},
		updated(t, { value: e, oldValue: n }, { transition: r }) {
			!e != !n &&
				(r
					? e
						? (r.beforeEnter(t), Fi(t, !0), r.enter(t))
						: r.leave(t, () => {
								Fi(t, !1);
						  })
					: Fi(t, e));
		},
		beforeUnmount(t, { value: e }) {
			Fi(t, e);
		},
	};
function Fi(t, e) {
	t.style.display = e ? t[jf] : "none";
}
const nx = Symbol("");
function rx(t, e, n) {
	const r = t.style,
		o = r.display,
		i = mt(n);
	if (n && !i) {
		if (e && !mt(e)) for (const s in e) n[s] == null && ad(r, s, "");
		for (const s in n) ad(r, s, n[s]);
	} else if (i) {
		if (e !== n) {
			const s = r[nx];
			s && (n += ";" + s), (r.cssText = n);
		}
	} else e && t.removeAttribute("style");
	jf in t && (r.display = o);
}
const Tp = /\s*!important$/;
function ad(t, e, n) {
	if (xe(n)) n.forEach((r) => ad(t, e, r));
	else if ((n == null && (n = ""), e.startsWith("--"))) t.setProperty(e, n);
	else {
		const r = ox(t, e);
		Tp.test(n)
			? t.setProperty(lo(r), n.replace(Tp, ""), "important")
			: (t[r] = n);
	}
}
const Ap = ["Webkit", "Moz", "ms"],
	lc = {};
function ox(t, e) {
	const n = lc[e];
	if (n) return n;
	let r = Fn(e);
	if (r !== "filter" && r in t) return (lc[e] = r);
	r = cu(r);
	for (let o = 0; o < Ap.length; o++) {
		const i = Ap[o] + r;
		if (i in t) return (lc[e] = i);
	}
	return e;
}
const Op = "http://www.w3.org/1999/xlink";
function ix(t, e, n, r, o) {
	if (r && e.startsWith("xlink:"))
		n == null
			? t.removeAttributeNS(Op, e.slice(6, e.length))
			: t.setAttributeNS(Op, e, n);
	else {
		const i = yb(e);
		n == null || (i && !k1(n))
			? t.removeAttribute(e)
			: t.setAttribute(e, i ? "" : n);
	}
}
function sx(t, e, n, r, o, i, s) {
	if (e === "innerHTML" || e === "textContent") {
		r && s(r, o, i), (t[e] = n == null ? "" : n);
		return;
	}
	const l = t.tagName;
	if (e === "value" && l !== "PROGRESS" && !l.includes("-")) {
		t._value = n;
		const u = l === "OPTION" ? t.getAttribute("value") : t.value,
			c = n == null ? "" : n;
		u !== c && (t.value = c), n == null && t.removeAttribute(e);
		return;
	}
	let a = !1;
	if (n === "" || n == null) {
		const u = typeof t[e];
		u === "boolean"
			? (n = k1(n))
			: n == null && u === "string"
			? ((n = ""), (a = !0))
			: u === "number" && ((n = 0), (a = !0));
	}
	try {
		t[e] = n;
	} catch (u) {}
	a && t.removeAttribute(e);
}
function lx(t, e, n, r) {
	t.addEventListener(e, n, r);
}
function ax(t, e, n, r) {
	t.removeEventListener(e, n, r);
}
const Rp = Symbol("_vei");
function ux(t, e, n, r, o = null) {
	const i = t[Rp] || (t[Rp] = {}),
		s = i[e];
	if (r && s) s.value = r;
	else {
		const [l, a] = cx(e);
		if (r) {
			const u = (i[e] = hx(r, o));
			lx(t, l, u, a);
		} else s && (ax(t, l, s, a), (i[e] = void 0));
	}
}
const Pp = /(?:Once|Passive|Capture)$/;
function cx(t) {
	let e;
	if (Pp.test(t)) {
		e = {};
		let r;
		for (; (r = t.match(Pp)); )
			(t = t.slice(0, t.length - r[0].length)),
				(e[r[0].toLowerCase()] = !0);
	}
	return [t[2] === ":" ? t.slice(3) : lo(t.slice(2)), e];
}
let ac = 0;
const dx = Promise.resolve(),
	fx = () => ac || (dx.then(() => (ac = 0)), (ac = Date.now()));
function hx(t, e) {
	const n = (r) => {
		if (!r._vts) r._vts = Date.now();
		else if (r._vts <= n.attached) return;
		En(px(r, n.value), e, 5, [r]);
	};
	return (n.value = t), (n.attached = fx()), n;
}
function px(t, e) {
	if (xe(e)) {
		const n = t.stopImmediatePropagation;
		return (
			(t.stopImmediatePropagation = () => {
				n.call(t), (t._stopped = !0);
			}),
			e.map((r) => (o) => !o._stopped && r && r(o))
		);
	} else return e;
}
const Ip = (t) =>
		t.charCodeAt(0) === 111 &&
		t.charCodeAt(1) === 110 &&
		t.charCodeAt(2) > 96 &&
		t.charCodeAt(2) < 123,
	mx = (t, e, n, r, o, i, s, l, a) => {
		const u = o === "svg";
		e === "class"
			? tx(t, r, u)
			: e === "style"
			? rx(t, n, r)
			: lu(e)
			? gf(e) || ux(t, e, n, r, s)
			: (
					e[0] === "."
						? ((e = e.slice(1)), !0)
						: e[0] === "^"
						? ((e = e.slice(1)), !1)
						: gx(t, e, r, u)
			  )
			? sx(t, e, r, i, s, l, a)
			: (e === "true-value"
					? (t._trueValue = r)
					: e === "false-value" && (t._falseValue = r),
			  ix(t, e, r, u));
	};
function gx(t, e, n, r) {
	if (r)
		return !!(
			e === "innerHTML" ||
			e === "textContent" ||
			(e in t && Ip(e) && Ee(n))
		);
	if (
		e === "spellcheck" ||
		e === "draggable" ||
		e === "translate" ||
		e === "form" ||
		(e === "list" && t.tagName === "INPUT") ||
		(e === "type" && t.tagName === "TEXTAREA")
	)
		return !1;
	if (e === "width" || e === "height") {
		const o = t.tagName;
		if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE")
			return !1;
	}
	return Ip(e) && mt(n) ? !1 : e in t;
}
const T0 = new WeakMap(),
	A0 = new WeakMap(),
	da = Symbol("_moveCb"),
	Np = Symbol("_enterCb"),
	O0 = {
		name: "TransitionGroup",
		props: kt({}, Xw, { tag: String, moveClass: String }),
		setup(t, { slots: e }) {
			const n = uo(),
				r = t0();
			let o, i;
			return (
				i0(() => {
					if (!o.length) return;
					const s = t.moveClass || `${t.name || "v"}-move`;
					if (!kx(o[0].el, n.vnode.el, s)) return;
					o.forEach(bx), o.forEach(wx);
					const l = o.filter(xx);
					M0(),
						l.forEach((a) => {
							const u = a.el,
								c = u.style;
							gr(u, s),
								(c.transform =
									c.webkitTransform =
									c.transitionDuration =
										"");
							const d = (u[da] = (h) => {
								(h && h.target !== u) ||
									((!h ||
										/transform$/.test(h.propertyName)) &&
										(u.removeEventListener(
											"transitionend",
											d
										),
										(u[da] = null),
										Ir(u, s)));
							});
							u.addEventListener("transitionend", d);
						});
				}),
				() => {
					const s = Oe(t),
						l = _0(s);
					let a = s.tag || Ne;
					(o = i), (i = e.default ? Of(e.default()) : []);
					for (let u = 0; u < i.length; u++) {
						const c = i[u];
						c.key != null && _s(c, Ss(c, l, r, n));
					}
					if (o)
						for (let u = 0; u < o.length; u++) {
							const c = o[u];
							_s(c, Ss(c, l, r, n)),
								T0.set(c, c.el.getBoundingClientRect());
						}
					return be(a, null, i);
				}
			);
		},
	},
	yx = (t) => delete t.mode;
O0.props;
const vx = O0;
function bx(t) {
	const e = t.el;
	e[da] && e[da](), e[Np] && e[Np]();
}
function wx(t) {
	A0.set(t, t.el.getBoundingClientRect());
}
function xx(t) {
	const e = T0.get(t),
		n = A0.get(t),
		r = e.left - n.left,
		o = e.top - n.top;
	if (r || o) {
		const i = t.el.style;
		return (
			(i.transform = i.webkitTransform = `translate(${r}px,${o}px)`),
			(i.transitionDuration = "0s"),
			t
		);
	}
}
function kx(t, e, n) {
	const r = t.cloneNode(),
		o = t[bi];
	o &&
		o.forEach((l) => {
			l.split(/\s+/).forEach((a) => a && r.classList.remove(a));
		}),
		n.split(/\s+/).forEach((l) => l && r.classList.add(l)),
		(r.style.display = "none");
	const i = e.nodeType === 1 ? e : e.parentNode;
	i.appendChild(r);
	const { hasTransform: s } = C0(r);
	return i.removeChild(r), s;
}
const Sx = ["ctrl", "shift", "alt", "meta"],
	_x = {
		stop: (t) => t.stopPropagation(),
		prevent: (t) => t.preventDefault(),
		self: (t) => t.target !== t.currentTarget,
		ctrl: (t) => !t.ctrlKey,
		shift: (t) => !t.shiftKey,
		alt: (t) => !t.altKey,
		meta: (t) => !t.metaKey,
		left: (t) => "button" in t && t.button !== 0,
		middle: (t) => "button" in t && t.button !== 1,
		right: (t) => "button" in t && t.button !== 2,
		exact: (t, e) => Sx.some((n) => t[`${n}Key`] && !e.includes(n)),
	},
	R0 = (t, e) => {
		const n = t._withMods || (t._withMods = {}),
			r = e.join(".");
		return (
			n[r] ||
			(n[r] = (o, ...i) => {
				for (let s = 0; s < e.length; s++) {
					const l = _x[e[s]];
					if (l && l(o, e)) return;
				}
				return t(o, ...i);
			})
		);
	},
	Cx = {
		esc: "escape",
		space: " ",
		up: "arrow-up",
		left: "arrow-left",
		right: "arrow-right",
		down: "arrow-down",
		delete: "backspace",
	},
	Pj = (t, e) => {
		const n = t._withKeys || (t._withKeys = {}),
			r = e.join(".");
		return (
			n[r] ||
			(n[r] = (o) => {
				if (!("key" in o)) return;
				const i = lo(o.key);
				if (e.some((s) => s === i || Cx[s] === i)) return t(o);
			})
		);
	},
	Mx = kt({ patchProp: mx }, Qw);
let Dp;
function Ex() {
	return Dp || (Dp = Rw(Mx));
}
const Ij = (...t) => {
	const e = Ex().createApp(...t),
		{ mount: n } = e;
	return (
		(e.mount = (r) => {
			const o = Ax(r);
			if (!o) return;
			const i = e._component;
			!Ee(i) && !i.render && !i.template && (i.template = o.innerHTML),
				(o.innerHTML = "");
			const s = n(o, !1, Tx(o));
			return (
				o instanceof Element &&
					(o.removeAttribute("v-cloak"),
					o.setAttribute("data-v-app", "")),
				s
			);
		}),
		e
	);
};
function Tx(t) {
	if (t instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && t instanceof MathMLElement)
		return "mathml";
}
function Ax(t) {
	return mt(t) ? document.querySelector(t) : t;
}
const Ox = "modulepreload",
	Rx = function (t) {
		return "/" + t;
	},
	jp = {},
	gl = function (e, n, r) {
		let o = Promise.resolve();
		if (n && n.length > 0) {
			const i = document.getElementsByTagName("link");
			o = Promise.all(
				n.map((s) => {
					if (((s = Rx(s)), s in jp)) return;
					jp[s] = !0;
					const l = s.endsWith(".css"),
						a = l ? '[rel="stylesheet"]' : "";
					if (!!r)
						for (let d = i.length - 1; d >= 0; d--) {
							const h = i[d];
							if (h.href === s && (!l || h.rel === "stylesheet"))
								return;
						}
					else if (document.querySelector(`link[href="${s}"]${a}`))
						return;
					const c = document.createElement("link");
					if (
						((c.rel = l ? "stylesheet" : Ox),
						l || ((c.as = "script"), (c.crossOrigin = "")),
						(c.href = s),
						document.head.appendChild(c),
						l)
					)
						return new Promise((d, h) => {
							c.addEventListener("load", d),
								c.addEventListener("error", () =>
									h(
										new Error(
											`Unable to preload CSS for ${s}`
										)
									)
								);
						});
				})
			);
		}
		return o
			.then(() => e())
			.catch((i) => {
				const s = new Event("vite:preloadError", { cancelable: !0 });
				if (
					((s.payload = i),
					window.dispatchEvent(s),
					!s.defaultPrevented)
				)
					throw i;
			});
	};
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const ei = typeof window != "undefined";
function Px(t) {
	return t.__esModule || t[Symbol.toStringTag] === "Module";
}
const tt = Object.assign;
function uc(t, e) {
	const n = {};
	for (const r in e) {
		const o = e[r];
		n[r] = Vn(o) ? o.map(t) : t(o);
	}
	return n;
}
const ss = () => {},
	Vn = Array.isArray,
	Ix = /\/$/,
	Nx = (t) => t.replace(Ix, "");
function cc(t, e, n = "/") {
	let r,
		o = {},
		i = "",
		s = "";
	const l = e.indexOf("#");
	let a = e.indexOf("?");
	return (
		l < a && l >= 0 && (a = -1),
		a > -1 &&
			((r = e.slice(0, a)),
			(i = e.slice(a + 1, l > -1 ? l : e.length)),
			(o = t(i))),
		l > -1 && ((r = r || e.slice(0, l)), (s = e.slice(l, e.length))),
		(r = $x(r != null ? r : e, n)),
		{ fullPath: r + (i && "?") + i + s, path: r, query: o, hash: s }
	);
}
function Dx(t, e) {
	const n = e.query ? t(e.query) : "";
	return e.path + (n && "?") + n + (e.hash || "");
}
function Lp(t, e) {
	return !e || !t.toLowerCase().startsWith(e.toLowerCase())
		? t
		: t.slice(e.length) || "/";
}
function jx(t, e, n) {
	const r = e.matched.length - 1,
		o = n.matched.length - 1;
	return (
		r > -1 &&
		r === o &&
		wi(e.matched[r], n.matched[o]) &&
		P0(e.params, n.params) &&
		t(e.query) === t(n.query) &&
		e.hash === n.hash
	);
}
function wi(t, e) {
	return (t.aliasOf || t) === (e.aliasOf || e);
}
function P0(t, e) {
	if (Object.keys(t).length !== Object.keys(e).length) return !1;
	for (const n in t) if (!Lx(t[n], e[n])) return !1;
	return !0;
}
function Lx(t, e) {
	return Vn(t) ? $p(t, e) : Vn(e) ? $p(e, t) : t === e;
}
function $p(t, e) {
	return Vn(e)
		? t.length === e.length && t.every((n, r) => n === e[r])
		: t.length === 1 && t[0] === e;
}
function $x(t, e) {
	if (t.startsWith("/")) return t;
	if (!t) return e;
	const n = e.split("/"),
		r = t.split("/"),
		o = r[r.length - 1];
	(o === ".." || o === ".") && r.push("");
	let i = n.length - 1,
		s,
		l;
	for (s = 0; s < r.length; s++)
		if (((l = r[s]), l !== "."))
			if (l === "..") i > 1 && i--;
			else break;
	return (
		n.slice(0, i).join("/") +
		"/" +
		r.slice(s - (s === r.length ? 1 : 0)).join("/")
	);
}
var Es;
(function (t) {
	(t.pop = "pop"), (t.push = "push");
})(Es || (Es = {}));
var ls;
(function (t) {
	(t.back = "back"), (t.forward = "forward"), (t.unknown = "");
})(ls || (ls = {}));
function Bx(t) {
	if (!t)
		if (ei) {
			const e = document.querySelector("base");
			(t = (e && e.getAttribute("href")) || "/"),
				(t = t.replace(/^\w+:\/\/[^\/]+/, ""));
		} else t = "/";
	return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), Nx(t);
}
const zx = /^[^#]+#/;
function Hx(t, e) {
	return t.replace(zx, "#") + e;
}
function Fx(t, e) {
	const n = document.documentElement.getBoundingClientRect(),
		r = t.getBoundingClientRect();
	return {
		behavior: e.behavior,
		left: r.left - n.left - (e.left || 0),
		top: r.top - n.top - (e.top || 0),
	};
}
const _u = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function Vx(t) {
	let e;
	if ("el" in t) {
		const n = t.el,
			r = typeof n == "string" && n.startsWith("#"),
			o =
				typeof n == "string"
					? r
						? document.getElementById(n.slice(1))
						: document.querySelector(n)
					: n;
		if (!o) return;
		e = Fx(o, t);
	} else e = t;
	"scrollBehavior" in document.documentElement.style
		? window.scrollTo(e)
		: window.scrollTo(
				e.left != null ? e.left : window.pageXOffset,
				e.top != null ? e.top : window.pageYOffset
		  );
}
function Bp(t, e) {
	return (history.state ? history.state.position - e : -1) + t;
}
const ud = new Map();
function Wx(t, e) {
	ud.set(t, e);
}
function Ux(t) {
	const e = ud.get(t);
	return ud.delete(t), e;
}
let Kx = () => location.protocol + "//" + location.host;
function I0(t, e) {
	const { pathname: n, search: r, hash: o } = e,
		i = t.indexOf("#");
	if (i > -1) {
		let l = o.includes(t.slice(i)) ? t.slice(i).length : 1,
			a = o.slice(l);
		return a[0] !== "/" && (a = "/" + a), Lp(a, "");
	}
	return Lp(n, t) + r + o;
}
function qx(t, e, n, r) {
	let o = [],
		i = [],
		s = null;
	const l = ({ state: h }) => {
		const p = I0(t, location),
			g = n.value,
			y = e.value;
		let b = 0;
		if (h) {
			if (((n.value = p), (e.value = h), s && s === g)) {
				s = null;
				return;
			}
			b = y ? h.position - y.position : 0;
		} else r(p);
		o.forEach((w) => {
			w(n.value, g, {
				delta: b,
				type: Es.pop,
				direction: b ? (b > 0 ? ls.forward : ls.back) : ls.unknown,
			});
		});
	};
	function a() {
		s = n.value;
	}
	function u(h) {
		o.push(h);
		const p = () => {
			const g = o.indexOf(h);
			g > -1 && o.splice(g, 1);
		};
		return i.push(p), p;
	}
	function c() {
		const { history: h } = window;
		h.state && h.replaceState(tt({}, h.state, { scroll: _u() }), "");
	}
	function d() {
		for (const h of i) h();
		(i = []),
			window.removeEventListener("popstate", l),
			window.removeEventListener("beforeunload", c);
	}
	return (
		window.addEventListener("popstate", l),
		window.addEventListener("beforeunload", c, { passive: !0 }),
		{ pauseListeners: a, listen: u, destroy: d }
	);
}
function zp(t, e, n, r = !1, o = !1) {
	return {
		back: t,
		current: e,
		forward: n,
		replaced: r,
		position: window.history.length,
		scroll: o ? _u() : null,
	};
}
function Jx(t) {
	const { history: e, location: n } = window,
		r = { value: I0(t, n) },
		o = { value: e.state };
	o.value ||
		i(
			r.value,
			{
				back: null,
				current: r.value,
				forward: null,
				position: e.length - 1,
				replaced: !0,
				scroll: null,
			},
			!0
		);
	function i(a, u, c) {
		const d = t.indexOf("#"),
			h =
				d > -1
					? (n.host && document.querySelector("base")
							? t
							: t.slice(d)) + a
					: Kx() + t + a;
		try {
			e[c ? "replaceState" : "pushState"](u, "", h), (o.value = u);
		} catch (p) {
			console.error(p), n[c ? "replace" : "assign"](h);
		}
	}
	function s(a, u) {
		const c = tt({}, e.state, zp(o.value.back, a, o.value.forward, !0), u, {
			position: o.value.position,
		});
		i(a, c, !0), (r.value = a);
	}
	function l(a, u) {
		const c = tt({}, o.value, e.state, { forward: a, scroll: _u() });
		i(c.current, c, !0);
		const d = tt({}, zp(r.value, a, null), { position: c.position + 1 }, u);
		i(a, d, !1), (r.value = a);
	}
	return { location: r, state: o, push: l, replace: s };
}
function Nj(t) {
	t = Bx(t);
	const e = Jx(t),
		n = qx(t, e.state, e.location, e.replace);
	function r(i, s = !0) {
		s || n.pauseListeners(), history.go(i);
	}
	const o = tt(
		{ location: "", base: t, go: r, createHref: Hx.bind(null, t) },
		e,
		n
	);
	return (
		Object.defineProperty(o, "location", {
			enumerable: !0,
			get: () => e.location.value,
		}),
		Object.defineProperty(o, "state", {
			enumerable: !0,
			get: () => e.state.value,
		}),
		o
	);
}
function Gx(t) {
	return typeof t == "string" || (t && typeof t == "object");
}
function N0(t) {
	return typeof t == "string" || typeof t == "symbol";
}
const Rr = {
		path: "/",
		name: void 0,
		params: {},
		query: {},
		hash: "",
		fullPath: "/",
		matched: [],
		meta: {},
		redirectedFrom: void 0,
	},
	D0 = Symbol("");
var Hp;
(function (t) {
	(t[(t.aborted = 4)] = "aborted"),
		(t[(t.cancelled = 8)] = "cancelled"),
		(t[(t.duplicated = 16)] = "duplicated");
})(Hp || (Hp = {}));
function xi(t, e) {
	return tt(new Error(), { type: t, [D0]: !0 }, e);
}
function pr(t, e) {
	return t instanceof Error && D0 in t && (e == null || !!(t.type & e));
}
const Fp = "[^/]+?",
	Yx = { sensitive: !1, strict: !1, start: !0, end: !0 },
	Qx = /[.+*?^${}()[\]/\\]/g;
function Xx(t, e) {
	const n = tt({}, Yx, e),
		r = [];
	let o = n.start ? "^" : "";
	const i = [];
	for (const u of t) {
		const c = u.length ? [] : [90];
		n.strict && !u.length && (o += "/");
		for (let d = 0; d < u.length; d++) {
			const h = u[d];
			let p = 40 + (n.sensitive ? 0.25 : 0);
			if (h.type === 0)
				d || (o += "/"), (o += h.value.replace(Qx, "\\$&")), (p += 40);
			else if (h.type === 1) {
				const { value: g, repeatable: y, optional: b, regexp: w } = h;
				i.push({ name: g, repeatable: y, optional: b });
				const S = w || Fp;
				if (S !== Fp) {
					p += 10;
					try {
						new RegExp(`(${S})`);
					} catch (f) {
						throw new Error(
							`Invalid custom RegExp for param "${g}" (${S}): ` +
								f.message
						);
					}
				}
				let E = y ? `((?:${S})(?:/(?:${S}))*)` : `(${S})`;
				d || (E = b && u.length < 2 ? `(?:/${E})` : "/" + E),
					b && (E += "?"),
					(o += E),
					(p += 20),
					b && (p += -8),
					y && (p += -20),
					S === ".*" && (p += -50);
			}
			c.push(p);
		}
		r.push(c);
	}
	if (n.strict && n.end) {
		const u = r.length - 1;
		r[u][r[u].length - 1] += 0.7000000000000001;
	}
	n.strict || (o += "/?"), n.end ? (o += "$") : n.strict && (o += "(?:/|$)");
	const s = new RegExp(o, n.sensitive ? "" : "i");
	function l(u) {
		const c = u.match(s),
			d = {};
		if (!c) return null;
		for (let h = 1; h < c.length; h++) {
			const p = c[h] || "",
				g = i[h - 1];
			d[g.name] = p && g.repeatable ? p.split("/") : p;
		}
		return d;
	}
	function a(u) {
		let c = "",
			d = !1;
		for (const h of t) {
			(!d || !c.endsWith("/")) && (c += "/"), (d = !1);
			for (const p of h)
				if (p.type === 0) c += p.value;
				else if (p.type === 1) {
					const { value: g, repeatable: y, optional: b } = p,
						w = g in u ? u[g] : "";
					if (Vn(w) && !y)
						throw new Error(
							`Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`
						);
					const S = Vn(w) ? w.join("/") : w;
					if (!S)
						if (b)
							h.length < 2 &&
								(c.endsWith("/")
									? (c = c.slice(0, -1))
									: (d = !0));
						else throw new Error(`Missing required param "${g}"`);
					c += S;
				}
		}
		return c || "/";
	}
	return { re: s, score: r, keys: i, parse: l, stringify: a };
}
function Zx(t, e) {
	let n = 0;
	for (; n < t.length && n < e.length; ) {
		const r = e[n] - t[n];
		if (r) return r;
		n++;
	}
	return t.length < e.length
		? t.length === 1 && t[0] === 80
			? -1
			: 1
		: t.length > e.length
		? e.length === 1 && e[0] === 80
			? 1
			: -1
		: 0;
}
function e3(t, e) {
	let n = 0;
	const r = t.score,
		o = e.score;
	for (; n < r.length && n < o.length; ) {
		const i = Zx(r[n], o[n]);
		if (i) return i;
		n++;
	}
	if (Math.abs(o.length - r.length) === 1) {
		if (Vp(r)) return 1;
		if (Vp(o)) return -1;
	}
	return o.length - r.length;
}
function Vp(t) {
	const e = t[t.length - 1];
	return t.length > 0 && e[e.length - 1] < 0;
}
const t3 = { type: 0, value: "" },
	n3 = /[a-zA-Z0-9_]/;
function r3(t) {
	if (!t) return [[]];
	if (t === "/") return [[t3]];
	if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`);
	function e(p) {
		throw new Error(`ERR (${n})/"${u}": ${p}`);
	}
	let n = 0,
		r = n;
	const o = [];
	let i;
	function s() {
		i && o.push(i), (i = []);
	}
	let l = 0,
		a,
		u = "",
		c = "";
	function d() {
		u &&
			(n === 0
				? i.push({ type: 0, value: u })
				: n === 1 || n === 2 || n === 3
				? (i.length > 1 &&
						(a === "*" || a === "+") &&
						e(
							`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`
						),
				  i.push({
						type: 1,
						value: u,
						regexp: c,
						repeatable: a === "*" || a === "+",
						optional: a === "*" || a === "?",
				  }))
				: e("Invalid state to consume buffer"),
			(u = ""));
	}
	function h() {
		u += a;
	}
	for (; l < t.length; ) {
		if (((a = t[l++]), a === "\\" && n !== 2)) {
			(r = n), (n = 4);
			continue;
		}
		switch (n) {
			case 0:
				a === "/" ? (u && d(), s()) : a === ":" ? (d(), (n = 1)) : h();
				break;
			case 4:
				h(), (n = r);
				break;
			case 1:
				a === "("
					? (n = 2)
					: n3.test(a)
					? h()
					: (d(),
					  (n = 0),
					  a !== "*" && a !== "?" && a !== "+" && l--);
				break;
			case 2:
				a === ")"
					? c[c.length - 1] == "\\"
						? (c = c.slice(0, -1) + a)
						: (n = 3)
					: (c += a);
				break;
			case 3:
				d(),
					(n = 0),
					a !== "*" && a !== "?" && a !== "+" && l--,
					(c = "");
				break;
			default:
				e("Unknown state");
				break;
		}
	}
	return (
		n === 2 && e(`Unfinished custom RegExp for param "${u}"`), d(), s(), o
	);
}
function o3(t, e, n) {
	const r = Xx(r3(t.path), n),
		o = tt(r, { record: t, parent: e, children: [], alias: [] });
	return e && !o.record.aliasOf == !e.record.aliasOf && e.children.push(o), o;
}
function i3(t, e) {
	const n = [],
		r = new Map();
	e = Kp({ strict: !1, end: !0, sensitive: !1 }, e);
	function o(c) {
		return r.get(c);
	}
	function i(c, d, h) {
		const p = !h,
			g = s3(c);
		g.aliasOf = h && h.record;
		const y = Kp(e, c),
			b = [g];
		if ("alias" in c) {
			const E = typeof c.alias == "string" ? [c.alias] : c.alias;
			for (const f of E)
				b.push(
					tt({}, g, {
						components: h ? h.record.components : g.components,
						path: f,
						aliasOf: h ? h.record : g,
					})
				);
		}
		let w, S;
		for (const E of b) {
			const { path: f } = E;
			if (d && f[0] !== "/") {
				const v = d.record.path,
					m = v[v.length - 1] === "/" ? "" : "/";
				E.path = d.record.path + (f && m + f);
			}
			if (
				((w = o3(E, d, y)),
				h
					? h.alias.push(w)
					: ((S = S || w),
					  S !== w && S.alias.push(w),
					  p && c.name && !Up(w) && s(c.name)),
				g.children)
			) {
				const v = g.children;
				for (let m = 0; m < v.length; m++)
					i(v[m], w, h && h.children[m]);
			}
			(h = h || w),
				((w.record.components &&
					Object.keys(w.record.components).length) ||
					w.record.name ||
					w.record.redirect) &&
					a(w);
		}
		return S
			? () => {
					s(S);
			  }
			: ss;
	}
	function s(c) {
		if (N0(c)) {
			const d = r.get(c);
			d &&
				(r.delete(c),
				n.splice(n.indexOf(d), 1),
				d.children.forEach(s),
				d.alias.forEach(s));
		} else {
			const d = n.indexOf(c);
			d > -1 &&
				(n.splice(d, 1),
				c.record.name && r.delete(c.record.name),
				c.children.forEach(s),
				c.alias.forEach(s));
		}
	}
	function l() {
		return n;
	}
	function a(c) {
		let d = 0;
		for (
			;
			d < n.length &&
			e3(c, n[d]) >= 0 &&
			(c.record.path !== n[d].record.path || !j0(c, n[d]));

		)
			d++;
		n.splice(d, 0, c), c.record.name && !Up(c) && r.set(c.record.name, c);
	}
	function u(c, d) {
		let h,
			p = {},
			g,
			y;
		if ("name" in c && c.name) {
			if (((h = r.get(c.name)), !h)) throw xi(1, { location: c });
			(y = h.record.name),
				(p = tt(
					Wp(
						d.params,
						h.keys.filter((S) => !S.optional).map((S) => S.name)
					),
					c.params &&
						Wp(
							c.params,
							h.keys.map((S) => S.name)
						)
				)),
				(g = h.stringify(p));
		} else if ("path" in c)
			(g = c.path),
				(h = n.find((S) => S.re.test(g))),
				h && ((p = h.parse(g)), (y = h.record.name));
		else {
			if (
				((h = d.name
					? r.get(d.name)
					: n.find((S) => S.re.test(d.path))),
				!h)
			)
				throw xi(1, { location: c, currentLocation: d });
			(y = h.record.name),
				(p = tt({}, d.params, c.params)),
				(g = h.stringify(p));
		}
		const b = [];
		let w = h;
		for (; w; ) b.unshift(w.record), (w = w.parent);
		return { name: y, path: g, params: p, matched: b, meta: a3(b) };
	}
	return (
		t.forEach((c) => i(c)),
		{
			addRoute: i,
			resolve: u,
			removeRoute: s,
			getRoutes: l,
			getRecordMatcher: o,
		}
	);
}
function Wp(t, e) {
	const n = {};
	for (const r of e) r in t && (n[r] = t[r]);
	return n;
}
function s3(t) {
	return {
		path: t.path,
		redirect: t.redirect,
		name: t.name,
		meta: t.meta || {},
		aliasOf: void 0,
		beforeEnter: t.beforeEnter,
		props: l3(t),
		children: t.children || [],
		instances: {},
		leaveGuards: new Set(),
		updateGuards: new Set(),
		enterCallbacks: {},
		components:
			"components" in t
				? t.components || null
				: t.component && { default: t.component },
	};
}
function l3(t) {
	const e = {},
		n = t.props || !1;
	if ("component" in t) e.default = n;
	else for (const r in t.components) e[r] = typeof n == "object" ? n[r] : n;
	return e;
}
function Up(t) {
	for (; t; ) {
		if (t.record.aliasOf) return !0;
		t = t.parent;
	}
	return !1;
}
function a3(t) {
	return t.reduce((e, n) => tt(e, n.meta), {});
}
function Kp(t, e) {
	const n = {};
	for (const r in t) n[r] = r in e ? e[r] : t[r];
	return n;
}
function j0(t, e) {
	return e.children.some((n) => n === t || j0(t, n));
}
const L0 = /#/g,
	u3 = /&/g,
	c3 = /\//g,
	d3 = /=/g,
	f3 = /\?/g,
	$0 = /\+/g,
	h3 = /%5B/g,
	p3 = /%5D/g,
	B0 = /%5E/g,
	m3 = /%60/g,
	z0 = /%7B/g,
	g3 = /%7C/g,
	H0 = /%7D/g,
	y3 = /%20/g;
function Lf(t) {
	return encodeURI("" + t)
		.replace(g3, "|")
		.replace(h3, "[")
		.replace(p3, "]");
}
function v3(t) {
	return Lf(t).replace(z0, "{").replace(H0, "}").replace(B0, "^");
}
function cd(t) {
	return Lf(t)
		.replace($0, "%2B")
		.replace(y3, "+")
		.replace(L0, "%23")
		.replace(u3, "%26")
		.replace(m3, "`")
		.replace(z0, "{")
		.replace(H0, "}")
		.replace(B0, "^");
}
function b3(t) {
	return cd(t).replace(d3, "%3D");
}
function w3(t) {
	return Lf(t).replace(L0, "%23").replace(f3, "%3F");
}
function x3(t) {
	return t == null ? "" : w3(t).replace(c3, "%2F");
}
function fa(t) {
	try {
		return decodeURIComponent("" + t);
	} catch (e) {}
	return "" + t;
}
function k3(t) {
	const e = {};
	if (t === "" || t === "?") return e;
	const r = (t[0] === "?" ? t.slice(1) : t).split("&");
	for (let o = 0; o < r.length; ++o) {
		const i = r[o].replace($0, " "),
			s = i.indexOf("="),
			l = fa(s < 0 ? i : i.slice(0, s)),
			a = s < 0 ? null : fa(i.slice(s + 1));
		if (l in e) {
			let u = e[l];
			Vn(u) || (u = e[l] = [u]), u.push(a);
		} else e[l] = a;
	}
	return e;
}
function qp(t) {
	let e = "";
	for (let n in t) {
		const r = t[n];
		if (((n = b3(n)), r == null)) {
			r !== void 0 && (e += (e.length ? "&" : "") + n);
			continue;
		}
		(Vn(r) ? r.map((i) => i && cd(i)) : [r && cd(r)]).forEach((i) => {
			i !== void 0 &&
				((e += (e.length ? "&" : "") + n), i != null && (e += "=" + i));
		});
	}
	return e;
}
function S3(t) {
	const e = {};
	for (const n in t) {
		const r = t[n];
		r !== void 0 &&
			(e[n] = Vn(r)
				? r.map((o) => (o == null ? null : "" + o))
				: r == null
				? r
				: "" + r);
	}
	return e;
}
const _3 = Symbol(""),
	Jp = Symbol(""),
	Cu = Symbol(""),
	$f = Symbol(""),
	dd = Symbol("");
function Vi() {
	let t = [];
	function e(r) {
		return (
			t.push(r),
			() => {
				const o = t.indexOf(r);
				o > -1 && t.splice(o, 1);
			}
		);
	}
	function n() {
		t = [];
	}
	return { add: e, list: () => t.slice(), reset: n };
}
function Br(t, e, n, r, o) {
	const i = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
	return () =>
		new Promise((s, l) => {
			const a = (d) => {
					d === !1
						? l(xi(4, { from: n, to: e }))
						: d instanceof Error
						? l(d)
						: Gx(d)
						? l(xi(2, { from: e, to: d }))
						: (i &&
								r.enterCallbacks[o] === i &&
								typeof d == "function" &&
								i.push(d),
						  s());
				},
				u = t.call(r && r.instances[o], e, n, a);
			let c = Promise.resolve(u);
			t.length < 3 && (c = c.then(a)), c.catch((d) => l(d));
		});
}
function dc(t, e, n, r) {
	const o = [];
	for (const i of t)
		for (const s in i.components) {
			let l = i.components[s];
			if (!(e !== "beforeRouteEnter" && !i.instances[s]))
				if (C3(l)) {
					const u = (l.__vccOpts || l)[e];
					u && o.push(Br(u, n, r, i, s));
				} else {
					let a = l();
					o.push(() =>
						a.then((u) => {
							if (!u)
								return Promise.reject(
									new Error(
										`Couldn't resolve component "${s}" at "${i.path}"`
									)
								);
							const c = Px(u) ? u.default : u;
							i.components[s] = c;
							const h = (c.__vccOpts || c)[e];
							return h && Br(h, n, r, i, s)();
						})
					);
				}
		}
	return o;
}
function C3(t) {
	return (
		typeof t == "object" ||
		"displayName" in t ||
		"props" in t ||
		"__vccOpts" in t
	);
}
function Gp(t) {
	const e = qe(Cu),
		n = qe($f),
		r = H(() => e.resolve(ue(t.to))),
		o = H(() => {
			const { matched: a } = r.value,
				{ length: u } = a,
				c = a[u - 1],
				d = n.matched;
			if (!c || !d.length) return -1;
			const h = d.findIndex(wi.bind(null, c));
			if (h > -1) return h;
			const p = Yp(a[u - 2]);
			return u > 1 && Yp(c) === p && d[d.length - 1].path !== p
				? d.findIndex(wi.bind(null, a[u - 2]))
				: h;
		}),
		i = H(() => o.value > -1 && A3(n.params, r.value.params)),
		s = H(
			() =>
				o.value > -1 &&
				o.value === n.matched.length - 1 &&
				P0(n.params, r.value.params)
		);
	function l(a = {}) {
		return T3(a)
			? e[ue(t.replace) ? "replace" : "push"](ue(t.to)).catch(ss)
			: Promise.resolve();
	}
	return {
		route: r,
		href: H(() => r.value.href),
		isActive: i,
		isExactActive: s,
		navigate: l,
	};
}
const M3 = Re({
		name: "RouterLink",
		compatConfig: { MODE: 3 },
		props: {
			to: { type: [String, Object], required: !0 },
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: { type: String, default: "page" },
		},
		useLink: Gp,
		setup(t, { slots: e }) {
			const n = Gt(Gp(t)),
				{ options: r } = qe(Cu),
				o = H(() => ({
					[Qp(
						t.activeClass,
						r.linkActiveClass,
						"router-link-active"
					)]: n.isActive,
					[Qp(
						t.exactActiveClass,
						r.linkExactActiveClass,
						"router-link-exact-active"
					)]: n.isExactActive,
				}));
			return () => {
				const i = e.default && e.default(n);
				return t.custom
					? i
					: Ue(
							"a",
							{
								"aria-current": n.isExactActive
									? t.ariaCurrentValue
									: null,
								href: n.href,
								onClick: n.navigate,
								class: o.value,
							},
							i
					  );
			};
		},
	}),
	E3 = M3;
function T3(t) {
	if (
		!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
		!t.defaultPrevented &&
		!(t.button !== void 0 && t.button !== 0)
	) {
		if (t.currentTarget && t.currentTarget.getAttribute) {
			const e = t.currentTarget.getAttribute("target");
			if (/\b_blank\b/i.test(e)) return;
		}
		return t.preventDefault && t.preventDefault(), !0;
	}
}
function A3(t, e) {
	for (const n in e) {
		const r = e[n],
			o = t[n];
		if (typeof r == "string") {
			if (r !== o) return !1;
		} else if (
			!Vn(o) ||
			o.length !== r.length ||
			r.some((i, s) => i !== o[s])
		)
			return !1;
	}
	return !0;
}
function Yp(t) {
	return t ? (t.aliasOf ? t.aliasOf.path : t.path) : "";
}
const Qp = (t, e, n) => (t != null ? t : e != null ? e : n),
	O3 = Re({
		name: "RouterView",
		inheritAttrs: !1,
		props: { name: { type: String, default: "default" }, route: Object },
		compatConfig: { MODE: 3 },
		setup(t, { attrs: e, slots: n }) {
			const r = qe(dd),
				o = H(() => t.route || r.value),
				i = qe(Jp, 0),
				s = H(() => {
					let u = ue(i);
					const { matched: c } = o.value;
					let d;
					for (; (d = c[u]) && !d.components; ) u++;
					return u;
				}),
				l = H(() => o.value.matched[s.value]);
			vt(
				Jp,
				H(() => s.value + 1)
			),
				vt(_3, l),
				vt(dd, o);
			const a = X();
			return (
				it(
					() => [a.value, l.value, t.name],
					([u, c, d], [h, p, g]) => {
						c &&
							((c.instances[d] = u),
							p &&
								p !== c &&
								u &&
								u === h &&
								(c.leaveGuards.size ||
									(c.leaveGuards = p.leaveGuards),
								c.updateGuards.size ||
									(c.updateGuards = p.updateGuards))),
							u &&
								c &&
								(!p || !wi(c, p) || !h) &&
								(c.enterCallbacks[d] || []).forEach((y) =>
									y(u)
								);
					},
					{ flush: "post" }
				),
				() => {
					const u = o.value,
						c = t.name,
						d = l.value,
						h = d && d.components[c];
					if (!h) return Xp(n.default, { Component: h, route: u });
					const p = d.props[c],
						g = p
							? p === !0
								? u.params
								: typeof p == "function"
								? p(u)
								: p
							: null,
						b = Ue(
							h,
							tt({}, g, e, {
								onVnodeUnmounted: (w) => {
									w.component.isUnmounted &&
										(d.instances[c] = null);
								},
								ref: a,
							})
						);
					return Xp(n.default, { Component: b, route: u }) || b;
				}
			);
		},
	});
function Xp(t, e) {
	if (!t) return null;
	const n = t(e);
	return n.length === 1 ? n[0] : n;
}
const R3 = O3;
function Dj(t) {
	const e = i3(t.routes, t),
		n = t.parseQuery || k3,
		r = t.stringifyQuery || qp,
		o = t.history,
		i = Vi(),
		s = Vi(),
		l = Vi(),
		a = pu(Rr);
	let u = Rr;
	ei &&
		t.scrollBehavior &&
		"scrollRestoration" in history &&
		(history.scrollRestoration = "manual");
	const c = uc.bind(null, (B) => "" + B),
		d = uc.bind(null, x3),
		h = uc.bind(null, fa);
	function p(B, Z) {
		let ne, ce;
		return (
			N0(B) ? ((ne = e.getRecordMatcher(B)), (ce = Z)) : (ce = B),
			e.addRoute(ce, ne)
		);
	}
	function g(B) {
		const Z = e.getRecordMatcher(B);
		Z && e.removeRoute(Z);
	}
	function y() {
		return e.getRoutes().map((B) => B.record);
	}
	function b(B) {
		return !!e.getRecordMatcher(B);
	}
	function w(B, Z) {
		if (((Z = tt({}, Z || a.value)), typeof B == "string")) {
			const O = cc(n, B, Z.path),
				L = e.resolve({ path: O.path }, Z),
				K = o.createHref(O.fullPath);
			return tt(O, L, {
				params: h(L.params),
				hash: fa(O.hash),
				redirectedFrom: void 0,
				href: K,
			});
		}
		let ne;
		if ("path" in B) ne = tt({}, B, { path: cc(n, B.path, Z.path).path });
		else {
			const O = tt({}, B.params);
			for (const L in O) O[L] == null && delete O[L];
			(ne = tt({}, B, { params: d(O) })), (Z.params = d(Z.params));
		}
		const ce = e.resolve(ne, Z),
			$e = B.hash || "";
		ce.params = c(h(ce.params));
		const Je = Dx(r, tt({}, B, { hash: v3($e), path: ce.path })),
			A = o.createHref(Je);
		return tt(
			{
				fullPath: Je,
				hash: $e,
				query: r === qp ? S3(B.query) : B.query || {},
			},
			ce,
			{ redirectedFrom: void 0, href: A }
		);
	}
	function S(B) {
		return typeof B == "string" ? cc(n, B, a.value.path) : tt({}, B);
	}
	function E(B, Z) {
		if (u !== B) return xi(8, { from: Z, to: B });
	}
	function f(B) {
		return x(B);
	}
	function v(B) {
		return f(tt(S(B), { replace: !0 }));
	}
	function m(B) {
		const Z = B.matched[B.matched.length - 1];
		if (Z && Z.redirect) {
			const { redirect: ne } = Z;
			let ce = typeof ne == "function" ? ne(B) : ne;
			return (
				typeof ce == "string" &&
					((ce =
						ce.includes("?") || ce.includes("#")
							? (ce = S(ce))
							: { path: ce }),
					(ce.params = {})),
				tt(
					{
						query: B.query,
						hash: B.hash,
						params: "path" in ce ? {} : B.params,
					},
					ce
				)
			);
		}
	}
	function x(B, Z) {
		const ne = (u = w(B)),
			ce = a.value,
			$e = B.state,
			Je = B.force,
			A = B.replace === !0,
			O = m(ne);
		if (O)
			return x(
				tt(S(O), {
					state: typeof O == "object" ? tt({}, $e, O.state) : $e,
					force: Je,
					replace: A,
				}),
				Z || ne
			);
		const L = ne;
		L.redirectedFrom = Z;
		let K;
		return (
			!Je &&
				jx(r, ce, ne) &&
				((K = xi(16, { to: L, from: ce })), Y(ce, ce, !0, !1)),
			(K ? Promise.resolve(K) : _(L, ce))
				.catch((W) => (pr(W) ? (pr(W, 2) ? W : ie(W)) : $(W, L, ce)))
				.then((W) => {
					if (W) {
						if (pr(W, 2))
							return x(
								tt({ replace: A }, S(W.to), {
									state:
										typeof W.to == "object"
											? tt({}, $e, W.to.state)
											: $e,
									force: Je,
								}),
								Z || L
							);
					} else W = R(L, ce, !0, A, $e);
					return T(L, ce, W), W;
				})
		);
	}
	function k(B, Z) {
		const ne = E(B, Z);
		return ne ? Promise.reject(ne) : Promise.resolve();
	}
	function C(B) {
		const Z = Ce.values().next().value;
		return Z && typeof Z.runWithContext == "function"
			? Z.runWithContext(B)
			: B();
	}
	function _(B, Z) {
		let ne;
		const [ce, $e, Je] = P3(B, Z);
		ne = dc(ce.reverse(), "beforeRouteLeave", B, Z);
		for (const O of ce)
			O.leaveGuards.forEach((L) => {
				ne.push(Br(L, B, Z));
			});
		const A = k.bind(null, B, Z);
		return (
			ne.push(A),
			Te(ne)
				.then(() => {
					ne = [];
					for (const O of i.list()) ne.push(Br(O, B, Z));
					return ne.push(A), Te(ne);
				})
				.then(() => {
					ne = dc($e, "beforeRouteUpdate", B, Z);
					for (const O of $e)
						O.updateGuards.forEach((L) => {
							ne.push(Br(L, B, Z));
						});
					return ne.push(A), Te(ne);
				})
				.then(() => {
					ne = [];
					for (const O of Je)
						if (O.beforeEnter)
							if (Vn(O.beforeEnter))
								for (const L of O.beforeEnter)
									ne.push(Br(L, B, Z));
							else ne.push(Br(O.beforeEnter, B, Z));
					return ne.push(A), Te(ne);
				})
				.then(
					() => (
						B.matched.forEach((O) => (O.enterCallbacks = {})),
						(ne = dc(Je, "beforeRouteEnter", B, Z)),
						ne.push(A),
						Te(ne)
					)
				)
				.then(() => {
					ne = [];
					for (const O of s.list()) ne.push(Br(O, B, Z));
					return ne.push(A), Te(ne);
				})
				.catch((O) => (pr(O, 8) ? O : Promise.reject(O)))
		);
	}
	function T(B, Z, ne) {
		l.list().forEach((ce) => C(() => ce(B, Z, ne)));
	}
	function R(B, Z, ne, ce, $e) {
		const Je = E(B, Z);
		if (Je) return Je;
		const A = Z === Rr,
			O = ei ? history.state : {};
		ne &&
			(ce || A
				? o.replace(B.fullPath, tt({ scroll: A && O && O.scroll }, $e))
				: o.push(B.fullPath, $e)),
			(a.value = B),
			Y(B, Z, ne, A),
			ie();
	}
	let P;
	function N() {
		P ||
			(P = o.listen((B, Z, ne) => {
				if (!Me.listening) return;
				const ce = w(B),
					$e = m(ce);
				if ($e) {
					x(tt($e, { replace: !0 }), ce).catch(ss);
					return;
				}
				u = ce;
				const Je = a.value;
				ei && Wx(Bp(Je.fullPath, ne.delta), _u()),
					_(ce, Je)
						.catch((A) =>
							pr(A, 12)
								? A
								: pr(A, 2)
								? (x(A.to, ce)
										.then((O) => {
											pr(O, 20) &&
												!ne.delta &&
												ne.type === Es.pop &&
												o.go(-1, !1);
										})
										.catch(ss),
								  Promise.reject())
								: (ne.delta && o.go(-ne.delta, !1),
								  $(A, ce, Je))
						)
						.then((A) => {
							(A = A || R(ce, Je, !1)),
								A &&
									(ne.delta && !pr(A, 8)
										? o.go(-ne.delta, !1)
										: ne.type === Es.pop &&
										  pr(A, 20) &&
										  o.go(-1, !1)),
								T(ce, Je, A);
						})
						.catch(ss);
			}));
	}
	let D = Vi(),
		M = Vi(),
		I;
	function $(B, Z, ne) {
		ie(B);
		const ce = M.list();
		return (
			ce.length ? ce.forEach(($e) => $e(B, Z, ne)) : console.error(B),
			Promise.reject(B)
		);
	}
	function V() {
		return I && a.value !== Rr
			? Promise.resolve()
			: new Promise((B, Z) => {
					D.add([B, Z]);
			  });
	}
	function ie(B) {
		return (
			I ||
				((I = !B),
				N(),
				D.list().forEach(([Z, ne]) => (B ? ne(B) : Z())),
				D.reset()),
			B
		);
	}
	function Y(B, Z, ne, ce) {
		const { scrollBehavior: $e } = t;
		if (!ei || !$e) return Promise.resolve();
		const Je =
			(!ne && Ux(Bp(B.fullPath, 0))) ||
			((ce || !ne) && history.state && history.state.scroll) ||
			null;
		return zt()
			.then(() => $e(B, Z, Je))
			.then((A) => A && Vx(A))
			.catch((A) => $(A, B, Z));
	}
	const he = (B) => o.go(B);
	let Le;
	const Ce = new Set(),
		Me = {
			currentRoute: a,
			listening: !0,
			addRoute: p,
			removeRoute: g,
			hasRoute: b,
			getRoutes: y,
			resolve: w,
			options: t,
			push: f,
			replace: v,
			go: he,
			back: () => he(-1),
			forward: () => he(1),
			beforeEach: i.add,
			beforeResolve: s.add,
			afterEach: l.add,
			onError: M.add,
			isReady: V,
			install(B) {
				const Z = this;
				B.component("RouterLink", E3),
					B.component("RouterView", R3),
					(B.config.globalProperties.$router = Z),
					Object.defineProperty(B.config.globalProperties, "$route", {
						enumerable: !0,
						get: () => ue(a),
					}),
					ei &&
						!Le &&
						a.value === Rr &&
						((Le = !0), f(o.location).catch(($e) => {}));
				const ne = {};
				for (const $e in Rr)
					Object.defineProperty(ne, $e, {
						get: () => a.value[$e],
						enumerable: !0,
					});
				B.provide(Cu, Z), B.provide($f, $1(ne)), B.provide(dd, a);
				const ce = B.unmount;
				Ce.add(B),
					(B.unmount = function () {
						Ce.delete(B),
							Ce.size < 1 &&
								((u = Rr),
								P && P(),
								(P = null),
								(a.value = Rr),
								(Le = !1),
								(I = !1)),
							ce();
					});
			},
		};
	function Te(B) {
		return B.reduce((Z, ne) => Z.then(() => C(ne)), Promise.resolve());
	}
	return Me;
}
function P3(t, e) {
	const n = [],
		r = [],
		o = [],
		i = Math.max(e.matched.length, t.matched.length);
	for (let s = 0; s < i; s++) {
		const l = e.matched[s];
		l && (t.matched.find((u) => wi(u, l)) ? r.push(l) : n.push(l));
		const a = t.matched[s];
		a && (e.matched.find((u) => wi(u, a)) || o.push(a));
	}
	return [n, r, o];
}
function F0() {
	return qe(Cu);
}
function jj() {
	return qe($f);
}
var Lj = !1;
const je = (t, e) => {
	const n = t.__vccOpts || t;
	for (const [r, o] of e) n[r] = o;
	return n;
};
/**
 * vue-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function ha() {
	return (
		(ha = Object.assign
			? Object.assign.bind()
			: function (t) {
					for (var e = 1; e < arguments.length; e++) {
						var n = arguments[e];
						for (var r in n)
							Object.prototype.hasOwnProperty.call(n, r) &&
								(t[r] = n[r]);
					}
					return t;
			  }),
		ha.apply(this, arguments)
	);
}
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function pa() {
	return (
		(pa = Object.assign
			? Object.assign.bind()
			: function (t) {
					for (var e = 1; e < arguments.length; e++) {
						var n = arguments[e];
						for (var r in n)
							Object.prototype.hasOwnProperty.call(n, r) &&
								(t[r] = n[r]);
					}
					return t;
			  }),
		pa.apply(this, arguments)
	);
}
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Go(t, e, n) {
	var r,
		o = (r = n.initialDeps) != null ? r : [],
		i;
	return function () {
		var s;
		n.key && n.debug != null && n.debug() && (s = Date.now());
		var l = t(),
			a =
				l.length !== o.length ||
				l.some(function (g, y) {
					return o[y] !== g;
				});
		if (!a) return i;
		o = l;
		var u;
		if (
			(n.key && n.debug != null && n.debug() && (u = Date.now()),
			(i = e.apply(void 0, l)),
			n.key && n.debug != null && n.debug())
		) {
			var c = Math.round((Date.now() - s) * 100) / 100,
				d = Math.round((Date.now() - u) * 100) / 100,
				h = d / 16,
				p = function (y, b) {
					for (y = String(y); y.length < b; ) y = " " + y;
					return y;
				};
			console.info(
				"%c " + p(d, 5) + " /" + p(c, 5) + " ms",
				`
            font-size: .6rem;
            font-weight: bold;
            color: hsl(` +
					Math.max(0, Math.min(120 - 120 * h, 120)) +
					"deg 100% 31%);",
				n == null ? void 0 : n.key
			);
		}
		return n == null || n.onChange == null || n.onChange(i), i;
	};
}
function fc(t, e) {
	if (t === void 0)
		throw new Error("Unexpected undefined" + (e ? ": " + e : ""));
	return t;
}
var I3 = function (e, n) {
	return Math.abs(e - n) < 1;
};
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ var N3 = function (e) {
		return e;
	},
	D3 = function (e) {
		for (
			var n = Math.max(e.startIndex - e.overscan, 0),
				r = Math.min(e.endIndex + e.overscan, e.count - 1),
				o = [],
				i = n;
			i <= r;
			i++
		)
			o.push(i);
		return o;
	},
	j3 = function (e, n) {
		var r = e.scrollElement;
		if (r) {
			var o = function (l) {
				var a = l.width,
					u = l.height;
				n({ width: Math.round(a), height: Math.round(u) });
			};
			o(r.getBoundingClientRect());
			var i = new ResizeObserver(function (s) {
				var l = s[0];
				if (l != null && l.borderBoxSize) {
					var a = l.borderBoxSize[0];
					if (a) {
						o({ width: a.inlineSize, height: a.blockSize });
						return;
					}
				}
				o(r.getBoundingClientRect());
			});
			return (
				i.observe(r, { box: "border-box" }),
				function () {
					i.unobserve(r);
				}
			);
		}
	},
	L3 = function (e, n) {
		var r = e.scrollElement;
		if (r) {
			var o = function () {
				n(r[e.options.horizontal ? "scrollLeft" : "scrollTop"]);
			};
			return (
				o(),
				r.addEventListener("scroll", o, { passive: !0 }),
				function () {
					r.removeEventListener("scroll", o);
				}
			);
		}
	},
	$3 = function (e, n, r) {
		if (n != null && n.borderBoxSize) {
			var o = n.borderBoxSize[0];
			if (o) {
				var i = Math.round(
					o[r.options.horizontal ? "inlineSize" : "blockSize"]
				);
				return i;
			}
		}
		return Math.round(
			e.getBoundingClientRect()[r.options.horizontal ? "width" : "height"]
		);
	},
	B3 = function (e, n, r) {
		var o,
			i,
			s = n.adjustments,
			l = s === void 0 ? 0 : s,
			a = n.behavior,
			u = e + l;
		(o = r.scrollElement) == null ||
			o.scrollTo == null ||
			o.scrollTo(
				((i = {}),
				(i[r.options.horizontal ? "left" : "top"] = u),
				(i.behavior = a),
				i)
			);
	},
	z3 = function (e) {
		var n = this;
		(this.unsubs = []),
			(this.scrollElement = null),
			(this.isScrolling = !1),
			(this.isScrollingTimeoutId = null),
			(this.scrollToIndexTimeoutId = null),
			(this.measurementsCache = []),
			(this.itemSizeCache = new Map()),
			(this.pendingMeasuredCacheIndexes = []),
			(this.scrollDirection = null),
			(this.scrollAdjustments = 0),
			(this.measureElementCache = new Map()),
			(this.observer = (function () {
				var r = null,
					o = function () {
						return (
							r ||
							(typeof ResizeObserver != "undefined"
								? (r = new ResizeObserver(function (s) {
										s.forEach(function (l) {
											n._measureElement(l.target, l);
										});
								  }))
								: null)
						);
					};
				return {
					disconnect: function () {
						var s;
						return (s = o()) == null ? void 0 : s.disconnect();
					},
					observe: function (s) {
						var l;
						return (l = o()) == null
							? void 0
							: l.observe(s, { box: "border-box" });
					},
					unobserve: function (s) {
						var l;
						return (l = o()) == null ? void 0 : l.unobserve(s);
					},
				};
			})()),
			(this.range = null),
			(this.setOptions = function (r) {
				Object.entries(r).forEach(function (o) {
					var i = o[0],
						s = o[1];
					typeof s == "undefined" && delete r[i];
				}),
					(n.options = pa(
						{
							debug: !1,
							initialOffset: 0,
							overscan: 1,
							paddingStart: 0,
							paddingEnd: 0,
							scrollPaddingStart: 0,
							scrollPaddingEnd: 0,
							horizontal: !1,
							getItemKey: N3,
							rangeExtractor: D3,
							onChange: function () {},
							measureElement: $3,
							initialRect: { width: 0, height: 0 },
							scrollMargin: 0,
							scrollingDelay: 150,
							indexAttribute: "data-index",
							initialMeasurementsCache: [],
							lanes: 1,
						},
						r
					));
			}),
			(this.notify = function (r) {
				n.options.onChange == null || n.options.onChange(n, r);
			}),
			(this.maybeNotify = Go(
				function () {
					return (
						n.calculateRange(),
						[
							n.isScrolling,
							n.range ? n.range.startIndex : null,
							n.range ? n.range.endIndex : null,
						]
					);
				},
				function (r) {
					n.notify(r);
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
					initialDeps: [
						this.isScrolling,
						this.range ? this.range.startIndex : null,
						this.range ? this.range.endIndex : null,
					],
				}
			)),
			(this.cleanup = function () {
				n.unsubs.filter(Boolean).forEach(function (r) {
					return r();
				}),
					(n.unsubs = []),
					(n.scrollElement = null);
			}),
			(this._didMount = function () {
				return (
					n.measureElementCache.forEach(n.observer.observe),
					function () {
						n.observer.disconnect(), n.cleanup();
					}
				);
			}),
			(this._willUpdate = function () {
				var r = n.options.getScrollElement();
				n.scrollElement !== r &&
					(n.cleanup(),
					(n.scrollElement = r),
					n._scrollToOffset(n.scrollOffset, {
						adjustments: void 0,
						behavior: void 0,
					}),
					n.unsubs.push(
						n.options.observeElementRect(n, function (o) {
							(n.scrollRect = o), n.maybeNotify();
						})
					),
					n.unsubs.push(
						n.options.observeElementOffset(n, function (o) {
							(n.scrollAdjustments = 0),
								n.scrollOffset !== o &&
									(n.isScrollingTimeoutId !== null &&
										(clearTimeout(n.isScrollingTimeoutId),
										(n.isScrollingTimeoutId = null)),
									(n.isScrolling = !0),
									(n.scrollDirection =
										n.scrollOffset < o
											? "forward"
											: "backward"),
									(n.scrollOffset = o),
									n.maybeNotify(),
									(n.isScrollingTimeoutId = setTimeout(
										function () {
											(n.isScrollingTimeoutId = null),
												(n.isScrolling = !1),
												(n.scrollDirection = null),
												n.maybeNotify();
										},
										n.options.scrollingDelay
									)));
						})
					));
			}),
			(this.getSize = function () {
				return n.scrollRect[n.options.horizontal ? "width" : "height"];
			}),
			(this.memoOptions = Go(
				function () {
					return [
						n.options.count,
						n.options.paddingStart,
						n.options.scrollMargin,
						n.options.getItemKey,
					];
				},
				function (r, o, i, s) {
					return (
						(n.pendingMeasuredCacheIndexes = []),
						{
							count: r,
							paddingStart: o,
							scrollMargin: i,
							getItemKey: s,
						}
					);
				},
				{ key: !1 }
			)),
			(this.getFurthestMeasurement = function (r, o) {
				for (var i = new Map(), s = new Map(), l = o - 1; l >= 0; l--) {
					var a = r[l];
					if (!i.has(a.lane)) {
						var u = s.get(a.lane);
						if (
							(u == null || a.end > u.end
								? s.set(a.lane, a)
								: a.end < u.end && i.set(a.lane, !0),
							i.size === n.options.lanes)
						)
							break;
					}
				}
				return s.size === n.options.lanes
					? Array.from(s.values()).sort(function (c, d) {
							return c.end - d.end;
					  })[0]
					: void 0;
			}),
			(this.getMeasurements = Go(
				function () {
					return [n.memoOptions(), n.itemSizeCache];
				},
				function (r, o) {
					var i = r.count,
						s = r.paddingStart,
						l = r.scrollMargin,
						a = r.getItemKey,
						u =
							n.pendingMeasuredCacheIndexes.length > 0
								? Math.min.apply(
										Math,
										n.pendingMeasuredCacheIndexes
								  )
								: 0;
					n.pendingMeasuredCacheIndexes = [];
					for (
						var c = n.measurementsCache.slice(0, u), d = u;
						d < i;
						d++
					) {
						var h = a(d),
							p =
								n.options.lanes === 1
									? c[d - 1]
									: n.getFurthestMeasurement(c, d),
							g = p ? p.end : s + l,
							y = o.get(h),
							b =
								typeof y == "number"
									? y
									: n.options.estimateSize(d),
							w = g + b,
							S = p ? p.lane : d % n.options.lanes;
						c[d] = {
							index: d,
							start: g,
							size: b,
							end: w,
							key: h,
							lane: S,
						};
					}
					return (n.measurementsCache = c), c;
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.calculateRange = Go(
				function () {
					return [n.getMeasurements(), n.getSize(), n.scrollOffset];
				},
				function (r, o, i) {
					return (n.range =
						r.length > 0 && o > 0
							? H3({
									measurements: r,
									outerSize: o,
									scrollOffset: i,
							  })
							: null);
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.getIndexes = Go(
				function () {
					return [
						n.options.rangeExtractor,
						n.calculateRange(),
						n.options.overscan,
						n.options.count,
					];
				},
				function (r, o, i, s) {
					return o === null
						? []
						: r(pa({}, o, { overscan: i, count: s }));
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.indexFromElement = function (r) {
				var o = n.options.indexAttribute,
					i = r.getAttribute(o);
				return i
					? parseInt(i, 10)
					: (console.warn(
							"Missing attribute name '" +
								o +
								"={index}' on measured element."
					  ),
					  -1);
			}),
			(this._measureElement = function (r, o) {
				var i = n.measurementsCache[n.indexFromElement(r)];
				if (!i || !r.isConnected) {
					n.measureElementCache.forEach(function (a, u) {
						a === r &&
							(n.observer.unobserve(r),
							n.measureElementCache.delete(u));
					});
					return;
				}
				var s = n.measureElementCache.get(i.key);
				s !== r &&
					(s && n.observer.unobserve(s),
					n.observer.observe(r),
					n.measureElementCache.set(i.key, r));
				var l = n.options.measureElement(r, o, n);
				n.resizeItem(i, l);
			}),
			(this.resizeItem = function (r, o) {
				var i,
					s = (i = n.itemSizeCache.get(r.key)) != null ? i : r.size,
					l = o - s;
				l !== 0 &&
					(r.start < n.scrollOffset &&
						n._scrollToOffset(n.scrollOffset, {
							adjustments: (n.scrollAdjustments += l),
							behavior: void 0,
						}),
					n.pendingMeasuredCacheIndexes.push(r.index),
					(n.itemSizeCache = new Map(n.itemSizeCache.set(r.key, o))),
					n.notify(!1));
			}),
			(this.measureElement = function (r) {
				r && n._measureElement(r, void 0);
			}),
			(this.getVirtualItems = Go(
				function () {
					return [n.getIndexes(), n.getMeasurements()];
				},
				function (r, o) {
					for (var i = [], s = 0, l = r.length; s < l; s++) {
						var a = r[s],
							u = o[a];
						i.push(u);
					}
					return i;
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.getVirtualItemForOffset = function (r) {
				var o = n.getMeasurements();
				return fc(
					o[
						V0(
							0,
							o.length - 1,
							function (i) {
								return fc(o[i]).start;
							},
							r
						)
					]
				);
			}),
			(this.getOffsetForAlignment = function (r, o) {
				var i = n.getSize();
				o === "auto" &&
					(r <= n.scrollOffset
						? (o = "start")
						: r >= n.scrollOffset + i
						? (o = "end")
						: (o = "start")),
					o === "start"
						? (r = r)
						: o === "end"
						? (r = r - i)
						: o === "center" && (r = r - i / 2);
				var s = n.options.horizontal ? "scrollWidth" : "scrollHeight",
					l = n.scrollElement
						? "document" in n.scrollElement
							? n.scrollElement.document.documentElement[s]
							: n.scrollElement[s]
						: 0,
					a = l - n.getSize();
				return Math.max(Math.min(a, r), 0);
			}),
			(this.getOffsetForIndex = function (r, o) {
				o === void 0 && (o = "auto"),
					(r = Math.max(0, Math.min(r, n.options.count - 1)));
				var i = fc(n.getMeasurements()[r]);
				if (o === "auto")
					if (
						i.end >=
						n.scrollOffset +
							n.getSize() -
							n.options.scrollPaddingEnd
					)
						o = "end";
					else if (
						i.start <=
						n.scrollOffset + n.options.scrollPaddingStart
					)
						o = "start";
					else return [n.scrollOffset, o];
				var s =
					o === "end"
						? i.end + n.options.scrollPaddingEnd
						: i.start - n.options.scrollPaddingStart;
				return [n.getOffsetForAlignment(s, o), o];
			}),
			(this.isDynamicMode = function () {
				return n.measureElementCache.size > 0;
			}),
			(this.cancelScrollToIndex = function () {
				n.scrollToIndexTimeoutId !== null &&
					(clearTimeout(n.scrollToIndexTimeoutId),
					(n.scrollToIndexTimeoutId = null));
			}),
			(this.scrollToOffset = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.align,
					l = s === void 0 ? "start" : s,
					a = i.behavior;
				n.cancelScrollToIndex(),
					a === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						),
					n._scrollToOffset(n.getOffsetForAlignment(r, l), {
						adjustments: void 0,
						behavior: a,
					});
			}),
			(this.scrollToIndex = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.align,
					l = s === void 0 ? "auto" : s,
					a = i.behavior;
				(r = Math.max(0, Math.min(r, n.options.count - 1))),
					n.cancelScrollToIndex(),
					a === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						);
				var u = n.getOffsetForIndex(r, l),
					c = u[0],
					d = u[1];
				n._scrollToOffset(c, { adjustments: void 0, behavior: a }),
					a !== "smooth" &&
						n.isDynamicMode() &&
						(n.scrollToIndexTimeoutId = setTimeout(function () {
							n.scrollToIndexTimeoutId = null;
							var h = n.measureElementCache.has(
								n.options.getItemKey(r)
							);
							if (h) {
								var p = n.getOffsetForIndex(r, d),
									g = p[0];
								I3(g, n.scrollOffset) ||
									n.scrollToIndex(r, {
										align: d,
										behavior: a,
									});
							} else n.scrollToIndex(r, { align: d, behavior: a });
						}));
			}),
			(this.scrollBy = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.behavior;
				n.cancelScrollToIndex(),
					s === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						),
					n._scrollToOffset(n.scrollOffset + r, {
						adjustments: void 0,
						behavior: s,
					});
			}),
			(this.getTotalSize = function () {
				var r;
				return (
					(((r = n.getMeasurements()[n.options.count - 1]) == null
						? void 0
						: r.end) || n.options.paddingStart) -
					n.options.scrollMargin +
					n.options.paddingEnd
				);
			}),
			(this._scrollToOffset = function (r, o) {
				var i = o.adjustments,
					s = o.behavior;
				n.options.scrollToFn(r, { behavior: s, adjustments: i }, n);
			}),
			(this.measure = function () {
				(n.itemSizeCache = new Map()), n.notify(!1);
			}),
			this.setOptions(e),
			(this.scrollRect = this.options.initialRect),
			(this.scrollOffset = this.options.initialOffset),
			(this.measurementsCache = this.options.initialMeasurementsCache),
			this.measurementsCache.forEach(function (r) {
				n.itemSizeCache.set(r.key, r.size);
			}),
			this.maybeNotify();
	},
	V0 = function (e, n, r, o) {
		for (; e <= n; ) {
			var i = ((e + n) / 2) | 0,
				s = r(i);
			if (s < o) e = i + 1;
			else if (s > o) n = i - 1;
			else return i;
		}
		return e > 0 ? e - 1 : 0;
	};
function H3(t) {
	for (
		var e = t.measurements,
			n = t.outerSize,
			r = t.scrollOffset,
			o = e.length - 1,
			i = function (u) {
				return e[u].start;
			},
			s = V0(0, o, i, r),
			l = s;
		l < o && e[l].end < r + n;

	)
		l++;
	return { startIndex: s, endIndex: l };
}
/**
 * vue-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function F3(t) {
	var e = new z3(ue(t)),
		n = pu(e),
		r = e._didMount();
	return (
		it(
			function () {
				return ue(t).getScrollElement();
			},
			function (o) {
				o && e._willUpdate();
			},
			{ immediate: !0 }
		),
		it(
			function () {
				return ue(t);
			},
			function (o) {
				e.setOptions(
					ha({}, o, {
						onChange: function (s, l) {
							op(n), o.onChange == null || o.onChange(s, l);
						},
					})
				),
					e._willUpdate(),
					op(n);
			},
			{ immediate: !0 }
		),
		M1(r),
		n
	);
}
function V3(t) {
	return F3(
		H(function () {
			return ha(
				{
					observeElementRect: j3,
					observeElementOffset: L3,
					scrollToFn: B3,
				},
				ue(t)
			);
		})
	);
}
function W3(t, e, n) {
	let r = X(n == null ? void 0 : n.value),
		o = H(() => t.value !== void 0);
	return [
		H(() => (o.value ? t.value : r.value)),
		function (i) {
			return o.value || (r.value = i), e == null ? void 0 : e(i);
		},
	];
}
let U3 = 0;
function K3() {
	return ++U3;
}
function dn() {
	return K3();
}
function re(t) {
	var e;
	if (t == null || t.value == null) return null;
	let n = (e = t.value.$el) != null ? e : t.value;
	return n instanceof Node ? n : null;
}
function pt(t, e, ...n) {
	if (t in e) {
		let o = e[t];
		return typeof o == "function" ? o(...n) : o;
	}
	let r = new Error(
		`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(
			e
		)
			.map((o) => `"${o}"`)
			.join(", ")}.`
	);
	throw (Error.captureStackTrace && Error.captureStackTrace(r, pt), r);
}
var q3 = Object.defineProperty,
	J3 = (t, e, n) =>
		e in t
			? q3(t, e, {
					enumerable: !0,
					configurable: !0,
					writable: !0,
					value: n,
			  })
			: (t[e] = n),
	Zp = (t, e, n) => (J3(t, typeof e != "symbol" ? e + "" : e, n), n);
let G3 = class {
		constructor() {
			Zp(this, "current", this.detect()), Zp(this, "currentId", 0);
		}
		set(e) {
			this.current !== e && ((this.currentId = 0), (this.current = e));
		}
		reset() {
			this.set(this.detect());
		}
		nextId() {
			return ++this.currentId;
		}
		get isServer() {
			return this.current === "server";
		}
		get isClient() {
			return this.current === "client";
		}
		detect() {
			return typeof window == "undefined" ||
				typeof document == "undefined"
				? "server"
				: "client";
		}
	},
	Js = new G3();
function dr(t) {
	if (Js.isServer) return null;
	if (t instanceof Node) return t.ownerDocument;
	if (t != null && t.hasOwnProperty("value")) {
		let e = re(t);
		if (e) return e.ownerDocument;
	}
	return document;
}
let fd = [
	"[contentEditable=true]",
	"[tabindex]",
	"a[href]",
	"area[href]",
	"button:not([disabled])",
	"iframe",
	"input:not([disabled])",
	"select:not([disabled])",
	"textarea:not([disabled])",
]
	.map((t) => `${t}:not([tabindex='-1'])`)
	.join(",");
var _t = ((t) => (
		(t[(t.First = 1)] = "First"),
		(t[(t.Previous = 2)] = "Previous"),
		(t[(t.Next = 4)] = "Next"),
		(t[(t.Last = 8)] = "Last"),
		(t[(t.WrapAround = 16)] = "WrapAround"),
		(t[(t.NoScroll = 32)] = "NoScroll"),
		t
	))(_t || {}),
	si = ((t) => (
		(t[(t.Error = 0)] = "Error"),
		(t[(t.Overflow = 1)] = "Overflow"),
		(t[(t.Success = 2)] = "Success"),
		(t[(t.Underflow = 3)] = "Underflow"),
		t
	))(si || {}),
	Y3 = ((t) => (
		(t[(t.Previous = -1)] = "Previous"), (t[(t.Next = 1)] = "Next"), t
	))(Y3 || {});
function W0(t = document.body) {
	return t == null
		? []
		: Array.from(t.querySelectorAll(fd)).sort((e, n) =>
				Math.sign(
					(e.tabIndex || Number.MAX_SAFE_INTEGER) -
						(n.tabIndex || Number.MAX_SAFE_INTEGER)
				)
		  );
}
var Bf = ((t) => (
	(t[(t.Strict = 0)] = "Strict"), (t[(t.Loose = 1)] = "Loose"), t
))(Bf || {});
function zf(t, e = 0) {
	var n;
	return t === ((n = dr(t)) == null ? void 0 : n.body)
		? !1
		: pt(e, {
				0() {
					return t.matches(fd);
				},
				1() {
					let r = t;
					for (; r !== null; ) {
						if (r.matches(fd)) return !0;
						r = r.parentElement;
					}
					return !1;
				},
		  });
}
function U0(t) {
	let e = dr(t);
	zt(() => {
		e && !zf(e.activeElement, 0) && Zr(t);
	});
}
var Q3 = ((t) => (
	(t[(t.Keyboard = 0)] = "Keyboard"), (t[(t.Mouse = 1)] = "Mouse"), t
))(Q3 || {});
typeof window != "undefined" &&
	typeof document != "undefined" &&
	(document.addEventListener(
		"keydown",
		(t) => {
			t.metaKey ||
				t.altKey ||
				t.ctrlKey ||
				(document.documentElement.dataset.headlessuiFocusVisible = "");
		},
		!0
	),
	document.addEventListener(
		"click",
		(t) => {
			t.detail === 1
				? delete document.documentElement.dataset.headlessuiFocusVisible
				: t.detail === 0 &&
				  (document.documentElement.dataset.headlessuiFocusVisible =
						"");
		},
		!0
	));
function Zr(t) {
	t == null || t.focus({ preventScroll: !0 });
}
let X3 = ["textarea", "input"].join(",");
function Z3(t) {
	var e, n;
	return (n =
		(e = t == null ? void 0 : t.matches) == null
			? void 0
			: e.call(t, X3)) != null
		? n
		: !1;
}
function Vr(t, e = (n) => n) {
	return t.slice().sort((n, r) => {
		let o = e(n),
			i = e(r);
		if (o === null || i === null) return 0;
		let s = o.compareDocumentPosition(i);
		return s & Node.DOCUMENT_POSITION_FOLLOWING
			? -1
			: s & Node.DOCUMENT_POSITION_PRECEDING
			? 1
			: 0;
	});
}
function ek(t, e) {
	return Nn(W0(), e, { relativeTo: t });
}
function Nn(
	t,
	e,
	{ sorted: n = !0, relativeTo: r = null, skipElements: o = [] } = {}
) {
	var i;
	let s =
			(i = Array.isArray(t)
				? t.length > 0
					? t[0].ownerDocument
					: document
				: t == null
				? void 0
				: t.ownerDocument) != null
				? i
				: document,
		l = Array.isArray(t) ? (n ? Vr(t) : t) : W0(t);
	o.length > 0 && l.length > 1 && (l = l.filter((g) => !o.includes(g))),
		(r = r != null ? r : s.activeElement);
	let a = (() => {
			if (e & 5) return 1;
			if (e & 10) return -1;
			throw new Error(
				"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
			);
		})(),
		u = (() => {
			if (e & 1) return 0;
			if (e & 2) return Math.max(0, l.indexOf(r)) - 1;
			if (e & 4) return Math.max(0, l.indexOf(r)) + 1;
			if (e & 8) return l.length - 1;
			throw new Error(
				"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
			);
		})(),
		c = e & 32 ? { preventScroll: !0 } : {},
		d = 0,
		h = l.length,
		p;
	do {
		if (d >= h || d + h <= 0) return 0;
		let g = u + d;
		if (e & 16) g = (g + h) % h;
		else {
			if (g < 0) return 3;
			if (g >= h) return 1;
		}
		(p = l[g]), p == null || p.focus(c), (d += a);
	} while (p !== s.activeElement);
	return e & 6 && Z3(p) && p.select(), 2;
}
function K0() {
	return (
		/iPhone/gi.test(window.navigator.platform) ||
		(/Mac/gi.test(window.navigator.platform) &&
			window.navigator.maxTouchPoints > 0)
	);
}
function tk() {
	return /Android/gi.test(window.navigator.userAgent);
}
function q0() {
	return K0() || tk();
}
function yl(t, e, n) {
	Js.isServer ||
		bt((r) => {
			document.addEventListener(t, e, n),
				r(() => document.removeEventListener(t, e, n));
		});
}
function J0(t, e, n) {
	Js.isServer ||
		bt((r) => {
			window.addEventListener(t, e, n),
				r(() => window.removeEventListener(t, e, n));
		});
}
function Hf(t, e, n = H(() => !0)) {
	function r(i, s) {
		if (!n.value || i.defaultPrevented) return;
		let l = s(i);
		if (l === null || !l.getRootNode().contains(l)) return;
		let a = (function u(c) {
			return typeof c == "function"
				? u(c())
				: Array.isArray(c) || c instanceof Set
				? c
				: [c];
		})(t);
		for (let u of a) {
			if (u === null) continue;
			let c = u instanceof HTMLElement ? u : re(u);
			if (
				(c != null && c.contains(l)) ||
				(i.composed && i.composedPath().includes(c))
			)
				return;
		}
		return (
			!zf(l, Bf.Loose) && l.tabIndex !== -1 && i.preventDefault(), e(i, l)
		);
	}
	let o = X(null);
	yl(
		"pointerdown",
		(i) => {
			var s, l;
			n.value &&
				(o.value =
					((l = (s = i.composedPath) == null ? void 0 : s.call(i)) ==
					null
						? void 0
						: l[0]) || i.target);
		},
		!0
	),
		yl(
			"mousedown",
			(i) => {
				var s, l;
				n.value &&
					(o.value =
						((l =
							(s = i.composedPath) == null
								? void 0
								: s.call(i)) == null
							? void 0
							: l[0]) || i.target);
			},
			!0
		),
		yl(
			"click",
			(i) => {
				q0() || (o.value && (r(i, () => o.value), (o.value = null)));
			},
			!0
		),
		yl(
			"touchend",
			(i) =>
				r(i, () => (i.target instanceof HTMLElement ? i.target : null)),
			!0
		),
		J0(
			"blur",
			(i) =>
				r(i, () =>
					window.document.activeElement instanceof HTMLIFrameElement
						? window.document.activeElement
						: null
				),
			!0
		);
}
function em(t, e) {
	if (t) return t;
	let n = e != null ? e : "button";
	if (typeof n == "string" && n.toLowerCase() === "button") return "button";
}
function Ff(t, e) {
	let n = X(em(t.value.type, t.value.as));
	return (
		Xe(() => {
			n.value = em(t.value.type, t.value.as);
		}),
		bt(() => {
			var r;
			n.value ||
				(re(e) &&
					re(e) instanceof HTMLButtonElement &&
					!((r = re(e)) != null && r.hasAttribute("type")) &&
					(n.value = "button"));
		}),
		n
	);
}
function tm(t) {
	return [t.screenX, t.screenY];
}
function G0() {
	let t = X([-1, -1]);
	return {
		wasMoved(e) {
			let n = tm(e);
			return t.value[0] === n[0] && t.value[1] === n[1]
				? !1
				: ((t.value = n), !0);
		},
		update(e) {
			t.value = tm(e);
		},
	};
}
function Y0({ container: t, accept: e, walk: n, enabled: r }) {
	bt(() => {
		let o = t.value;
		if (!o || (r !== void 0 && !r.value)) return;
		let i = dr(t);
		if (!i) return;
		let s = Object.assign((a) => e(a), { acceptNode: e }),
			l = i.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, s, !1);
		for (; l.nextNode(); ) n(l.currentNode);
	});
}
var fn = ((t) => (
		(t[(t.None = 0)] = "None"),
		(t[(t.RenderStrategy = 1)] = "RenderStrategy"),
		(t[(t.Static = 2)] = "Static"),
		t
	))(fn || {}),
	qr = ((t) => (
		(t[(t.Unmount = 0)] = "Unmount"), (t[(t.Hidden = 1)] = "Hidden"), t
	))(qr || {});
function ut(i) {
	var s = i,
		{ visible: t = !0, features: e = 0, ourProps: n, theirProps: r } = s,
		o = et(s, ["visible", "features", "ourProps", "theirProps"]);
	var l;
	let a = X0(r, n),
		u = Object.assign(o, { props: a });
	if (t || (e & 2 && a.static)) return hc(u);
	if (e & 1) {
		let c = (l = a.unmount) == null || l ? 0 : 1;
		return pt(c, {
			0() {
				return null;
			},
			1() {
				return hc(
					ye(z({}, o), {
						props: ye(z({}, a), {
							hidden: !0,
							style: { display: "none" },
						}),
					})
				);
			},
		});
	}
	return hc(u);
}
function hc({ props: t, attrs: e, slots: n, slot: r, name: o }) {
	var i, s;
	let d = Di(t, ["unmount", "static"]),
		{ as: l } = d,
		a = et(d, ["as"]),
		u = (i = n.default) == null ? void 0 : i.call(n, r),
		c = {};
	if (r) {
		let h = !1,
			p = [];
		for (let [g, y] of Object.entries(r))
			typeof y == "boolean" && (h = !0), y === !0 && p.push(g);
		h && (c["data-headlessui-state"] = p.join(" "));
	}
	if (l === "template") {
		if (
			((u = Q0(u != null ? u : [])),
			Object.keys(a).length > 0 || Object.keys(e).length > 0)
		) {
			let [h, ...p] = u != null ? u : [];
			if (!rk(h) || p.length > 0)
				throw new Error(
					[
						'Passing props on "template"!',
						"",
						`The current component <${o} /> is rendering a "template".`,
						"However we need to passthrough the following props:",
						Object.keys(a)
							.concat(Object.keys(e))
							.map((b) => b.trim())
							.filter((b, w, S) => S.indexOf(b) === w)
							.sort((b, w) => b.localeCompare(w))
							.map((b) => `  - ${b}`).join(`
`),
						"",
						"You can apply a few solutions:",
						[
							'Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".',
							"Render a single element as the child so that we can forward the props onto that element.",
						].map((b) => `  - ${b}`).join(`
`),
					].join(`
`)
				);
			let g = X0((s = h.props) != null ? s : {}, a, c),
				y = sr(h, g, !0);
			for (let b in g)
				b.startsWith("on") &&
					(y.props || (y.props = {}), (y.props[b] = g[b]));
			return y;
		}
		return Array.isArray(u) && u.length === 1 ? u[0] : u;
	}
	return Ue(l, Object.assign({}, a, c), { default: () => u });
}
function Q0(t) {
	return t.flatMap((e) => (e.type === Ne ? Q0(e.children) : [e]));
}
function X0(...t) {
	if (t.length === 0) return {};
	if (t.length === 1) return t[0];
	let e = {},
		n = {};
	for (let r of t)
		for (let o in r)
			o.startsWith("on") && typeof r[o] == "function"
				? (n[o] != null || (n[o] = []), n[o].push(r[o]))
				: (e[o] = r[o]);
	if (e.disabled || e["aria-disabled"])
		return Object.assign(
			e,
			Object.fromEntries(Object.keys(n).map((r) => [r, void 0]))
		);
	for (let r in n)
		Object.assign(e, {
			[r](o, ...i) {
				let s = n[r];
				for (let l of s) {
					if (o instanceof Event && o.defaultPrevented) return;
					l(o, ...i);
				}
			},
		});
	return e;
}
function nk(t) {
	let e = Object.assign({}, t);
	for (let n in e) e[n] === void 0 && delete e[n];
	return e;
}
function Di(t, e = []) {
	let n = Object.assign({}, t);
	for (let r of e) r in n && delete n[r];
	return n;
}
function rk(t) {
	return t == null
		? !1
		: typeof t.type == "string" ||
				typeof t.type == "object" ||
				typeof t.type == "function";
}
var ki = ((t) => (
	(t[(t.None = 1)] = "None"),
	(t[(t.Focusable = 2)] = "Focusable"),
	(t[(t.Hidden = 4)] = "Hidden"),
	t
))(ki || {});
let Si = Re({
		name: "Hidden",
		props: {
			as: { type: [Object, String], default: "div" },
			features: { type: Number, default: 1 },
		},
		setup(t, { slots: e, attrs: n }) {
			return () => {
				var r;
				let l = t,
					{ features: o } = l,
					i = et(l, ["features"]),
					s = {
						"aria-hidden":
							(o & 2) === 2
								? !0
								: (r = i["aria-hidden"]) != null
								? r
								: void 0,
						style: z(
							{
								position: "fixed",
								top: 1,
								left: 1,
								width: 1,
								height: 0,
								padding: 0,
								margin: -1,
								overflow: "hidden",
								clip: "rect(0, 0, 0, 0)",
								whiteSpace: "nowrap",
								borderWidth: "0",
							},
							(o & 4) === 4 &&
								(o & 2) !== 2 && { display: "none" }
						),
					};
				return ut({
					ourProps: s,
					theirProps: i,
					slot: {},
					attrs: n,
					slots: e,
					name: "Hidden",
				});
			};
		},
	}),
	Z0 = Symbol("Context");
var ct = ((t) => (
	(t[(t.Open = 1)] = "Open"),
	(t[(t.Closed = 2)] = "Closed"),
	(t[(t.Closing = 4)] = "Closing"),
	(t[(t.Opening = 8)] = "Opening"),
	t
))(ct || {});
function ok() {
	return ji() !== null;
}
function ji() {
	return qe(Z0, null);
}
function Mu(t) {
	vt(Z0, t);
}
var Ae = ((t) => (
	(t.Space = " "),
	(t.Enter = "Enter"),
	(t.Escape = "Escape"),
	(t.Backspace = "Backspace"),
	(t.Delete = "Delete"),
	(t.ArrowLeft = "ArrowLeft"),
	(t.ArrowUp = "ArrowUp"),
	(t.ArrowRight = "ArrowRight"),
	(t.ArrowDown = "ArrowDown"),
	(t.Home = "Home"),
	(t.End = "End"),
	(t.PageUp = "PageUp"),
	(t.PageDown = "PageDown"),
	(t.Tab = "Tab"),
	t
))(Ae || {});
function ik(t) {
	function e() {
		document.readyState !== "loading" &&
			(t(), document.removeEventListener("DOMContentLoaded", e));
	}
	typeof window != "undefined" &&
		typeof document != "undefined" &&
		(document.addEventListener("DOMContentLoaded", e), e());
}
let wr = [];
ik(() => {
	function t(e) {
		e.target instanceof HTMLElement &&
			e.target !== document.body &&
			wr[0] !== e.target &&
			(wr.unshift(e.target),
			(wr = wr.filter((n) => n != null && n.isConnected)),
			wr.splice(10));
	}
	window.addEventListener("click", t, { capture: !0 }),
		window.addEventListener("mousedown", t, { capture: !0 }),
		window.addEventListener("focus", t, { capture: !0 }),
		document.body.addEventListener("click", t, { capture: !0 }),
		document.body.addEventListener("mousedown", t, { capture: !0 }),
		document.body.addEventListener("focus", t, { capture: !0 });
});
function sk(t) {
	throw new Error("Unexpected object: " + t);
}
var rt = ((t) => (
	(t[(t.First = 0)] = "First"),
	(t[(t.Previous = 1)] = "Previous"),
	(t[(t.Next = 2)] = "Next"),
	(t[(t.Last = 3)] = "Last"),
	(t[(t.Specific = 4)] = "Specific"),
	(t[(t.Nothing = 5)] = "Nothing"),
	t
))(rt || {});
function hd(t, e) {
	let n = e.resolveItems();
	if (n.length <= 0) return null;
	let r = e.resolveActiveIndex(),
		o = r != null ? r : -1;
	switch (t.focus) {
		case 0: {
			for (let i = 0; i < n.length; ++i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 1: {
			o === -1 && (o = n.length);
			for (let i = o - 1; i >= 0; --i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 2: {
			for (let i = o + 1; i < n.length; ++i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 3: {
			for (let i = n.length - 1; i >= 0; --i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 4: {
			for (let i = 0; i < n.length; ++i)
				if (e.resolveId(n[i], i, n) === t.id) return i;
			return r;
		}
		case 5:
			return null;
		default:
			sk(t);
	}
}
function Eu(t) {
	typeof queueMicrotask == "function"
		? queueMicrotask(t)
		: Promise.resolve()
				.then(t)
				.catch((e) =>
					setTimeout(() => {
						throw e;
					})
				);
}
function Lo() {
	let t = [],
		e = {
			addEventListener(n, r, o, i) {
				return (
					n.addEventListener(r, o, i),
					e.add(() => n.removeEventListener(r, o, i))
				);
			},
			requestAnimationFrame(...n) {
				let r = requestAnimationFrame(...n);
				e.add(() => cancelAnimationFrame(r));
			},
			nextFrame(...n) {
				e.requestAnimationFrame(() => {
					e.requestAnimationFrame(...n);
				});
			},
			setTimeout(...n) {
				let r = setTimeout(...n);
				e.add(() => clearTimeout(r));
			},
			microTask(...n) {
				let r = { current: !0 };
				return (
					Eu(() => {
						r.current && n[0]();
					}),
					e.add(() => {
						r.current = !1;
					})
				);
			},
			style(n, r, o) {
				let i = n.style.getPropertyValue(r);
				return (
					Object.assign(n.style, { [r]: o }),
					this.add(() => {
						Object.assign(n.style, { [r]: i });
					})
				);
			},
			group(n) {
				let r = Lo();
				return n(r), this.add(() => r.dispose());
			},
			add(n) {
				return (
					t.push(n),
					() => {
						let r = t.indexOf(n);
						if (r >= 0) for (let o of t.splice(r, 1)) o();
					}
				);
			},
			dispose() {
				for (let n of t.splice(0)) n();
			},
		};
	return e;
}
function ey(t = {}, e = null, n = []) {
	for (let [r, o] of Object.entries(t)) ny(n, ty(e, r), o);
	return n;
}
function ty(t, e) {
	return t ? t + "[" + e + "]" : e;
}
function ny(t, e, n) {
	if (Array.isArray(n))
		for (let [r, o] of n.entries()) ny(t, ty(e, r.toString()), o);
	else
		n instanceof Date
			? t.push([e, n.toISOString()])
			: typeof n == "boolean"
			? t.push([e, n ? "1" : "0"])
			: typeof n == "string"
			? t.push([e, n])
			: typeof n == "number"
			? t.push([e, `${n}`])
			: n == null
			? t.push([e, ""])
			: ey(n, e, t);
}
var lk = {};
function ak(t, e) {
	return t === e;
}
var uk = ((t) => (
		(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
	))(uk || {}),
	ck = ((t) => (
		(t[(t.Single = 0)] = "Single"), (t[(t.Multi = 1)] = "Multi"), t
	))(ck || {}),
	dk = ((t) => (
		(t[(t.Pointer = 0)] = "Pointer"),
		(t[(t.Focus = 1)] = "Focus"),
		(t[(t.Other = 2)] = "Other"),
		t
	))(dk || {});
let ry = Symbol("ComboboxContext");
function Gs(t) {
	let e = qe(ry, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <Combobox /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Gs), n);
	}
	return e;
}
let oy = Symbol("VirtualContext"),
	fk = Re({
		name: "VirtualProvider",
		setup(t, { slots: e }) {
			let n = Gs("VirtualProvider"),
				r = H(() => {
					let l = re(n.optionsRef);
					if (!l) return { start: 0, end: 0 };
					let a = window.getComputedStyle(l);
					return {
						start: parseFloat(a.paddingBlockStart || a.paddingTop),
						end: parseFloat(a.paddingBlockEnd || a.paddingBottom),
					};
				}),
				o = V3(
					H(() => ({
						scrollPaddingStart: r.value.start,
						scrollPaddingEnd: r.value.end,
						count: n.virtual.value.options.length,
						estimateSize() {
							return 40;
						},
						getScrollElement() {
							return re(n.optionsRef);
						},
						overscan: 12,
					}))
				),
				i = H(() => {
					var l;
					return (l = n.virtual.value) == null ? void 0 : l.options;
				}),
				s = X(0);
			return (
				it([i], () => {
					s.value += 1;
				}),
				vt(oy, n.virtual.value ? o : null),
				() => [
					Ue(
						"div",
						{
							style: {
								position: "relative",
								width: "100%",
								height: `${o.value.getTotalSize()}px`,
							},
							ref: (l) => {
								if (l) {
									if (
										(typeof process != "undefined" &&
											lk.JEST_WORKER_ID !== void 0) ||
										n.activationTrigger.value === 0
									)
										return;
									n.activeOptionIndex.value !== null &&
										n.virtual.value.options.length >
											n.activeOptionIndex.value &&
										o.value.scrollToIndex(
											n.activeOptionIndex.value
										);
								}
							},
						},
						o.value.getVirtualItems().map((l) =>
							sr(
								e.default({
									option: n.virtual.value.options[l.index],
									open: n.comboboxState.value === 0,
								})[0],
								{
									key: `${s.value}-${l.index}`,
									"data-index": l.index,
									"aria-setsize":
										n.virtual.value.options.length,
									"aria-posinset": l.index + 1,
									style: {
										position: "absolute",
										top: 0,
										left: 0,
										transform: `translateY(${l.start}px)`,
										overflowAnchor: "none",
									},
								}
							)
						)
					),
				]
			);
		},
	}),
	Bj = Re({
		name: "Combobox",
		emits: { "update:modelValue": (t) => !0 },
		props: {
			as: { type: [Object, String], default: "template" },
			disabled: { type: [Boolean], default: !1 },
			by: { type: [String, Function], nullable: !0, default: null },
			modelValue: {
				type: [Object, String, Number, Boolean],
				default: void 0,
			},
			defaultValue: {
				type: [Object, String, Number, Boolean],
				default: void 0,
			},
			form: { type: String, optional: !0 },
			name: { type: String, optional: !0 },
			nullable: { type: Boolean, default: !1 },
			multiple: { type: [Boolean], default: !1 },
			immediate: { type: [Boolean], default: !1 },
			virtual: { type: Object, default: null },
		},
		inheritAttrs: !1,
		setup(t, { slots: e, attrs: n, emit: r }) {
			let o = X(1),
				i = X(null),
				s = X(null),
				l = X(null),
				a = X(null),
				u = X({ static: !1, hold: !1 }),
				c = X([]),
				d = X(null),
				h = X(2),
				p = X(!1);
			function g(_ = (T) => T) {
				let T = d.value !== null ? c.value[d.value] : null,
					R = _(c.value.slice()),
					P =
						R.length > 0 && R[0].dataRef.order.value !== null
							? R.sort(
									(D, M) =>
										D.dataRef.order.value -
										M.dataRef.order.value
							  )
							: Vr(R, (D) => re(D.dataRef.domRef)),
					N = T ? P.indexOf(T) : null;
				return (
					N === -1 && (N = null), { options: P, activeOptionIndex: N }
				);
			}
			let y = H(() => (t.multiple ? 1 : 0)),
				b = H(() => t.nullable),
				[w, S] = W3(
					H(() => t.modelValue),
					(_) => r("update:modelValue", _),
					H(() => t.defaultValue)
				),
				E = H(() =>
					w.value === void 0
						? pt(y.value, { 1: [], 0: void 0 })
						: w.value
				),
				f = null,
				v = null;
			function m(_) {
				return pt(y.value, {
					0() {
						return S == null ? void 0 : S(_);
					},
					1: () => {
						let T = Oe(k.value.value).slice(),
							R = Oe(_),
							P = T.findIndex((N) => k.compare(R, Oe(N)));
						return (
							P === -1 ? T.push(R) : T.splice(P, 1),
							S == null ? void 0 : S(T)
						);
					},
				});
			}
			let x = H(() => {});
			it([x], ([_], [T]) => {
				if (k.virtual.value && _ && T && d.value !== null) {
					let R = _.indexOf(T[d.value]);
					R !== -1 ? (d.value = R) : (d.value = null);
				}
			});
			let k = {
				comboboxState: o,
				value: E,
				mode: y,
				compare(_, T) {
					if (typeof t.by == "string") {
						let R = t.by;
						return (
							(_ == null ? void 0 : _[R]) ===
							(T == null ? void 0 : T[R])
						);
					}
					return t.by === null ? ak(_, T) : t.by(_, T);
				},
				calculateIndex(_) {
					return k.virtual.value
						? t.by === null
							? k.virtual.value.options.indexOf(_)
							: k.virtual.value.options.findIndex((T) =>
									k.compare(T, _)
							  )
						: c.value.findIndex((T) =>
								k.compare(T.dataRef.value, _)
						  );
				},
				defaultValue: H(() => t.defaultValue),
				nullable: b,
				immediate: H(() => !1),
				virtual: H(() => null),
				inputRef: s,
				labelRef: i,
				buttonRef: l,
				optionsRef: a,
				disabled: H(() => t.disabled),
				options: c,
				change(_) {
					S(_);
				},
				activeOptionIndex: H(() => {
					if (
						p.value &&
						d.value === null &&
						(k.virtual.value
							? k.virtual.value.options.length > 0
							: c.value.length > 0)
					) {
						if (k.virtual.value) {
							let T = k.virtual.value.options.findIndex((R) => {
								var P;
								return !(
									(P = k.virtual.value) != null &&
									P.disabled(R)
								);
							});
							if (T !== -1) return T;
						}
						let _ = c.value.findIndex((T) => !T.dataRef.disabled);
						if (_ !== -1) return _;
					}
					return d.value;
				}),
				activationTrigger: h,
				optionsPropsRef: u,
				closeCombobox() {
					(p.value = !1),
						!t.disabled &&
							o.value !== 1 &&
							((o.value = 1), (d.value = null));
				},
				openCombobox() {
					if (((p.value = !0), !t.disabled && o.value !== 0)) {
						if (k.value.value) {
							let _ = k.calculateIndex(k.value.value);
							_ !== -1 && (d.value = _);
						}
						o.value = 0;
					}
				},
				setActivationTrigger(_) {
					h.value = _;
				},
				goToOption(_, T, R) {
					(p.value = !1),
						f !== null && cancelAnimationFrame(f),
						(f = requestAnimationFrame(() => {
							if (
								t.disabled ||
								(a.value && !u.value.static && o.value === 1)
							)
								return;
							if (k.virtual.value) {
								(d.value =
									_ === rt.Specific
										? T
										: hd(
												{ focus: _ },
												{
													resolveItems: () =>
														k.virtual.value.options,
													resolveActiveIndex: () => {
														var D, M;
														return (M =
															(D =
																k
																	.activeOptionIndex
																	.value) !=
															null
																? D
																: k.virtual.value.options.findIndex(
																		(I) => {
																			var $;
																			return !(
																				($ =
																					k
																						.virtual
																						.value) !=
																					null &&
																				$.disabled(
																					I
																				)
																			);
																		}
																  )) != null
															? M
															: null;
													},
													resolveDisabled: (D) =>
														k.virtual.value.disabled(
															D
														),
													resolveId() {
														throw new Error(
															"Function not implemented."
														);
													},
												}
										  )),
									(h.value = R != null ? R : 2);
								return;
							}
							let P = g();
							if (P.activeOptionIndex === null) {
								let D = P.options.findIndex(
									(M) => !M.dataRef.disabled
								);
								D !== -1 && (P.activeOptionIndex = D);
							}
							let N =
								_ === rt.Specific
									? T
									: hd(
											{ focus: _ },
											{
												resolveItems: () => P.options,
												resolveActiveIndex: () =>
													P.activeOptionIndex,
												resolveId: (D) => D.id,
												resolveDisabled: (D) =>
													D.dataRef.disabled,
											}
									  );
							(d.value = N),
								(h.value = R != null ? R : 2),
								(c.value = P.options);
						}));
				},
				selectOption(_) {
					let T = c.value.find((P) => P.id === _);
					if (!T) return;
					let { dataRef: R } = T;
					m(R.value);
				},
				selectActiveOption() {
					if (k.activeOptionIndex.value !== null) {
						if (k.virtual.value)
							m(
								k.virtual.value.options[
									k.activeOptionIndex.value
								]
							);
						else {
							let { dataRef: _ } =
								c.value[k.activeOptionIndex.value];
							m(_.value);
						}
						k.goToOption(rt.Specific, k.activeOptionIndex.value);
					}
				},
				registerOption(_, T) {
					let R = Gt({ id: _, dataRef: T });
					if (k.virtual.value) {
						c.value.push(R);
						return;
					}
					v && cancelAnimationFrame(v);
					let P = g((N) => (N.push(R), N));
					d.value === null &&
						k.isSelected(T.value.value) &&
						(P.activeOptionIndex = P.options.indexOf(R)),
						(c.value = P.options),
						(d.value = P.activeOptionIndex),
						(h.value = 2),
						P.options.some((N) => !re(N.dataRef.domRef)) &&
							(v = requestAnimationFrame(() => {
								let N = g();
								(c.value = N.options),
									(d.value = N.activeOptionIndex);
							}));
				},
				unregisterOption(_, T) {
					if (
						(f !== null && cancelAnimationFrame(f),
						T && (p.value = !0),
						k.virtual.value)
					) {
						c.value = c.value.filter((P) => P.id !== _);
						return;
					}
					let R = g((P) => {
						let N = P.findIndex((D) => D.id === _);
						return N !== -1 && P.splice(N, 1), P;
					});
					(c.value = R.options),
						(d.value = R.activeOptionIndex),
						(h.value = 2);
				},
				isSelected(_) {
					return pt(y.value, {
						0: () => k.compare(Oe(k.value.value), Oe(_)),
						1: () =>
							Oe(k.value.value).some((T) =>
								k.compare(Oe(T), Oe(_))
							),
					});
				},
				isActive(_) {
					return d.value === k.calculateIndex(_);
				},
			};
			Hf(
				[s, l, a],
				() => k.closeCombobox(),
				H(() => o.value === 0)
			),
				vt(ry, k),
				Mu(H(() => pt(o.value, { 0: ct.Open, 1: ct.Closed })));
			let C = H(() => {
				var _;
				return (_ = re(s)) == null ? void 0 : _.closest("form");
			});
			return (
				Xe(() => {
					it(
						[C],
						() => {
							if (!C.value || t.defaultValue === void 0) return;
							function _() {
								k.change(t.defaultValue);
							}
							return (
								C.value.addEventListener("reset", _),
								() => {
									var T;
									(T = C.value) == null ||
										T.removeEventListener("reset", _);
								}
							);
						},
						{ immediate: !0 }
					);
				}),
				() => {
					var _, T, R;
					let $ = t,
						{ name: P, disabled: N, form: D } = $,
						M = et($, ["name", "disabled", "form"]),
						I = {
							open: o.value === 0,
							disabled: N,
							activeIndex: k.activeOptionIndex.value,
							activeOption:
								k.activeOptionIndex.value === null
									? null
									: k.virtual.value
									? k.virtual.value.options[
											(_ = k.activeOptionIndex.value) !=
											null
												? _
												: 0
									  ]
									: (R =
											(T =
												k.options.value[
													k.activeOptionIndex.value
												]) == null
												? void 0
												: T.dataRef.value.value) != null
									? R
									: null,
							value: E.value,
						};
					return Ue(Ne, [
						...(P != null && E.value != null
							? ey({ [P]: E.value }).map(([V, ie]) =>
									Ue(
										Si,
										nk({
											features: ki.Hidden,
											key: V,
											as: "input",
											type: "hidden",
											hidden: !0,
											readOnly: !0,
											form: D,
											name: V,
											value: ie,
										})
									)
							  )
							: []),
						ut({
							theirProps: z(
								z({}, n),
								Di(M, [
									"by",
									"defaultValue",
									"immediate",
									"modelValue",
									"multiple",
									"nullable",
									"onUpdate:modelValue",
									"virtual",
								])
							),
							ourProps: {},
							slot: I,
							slots: e,
							attrs: n,
							name: "Combobox",
						}),
					]);
				}
			);
		},
	}),
	zj = Re({
		name: "ComboboxInput",
		props: {
			as: { type: [Object, String], default: "input" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			displayValue: { type: Function },
			defaultValue: { type: String, default: void 0 },
			id: {
				type: String,
				default: () => `headlessui-combobox-input-${dn()}`,
			},
		},
		emits: { change: (t) => !0 },
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			let i = Gs("ComboboxInput"),
				s = H(() => dr(re(i.inputRef))),
				l = { value: !1 };
			o({ el: i.inputRef, $el: i.inputRef });
			function a() {
				i.change(null);
				let S = re(i.optionsRef);
				S && (S.scrollTop = 0), i.goToOption(rt.Nothing);
			}
			let u = H(() => {
				var S;
				let E = i.value.value;
				return re(i.inputRef)
					? typeof t.displayValue != "undefined" && E !== void 0
						? (S = t.displayValue(E)) != null
							? S
							: ""
						: typeof E == "string"
						? E
						: ""
					: "";
			});
			Xe(() => {
				it(
					[u, i.comboboxState, s],
					([S, E], [f, v]) => {
						if (l.value) return;
						let m = re(i.inputRef);
						m &&
							(((v === 0 && E === 1) || S !== f) && (m.value = S),
							requestAnimationFrame(() => {
								var x;
								if (
									l.value ||
									!m ||
									((x = s.value) == null
										? void 0
										: x.activeElement) !== m
								)
									return;
								let { selectionStart: k, selectionEnd: C } = m;
								Math.abs(
									(C != null ? C : 0) - (k != null ? k : 0)
								) === 0 &&
									k === 0 &&
									m.setSelectionRange(
										m.value.length,
										m.value.length
									);
							}));
					},
					{ immediate: !0 }
				),
					it([i.comboboxState], ([S], [E]) => {
						if (S === 0 && E === 1) {
							if (l.value) return;
							let f = re(i.inputRef);
							if (!f) return;
							let v = f.value,
								{
									selectionStart: m,
									selectionEnd: x,
									selectionDirection: k,
								} = f;
							(f.value = ""),
								(f.value = v),
								k !== null
									? f.setSelectionRange(m, x, k)
									: f.setSelectionRange(m, x);
						}
					});
			});
			let c = X(!1);
			function d() {
				c.value = !0;
			}
			function h() {
				Lo().nextFrame(() => {
					c.value = !1;
				});
			}
			function p(S) {
				switch (((l.value = !0), S.key)) {
					case Ae.Enter:
						if (
							((l.value = !1),
							i.comboboxState.value !== 0 || c.value)
						)
							return;
						if (
							(S.preventDefault(),
							S.stopPropagation(),
							i.activeOptionIndex.value === null)
						) {
							i.closeCombobox();
							return;
						}
						i.selectActiveOption(),
							i.mode.value === 0 && i.closeCombobox();
						break;
					case Ae.ArrowDown:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							pt(i.comboboxState.value, {
								0: () => i.goToOption(rt.Next),
								1: () => i.openCombobox(),
							})
						);
					case Ae.ArrowUp:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							pt(i.comboboxState.value, {
								0: () => i.goToOption(rt.Previous),
								1: () => {
									i.openCombobox(),
										zt(() => {
											i.value.value ||
												i.goToOption(rt.Last);
										});
								},
							})
						);
					case Ae.Home:
						if (S.shiftKey) break;
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.First)
						);
					case Ae.PageUp:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.First)
						);
					case Ae.End:
						if (S.shiftKey) break;
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.Last)
						);
					case Ae.PageDown:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.Last)
						);
					case Ae.Escape:
						if (((l.value = !1), i.comboboxState.value !== 0))
							return;
						S.preventDefault(),
							i.optionsRef.value &&
								!i.optionsPropsRef.value.static &&
								S.stopPropagation(),
							i.nullable.value &&
								i.mode.value === 0 &&
								i.value.value === null &&
								a(),
							i.closeCombobox();
						break;
					case Ae.Tab:
						if (((l.value = !1), i.comboboxState.value !== 0))
							return;
						i.mode.value === 0 &&
							i.activationTrigger.value !== 1 &&
							i.selectActiveOption(),
							i.closeCombobox();
						break;
				}
			}
			function g(S) {
				e("change", S),
					i.nullable.value &&
						i.mode.value === 0 &&
						S.target.value === "" &&
						a(),
					i.openCombobox();
			}
			function y(S) {
				var E, f, v;
				let m =
					(E = S.relatedTarget) != null
						? E
						: wr.find((x) => x !== S.currentTarget);
				if (
					((l.value = !1),
					!((f = re(i.optionsRef)) != null && f.contains(m)) &&
						!((v = re(i.buttonRef)) != null && v.contains(m)) &&
						i.comboboxState.value === 0)
				)
					return (
						S.preventDefault(),
						i.mode.value === 0 &&
							(i.nullable.value && i.value.value === null
								? a()
								: i.activationTrigger.value !== 1 &&
								  i.selectActiveOption()),
						i.closeCombobox()
					);
			}
			function b(S) {
				var E, f, v;
				let m =
					(E = S.relatedTarget) != null
						? E
						: wr.find((x) => x !== S.currentTarget);
				((f = re(i.buttonRef)) != null && f.contains(m)) ||
					((v = re(i.optionsRef)) != null && v.contains(m)) ||
					i.disabled.value ||
					(i.immediate.value &&
						i.comboboxState.value !== 0 &&
						(i.openCombobox(),
						Lo().nextFrame(() => {
							i.setActivationTrigger(1);
						})));
			}
			let w = H(() => {
				var S, E, f, v;
				return (v =
					(f =
						(E = t.defaultValue) != null
							? E
							: i.defaultValue.value !== void 0
							? (S = t.displayValue) == null
								? void 0
								: S.call(t, i.defaultValue.value)
							: null) != null
						? f
						: i.defaultValue.value) != null
					? v
					: "";
			});
			return () => {
				var S, E, f, v, m, x, k;
				let C = { open: i.comboboxState.value === 0 },
					D = t,
					{ id: _, displayValue: T, onChange: R } = D,
					P = et(D, ["id", "displayValue", "onChange"]),
					N = {
						"aria-controls":
							(S = i.optionsRef.value) == null ? void 0 : S.id,
						"aria-expanded": i.comboboxState.value === 0,
						"aria-activedescendant":
							i.activeOptionIndex.value === null
								? void 0
								: i.virtual.value
								? (E = i.options.value.find(
										(M) =>
											!i.virtual.value.disabled(
												M.dataRef.value
											) &&
											i.compare(
												M.dataRef.value,
												i.virtual.value.options[
													i.activeOptionIndex.value
												]
											)
								  )) == null
									? void 0
									: E.id
								: (f =
										i.options.value[
											i.activeOptionIndex.value
										]) == null
								? void 0
								: f.id,
						"aria-labelledby":
							(x =
								(v = re(i.labelRef)) == null ? void 0 : v.id) !=
							null
								? x
								: (m = re(i.buttonRef)) == null
								? void 0
								: m.id,
						"aria-autocomplete": "list",
						id: _,
						onCompositionstart: d,
						onCompositionend: h,
						onKeydown: p,
						onInput: g,
						onFocus: b,
						onBlur: y,
						role: "combobox",
						type: (k = n.type) != null ? k : "text",
						tabIndex: 0,
						ref: i.inputRef,
						defaultValue: w.value,
						disabled: i.disabled.value === !0 ? !0 : void 0,
					};
				return ut({
					ourProps: N,
					theirProps: P,
					slot: C,
					attrs: n,
					slots: r,
					features: fn.RenderStrategy | fn.Static,
					name: "ComboboxInput",
				});
			};
		},
	}),
	Hj = Re({
		name: "ComboboxOptions",
		props: {
			as: { type: [Object, String], default: "ul" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			hold: { type: [Boolean], default: !1 },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Gs("ComboboxOptions"),
				i = `headlessui-combobox-options-${dn()}`;
			r({ el: o.optionsRef, $el: o.optionsRef }),
				bt(() => {
					o.optionsPropsRef.value.static = t.static;
				}),
				bt(() => {
					o.optionsPropsRef.value.hold = t.hold;
				});
			let s = ji(),
				l = H(() =>
					s !== null
						? (s.value & ct.Open) === ct.Open
						: o.comboboxState.value === 0
				);
			return (
				Y0({
					container: H(() => re(o.optionsRef)),
					enabled: H(() => o.comboboxState.value === 0),
					accept(a) {
						return a.getAttribute("role") === "option"
							? NodeFilter.FILTER_REJECT
							: a.hasAttribute("role")
							? NodeFilter.FILTER_SKIP
							: NodeFilter.FILTER_ACCEPT;
					},
					walk(a) {
						a.setAttribute("role", "none");
					},
				}),
				() => {
					var a, u, c;
					let d = { open: o.comboboxState.value === 0 },
						h = {
							"aria-labelledby":
								(c =
									(a = re(o.labelRef)) == null
										? void 0
										: a.id) != null
									? c
									: (u = re(o.buttonRef)) == null
									? void 0
									: u.id,
							id: i,
							ref: o.optionsRef,
							role: "listbox",
							"aria-multiselectable":
								o.mode.value === 1 ? !0 : void 0,
						},
						p = Di(t, ["hold"]);
					return ut({
						ourProps: h,
						theirProps: p,
						slot: d,
						attrs: e,
						slots:
							o.virtual.value && o.comboboxState.value === 0
								? ye(z({}, n), {
										default: () => [Ue(fk, {}, n.default)],
								  })
								: n,
						features: fn.RenderStrategy | fn.Static,
						visible: l.value,
						name: "ComboboxOptions",
					});
				}
			);
		},
	}),
	Fj = Re({
		name: "ComboboxOption",
		props: {
			as: { type: [Object, String], default: "li" },
			value: { type: [Object, String, Number, Boolean] },
			disabled: { type: Boolean, default: !1 },
			order: { type: [Number], default: null },
		},
		setup(t, { slots: e, attrs: n, expose: r }) {
			let o = Gs("ComboboxOption"),
				i = `headlessui-combobox-option-${dn()}`,
				s = X(null);
			r({ el: s, $el: s });
			let l = H(() => {
					var w;
					return o.virtual.value
						? o.activeOptionIndex.value ===
								o.calculateIndex(t.value)
						: o.activeOptionIndex.value === null
						? !1
						: ((w = o.options.value[o.activeOptionIndex.value]) ==
						  null
								? void 0
								: w.id) === i;
				}),
				a = H(() => o.isSelected(t.value)),
				u = qe(oy, null),
				c = H(() => ({
					disabled: t.disabled,
					value: t.value,
					domRef: s,
					order: H(() => t.order),
				}));
			Xe(() => o.registerOption(i, c)),
				Dt(() => o.unregisterOption(i, l.value)),
				bt(() => {
					let w = re(s);
					w && (u == null || u.value.measureElement(w));
				}),
				bt(() => {
					o.comboboxState.value === 0 &&
						l.value &&
						(o.virtual.value ||
							(o.activationTrigger.value !== 0 &&
								zt(() => {
									var w, S;
									return (S =
										(w = re(s)) == null
											? void 0
											: w.scrollIntoView) == null
										? void 0
										: S.call(w, { block: "nearest" });
								})));
				});
			function d(w) {
				var S;
				if (
					t.disabled ||
					((S = o.virtual.value) != null && S.disabled(t.value))
				)
					return w.preventDefault();
				o.selectOption(i),
					q0() ||
						requestAnimationFrame(() => {
							var E;
							return (E = re(o.inputRef)) == null
								? void 0
								: E.focus({ preventScroll: !0 });
						}),
					o.mode.value === 0 &&
						requestAnimationFrame(() => o.closeCombobox());
			}
			function h() {
				var w;
				if (
					t.disabled ||
					((w = o.virtual.value) != null && w.disabled(t.value))
				)
					return o.goToOption(rt.Nothing);
				let S = o.calculateIndex(t.value);
				o.goToOption(rt.Specific, S);
			}
			let p = G0();
			function g(w) {
				p.update(w);
			}
			function y(w) {
				var S;
				if (
					!p.wasMoved(w) ||
					t.disabled ||
					((S = o.virtual.value) != null && S.disabled(t.value)) ||
					l.value
				)
					return;
				let E = o.calculateIndex(t.value);
				o.goToOption(rt.Specific, E, 0);
			}
			function b(w) {
				var S;
				p.wasMoved(w) &&
					(t.disabled ||
						((S = o.virtual.value) != null &&
							S.disabled(t.value)) ||
						(l.value &&
							(o.optionsPropsRef.value.hold ||
								o.goToOption(rt.Nothing))));
			}
			return () => {
				let { disabled: w } = t,
					S = { active: l.value, selected: a.value, disabled: w },
					E = {
						id: i,
						ref: s,
						role: "option",
						tabIndex: w === !0 ? void 0 : -1,
						"aria-disabled": w === !0 ? !0 : void 0,
						"aria-selected": a.value,
						disabled: void 0,
						onClick: d,
						onFocus: h,
						onPointerenter: g,
						onMouseenter: g,
						onPointermove: y,
						onMousemove: y,
						onPointerleave: b,
						onMouseleave: b,
					},
					f = Di(t, ["order", "value"]);
				return ut({
					ourProps: E,
					theirProps: f,
					slot: S,
					attrs: n,
					slots: e,
					name: "ComboboxOption",
				});
			};
		},
	});
function iy(t, e, n, r) {
	Js.isServer ||
		bt((o) => {
			(t = t != null ? t : window),
				t.addEventListener(e, n, r),
				o(() => t.removeEventListener(e, n, r));
		});
}
var Yi = ((t) => (
	(t[(t.Forwards = 0)] = "Forwards"), (t[(t.Backwards = 1)] = "Backwards"), t
))(Yi || {});
function hk() {
	let t = X(0);
	return (
		J0("keydown", (e) => {
			e.key === "Tab" && (t.value = e.shiftKey ? 1 : 0);
		}),
		t
	);
}
function sy(t) {
	if (!t) return new Set();
	if (typeof t == "function") return new Set(t());
	let e = new Set();
	for (let n of t.value) {
		let r = re(n);
		r instanceof HTMLElement && e.add(r);
	}
	return e;
}
var ly = ((t) => (
	(t[(t.None = 1)] = "None"),
	(t[(t.InitialFocus = 2)] = "InitialFocus"),
	(t[(t.TabLock = 4)] = "TabLock"),
	(t[(t.FocusLock = 8)] = "FocusLock"),
	(t[(t.RestoreFocus = 16)] = "RestoreFocus"),
	(t[(t.All = 30)] = "All"),
	t
))(ly || {});
let Wi = Object.assign(
	Re({
		name: "FocusTrap",
		props: {
			as: { type: [Object, String], default: "div" },
			initialFocus: { type: Object, default: null },
			features: { type: Number, default: 30 },
			containers: { type: [Object, Function], default: X(new Set()) },
		},
		inheritAttrs: !1,
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = X(null);
			r({ el: o, $el: o });
			let i = H(() => dr(o)),
				s = X(!1);
			Xe(() => (s.value = !0)),
				Dt(() => (s.value = !1)),
				mk(
					{ ownerDocument: i },
					H(() => s.value && !!(t.features & 16))
				);
			let l = gk(
				{
					ownerDocument: i,
					container: o,
					initialFocus: H(() => t.initialFocus),
				},
				H(() => s.value && !!(t.features & 2))
			);
			yk(
				{
					ownerDocument: i,
					container: o,
					containers: t.containers,
					previousActiveElement: l,
				},
				H(() => s.value && !!(t.features & 8))
			);
			let a = hk();
			function u(p) {
				let g = re(o);
				g &&
					((y) => y())(() => {
						pt(a.value, {
							[Yi.Forwards]: () => {
								Nn(g, _t.First, {
									skipElements: [p.relatedTarget],
								});
							},
							[Yi.Backwards]: () => {
								Nn(g, _t.Last, {
									skipElements: [p.relatedTarget],
								});
							},
						});
					});
			}
			let c = X(!1);
			function d(p) {
				p.key === "Tab" &&
					((c.value = !0),
					requestAnimationFrame(() => {
						c.value = !1;
					}));
			}
			function h(p) {
				if (!s.value) return;
				let g = sy(t.containers);
				re(o) instanceof HTMLElement && g.add(re(o));
				let y = p.relatedTarget;
				y instanceof HTMLElement &&
					y.dataset.headlessuiFocusGuard !== "true" &&
					(ay(g, y) ||
						(c.value
							? Nn(
									re(o),
									pt(a.value, {
										[Yi.Forwards]: () => _t.Next,
										[Yi.Backwards]: () => _t.Previous,
									}) | _t.WrapAround,
									{ relativeTo: p.target }
							  )
							: p.target instanceof HTMLElement && Zr(p.target)));
			}
			return () => {
				let p = {},
					g = { ref: o, onKeydown: d, onFocusout: h },
					E = t,
					{ features: y, initialFocus: b, containers: w } = E,
					S = et(E, ["features", "initialFocus", "containers"]);
				return Ue(Ne, [
					!!(y & 4) &&
						Ue(Si, {
							as: "button",
							type: "button",
							"data-headlessui-focus-guard": !0,
							onFocus: u,
							features: ki.Focusable,
						}),
					ut({
						ourProps: g,
						theirProps: z(z({}, e), S),
						slot: p,
						attrs: e,
						slots: n,
						name: "FocusTrap",
					}),
					!!(y & 4) &&
						Ue(Si, {
							as: "button",
							type: "button",
							"data-headlessui-focus-guard": !0,
							onFocus: u,
							features: ki.Focusable,
						}),
				]);
			};
		},
	}),
	{ features: ly }
);
function pk(t) {
	let e = X(wr.slice());
	return (
		it(
			[t],
			([n], [r]) => {
				r === !0 && n === !1
					? Eu(() => {
							e.value.splice(0);
					  })
					: r === !1 && n === !0 && (e.value = wr.slice());
			},
			{ flush: "post" }
		),
		() => {
			var n;
			return (n = e.value.find((r) => r != null && r.isConnected)) != null
				? n
				: null;
		}
	);
}
function mk({ ownerDocument: t }, e) {
	let n = pk(e);
	Xe(() => {
		bt(
			() => {
				var r, o;
				e.value ||
					(((r = t.value) == null ? void 0 : r.activeElement) ===
						((o = t.value) == null ? void 0 : o.body) &&
						Zr(n()));
			},
			{ flush: "post" }
		);
	}),
		Dt(() => {
			e.value && Zr(n());
		});
}
function gk({ ownerDocument: t, container: e, initialFocus: n }, r) {
	let o = X(null),
		i = X(!1);
	return (
		Xe(() => (i.value = !0)),
		Dt(() => (i.value = !1)),
		Xe(() => {
			it(
				[e, n, r],
				(s, l) => {
					if (
						s.every((u, c) => (l == null ? void 0 : l[c]) === u) ||
						!r.value
					)
						return;
					let a = re(e);
					a &&
						Eu(() => {
							var u, c;
							if (!i.value) return;
							let d = re(n),
								h =
									(u = t.value) == null
										? void 0
										: u.activeElement;
							if (d) {
								if (d === h) {
									o.value = h;
									return;
								}
							} else if (a.contains(h)) {
								o.value = h;
								return;
							}
							d
								? Zr(d)
								: Nn(a, _t.First | _t.NoScroll) === si.Error &&
								  console.warn(
										"There are no focusable elements inside the <FocusTrap />"
								  ),
								(o.value =
									(c = t.value) == null
										? void 0
										: c.activeElement);
						});
				},
				{ immediate: !0, flush: "post" }
			);
		}),
		o
	);
}
function yk(
	{ ownerDocument: t, container: e, containers: n, previousActiveElement: r },
	o
) {
	var i;
	iy(
		(i = t.value) == null ? void 0 : i.defaultView,
		"focus",
		(s) => {
			if (!o.value) return;
			let l = sy(n);
			re(e) instanceof HTMLElement && l.add(re(e));
			let a = r.value;
			if (!a) return;
			let u = s.target;
			u && u instanceof HTMLElement
				? ay(l, u)
					? ((r.value = u), Zr(u))
					: (s.preventDefault(), s.stopPropagation(), Zr(a))
				: Zr(r.value);
		},
		!0
	);
}
function ay(t, e) {
	for (let n of t) if (n.contains(e)) return !0;
	return !1;
}
function vk(t) {
	let e = pu(t.getSnapshot());
	return (
		Dt(
			t.subscribe(() => {
				e.value = t.getSnapshot();
			})
		),
		e
	);
}
function bk(t, e) {
	let n = t(),
		r = new Set();
	return {
		getSnapshot() {
			return n;
		},
		subscribe(o) {
			return r.add(o), () => r.delete(o);
		},
		dispatch(o, ...i) {
			let s = e[o].call(n, ...i);
			s && ((n = s), r.forEach((l) => l()));
		},
	};
}
function wk() {
	let t;
	return {
		before({ doc: e }) {
			var n;
			let r = e.documentElement;
			t =
				((n = e.defaultView) != null ? n : window).innerWidth -
				r.clientWidth;
		},
		after({ doc: e, d: n }) {
			let r = e.documentElement,
				o = r.clientWidth - r.offsetWidth,
				i = t - o;
			n.style(r, "paddingRight", `${i}px`);
		},
	};
}
function xk() {
	return K0()
		? {
				before({ doc: t, d: e, meta: n }) {
					function r(o) {
						return n.containers
							.flatMap((i) => i())
							.some((i) => i.contains(o));
					}
					e.microTask(() => {
						var o;
						if (
							window.getComputedStyle(t.documentElement)
								.scrollBehavior !== "auto"
						) {
							let l = Lo();
							l.style(
								t.documentElement,
								"scrollBehavior",
								"auto"
							),
								e.add(() => e.microTask(() => l.dispose()));
						}
						let i =
								(o = window.scrollY) != null
									? o
									: window.pageYOffset,
							s = null;
						e.addEventListener(
							t,
							"click",
							(l) => {
								if (l.target instanceof HTMLElement)
									try {
										let a = l.target.closest("a");
										if (!a) return;
										let { hash: u } = new URL(a.href),
											c = t.querySelector(u);
										c && !r(c) && (s = c);
									} catch (a) {}
							},
							!0
						),
							e.addEventListener(t, "touchstart", (l) => {
								if (l.target instanceof HTMLElement)
									if (r(l.target)) {
										let a = l.target;
										for (
											;
											a.parentElement &&
											r(a.parentElement);

										)
											a = a.parentElement;
										e.style(
											a,
											"overscrollBehavior",
											"contain"
										);
									} else
										e.style(
											l.target,
											"touchAction",
											"none"
										);
							}),
							e.addEventListener(
								t,
								"touchmove",
								(l) => {
									if (l.target instanceof HTMLElement)
										if (r(l.target)) {
											let a = l.target;
											for (
												;
												a.parentElement &&
												a.dataset.headlessuiPortal !==
													"" &&
												!(
													a.scrollHeight >
														a.clientHeight ||
													a.scrollWidth >
														a.clientWidth
												);

											)
												a = a.parentElement;
											a.dataset.headlessuiPortal === "" &&
												l.preventDefault();
										} else l.preventDefault();
								},
								{ passive: !1 }
							),
							e.add(() => {
								var l;
								let a =
									(l = window.scrollY) != null
										? l
										: window.pageYOffset;
								i !== a && window.scrollTo(0, i),
									s &&
										s.isConnected &&
										(s.scrollIntoView({ block: "nearest" }),
										(s = null));
							});
					});
				},
		  }
		: {};
}
function kk() {
	return {
		before({ doc: t, d: e }) {
			e.style(t.documentElement, "overflow", "hidden");
		},
	};
}
function Sk(t) {
	let e = {};
	for (let n of t) Object.assign(e, n(e));
	return e;
}
let Co = bk(() => new Map(), {
	PUSH(t, e) {
		var n;
		let r =
			(n = this.get(t)) != null
				? n
				: { doc: t, count: 0, d: Lo(), meta: new Set() };
		return r.count++, r.meta.add(e), this.set(t, r), this;
	},
	POP(t, e) {
		let n = this.get(t);
		return n && (n.count--, n.meta.delete(e)), this;
	},
	SCROLL_PREVENT({ doc: t, d: e, meta: n }) {
		let r = { doc: t, d: e, meta: Sk(n) },
			o = [xk(), wk(), kk()];
		o.forEach(({ before: i }) => (i == null ? void 0 : i(r))),
			o.forEach(({ after: i }) => (i == null ? void 0 : i(r)));
	},
	SCROLL_ALLOW({ d: t }) {
		t.dispose();
	},
	TEARDOWN({ doc: t }) {
		this.delete(t);
	},
});
Co.subscribe(() => {
	let t = Co.getSnapshot(),
		e = new Map();
	for (let [n] of t) e.set(n, n.documentElement.style.overflow);
	for (let n of t.values()) {
		let r = e.get(n.doc) === "hidden",
			o = n.count !== 0;
		((o && !r) || (!o && r)) &&
			Co.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
			n.count === 0 && Co.dispatch("TEARDOWN", n);
	}
});
function _k(t, e, n) {
	let r = vk(Co),
		o = H(() => {
			let i = t.value ? r.value.get(t.value) : void 0;
			return i ? i.count > 0 : !1;
		});
	return (
		it(
			[t, e],
			([i, s], [l], a) => {
				if (!i || !s) return;
				Co.dispatch("PUSH", i, n);
				let u = !1;
				a(() => {
					u || (Co.dispatch("POP", l != null ? l : i, n), (u = !0));
				});
			},
			{ immediate: !0 }
		),
		o
	);
}
let pc = new Map(),
	Ui = new Map();
function nm(t, e = X(!0)) {
	bt((n) => {
		var r;
		if (!e.value) return;
		let o = re(t);
		if (!o) return;
		n(function () {
			var s;
			if (!o) return;
			let l = (s = Ui.get(o)) != null ? s : 1;
			if ((l === 1 ? Ui.delete(o) : Ui.set(o, l - 1), l !== 1)) return;
			let a = pc.get(o);
			a &&
				(a["aria-hidden"] === null
					? o.removeAttribute("aria-hidden")
					: o.setAttribute("aria-hidden", a["aria-hidden"]),
				(o.inert = a.inert),
				pc.delete(o));
		});
		let i = (r = Ui.get(o)) != null ? r : 0;
		Ui.set(o, i + 1),
			i === 0 &&
				(pc.set(o, {
					"aria-hidden": o.getAttribute("aria-hidden"),
					inert: o.inert,
				}),
				o.setAttribute("aria-hidden", "true"),
				(o.inert = !0));
	});
}
function Ck({
	defaultContainers: t = [],
	portals: e,
	mainTreeNodeRef: n,
} = {}) {
	let r = X(null),
		o = dr(r);
	function i() {
		var s, l, a;
		let u = [];
		for (let c of t)
			c !== null &&
				(c instanceof HTMLElement
					? u.push(c)
					: "value" in c &&
					  c.value instanceof HTMLElement &&
					  u.push(c.value));
		if (e != null && e.value) for (let c of e.value) u.push(c);
		for (let c of (s =
			o == null ? void 0 : o.querySelectorAll("html > *, body > *")) !=
		null
			? s
			: [])
			c !== document.body &&
				c !== document.head &&
				c instanceof HTMLElement &&
				c.id !== "headlessui-portal-root" &&
				(c.contains(re(r)) ||
					c.contains(
						(a = (l = re(r)) == null ? void 0 : l.getRootNode()) ==
							null
							? void 0
							: a.host
					) ||
					u.some((d) => c.contains(d)) ||
					u.push(c));
		return u;
	}
	return {
		resolveContainers: i,
		contains(s) {
			return i().some((l) => l.contains(s));
		},
		mainTreeNodeRef: r,
		MainTreeNode() {
			return n != null ? null : Ue(Si, { features: ki.Hidden, ref: r });
		},
	};
}
let uy = Symbol("ForcePortalRootContext");
function Mk() {
	return qe(uy, !1);
}
let rm = Re({
		name: "ForcePortalRoot",
		props: {
			as: { type: [Object, String], default: "template" },
			force: { type: Boolean, default: !1 },
		},
		setup(t, { slots: e, attrs: n }) {
			return (
				vt(uy, t.force),
				() => {
					let i = t,
						{ force: r } = i,
						o = et(i, ["force"]);
					return ut({
						theirProps: o,
						ourProps: {},
						slot: {},
						slots: e,
						attrs: n,
						name: "ForcePortalRoot",
					});
				}
			);
		},
	}),
	cy = Symbol("StackContext");
var pd = ((t) => ((t[(t.Add = 0)] = "Add"), (t[(t.Remove = 1)] = "Remove"), t))(
	pd || {}
);
function Ek() {
	return qe(cy, () => {});
}
function Tk({ type: t, enabled: e, element: n, onUpdate: r }) {
	let o = Ek();
	function i(...s) {
		r == null || r(...s), o(...s);
	}
	Xe(() => {
		it(
			e,
			(s, l) => {
				s ? i(0, t, n) : l === !0 && i(1, t, n);
			},
			{ immediate: !0, flush: "sync" }
		);
	}),
		Dt(() => {
			e.value && i(1, t, n);
		}),
		vt(cy, i);
}
let Ak = Symbol("DescriptionContext");
function Ok({ slot: t = X({}), name: e = "Description", props: n = {} } = {}) {
	let r = X([]);
	function o(i) {
		return (
			r.value.push(i),
			() => {
				let s = r.value.indexOf(i);
				s !== -1 && r.value.splice(s, 1);
			}
		);
	}
	return (
		vt(Ak, { register: o, slot: t, name: e, props: n }),
		H(() => (r.value.length > 0 ? r.value.join(" ") : void 0))
	);
}
function Rk(t) {
	let e = dr(t);
	if (!e) {
		if (t === null) return null;
		throw new Error(
			`[Headless UI]: Cannot find ownerDocument for contextElement: ${t}`
		);
	}
	let n = e.getElementById("headlessui-portal-root");
	if (n) return n;
	let r = e.createElement("div");
	return (
		r.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(r)
	);
}
let Pk = Re({
		name: "Portal",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { slots: e, attrs: n }) {
			let r = X(null),
				o = H(() => dr(r)),
				i = Mk(),
				s = qe(dy, null),
				l = X(i === !0 || s == null ? Rk(r.value) : s.resolveTarget()),
				a = X(!1);
			Xe(() => {
				a.value = !0;
			}),
				bt(() => {
					i || (s != null && (l.value = s.resolveTarget()));
				});
			let u = qe(md, null),
				c = !1,
				d = uo();
			return (
				it(r, () => {
					if (c || !u) return;
					let h = re(r);
					h && (Dt(u.register(h), d), (c = !0));
				}),
				Dt(() => {
					var h, p;
					let g =
						(h = o.value) == null
							? void 0
							: h.getElementById("headlessui-portal-root");
					g &&
						l.value === g &&
						l.value.children.length <= 0 &&
						((p = l.value.parentElement) == null ||
							p.removeChild(l.value));
				}),
				() => {
					if (!a.value || l.value === null) return null;
					let h = { ref: r, "data-headlessui-portal": "" };
					return Ue(
						bu,
						{ to: l.value },
						ut({
							ourProps: h,
							theirProps: t,
							slot: {},
							attrs: n,
							slots: e,
							name: "Portal",
						})
					);
				}
			);
		},
	}),
	md = Symbol("PortalParentContext");
function Ik() {
	let t = qe(md, null),
		e = X([]);
	function n(i) {
		return e.value.push(i), t && t.register(i), () => r(i);
	}
	function r(i) {
		let s = e.value.indexOf(i);
		s !== -1 && e.value.splice(s, 1), t && t.unregister(i);
	}
	let o = { register: n, unregister: r, portals: e };
	return [
		e,
		Re({
			name: "PortalWrapper",
			setup(i, { slots: s }) {
				return (
					vt(md, o),
					() => {
						var l;
						return (l = s.default) == null ? void 0 : l.call(s);
					}
				);
			},
		}),
	];
}
let dy = Symbol("PortalGroupContext"),
	Nk = Re({
		name: "PortalGroup",
		props: {
			as: { type: [Object, String], default: "template" },
			target: { type: Object, default: null },
		},
		setup(t, { attrs: e, slots: n }) {
			let r = Gt({
				resolveTarget() {
					return t.target;
				},
			});
			return (
				vt(dy, r),
				() => {
					let s = t,
						{ target: o } = s,
						i = et(s, ["target"]);
					return ut({
						theirProps: i,
						ourProps: {},
						slot: {},
						attrs: e,
						slots: n,
						name: "PortalGroup",
					});
				}
			);
		},
	});
var Dk = ((t) => (
	(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
))(Dk || {});
let gd = Symbol("DialogContext");
function Vf(t) {
	let e = qe(gd, null);
	if (e === null) {
		let n = new Error(`<${t} /> is missing a parent <Dialog /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Vf), n);
	}
	return e;
}
let vl = "DC8F892D-2EBD-447C-A4C8-A03058436FF4",
	jk = Re({
		name: "Dialog",
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			open: { type: [Boolean, String], default: vl },
			initialFocus: { type: Object, default: null },
			id: { type: String, default: () => `headlessui-dialog-${dn()}` },
			role: { type: String, default: "dialog" },
		},
		emits: { close: (t) => !0 },
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			var i;
			let s = X(!1);
			Xe(() => {
				s.value = !0;
			});
			let l = !1,
				a = H(() =>
					t.role === "dialog" || t.role === "alertdialog"
						? t.role
						: (l ||
								((l = !0),
								console.warn(
									`Invalid role [${a}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`
								)),
						  "dialog")
				),
				u = X(0),
				c = ji(),
				d = H(() =>
					t.open === vl && c !== null
						? (c.value & ct.Open) === ct.Open
						: t.open
				),
				h = X(null),
				p = H(() => dr(h));
			if ((o({ el: h, $el: h }), !(t.open !== vl || c !== null)))
				throw new Error(
					"You forgot to provide an `open` prop to the `Dialog`."
				);
			if (typeof d.value != "boolean")
				throw new Error(
					`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${
						d.value === vl ? void 0 : t.open
					}`
				);
			let g = H(() => (s.value && d.value ? 0 : 1)),
				y = H(() => g.value === 0),
				b = H(() => u.value > 1),
				w = qe(gd, null) !== null,
				[S, E] = Ik(),
				{
					resolveContainers: f,
					mainTreeNodeRef: v,
					MainTreeNode: m,
				} = Ck({
					portals: S,
					defaultContainers: [
						H(() => {
							var V;
							return (V = D.panelRef.value) != null ? V : h.value;
						}),
					],
				}),
				x = H(() => (b.value ? "parent" : "leaf")),
				k = H(() =>
					c !== null ? (c.value & ct.Closing) === ct.Closing : !1
				),
				C = H(() => (w || k.value ? !1 : y.value)),
				_ = H(() => {
					var V, ie, Y;
					return (Y = Array.from(
						(ie =
							(V = p.value) == null
								? void 0
								: V.querySelectorAll("body > *")) != null
							? ie
							: []
					).find((he) =>
						he.id === "headlessui-portal-root"
							? !1
							: he.contains(re(v)) && he instanceof HTMLElement
					)) != null
						? Y
						: null;
				});
			nm(_, C);
			let T = H(() => (b.value ? !0 : y.value)),
				R = H(() => {
					var V, ie, Y;
					return (Y = Array.from(
						(ie =
							(V = p.value) == null
								? void 0
								: V.querySelectorAll(
										"[data-headlessui-portal]"
								  )) != null
							? ie
							: []
					).find(
						(he) => he.contains(re(v)) && he instanceof HTMLElement
					)) != null
						? Y
						: null;
				});
			nm(R, T),
				Tk({
					type: "Dialog",
					enabled: H(() => g.value === 0),
					element: h,
					onUpdate: (V, ie) => {
						if (ie === "Dialog")
							return pt(V, {
								[pd.Add]: () => (u.value += 1),
								[pd.Remove]: () => (u.value -= 1),
							});
					},
				});
			let P = Ok({
					name: "DialogDescription",
					slot: H(() => ({ open: d.value })),
				}),
				N = X(null),
				D = {
					titleId: N,
					panelRef: X(null),
					dialogState: g,
					setTitleId(V) {
						N.value !== V && (N.value = V);
					},
					close() {
						e("close", !1);
					},
				};
			vt(gd, D);
			let M = H(() => !(!y.value || b.value));
			Hf(
				f,
				(V, ie) => {
					D.close(), zt(() => (ie == null ? void 0 : ie.focus()));
				},
				M
			);
			let I = H(() => !(b.value || g.value !== 0));
			iy(
				(i = p.value) == null ? void 0 : i.defaultView,
				"keydown",
				(V) => {
					I.value &&
						(V.defaultPrevented ||
							(V.key === Ae.Escape &&
								(V.preventDefault(),
								V.stopPropagation(),
								D.close())));
				}
			);
			let $ = H(() => !(k.value || g.value !== 0 || w));
			return (
				_k(p, $, (V) => {
					var ie;
					return {
						containers: [
							...((ie = V.containers) != null ? ie : []),
							f,
						],
					};
				}),
				bt((V) => {
					if (g.value !== 0) return;
					let ie = re(h);
					if (!ie) return;
					let Y = new ResizeObserver((he) => {
						for (let Le of he) {
							let Ce = Le.target.getBoundingClientRect();
							Ce.x === 0 &&
								Ce.y === 0 &&
								Ce.width === 0 &&
								Ce.height === 0 &&
								D.close();
						}
					});
					Y.observe(ie), V(() => Y.disconnect());
				}),
				() => {
					let Me = t,
						{ id: V, open: ie, initialFocus: Y } = Me,
						he = et(Me, ["id", "open", "initialFocus"]),
						Le = ye(z({}, n), {
							ref: h,
							id: V,
							role: a.value,
							"aria-modal": g.value === 0 ? !0 : void 0,
							"aria-labelledby": N.value,
							"aria-describedby": P.value,
						}),
						Ce = { open: g.value === 0 };
					return Ue(rm, { force: !0 }, () => [
						Ue(Pk, () =>
							Ue(Nk, { target: h.value }, () =>
								Ue(rm, { force: !1 }, () =>
									Ue(
										Wi,
										{
											initialFocus: Y,
											containers: f,
											features: y.value
												? pt(x.value, {
														parent: Wi.features
															.RestoreFocus,
														leaf:
															Wi.features.All &
															~Wi.features
																.FocusLock,
												  })
												: Wi.features.None,
										},
										() =>
											Ue(E, {}, () =>
												ut({
													ourProps: Le,
													theirProps: z(z({}, he), n),
													slot: Ce,
													attrs: n,
													slots: r,
													visible: g.value === 0,
													features:
														fn.RenderStrategy |
														fn.Static,
													name: "Dialog",
												})
											)
									)
								)
							)
						),
						Ue(m),
					]);
				}
			);
		},
	}),
	Lk = Re({
		name: "DialogPanel",
		props: {
			as: { type: [Object, String], default: "div" },
			id: {
				type: String,
				default: () => `headlessui-dialog-panel-${dn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Vf("DialogPanel");
			r({ el: o.panelRef, $el: o.panelRef });
			function i(s) {
				s.stopPropagation();
			}
			return () => {
				let u = t,
					{ id: s } = u,
					l = et(u, ["id"]),
					a = { id: s, ref: o.panelRef, onClick: i };
				return ut({
					ourProps: a,
					theirProps: l,
					slot: { open: o.dialogState.value === 0 },
					attrs: e,
					slots: n,
					name: "DialogPanel",
				});
			};
		},
	}),
	$k = Re({
		name: "DialogTitle",
		props: {
			as: { type: [Object, String], default: "h2" },
			id: {
				type: String,
				default: () => `headlessui-dialog-title-${dn()}`,
			},
		},
		setup(t, { attrs: e, slots: n }) {
			let r = Vf("DialogTitle");
			return (
				Xe(() => {
					r.setTitleId(t.id), Dt(() => r.setTitleId(null));
				}),
				() => {
					let s = t,
						{ id: o } = s,
						i = et(s, ["id"]);
					return ut({
						ourProps: { id: o },
						theirProps: i,
						slot: { open: r.dialogState.value === 0 },
						attrs: e,
						slots: n,
						name: "DialogTitle",
					});
				}
			);
		},
	});
var Bk = ((t) => (
	(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
))(Bk || {});
let fy = Symbol("DisclosureContext");
function Wf(t) {
	let e = qe(fy, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <Disclosure /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Wf), n);
	}
	return e;
}
let hy = Symbol("DisclosurePanelContext");
function zk() {
	return qe(hy, null);
}
let Vj = Re({
		name: "Disclosure",
		props: {
			as: { type: [Object, String], default: "template" },
			defaultOpen: { type: [Boolean], default: !1 },
		},
		setup(t, { slots: e, attrs: n }) {
			let r = X(t.defaultOpen ? 0 : 1),
				o = X(null),
				i = X(null),
				s = {
					buttonId: X(`headlessui-disclosure-button-${dn()}`),
					panelId: X(`headlessui-disclosure-panel-${dn()}`),
					disclosureState: r,
					panel: o,
					button: i,
					toggleDisclosure() {
						r.value = pt(r.value, { 0: 1, 1: 0 });
					},
					closeDisclosure() {
						r.value !== 1 && (r.value = 1);
					},
					close(l) {
						s.closeDisclosure();
						let a = l
							? l instanceof HTMLElement
								? l
								: l.value instanceof HTMLElement
								? re(l)
								: re(s.button)
							: re(s.button);
						a == null || a.focus();
					},
				};
			return (
				vt(fy, s),
				Mu(H(() => pt(r.value, { 0: ct.Open, 1: ct.Closed }))),
				() => {
					let c = t,
						{ defaultOpen: l } = c,
						a = et(c, ["defaultOpen"]),
						u = { open: r.value === 0, close: s.close };
					return ut({
						theirProps: a,
						ourProps: {},
						slot: u,
						slots: e,
						attrs: n,
						name: "Disclosure",
					});
				}
			);
		},
	}),
	Wj = Re({
		name: "DisclosureButton",
		props: {
			as: { type: [Object, String], default: "button" },
			disabled: { type: [Boolean], default: !1 },
			id: { type: String, default: null },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Wf("DisclosureButton"),
				i = zk(),
				s = H(() => (i === null ? !1 : i.value === o.panelId.value));
			Xe(() => {
				s.value || (t.id !== null && (o.buttonId.value = t.id));
			}),
				Dt(() => {
					s.value || (o.buttonId.value = null);
				});
			let l = X(null);
			r({ el: l, $el: l }),
				s.value ||
					bt(() => {
						o.button.value = l.value;
					});
			let a = Ff(
				H(() => ({ as: t.as, type: e.type })),
				l
			);
			function u() {
				var h;
				t.disabled ||
					(s.value
						? (o.toggleDisclosure(),
						  (h = re(o.button)) == null || h.focus())
						: o.toggleDisclosure());
			}
			function c(h) {
				var p;
				if (!t.disabled)
					if (s.value)
						switch (h.key) {
							case Ae.Space:
							case Ae.Enter:
								h.preventDefault(),
									h.stopPropagation(),
									o.toggleDisclosure(),
									(p = re(o.button)) == null || p.focus();
								break;
						}
					else
						switch (h.key) {
							case Ae.Space:
							case Ae.Enter:
								h.preventDefault(),
									h.stopPropagation(),
									o.toggleDisclosure();
								break;
						}
			}
			function d(h) {
				switch (h.key) {
					case Ae.Space:
						h.preventDefault();
						break;
				}
			}
			return () => {
				var h;
				let p = { open: o.disclosureState.value === 0 },
					w = t,
					{ id: g } = w,
					y = et(w, ["id"]),
					b = s.value
						? { ref: l, type: a.value, onClick: u, onKeydown: c }
						: {
								id: (h = o.buttonId.value) != null ? h : g,
								ref: l,
								type: a.value,
								"aria-expanded": o.disclosureState.value === 0,
								"aria-controls":
									o.disclosureState.value === 0 || re(o.panel)
										? o.panelId.value
										: void 0,
								disabled: t.disabled ? !0 : void 0,
								onClick: u,
								onKeydown: c,
								onKeyup: d,
						  };
				return ut({
					ourProps: b,
					theirProps: y,
					slot: p,
					attrs: e,
					slots: n,
					name: "DisclosureButton",
				});
			};
		},
	}),
	Uj = Re({
		name: "DisclosurePanel",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: { type: String, default: null },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Wf("DisclosurePanel");
			Xe(() => {
				t.id !== null && (o.panelId.value = t.id);
			}),
				Dt(() => {
					o.panelId.value = null;
				}),
				r({ el: o.panel, $el: o.panel }),
				vt(hy, o.panelId);
			let i = ji(),
				s = H(() =>
					i !== null
						? (i.value & ct.Open) === ct.Open
						: o.disclosureState.value === 0
				);
			return () => {
				var l;
				let a = { open: o.disclosureState.value === 0, close: o.close },
					h = t,
					{ id: u } = h,
					c = et(h, ["id"]),
					d = {
						id: (l = o.panelId.value) != null ? l : u,
						ref: o.panel,
					};
				return ut({
					ourProps: d,
					theirProps: c,
					slot: a,
					attrs: e,
					slots: n,
					features: fn.RenderStrategy | fn.Static,
					visible: s.value,
					name: "DisclosurePanel",
				});
			};
		},
	}),
	om =
		/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function im(t) {
	var e, n;
	let r = (e = t.innerText) != null ? e : "",
		o = t.cloneNode(!0);
	if (!(o instanceof HTMLElement)) return r;
	let i = !1;
	for (let l of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
		l.remove(), (i = !0);
	let s = i ? ((n = o.innerText) != null ? n : "") : r;
	return om.test(s) && (s = s.replace(om, "")), s;
}
function Hk(t) {
	let e = t.getAttribute("aria-label");
	if (typeof e == "string") return e.trim();
	let n = t.getAttribute("aria-labelledby");
	if (n) {
		let r = n
			.split(" ")
			.map((o) => {
				let i = document.getElementById(o);
				if (i) {
					let s = i.getAttribute("aria-label");
					return typeof s == "string" ? s.trim() : im(i).trim();
				}
				return null;
			})
			.filter(Boolean);
		if (r.length > 0) return r.join(", ");
	}
	return im(t).trim();
}
function Fk(t) {
	let e = X(""),
		n = X("");
	return () => {
		let r = re(t);
		if (!r) return "";
		let o = r.innerText;
		if (e.value === o) return n.value;
		let i = Hk(r).trim().toLowerCase();
		return (e.value = o), (n.value = i), i;
	};
}
var Vk = ((t) => (
		(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
	))(Vk || {}),
	Wk = ((t) => (
		(t[(t.Pointer = 0)] = "Pointer"), (t[(t.Other = 1)] = "Other"), t
	))(Wk || {});
function Uk(t) {
	requestAnimationFrame(() => requestAnimationFrame(t));
}
let py = Symbol("MenuContext");
function Tu(t) {
	let e = qe(py, null);
	if (e === null) {
		let n = new Error(`<${t} /> is missing a parent <Menu /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Tu), n);
	}
	return e;
}
let Kk = Re({
		name: "Menu",
		props: { as: { type: [Object, String], default: "template" } },
		setup(t, { slots: e, attrs: n }) {
			let r = X(1),
				o = X(null),
				i = X(null),
				s = X([]),
				l = X(""),
				a = X(null),
				u = X(1);
			function c(h = (p) => p) {
				let p = a.value !== null ? s.value[a.value] : null,
					g = Vr(h(s.value.slice()), (b) => re(b.dataRef.domRef)),
					y = p ? g.indexOf(p) : null;
				return y === -1 && (y = null), { items: g, activeItemIndex: y };
			}
			let d = {
				menuState: r,
				buttonRef: o,
				itemsRef: i,
				items: s,
				searchQuery: l,
				activeItemIndex: a,
				activationTrigger: u,
				closeMenu: () => {
					(r.value = 1), (a.value = null);
				},
				openMenu: () => (r.value = 0),
				goToItem(h, p, g) {
					let y = c(),
						b = hd(
							h === rt.Specific
								? { focus: rt.Specific, id: p }
								: { focus: h },
							{
								resolveItems: () => y.items,
								resolveActiveIndex: () => y.activeItemIndex,
								resolveId: (w) => w.id,
								resolveDisabled: (w) => w.dataRef.disabled,
							}
						);
					(l.value = ""),
						(a.value = b),
						(u.value = g != null ? g : 1),
						(s.value = y.items);
				},
				search(h) {
					let p = l.value !== "" ? 0 : 1;
					l.value += h.toLowerCase();
					let g = (
							a.value !== null
								? s.value
										.slice(a.value + p)
										.concat(s.value.slice(0, a.value + p))
								: s.value
						).find(
							(b) =>
								b.dataRef.textValue.startsWith(l.value) &&
								!b.dataRef.disabled
						),
						y = g ? s.value.indexOf(g) : -1;
					y === -1 || y === a.value || ((a.value = y), (u.value = 1));
				},
				clearSearch() {
					l.value = "";
				},
				registerItem(h, p) {
					let g = c((y) => [...y, { id: h, dataRef: p }]);
					(s.value = g.items),
						(a.value = g.activeItemIndex),
						(u.value = 1);
				},
				unregisterItem(h) {
					let p = c((g) => {
						let y = g.findIndex((b) => b.id === h);
						return y !== -1 && g.splice(y, 1), g;
					});
					(s.value = p.items),
						(a.value = p.activeItemIndex),
						(u.value = 1);
				},
			};
			return (
				Hf(
					[o, i],
					(h, p) => {
						var g;
						d.closeMenu(),
							zf(p, Bf.Loose) ||
								(h.preventDefault(),
								(g = re(o)) == null || g.focus());
					},
					H(() => r.value === 0)
				),
				vt(py, d),
				Mu(H(() => pt(r.value, { 0: ct.Open, 1: ct.Closed }))),
				() => {
					let h = { open: r.value === 0, close: d.closeMenu };
					return ut({
						ourProps: {},
						theirProps: t,
						slot: h,
						slots: e,
						attrs: n,
						name: "Menu",
					});
				}
			);
		},
	}),
	qk = Re({
		name: "MenuButton",
		props: {
			disabled: { type: Boolean, default: !1 },
			as: { type: [Object, String], default: "button" },
			id: {
				type: String,
				default: () => `headlessui-menu-button-${dn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Tu("MenuButton");
			r({ el: o.buttonRef, $el: o.buttonRef });
			function i(u) {
				switch (u.key) {
					case Ae.Space:
					case Ae.Enter:
					case Ae.ArrowDown:
						u.preventDefault(),
							u.stopPropagation(),
							o.openMenu(),
							zt(() => {
								var c;
								(c = re(o.itemsRef)) == null ||
									c.focus({ preventScroll: !0 }),
									o.goToItem(rt.First);
							});
						break;
					case Ae.ArrowUp:
						u.preventDefault(),
							u.stopPropagation(),
							o.openMenu(),
							zt(() => {
								var c;
								(c = re(o.itemsRef)) == null ||
									c.focus({ preventScroll: !0 }),
									o.goToItem(rt.Last);
							});
						break;
				}
			}
			function s(u) {
				switch (u.key) {
					case Ae.Space:
						u.preventDefault();
						break;
				}
			}
			function l(u) {
				t.disabled ||
					(o.menuState.value === 0
						? (o.closeMenu(),
						  zt(() => {
								var c;
								return (c = re(o.buttonRef)) == null
									? void 0
									: c.focus({ preventScroll: !0 });
						  }))
						: (u.preventDefault(),
						  o.openMenu(),
						  Uk(() => {
								var c;
								return (c = re(o.itemsRef)) == null
									? void 0
									: c.focus({ preventScroll: !0 });
						  })));
			}
			let a = Ff(
				H(() => ({ as: t.as, type: e.type })),
				o.buttonRef
			);
			return () => {
				var u;
				let c = { open: o.menuState.value === 0 },
					g = t,
					{ id: d } = g,
					h = et(g, ["id"]),
					p = {
						ref: o.buttonRef,
						id: d,
						type: a.value,
						"aria-haspopup": "menu",
						"aria-controls":
							(u = re(o.itemsRef)) == null ? void 0 : u.id,
						"aria-expanded": o.menuState.value === 0,
						onKeydown: i,
						onKeyup: s,
						onClick: l,
					};
				return ut({
					ourProps: p,
					theirProps: h,
					slot: c,
					attrs: e,
					slots: n,
					name: "MenuButton",
				});
			};
		},
	}),
	Jk = Re({
		name: "MenuItems",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: {
				type: String,
				default: () => `headlessui-menu-items-${dn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Tu("MenuItems"),
				i = X(null);
			r({ el: o.itemsRef, $el: o.itemsRef }),
				Y0({
					container: H(() => re(o.itemsRef)),
					enabled: H(() => o.menuState.value === 0),
					accept(c) {
						return c.getAttribute("role") === "menuitem"
							? NodeFilter.FILTER_REJECT
							: c.hasAttribute("role")
							? NodeFilter.FILTER_SKIP
							: NodeFilter.FILTER_ACCEPT;
					},
					walk(c) {
						c.setAttribute("role", "none");
					},
				});
			function s(c) {
				var d;
				switch ((i.value && clearTimeout(i.value), c.key)) {
					case Ae.Space:
						if (o.searchQuery.value !== "")
							return (
								c.preventDefault(),
								c.stopPropagation(),
								o.search(c.key)
							);
					case Ae.Enter:
						if (
							(c.preventDefault(),
							c.stopPropagation(),
							o.activeItemIndex.value !== null)
						) {
							let h = o.items.value[o.activeItemIndex.value];
							(d = re(h.dataRef.domRef)) == null || d.click();
						}
						o.closeMenu(), U0(re(o.buttonRef));
						break;
					case Ae.ArrowDown:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Next)
						);
					case Ae.ArrowUp:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Previous)
						);
					case Ae.Home:
					case Ae.PageUp:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.First)
						);
					case Ae.End:
					case Ae.PageDown:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Last)
						);
					case Ae.Escape:
						c.preventDefault(),
							c.stopPropagation(),
							o.closeMenu(),
							zt(() => {
								var h;
								return (h = re(o.buttonRef)) == null
									? void 0
									: h.focus({ preventScroll: !0 });
							});
						break;
					case Ae.Tab:
						c.preventDefault(),
							c.stopPropagation(),
							o.closeMenu(),
							zt(() =>
								ek(
									re(o.buttonRef),
									c.shiftKey ? _t.Previous : _t.Next
								)
							);
						break;
					default:
						c.key.length === 1 &&
							(o.search(c.key),
							(i.value = setTimeout(() => o.clearSearch(), 350)));
						break;
				}
			}
			function l(c) {
				switch (c.key) {
					case Ae.Space:
						c.preventDefault();
						break;
				}
			}
			let a = ji(),
				u = H(() =>
					a !== null
						? (a.value & ct.Open) === ct.Open
						: o.menuState.value === 0
				);
			return () => {
				var c, d;
				let h = { open: o.menuState.value === 0 },
					b = t,
					{ id: p } = b,
					g = et(b, ["id"]),
					y = {
						"aria-activedescendant":
							o.activeItemIndex.value === null ||
							(c = o.items.value[o.activeItemIndex.value]) == null
								? void 0
								: c.id,
						"aria-labelledby":
							(d = re(o.buttonRef)) == null ? void 0 : d.id,
						id: p,
						onKeydown: s,
						onKeyup: l,
						role: "menu",
						tabIndex: 0,
						ref: o.itemsRef,
					};
				return ut({
					ourProps: y,
					theirProps: g,
					slot: h,
					attrs: e,
					slots: n,
					features: fn.RenderStrategy | fn.Static,
					visible: u.value,
					name: "MenuItems",
				});
			};
		},
	}),
	Gk = Re({
		name: "MenuItem",
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "template" },
			disabled: { type: Boolean, default: !1 },
			id: { type: String, default: () => `headlessui-menu-item-${dn()}` },
		},
		setup(t, { slots: e, attrs: n, expose: r }) {
			let o = Tu("MenuItem"),
				i = X(null);
			r({ el: i, $el: i });
			let s = H(() =>
					o.activeItemIndex.value !== null
						? o.items.value[o.activeItemIndex.value].id === t.id
						: !1
				),
				l = Fk(i),
				a = H(() => ({
					disabled: t.disabled,
					get textValue() {
						return l();
					},
					domRef: i,
				}));
			Xe(() => o.registerItem(t.id, a)),
				Dt(() => o.unregisterItem(t.id)),
				bt(() => {
					o.menuState.value === 0 &&
						s.value &&
						o.activationTrigger.value !== 0 &&
						zt(() => {
							var y, b;
							return (b =
								(y = re(i)) == null
									? void 0
									: y.scrollIntoView) == null
								? void 0
								: b.call(y, { block: "nearest" });
						});
				});
			function u(y) {
				if (t.disabled) return y.preventDefault();
				o.closeMenu(), U0(re(o.buttonRef));
			}
			function c() {
				if (t.disabled) return o.goToItem(rt.Nothing);
				o.goToItem(rt.Specific, t.id);
			}
			let d = G0();
			function h(y) {
				d.update(y);
			}
			function p(y) {
				d.wasMoved(y) &&
					(t.disabled || s.value || o.goToItem(rt.Specific, t.id, 0));
			}
			function g(y) {
				d.wasMoved(y) &&
					(t.disabled || (s.value && o.goToItem(rt.Nothing)));
			}
			return () => {
				let { disabled: y } = t,
					b = { active: s.value, disabled: y, close: o.closeMenu },
					E = t,
					{ id: w } = E,
					S = et(E, ["id"]);
				return ut({
					ourProps: {
						id: w,
						ref: i,
						role: "menuitem",
						tabIndex: y === !0 ? void 0 : -1,
						"aria-disabled": y === !0 ? !0 : void 0,
						disabled: void 0,
						onClick: u,
						onFocus: c,
						onPointerenter: h,
						onMouseenter: h,
						onPointermove: p,
						onMousemove: p,
						onPointerleave: g,
						onMouseleave: g,
					},
					theirProps: z(z({}, n), S),
					slot: b,
					attrs: n,
					slots: e,
					name: "MenuItem",
				});
			};
		},
	}),
	Yk = Re({
		props: { onFocus: { type: Function, required: !0 } },
		setup(t) {
			let e = X(!0);
			return () =>
				e.value
					? Ue(Si, {
							as: "button",
							type: "button",
							features: ki.Focusable,
							onFocus(n) {
								n.preventDefault();
								let r,
									o = 50;
								function i() {
									var s;
									if (o-- <= 0) {
										r && cancelAnimationFrame(r);
										return;
									}
									if ((s = t.onFocus) != null && s.call(t)) {
										(e.value = !1), cancelAnimationFrame(r);
										return;
									}
									r = requestAnimationFrame(i);
								}
								r = requestAnimationFrame(i);
							},
					  })
					: null;
		},
	});
var Qk = ((t) => (
		(t[(t.Forwards = 0)] = "Forwards"),
		(t[(t.Backwards = 1)] = "Backwards"),
		t
	))(Qk || {}),
	Xk = ((t) => (
		(t[(t.Less = -1)] = "Less"),
		(t[(t.Equal = 0)] = "Equal"),
		(t[(t.Greater = 1)] = "Greater"),
		t
	))(Xk || {});
let my = Symbol("TabsContext");
function Ys(t) {
	let e = qe(my, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <TabGroup /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Ys), n);
	}
	return e;
}
let Uf = Symbol("TabsSSRContext"),
	Zk = Re({
		name: "TabGroup",
		emits: { change: (t) => !0 },
		props: {
			as: { type: [Object, String], default: "template" },
			selectedIndex: { type: [Number], default: null },
			defaultIndex: { type: [Number], default: 0 },
			vertical: { type: [Boolean], default: !1 },
			manual: { type: [Boolean], default: !1 },
		},
		inheritAttrs: !1,
		setup(t, { slots: e, attrs: n, emit: r }) {
			var o;
			let i = X((o = t.selectedIndex) != null ? o : t.defaultIndex),
				s = X([]),
				l = X([]),
				a = H(() => t.selectedIndex !== null),
				u = H(() => (a.value ? t.selectedIndex : i.value));
			function c(y) {
				var b;
				let w = Vr(d.tabs.value, re),
					S = Vr(d.panels.value, re),
					E = w.filter((f) => {
						var v;
						return !(
							(v = re(f)) != null && v.hasAttribute("disabled")
						);
					});
				if (y < 0 || y > w.length - 1) {
					let f = pt(i.value === null ? 0 : Math.sign(y - i.value), {
							[-1]: () => 1,
							0: () =>
								pt(Math.sign(y), {
									[-1]: () => 0,
									0: () => 0,
									1: () => 1,
								}),
							1: () => 0,
						}),
						v = pt(f, {
							0: () => w.indexOf(E[0]),
							1: () => w.indexOf(E[E.length - 1]),
						});
					v !== -1 && (i.value = v),
						(d.tabs.value = w),
						(d.panels.value = S);
				} else {
					let f = w.slice(0, y),
						v = [...w.slice(y), ...f].find((x) => E.includes(x));
					if (!v) return;
					let m =
						(b = w.indexOf(v)) != null ? b : d.selectedIndex.value;
					m === -1 && (m = d.selectedIndex.value),
						(i.value = m),
						(d.tabs.value = w),
						(d.panels.value = S);
				}
			}
			let d = {
				selectedIndex: H(() => {
					var y, b;
					return (b = (y = i.value) != null ? y : t.defaultIndex) !=
						null
						? b
						: null;
				}),
				orientation: H(() => (t.vertical ? "vertical" : "horizontal")),
				activation: H(() => (t.manual ? "manual" : "auto")),
				tabs: s,
				panels: l,
				setSelectedIndex(y) {
					u.value !== y && r("change", y), a.value || c(y);
				},
				registerTab(y) {
					var b;
					if (s.value.includes(y)) return;
					let w = s.value[i.value];
					s.value.push(y), (s.value = Vr(s.value, re));
					let S = (b = s.value.indexOf(w)) != null ? b : i.value;
					S !== -1 && (i.value = S);
				},
				unregisterTab(y) {
					let b = s.value.indexOf(y);
					b !== -1 && s.value.splice(b, 1);
				},
				registerPanel(y) {
					l.value.includes(y) ||
						(l.value.push(y), (l.value = Vr(l.value, re)));
				},
				unregisterPanel(y) {
					let b = l.value.indexOf(y);
					b !== -1 && l.value.splice(b, 1);
				},
			};
			vt(my, d);
			let h = X({ tabs: [], panels: [] }),
				p = X(!1);
			Xe(() => {
				p.value = !0;
			}),
				vt(
					Uf,
					H(() => (p.value ? null : h.value))
				);
			let g = H(() => t.selectedIndex);
			return (
				Xe(() => {
					it(
						[g],
						() => {
							var y;
							return c(
								(y = t.selectedIndex) != null
									? y
									: t.defaultIndex
							);
						},
						{ immediate: !0 }
					);
				}),
				bt(() => {
					if (!a.value || u.value == null || d.tabs.value.length <= 0)
						return;
					let y = Vr(d.tabs.value, re);
					y.some((b, w) => re(d.tabs.value[w]) !== re(b)) &&
						d.setSelectedIndex(
							y.findIndex(
								(b) => re(b) === re(d.tabs.value[u.value])
							)
						);
				}),
				() => {
					let y = { selectedIndex: i.value };
					return Ue(Ne, [
						s.value.length <= 0 &&
							Ue(Yk, {
								onFocus: () => {
									for (let b of s.value) {
										let w = re(b);
										if (
											(w == null
												? void 0
												: w.tabIndex) === 0
										)
											return w.focus(), !0;
									}
									return !1;
								},
							}),
						ut({
							theirProps: z(
								z({}, n),
								Di(t, [
									"selectedIndex",
									"defaultIndex",
									"manual",
									"vertical",
									"onChange",
								])
							),
							ourProps: {},
							slot: y,
							slots: e,
							attrs: n,
							name: "TabGroup",
						}),
					]);
				}
			);
		},
	}),
	e8 = Re({
		name: "TabList",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { attrs: e, slots: n }) {
			let r = Ys("TabList");
			return () => {
				let o = { selectedIndex: r.selectedIndex.value },
					i = {
						role: "tablist",
						"aria-orientation": r.orientation.value,
					};
				return ut({
					ourProps: i,
					theirProps: t,
					slot: o,
					attrs: e,
					slots: n,
					name: "TabList",
				});
			};
		},
	}),
	t8 = Re({
		name: "Tab",
		props: {
			as: { type: [Object, String], default: "button" },
			disabled: { type: [Boolean], default: !1 },
			id: { type: String, default: () => `headlessui-tabs-tab-${dn()}` },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Ys("Tab"),
				i = X(null);
			r({ el: i, $el: i }),
				Xe(() => o.registerTab(i)),
				Dt(() => o.unregisterTab(i));
			let s = qe(Uf),
				l = H(() => {
					if (s.value) {
						let b = s.value.tabs.indexOf(t.id);
						return b === -1 ? s.value.tabs.push(t.id) - 1 : b;
					}
					return -1;
				}),
				a = H(() => {
					let b = o.tabs.value.indexOf(i);
					return b === -1 ? l.value : b;
				}),
				u = H(() => a.value === o.selectedIndex.value);
			function c(b) {
				var w;
				let S = b();
				if (S === si.Success && o.activation.value === "auto") {
					let E = (w = dr(i)) == null ? void 0 : w.activeElement,
						f = o.tabs.value.findIndex((v) => re(v) === E);
					f !== -1 && o.setSelectedIndex(f);
				}
				return S;
			}
			function d(b) {
				let w = o.tabs.value.map((S) => re(S)).filter(Boolean);
				if (b.key === Ae.Space || b.key === Ae.Enter) {
					b.preventDefault(),
						b.stopPropagation(),
						o.setSelectedIndex(a.value);
					return;
				}
				switch (b.key) {
					case Ae.Home:
					case Ae.PageUp:
						return (
							b.preventDefault(),
							b.stopPropagation(),
							c(() => Nn(w, _t.First))
						);
					case Ae.End:
					case Ae.PageDown:
						return (
							b.preventDefault(),
							b.stopPropagation(),
							c(() => Nn(w, _t.Last))
						);
				}
				if (
					c(() =>
						pt(o.orientation.value, {
							vertical() {
								return b.key === Ae.ArrowUp
									? Nn(w, _t.Previous | _t.WrapAround)
									: b.key === Ae.ArrowDown
									? Nn(w, _t.Next | _t.WrapAround)
									: si.Error;
							},
							horizontal() {
								return b.key === Ae.ArrowLeft
									? Nn(w, _t.Previous | _t.WrapAround)
									: b.key === Ae.ArrowRight
									? Nn(w, _t.Next | _t.WrapAround)
									: si.Error;
							},
						})
					) === si.Success
				)
					return b.preventDefault();
			}
			let h = X(!1);
			function p() {
				var b;
				h.value ||
					((h.value = !0),
					!t.disabled &&
						((b = re(i)) == null || b.focus({ preventScroll: !0 }),
						o.setSelectedIndex(a.value),
						Eu(() => {
							h.value = !1;
						})));
			}
			function g(b) {
				b.preventDefault();
			}
			let y = Ff(
				H(() => ({ as: t.as, type: e.type })),
				i
			);
			return () => {
				var b;
				let w = { selected: u.value },
					v = t,
					{ id: S } = v,
					E = et(v, ["id"]),
					f = {
						ref: i,
						onKeydown: d,
						onMousedown: g,
						onClick: p,
						id: S,
						role: "tab",
						type: y.value,
						"aria-controls":
							(b = re(o.panels.value[a.value])) == null
								? void 0
								: b.id,
						"aria-selected": u.value,
						tabIndex: u.value ? 0 : -1,
						disabled: t.disabled ? !0 : void 0,
					};
				return ut({
					ourProps: f,
					theirProps: E,
					slot: w,
					attrs: e,
					slots: n,
					name: "Tab",
				});
			};
		},
	}),
	n8 = Re({
		name: "TabPanels",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { slots: e, attrs: n }) {
			let r = Ys("TabPanels");
			return () => {
				let o = { selectedIndex: r.selectedIndex.value };
				return ut({
					theirProps: t,
					ourProps: {},
					slot: o,
					attrs: n,
					slots: e,
					name: "TabPanels",
				});
			};
		},
	}),
	r8 = Re({
		name: "TabPanel",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: {
				type: String,
				default: () => `headlessui-tabs-panel-${dn()}`,
			},
			tabIndex: { type: Number, default: 0 },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Ys("TabPanel"),
				i = X(null);
			r({ el: i, $el: i }),
				Xe(() => o.registerPanel(i)),
				Dt(() => o.unregisterPanel(i));
			let s = qe(Uf),
				l = H(() => {
					if (s.value) {
						let c = s.value.panels.indexOf(t.id);
						return c === -1 ? s.value.panels.push(t.id) - 1 : c;
					}
					return -1;
				}),
				a = H(() => {
					let c = o.panels.value.indexOf(i);
					return c === -1 ? l.value : c;
				}),
				u = H(() => a.value === o.selectedIndex.value);
			return () => {
				var c;
				let d = { selected: u.value },
					b = t,
					{ id: h, tabIndex: p } = b,
					g = et(b, ["id", "tabIndex"]),
					y = {
						ref: i,
						id: h,
						role: "tabpanel",
						"aria-labelledby":
							(c = re(o.tabs.value[a.value])) == null
								? void 0
								: c.id,
						tabIndex: u.value ? p : -1,
					};
				return !u.value && t.unmount && !t.static
					? Ue(Si, z({ as: "span", "aria-hidden": !0 }, y))
					: ut({
							ourProps: y,
							theirProps: g,
							slot: d,
							attrs: e,
							slots: n,
							features: fn.Static | fn.RenderStrategy,
							visible: u.value,
							name: "TabPanel",
					  });
			};
		},
	});
function o8(t) {
	let e = { called: !1 };
	return (...n) => {
		if (!e.called) return (e.called = !0), t(...n);
	};
}
function mc(t, ...e) {
	t && e.length > 0 && t.classList.add(...e);
}
function bl(t, ...e) {
	t && e.length > 0 && t.classList.remove(...e);
}
var yd = ((t) => ((t.Finished = "finished"), (t.Cancelled = "cancelled"), t))(
	yd || {}
);
function i8(t, e) {
	let n = Lo();
	if (!t) return n.dispose;
	let { transitionDuration: r, transitionDelay: o } = getComputedStyle(t),
		[i, s] = [r, o].map((l) => {
			let [a = 0] = l
				.split(",")
				.filter(Boolean)
				.map((u) =>
					u.includes("ms") ? parseFloat(u) : parseFloat(u) * 1e3
				)
				.sort((u, c) => c - u);
			return a;
		});
	return (
		i !== 0 ? n.setTimeout(() => e("finished"), i + s) : e("finished"),
		n.add(() => e("cancelled")),
		n.dispose
	);
}
function sm(t, e, n, r, o, i) {
	let s = Lo(),
		l = i !== void 0 ? o8(i) : () => {};
	return (
		bl(t, ...o),
		mc(t, ...e, ...n),
		s.nextFrame(() => {
			bl(t, ...n),
				mc(t, ...r),
				s.add(i8(t, (a) => (bl(t, ...r, ...e), mc(t, ...o), l(a))));
		}),
		s.add(() => bl(t, ...e, ...n, ...r, ...o)),
		s.add(() => l("cancelled")),
		s.dispose
	);
}
function bo(t = "") {
	return t.split(/\s+/).filter((e) => e.length > 1);
}
let Kf = Symbol("TransitionContext");
var s8 = ((t) => ((t.Visible = "visible"), (t.Hidden = "hidden"), t))(s8 || {});
function l8() {
	return qe(Kf, null) !== null;
}
function a8() {
	let t = qe(Kf, null);
	if (t === null)
		throw new Error(
			"A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."
		);
	return t;
}
function u8() {
	let t = qe(qf, null);
	if (t === null)
		throw new Error(
			"A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."
		);
	return t;
}
let qf = Symbol("NestingContext");
function Au(t) {
	return "children" in t
		? Au(t.children)
		: t.value.filter(({ state: e }) => e === "visible").length > 0;
}
function gy(t) {
	let e = X([]),
		n = X(!1);
	Xe(() => (n.value = !0)), Dt(() => (n.value = !1));
	function r(i, s = qr.Hidden) {
		let l = e.value.findIndex(({ id: a }) => a === i);
		l !== -1 &&
			(pt(s, {
				[qr.Unmount]() {
					e.value.splice(l, 1);
				},
				[qr.Hidden]() {
					e.value[l].state = "hidden";
				},
			}),
			!Au(e) && n.value && (t == null || t()));
	}
	function o(i) {
		let s = e.value.find(({ id: l }) => l === i);
		return (
			s
				? s.state !== "visible" && (s.state = "visible")
				: e.value.push({ id: i, state: "visible" }),
			() => r(i, qr.Unmount)
		);
	}
	return { children: e, register: o, unregister: r };
}
let yy = fn.RenderStrategy,
	vy = Re({
		props: {
			as: { type: [Object, String], default: "div" },
			show: { type: [Boolean], default: null },
			unmount: { type: [Boolean], default: !0 },
			appear: { type: [Boolean], default: !1 },
			enter: { type: [String], default: "" },
			enterFrom: { type: [String], default: "" },
			enterTo: { type: [String], default: "" },
			entered: { type: [String], default: "" },
			leave: { type: [String], default: "" },
			leaveFrom: { type: [String], default: "" },
			leaveTo: { type: [String], default: "" },
		},
		emits: {
			beforeEnter: () => !0,
			afterEnter: () => !0,
			beforeLeave: () => !0,
			afterLeave: () => !0,
		},
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			let i = X(0);
			function s() {
				(i.value |= ct.Opening), e("beforeEnter");
			}
			function l() {
				(i.value &= ~ct.Opening), e("afterEnter");
			}
			function a() {
				(i.value |= ct.Closing), e("beforeLeave");
			}
			function u() {
				(i.value &= ~ct.Closing), e("afterLeave");
			}
			if (!l8() && ok())
				return () =>
					Ue(
						by,
						ye(z({}, t), {
							onBeforeEnter: s,
							onAfterEnter: l,
							onBeforeLeave: a,
							onAfterLeave: u,
						}),
						r
					);
			let c = X(null),
				d = H(() => (t.unmount ? qr.Unmount : qr.Hidden));
			o({ el: c, $el: c });
			let { show: h, appear: p } = a8(),
				{ register: g, unregister: y } = u8(),
				b = X(h.value ? "visible" : "hidden"),
				w = { value: !0 },
				S = dn(),
				E = { value: !1 },
				f = gy(() => {
					!E.value &&
						b.value !== "hidden" &&
						((b.value = "hidden"), y(S), u());
				});
			Xe(() => {
				let P = g(S);
				Dt(P);
			}),
				bt(() => {
					if (d.value === qr.Hidden && S) {
						if (h.value && b.value !== "visible") {
							b.value = "visible";
							return;
						}
						pt(b.value, {
							hidden: () => y(S),
							visible: () => g(S),
						});
					}
				});
			let v = bo(t.enter),
				m = bo(t.enterFrom),
				x = bo(t.enterTo),
				k = bo(t.entered),
				C = bo(t.leave),
				_ = bo(t.leaveFrom),
				T = bo(t.leaveTo);
			Xe(() => {
				bt(() => {
					if (b.value === "visible") {
						let P = re(c);
						if (P instanceof Comment && P.data === "")
							throw new Error(
								"Did you forget to passthrough the `ref` to the actual DOM node?"
							);
					}
				});
			});
			function R(P) {
				let N = w.value && !p.value,
					D = re(c);
				!D ||
					!(D instanceof HTMLElement) ||
					N ||
					((E.value = !0),
					h.value && s(),
					h.value || a(),
					P(
						h.value
							? sm(D, v, m, x, k, (M) => {
									(E.value = !1), M === yd.Finished && l();
							  })
							: sm(D, C, _, T, k, (M) => {
									(E.value = !1),
										M === yd.Finished &&
											(Au(f) ||
												((b.value = "hidden"),
												y(S),
												u()));
							  })
					));
			}
			return (
				Xe(() => {
					it(
						[h],
						(P, N, D) => {
							R(D), (w.value = !1);
						},
						{ immediate: !0 }
					);
				}),
				vt(qf, f),
				Mu(
					H(
						() =>
							pt(b.value, {
								visible: ct.Open,
								hidden: ct.Closed,
							}) | i.value
					)
				),
				() => {
					let Me = t,
						{
							appear: P,
							show: N,
							enter: D,
							enterFrom: M,
							enterTo: I,
							entered: $,
							leave: V,
							leaveFrom: ie,
							leaveTo: Y,
						} = Me,
						he = et(Me, [
							"appear",
							"show",
							"enter",
							"enterFrom",
							"enterTo",
							"entered",
							"leave",
							"leaveFrom",
							"leaveTo",
						]),
						Le = { ref: c },
						Ce = z(
							z({}, he),
							p.value && h.value && Js.isServer
								? { class: we([n.class, he.class, ...v, ...m]) }
								: {}
						);
					return ut({
						theirProps: Ce,
						ourProps: Le,
						slot: {},
						slots: r,
						attrs: n,
						features: yy,
						visible: b.value === "visible",
						name: "TransitionChild",
					});
				}
			);
		},
	}),
	c8 = vy,
	by = Re({
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "div" },
			show: { type: [Boolean], default: null },
			unmount: { type: [Boolean], default: !0 },
			appear: { type: [Boolean], default: !1 },
			enter: { type: [String], default: "" },
			enterFrom: { type: [String], default: "" },
			enterTo: { type: [String], default: "" },
			entered: { type: [String], default: "" },
			leave: { type: [String], default: "" },
			leaveFrom: { type: [String], default: "" },
			leaveTo: { type: [String], default: "" },
		},
		emits: {
			beforeEnter: () => !0,
			afterEnter: () => !0,
			beforeLeave: () => !0,
			afterLeave: () => !0,
		},
		setup(t, { emit: e, attrs: n, slots: r }) {
			let o = ji(),
				i = H(() =>
					t.show === null && o !== null
						? (o.value & ct.Open) === ct.Open
						: t.show
				);
			bt(() => {
				if (![!0, !1].includes(i.value))
					throw new Error(
						'A <Transition /> is used but it is missing a `:show="true | false"` prop.'
					);
			});
			let s = X(i.value ? "visible" : "hidden"),
				l = gy(() => {
					s.value = "hidden";
				}),
				a = X(!0),
				u = { show: i, appear: H(() => t.appear || !a.value) };
			return (
				Xe(() => {
					bt(() => {
						(a.value = !1),
							i.value
								? (s.value = "visible")
								: Au(l) || (s.value = "hidden");
					});
				}),
				vt(qf, l),
				vt(Kf, u),
				() => {
					let c = Di(t, [
							"show",
							"appear",
							"unmount",
							"onBeforeEnter",
							"onBeforeLeave",
							"onAfterEnter",
							"onAfterLeave",
						]),
						d = { unmount: t.unmount };
					return ut({
						ourProps: ye(z({}, d), { as: "template" }),
						theirProps: {},
						slot: {},
						slots: ye(z({}, r), {
							default: () => [
								Ue(
									c8,
									z(
										z(
											z(
												{
													onBeforeEnter: () =>
														e("beforeEnter"),
													onAfterEnter: () =>
														e("afterEnter"),
													onBeforeLeave: () =>
														e("beforeLeave"),
													onAfterLeave: () =>
														e("afterLeave"),
												},
												n
											),
											d
										),
										c
									),
									r.default
								),
							],
						}),
						attrs: {},
						features: yy,
						visible: s.value === "visible",
						name: "Transition",
					});
				}
			);
		},
	});
var ln = "top",
	Rn = "bottom",
	Pn = "right",
	an = "left",
	Jf = "auto",
	Qs = [ln, Rn, Pn, an],
	_i = "start",
	Ts = "end",
	d8 = "clippingParents",
	wy = "viewport",
	Ki = "popper",
	f8 = "reference",
	lm = Qs.reduce(function (t, e) {
		return t.concat([e + "-" + _i, e + "-" + Ts]);
	}, []),
	xy = [].concat(Qs, [Jf]).reduce(function (t, e) {
		return t.concat([e, e + "-" + _i, e + "-" + Ts]);
	}, []),
	h8 = "beforeRead",
	p8 = "read",
	m8 = "afterRead",
	g8 = "beforeMain",
	y8 = "main",
	v8 = "afterMain",
	b8 = "beforeWrite",
	w8 = "write",
	x8 = "afterWrite",
	k8 = [h8, p8, m8, g8, y8, v8, b8, w8, x8];
function lr(t) {
	return t ? (t.nodeName || "").toLowerCase() : null;
}
function yn(t) {
	if (t == null) return window;
	if (t.toString() !== "[object Window]") {
		var e = t.ownerDocument;
		return (e && e.defaultView) || window;
	}
	return t;
}
function $o(t) {
	var e = yn(t).Element;
	return t instanceof e || t instanceof Element;
}
function An(t) {
	var e = yn(t).HTMLElement;
	return t instanceof e || t instanceof HTMLElement;
}
function Gf(t) {
	if (typeof ShadowRoot == "undefined") return !1;
	var e = yn(t).ShadowRoot;
	return t instanceof e || t instanceof ShadowRoot;
}
function S8(t) {
	var e = t.state;
	Object.keys(e.elements).forEach(function (n) {
		var r = e.styles[n] || {},
			o = e.attributes[n] || {},
			i = e.elements[n];
		!An(i) ||
			!lr(i) ||
			(Object.assign(i.style, r),
			Object.keys(o).forEach(function (s) {
				var l = o[s];
				l === !1
					? i.removeAttribute(s)
					: i.setAttribute(s, l === !0 ? "" : l);
			}));
	});
}
function _8(t) {
	var e = t.state,
		n = {
			popper: {
				position: e.options.strategy,
				left: "0",
				top: "0",
				margin: "0",
			},
			arrow: { position: "absolute" },
			reference: {},
		};
	return (
		Object.assign(e.elements.popper.style, n.popper),
		(e.styles = n),
		e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
		function () {
			Object.keys(e.elements).forEach(function (r) {
				var o = e.elements[r],
					i = e.attributes[r] || {},
					s = Object.keys(
						e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]
					),
					l = s.reduce(function (a, u) {
						return (a[u] = ""), a;
					}, {});
				!An(o) ||
					!lr(o) ||
					(Object.assign(o.style, l),
					Object.keys(i).forEach(function (a) {
						o.removeAttribute(a);
					}));
			});
		}
	);
}
const ky = {
	name: "applyStyles",
	enabled: !0,
	phase: "write",
	fn: S8,
	effect: _8,
	requires: ["computeStyles"],
};
function rr(t) {
	return t.split("-")[0];
}
var Ro = Math.max,
	ma = Math.min,
	Ci = Math.round;
function vd() {
	var t = navigator.userAgentData;
	return t != null && t.brands && Array.isArray(t.brands)
		? t.brands
				.map(function (e) {
					return e.brand + "/" + e.version;
				})
				.join(" ")
		: navigator.userAgent;
}
function Sy() {
	return !/^((?!chrome|android).)*safari/i.test(vd());
}
function Mi(t, e, n) {
	e === void 0 && (e = !1), n === void 0 && (n = !1);
	var r = t.getBoundingClientRect(),
		o = 1,
		i = 1;
	e &&
		An(t) &&
		((o = (t.offsetWidth > 0 && Ci(r.width) / t.offsetWidth) || 1),
		(i = (t.offsetHeight > 0 && Ci(r.height) / t.offsetHeight) || 1));
	var s = $o(t) ? yn(t) : window,
		l = s.visualViewport,
		a = !Sy() && n,
		u = (r.left + (a && l ? l.offsetLeft : 0)) / o,
		c = (r.top + (a && l ? l.offsetTop : 0)) / i,
		d = r.width / o,
		h = r.height / i;
	return {
		width: d,
		height: h,
		top: c,
		right: u + d,
		bottom: c + h,
		left: u,
		x: u,
		y: c,
	};
}
function Yf(t) {
	var e = Mi(t),
		n = t.offsetWidth,
		r = t.offsetHeight;
	return (
		Math.abs(e.width - n) <= 1 && (n = e.width),
		Math.abs(e.height - r) <= 1 && (r = e.height),
		{ x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
	);
}
function _y(t, e) {
	var n = e.getRootNode && e.getRootNode();
	if (t.contains(e)) return !0;
	if (n && Gf(n)) {
		var r = e;
		do {
			if (r && t.isSameNode(r)) return !0;
			r = r.parentNode || r.host;
		} while (r);
	}
	return !1;
}
function Cr(t) {
	return yn(t).getComputedStyle(t);
}
function C8(t) {
	return ["table", "td", "th"].indexOf(lr(t)) >= 0;
}
function co(t) {
	return (($o(t) ? t.ownerDocument : t.document) || window.document)
		.documentElement;
}
function Ou(t) {
	return lr(t) === "html"
		? t
		: t.assignedSlot || t.parentNode || (Gf(t) ? t.host : null) || co(t);
}
function am(t) {
	return !An(t) || Cr(t).position === "fixed" ? null : t.offsetParent;
}
function M8(t) {
	var e = /firefox/i.test(vd()),
		n = /Trident/i.test(vd());
	if (n && An(t)) {
		var r = Cr(t);
		if (r.position === "fixed") return null;
	}
	var o = Ou(t);
	for (
		Gf(o) && (o = o.host);
		An(o) && ["html", "body"].indexOf(lr(o)) < 0;

	) {
		var i = Cr(o);
		if (
			i.transform !== "none" ||
			i.perspective !== "none" ||
			i.contain === "paint" ||
			["transform", "perspective"].indexOf(i.willChange) !== -1 ||
			(e && i.willChange === "filter") ||
			(e && i.filter && i.filter !== "none")
		)
			return o;
		o = o.parentNode;
	}
	return null;
}
function Xs(t) {
	for (var e = yn(t), n = am(t); n && C8(n) && Cr(n).position === "static"; )
		n = am(n);
	return n &&
		(lr(n) === "html" || (lr(n) === "body" && Cr(n).position === "static"))
		? e
		: n || M8(t) || e;
}
function Qf(t) {
	return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function as(t, e, n) {
	return Ro(t, ma(e, n));
}
function E8(t, e, n) {
	var r = as(t, e, n);
	return r > n ? n : r;
}
function Cy() {
	return { top: 0, right: 0, bottom: 0, left: 0 };
}
function My(t) {
	return Object.assign({}, Cy(), t);
}
function Ey(t, e) {
	return e.reduce(function (n, r) {
		return (n[r] = t), n;
	}, {});
}
var T8 = function (e, n) {
	return (
		(e =
			typeof e == "function"
				? e(Object.assign({}, n.rects, { placement: n.placement }))
				: e),
		My(typeof e != "number" ? e : Ey(e, Qs))
	);
};
function A8(t) {
	var e,
		n = t.state,
		r = t.name,
		o = t.options,
		i = n.elements.arrow,
		s = n.modifiersData.popperOffsets,
		l = rr(n.placement),
		a = Qf(l),
		u = [an, Pn].indexOf(l) >= 0,
		c = u ? "height" : "width";
	if (!(!i || !s)) {
		var d = T8(o.padding, n),
			h = Yf(i),
			p = a === "y" ? ln : an,
			g = a === "y" ? Rn : Pn,
			y =
				n.rects.reference[c] +
				n.rects.reference[a] -
				s[a] -
				n.rects.popper[c],
			b = s[a] - n.rects.reference[a],
			w = Xs(i),
			S = w ? (a === "y" ? w.clientHeight || 0 : w.clientWidth || 0) : 0,
			E = y / 2 - b / 2,
			f = d[p],
			v = S - h[c] - d[g],
			m = S / 2 - h[c] / 2 + E,
			x = as(f, m, v),
			k = a;
		n.modifiersData[r] =
			((e = {}), (e[k] = x), (e.centerOffset = x - m), e);
	}
}
function O8(t) {
	var e = t.state,
		n = t.options,
		r = n.element,
		o = r === void 0 ? "[data-popper-arrow]" : r;
	o != null &&
		((typeof o == "string" &&
			((o = e.elements.popper.querySelector(o)), !o)) ||
			(_y(e.elements.popper, o) && (e.elements.arrow = o)));
}
const R8 = {
	name: "arrow",
	enabled: !0,
	phase: "main",
	fn: A8,
	effect: O8,
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"],
};
function Ei(t) {
	return t.split("-")[1];
}
var P8 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function I8(t, e) {
	var n = t.x,
		r = t.y,
		o = e.devicePixelRatio || 1;
	return { x: Ci(n * o) / o || 0, y: Ci(r * o) / o || 0 };
}
function um(t) {
	var e,
		n = t.popper,
		r = t.popperRect,
		o = t.placement,
		i = t.variation,
		s = t.offsets,
		l = t.position,
		a = t.gpuAcceleration,
		u = t.adaptive,
		c = t.roundOffsets,
		d = t.isFixed,
		h = s.x,
		p = h === void 0 ? 0 : h,
		g = s.y,
		y = g === void 0 ? 0 : g,
		b = typeof c == "function" ? c({ x: p, y }) : { x: p, y };
	(p = b.x), (y = b.y);
	var w = s.hasOwnProperty("x"),
		S = s.hasOwnProperty("y"),
		E = an,
		f = ln,
		v = window;
	if (u) {
		var m = Xs(n),
			x = "clientHeight",
			k = "clientWidth";
		if (
			(m === yn(n) &&
				((m = co(n)),
				Cr(m).position !== "static" &&
					l === "absolute" &&
					((x = "scrollHeight"), (k = "scrollWidth"))),
			(m = m),
			o === ln || ((o === an || o === Pn) && i === Ts))
		) {
			f = Rn;
			var C =
				d && m === v && v.visualViewport
					? v.visualViewport.height
					: m[x];
			(y -= C - r.height), (y *= a ? 1 : -1);
		}
		if (o === an || ((o === ln || o === Rn) && i === Ts)) {
			E = Pn;
			var _ =
				d && m === v && v.visualViewport
					? v.visualViewport.width
					: m[k];
			(p -= _ - r.width), (p *= a ? 1 : -1);
		}
	}
	var T = Object.assign({ position: l }, u && P8),
		R = c === !0 ? I8({ x: p, y }, yn(n)) : { x: p, y };
	if (((p = R.x), (y = R.y), a)) {
		var P;
		return Object.assign(
			{},
			T,
			((P = {}),
			(P[f] = S ? "0" : ""),
			(P[E] = w ? "0" : ""),
			(P.transform =
				(v.devicePixelRatio || 1) <= 1
					? "translate(" + p + "px, " + y + "px)"
					: "translate3d(" + p + "px, " + y + "px, 0)"),
			P)
		);
	}
	return Object.assign(
		{},
		T,
		((e = {}),
		(e[f] = S ? y + "px" : ""),
		(e[E] = w ? p + "px" : ""),
		(e.transform = ""),
		e)
	);
}
function N8(t) {
	var e = t.state,
		n = t.options,
		r = n.gpuAcceleration,
		o = r === void 0 ? !0 : r,
		i = n.adaptive,
		s = i === void 0 ? !0 : i,
		l = n.roundOffsets,
		a = l === void 0 ? !0 : l,
		u = {
			placement: rr(e.placement),
			variation: Ei(e.placement),
			popper: e.elements.popper,
			popperRect: e.rects.popper,
			gpuAcceleration: o,
			isFixed: e.options.strategy === "fixed",
		};
	e.modifiersData.popperOffsets != null &&
		(e.styles.popper = Object.assign(
			{},
			e.styles.popper,
			um(
				Object.assign({}, u, {
					offsets: e.modifiersData.popperOffsets,
					position: e.options.strategy,
					adaptive: s,
					roundOffsets: a,
				})
			)
		)),
		e.modifiersData.arrow != null &&
			(e.styles.arrow = Object.assign(
				{},
				e.styles.arrow,
				um(
					Object.assign({}, u, {
						offsets: e.modifiersData.arrow,
						position: "absolute",
						adaptive: !1,
						roundOffsets: a,
					})
				)
			)),
		(e.attributes.popper = Object.assign({}, e.attributes.popper, {
			"data-popper-placement": e.placement,
		}));
}
const D8 = {
	name: "computeStyles",
	enabled: !0,
	phase: "beforeWrite",
	fn: N8,
	data: {},
};
var wl = { passive: !0 };
function j8(t) {
	var e = t.state,
		n = t.instance,
		r = t.options,
		o = r.scroll,
		i = o === void 0 ? !0 : o,
		s = r.resize,
		l = s === void 0 ? !0 : s,
		a = yn(e.elements.popper),
		u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
	return (
		i &&
			u.forEach(function (c) {
				c.addEventListener("scroll", n.update, wl);
			}),
		l && a.addEventListener("resize", n.update, wl),
		function () {
			i &&
				u.forEach(function (c) {
					c.removeEventListener("scroll", n.update, wl);
				}),
				l && a.removeEventListener("resize", n.update, wl);
		}
	);
}
const L8 = {
	name: "eventListeners",
	enabled: !0,
	phase: "write",
	fn: function () {},
	effect: j8,
	data: {},
};
var $8 = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Vl(t) {
	return t.replace(/left|right|bottom|top/g, function (e) {
		return $8[e];
	});
}
var B8 = { start: "end", end: "start" };
function cm(t) {
	return t.replace(/start|end/g, function (e) {
		return B8[e];
	});
}
function Xf(t) {
	var e = yn(t),
		n = e.pageXOffset,
		r = e.pageYOffset;
	return { scrollLeft: n, scrollTop: r };
}
function Zf(t) {
	return Mi(co(t)).left + Xf(t).scrollLeft;
}
function z8(t, e) {
	var n = yn(t),
		r = co(t),
		o = n.visualViewport,
		i = r.clientWidth,
		s = r.clientHeight,
		l = 0,
		a = 0;
	if (o) {
		(i = o.width), (s = o.height);
		var u = Sy();
		(u || (!u && e === "fixed")) && ((l = o.offsetLeft), (a = o.offsetTop));
	}
	return { width: i, height: s, x: l + Zf(t), y: a };
}
function H8(t) {
	var e,
		n = co(t),
		r = Xf(t),
		o = (e = t.ownerDocument) == null ? void 0 : e.body,
		i = Ro(
			n.scrollWidth,
			n.clientWidth,
			o ? o.scrollWidth : 0,
			o ? o.clientWidth : 0
		),
		s = Ro(
			n.scrollHeight,
			n.clientHeight,
			o ? o.scrollHeight : 0,
			o ? o.clientHeight : 0
		),
		l = -r.scrollLeft + Zf(t),
		a = -r.scrollTop;
	return (
		Cr(o || n).direction === "rtl" &&
			(l += Ro(n.clientWidth, o ? o.clientWidth : 0) - i),
		{ width: i, height: s, x: l, y: a }
	);
}
function eh(t) {
	var e = Cr(t),
		n = e.overflow,
		r = e.overflowX,
		o = e.overflowY;
	return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function Ty(t) {
	return ["html", "body", "#document"].indexOf(lr(t)) >= 0
		? t.ownerDocument.body
		: An(t) && eh(t)
		? t
		: Ty(Ou(t));
}
function us(t, e) {
	var n;
	e === void 0 && (e = []);
	var r = Ty(t),
		o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
		i = yn(r),
		s = o ? [i].concat(i.visualViewport || [], eh(r) ? r : []) : r,
		l = e.concat(s);
	return o ? l : l.concat(us(Ou(s)));
}
function bd(t) {
	return Object.assign({}, t, {
		left: t.x,
		top: t.y,
		right: t.x + t.width,
		bottom: t.y + t.height,
	});
}
function F8(t, e) {
	var n = Mi(t, !1, e === "fixed");
	return (
		(n.top = n.top + t.clientTop),
		(n.left = n.left + t.clientLeft),
		(n.bottom = n.top + t.clientHeight),
		(n.right = n.left + t.clientWidth),
		(n.width = t.clientWidth),
		(n.height = t.clientHeight),
		(n.x = n.left),
		(n.y = n.top),
		n
	);
}
function dm(t, e, n) {
	return e === wy ? bd(z8(t, n)) : $o(e) ? F8(e, n) : bd(H8(co(t)));
}
function V8(t) {
	var e = us(Ou(t)),
		n = ["absolute", "fixed"].indexOf(Cr(t).position) >= 0,
		r = n && An(t) ? Xs(t) : t;
	return $o(r)
		? e.filter(function (o) {
				return $o(o) && _y(o, r) && lr(o) !== "body";
		  })
		: [];
}
function W8(t, e, n, r) {
	var o = e === "clippingParents" ? V8(t) : [].concat(e),
		i = [].concat(o, [n]),
		s = i[0],
		l = i.reduce(function (a, u) {
			var c = dm(t, u, r);
			return (
				(a.top = Ro(c.top, a.top)),
				(a.right = ma(c.right, a.right)),
				(a.bottom = ma(c.bottom, a.bottom)),
				(a.left = Ro(c.left, a.left)),
				a
			);
		}, dm(t, s, r));
	return (
		(l.width = l.right - l.left),
		(l.height = l.bottom - l.top),
		(l.x = l.left),
		(l.y = l.top),
		l
	);
}
function Ay(t) {
	var e = t.reference,
		n = t.element,
		r = t.placement,
		o = r ? rr(r) : null,
		i = r ? Ei(r) : null,
		s = e.x + e.width / 2 - n.width / 2,
		l = e.y + e.height / 2 - n.height / 2,
		a;
	switch (o) {
		case ln:
			a = { x: s, y: e.y - n.height };
			break;
		case Rn:
			a = { x: s, y: e.y + e.height };
			break;
		case Pn:
			a = { x: e.x + e.width, y: l };
			break;
		case an:
			a = { x: e.x - n.width, y: l };
			break;
		default:
			a = { x: e.x, y: e.y };
	}
	var u = o ? Qf(o) : null;
	if (u != null) {
		var c = u === "y" ? "height" : "width";
		switch (i) {
			case _i:
				a[u] = a[u] - (e[c] / 2 - n[c] / 2);
				break;
			case Ts:
				a[u] = a[u] + (e[c] / 2 - n[c] / 2);
				break;
		}
	}
	return a;
}
function As(t, e) {
	e === void 0 && (e = {});
	var n = e,
		r = n.placement,
		o = r === void 0 ? t.placement : r,
		i = n.strategy,
		s = i === void 0 ? t.strategy : i,
		l = n.boundary,
		a = l === void 0 ? d8 : l,
		u = n.rootBoundary,
		c = u === void 0 ? wy : u,
		d = n.elementContext,
		h = d === void 0 ? Ki : d,
		p = n.altBoundary,
		g = p === void 0 ? !1 : p,
		y = n.padding,
		b = y === void 0 ? 0 : y,
		w = My(typeof b != "number" ? b : Ey(b, Qs)),
		S = h === Ki ? f8 : Ki,
		E = t.rects.popper,
		f = t.elements[g ? S : h],
		v = W8($o(f) ? f : f.contextElement || co(t.elements.popper), a, c, s),
		m = Mi(t.elements.reference),
		x = Ay({
			reference: m,
			element: E,
			strategy: "absolute",
			placement: o,
		}),
		k = bd(Object.assign({}, E, x)),
		C = h === Ki ? k : m,
		_ = {
			top: v.top - C.top + w.top,
			bottom: C.bottom - v.bottom + w.bottom,
			left: v.left - C.left + w.left,
			right: C.right - v.right + w.right,
		},
		T = t.modifiersData.offset;
	if (h === Ki && T) {
		var R = T[o];
		Object.keys(_).forEach(function (P) {
			var N = [Pn, Rn].indexOf(P) >= 0 ? 1 : -1,
				D = [ln, Rn].indexOf(P) >= 0 ? "y" : "x";
			_[P] += R[D] * N;
		});
	}
	return _;
}
function U8(t, e) {
	e === void 0 && (e = {});
	var n = e,
		r = n.placement,
		o = n.boundary,
		i = n.rootBoundary,
		s = n.padding,
		l = n.flipVariations,
		a = n.allowedAutoPlacements,
		u = a === void 0 ? xy : a,
		c = Ei(r),
		d = c
			? l
				? lm
				: lm.filter(function (g) {
						return Ei(g) === c;
				  })
			: Qs,
		h = d.filter(function (g) {
			return u.indexOf(g) >= 0;
		});
	h.length === 0 && (h = d);
	var p = h.reduce(function (g, y) {
		return (
			(g[y] = As(t, {
				placement: y,
				boundary: o,
				rootBoundary: i,
				padding: s,
			})[rr(y)]),
			g
		);
	}, {});
	return Object.keys(p).sort(function (g, y) {
		return p[g] - p[y];
	});
}
function K8(t) {
	if (rr(t) === Jf) return [];
	var e = Vl(t);
	return [cm(t), e, cm(e)];
}
function q8(t) {
	var e = t.state,
		n = t.options,
		r = t.name;
	if (!e.modifiersData[r]._skip) {
		for (
			var o = n.mainAxis,
				i = o === void 0 ? !0 : o,
				s = n.altAxis,
				l = s === void 0 ? !0 : s,
				a = n.fallbackPlacements,
				u = n.padding,
				c = n.boundary,
				d = n.rootBoundary,
				h = n.altBoundary,
				p = n.flipVariations,
				g = p === void 0 ? !0 : p,
				y = n.allowedAutoPlacements,
				b = e.options.placement,
				w = rr(b),
				S = w === b,
				E = a || (S || !g ? [Vl(b)] : K8(b)),
				f = [b].concat(E).reduce(function (Ce, Me) {
					return Ce.concat(
						rr(Me) === Jf
							? U8(e, {
									placement: Me,
									boundary: c,
									rootBoundary: d,
									padding: u,
									flipVariations: g,
									allowedAutoPlacements: y,
							  })
							: Me
					);
				}, []),
				v = e.rects.reference,
				m = e.rects.popper,
				x = new Map(),
				k = !0,
				C = f[0],
				_ = 0;
			_ < f.length;
			_++
		) {
			var T = f[_],
				R = rr(T),
				P = Ei(T) === _i,
				N = [ln, Rn].indexOf(R) >= 0,
				D = N ? "width" : "height",
				M = As(e, {
					placement: T,
					boundary: c,
					rootBoundary: d,
					altBoundary: h,
					padding: u,
				}),
				I = N ? (P ? Pn : an) : P ? Rn : ln;
			v[D] > m[D] && (I = Vl(I));
			var $ = Vl(I),
				V = [];
			if (
				(i && V.push(M[R] <= 0),
				l && V.push(M[I] <= 0, M[$] <= 0),
				V.every(function (Ce) {
					return Ce;
				}))
			) {
				(C = T), (k = !1);
				break;
			}
			x.set(T, V);
		}
		if (k)
			for (
				var ie = g ? 3 : 1,
					Y = function (Me) {
						var Te = f.find(function (B) {
							var Z = x.get(B);
							if (Z)
								return Z.slice(0, Me).every(function (ne) {
									return ne;
								});
						});
						if (Te) return (C = Te), "break";
					},
					he = ie;
				he > 0;
				he--
			) {
				var Le = Y(he);
				if (Le === "break") break;
			}
		e.placement !== C &&
			((e.modifiersData[r]._skip = !0),
			(e.placement = C),
			(e.reset = !0));
	}
}
const J8 = {
	name: "flip",
	enabled: !0,
	phase: "main",
	fn: q8,
	requiresIfExists: ["offset"],
	data: { _skip: !1 },
};
function fm(t, e, n) {
	return (
		n === void 0 && (n = { x: 0, y: 0 }),
		{
			top: t.top - e.height - n.y,
			right: t.right - e.width + n.x,
			bottom: t.bottom - e.height + n.y,
			left: t.left - e.width - n.x,
		}
	);
}
function hm(t) {
	return [ln, Pn, Rn, an].some(function (e) {
		return t[e] >= 0;
	});
}
function G8(t) {
	var e = t.state,
		n = t.name,
		r = e.rects.reference,
		o = e.rects.popper,
		i = e.modifiersData.preventOverflow,
		s = As(e, { elementContext: "reference" }),
		l = As(e, { altBoundary: !0 }),
		a = fm(s, r),
		u = fm(l, o, i),
		c = hm(a),
		d = hm(u);
	(e.modifiersData[n] = {
		referenceClippingOffsets: a,
		popperEscapeOffsets: u,
		isReferenceHidden: c,
		hasPopperEscaped: d,
	}),
		(e.attributes.popper = Object.assign({}, e.attributes.popper, {
			"data-popper-reference-hidden": c,
			"data-popper-escaped": d,
		}));
}
const Y8 = {
	name: "hide",
	enabled: !0,
	phase: "main",
	requiresIfExists: ["preventOverflow"],
	fn: G8,
};
function Q8(t, e, n) {
	var r = rr(t),
		o = [an, ln].indexOf(r) >= 0 ? -1 : 1,
		i =
			typeof n == "function"
				? n(Object.assign({}, e, { placement: t }))
				: n,
		s = i[0],
		l = i[1];
	return (
		(s = s || 0),
		(l = (l || 0) * o),
		[an, Pn].indexOf(r) >= 0 ? { x: l, y: s } : { x: s, y: l }
	);
}
function X8(t) {
	var e = t.state,
		n = t.options,
		r = t.name,
		o = n.offset,
		i = o === void 0 ? [0, 0] : o,
		s = xy.reduce(function (c, d) {
			return (c[d] = Q8(d, e.rects, i)), c;
		}, {}),
		l = s[e.placement],
		a = l.x,
		u = l.y;
	e.modifiersData.popperOffsets != null &&
		((e.modifiersData.popperOffsets.x += a),
		(e.modifiersData.popperOffsets.y += u)),
		(e.modifiersData[r] = s);
}
const Z8 = {
	name: "offset",
	enabled: !0,
	phase: "main",
	requires: ["popperOffsets"],
	fn: X8,
};
function eS(t) {
	var e = t.state,
		n = t.name;
	e.modifiersData[n] = Ay({
		reference: e.rects.reference,
		element: e.rects.popper,
		strategy: "absolute",
		placement: e.placement,
	});
}
const tS = {
	name: "popperOffsets",
	enabled: !0,
	phase: "read",
	fn: eS,
	data: {},
};
function nS(t) {
	return t === "x" ? "y" : "x";
}
function rS(t) {
	var e = t.state,
		n = t.options,
		r = t.name,
		o = n.mainAxis,
		i = o === void 0 ? !0 : o,
		s = n.altAxis,
		l = s === void 0 ? !1 : s,
		a = n.boundary,
		u = n.rootBoundary,
		c = n.altBoundary,
		d = n.padding,
		h = n.tether,
		p = h === void 0 ? !0 : h,
		g = n.tetherOffset,
		y = g === void 0 ? 0 : g,
		b = As(e, { boundary: a, rootBoundary: u, padding: d, altBoundary: c }),
		w = rr(e.placement),
		S = Ei(e.placement),
		E = !S,
		f = Qf(w),
		v = nS(f),
		m = e.modifiersData.popperOffsets,
		x = e.rects.reference,
		k = e.rects.popper,
		C =
			typeof y == "function"
				? y(Object.assign({}, e.rects, { placement: e.placement }))
				: y,
		_ =
			typeof C == "number"
				? { mainAxis: C, altAxis: C }
				: Object.assign({ mainAxis: 0, altAxis: 0 }, C),
		T = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
		R = { x: 0, y: 0 };
	if (m) {
		if (i) {
			var P,
				N = f === "y" ? ln : an,
				D = f === "y" ? Rn : Pn,
				M = f === "y" ? "height" : "width",
				I = m[f],
				$ = I + b[N],
				V = I - b[D],
				ie = p ? -k[M] / 2 : 0,
				Y = S === _i ? x[M] : k[M],
				he = S === _i ? -k[M] : -x[M],
				Le = e.elements.arrow,
				Ce = p && Le ? Yf(Le) : { width: 0, height: 0 },
				Me = e.modifiersData["arrow#persistent"]
					? e.modifiersData["arrow#persistent"].padding
					: Cy(),
				Te = Me[N],
				B = Me[D],
				Z = as(0, x[M], Ce[M]),
				ne = E
					? x[M] / 2 - ie - Z - Te - _.mainAxis
					: Y - Z - Te - _.mainAxis,
				ce = E
					? -x[M] / 2 + ie + Z + B + _.mainAxis
					: he + Z + B + _.mainAxis,
				$e = e.elements.arrow && Xs(e.elements.arrow),
				Je = $e
					? f === "y"
						? $e.clientTop || 0
						: $e.clientLeft || 0
					: 0,
				A = (P = T == null ? void 0 : T[f]) != null ? P : 0,
				O = I + ne - A - Je,
				L = I + ce - A,
				K = as(p ? ma($, O) : $, I, p ? Ro(V, L) : V);
			(m[f] = K), (R[f] = K - I);
		}
		if (l) {
			var W,
				ee = f === "x" ? ln : an,
				le = f === "x" ? Rn : Pn,
				Q = m[v],
				te = v === "y" ? "height" : "width",
				G = Q + b[ee],
				ae = Q - b[le],
				ge = [ln, an].indexOf(w) !== -1,
				me = (W = T == null ? void 0 : T[v]) != null ? W : 0,
				Se = ge ? G : Q - x[te] - k[te] - me + _.altAxis,
				Pe = ge ? Q + x[te] + k[te] - me - _.altAxis : ae,
				Ge = p && ge ? E8(Se, Q, Pe) : as(p ? Se : G, Q, p ? Pe : ae);
			(m[v] = Ge), (R[v] = Ge - Q);
		}
		e.modifiersData[r] = R;
	}
}
const oS = {
	name: "preventOverflow",
	enabled: !0,
	phase: "main",
	fn: rS,
	requiresIfExists: ["offset"],
};
function iS(t) {
	return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function sS(t) {
	return t === yn(t) || !An(t) ? Xf(t) : iS(t);
}
function lS(t) {
	var e = t.getBoundingClientRect(),
		n = Ci(e.width) / t.offsetWidth || 1,
		r = Ci(e.height) / t.offsetHeight || 1;
	return n !== 1 || r !== 1;
}
function aS(t, e, n) {
	n === void 0 && (n = !1);
	var r = An(e),
		o = An(e) && lS(e),
		i = co(e),
		s = Mi(t, o, n),
		l = { scrollLeft: 0, scrollTop: 0 },
		a = { x: 0, y: 0 };
	return (
		(r || (!r && !n)) &&
			((lr(e) !== "body" || eh(i)) && (l = sS(e)),
			An(e)
				? ((a = Mi(e, !0)), (a.x += e.clientLeft), (a.y += e.clientTop))
				: i && (a.x = Zf(i))),
		{
			x: s.left + l.scrollLeft - a.x,
			y: s.top + l.scrollTop - a.y,
			width: s.width,
			height: s.height,
		}
	);
}
function uS(t) {
	var e = new Map(),
		n = new Set(),
		r = [];
	t.forEach(function (i) {
		e.set(i.name, i);
	});
	function o(i) {
		n.add(i.name);
		var s = [].concat(i.requires || [], i.requiresIfExists || []);
		s.forEach(function (l) {
			if (!n.has(l)) {
				var a = e.get(l);
				a && o(a);
			}
		}),
			r.push(i);
	}
	return (
		t.forEach(function (i) {
			n.has(i.name) || o(i);
		}),
		r
	);
}
function cS(t) {
	var e = uS(t);
	return k8.reduce(function (n, r) {
		return n.concat(
			e.filter(function (o) {
				return o.phase === r;
			})
		);
	}, []);
}
function dS(t) {
	var e;
	return function () {
		return (
			e ||
				(e = new Promise(function (n) {
					Promise.resolve().then(function () {
						(e = void 0), n(t());
					});
				})),
			e
		);
	};
}
function fS(t) {
	var e = t.reduce(function (n, r) {
		var o = n[r.name];
		return (
			(n[r.name] = o
				? Object.assign({}, o, r, {
						options: Object.assign({}, o.options, r.options),
						data: Object.assign({}, o.data, r.data),
				  })
				: r),
			n
		);
	}, {});
	return Object.keys(e).map(function (n) {
		return e[n];
	});
}
var pm = { placement: "bottom", modifiers: [], strategy: "absolute" };
function mm() {
	for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
		e[n] = arguments[n];
	return !e.some(function (r) {
		return !(r && typeof r.getBoundingClientRect == "function");
	});
}
function hS(t) {
	t === void 0 && (t = {});
	var e = t,
		n = e.defaultModifiers,
		r = n === void 0 ? [] : n,
		o = e.defaultOptions,
		i = o === void 0 ? pm : o;
	return function (l, a, u) {
		u === void 0 && (u = i);
		var c = {
				placement: "bottom",
				orderedModifiers: [],
				options: Object.assign({}, pm, i),
				modifiersData: {},
				elements: { reference: l, popper: a },
				attributes: {},
				styles: {},
			},
			d = [],
			h = !1,
			p = {
				state: c,
				setOptions: function (w) {
					var S = typeof w == "function" ? w(c.options) : w;
					y(),
						(c.options = Object.assign({}, i, c.options, S)),
						(c.scrollParents = {
							reference: $o(l)
								? us(l)
								: l.contextElement
								? us(l.contextElement)
								: [],
							popper: us(a),
						});
					var E = cS(fS([].concat(r, c.options.modifiers)));
					return (
						(c.orderedModifiers = E.filter(function (f) {
							return f.enabled;
						})),
						g(),
						p.update()
					);
				},
				forceUpdate: function () {
					if (!h) {
						var w = c.elements,
							S = w.reference,
							E = w.popper;
						if (mm(S, E)) {
							(c.rects = {
								reference: aS(
									S,
									Xs(E),
									c.options.strategy === "fixed"
								),
								popper: Yf(E),
							}),
								(c.reset = !1),
								(c.placement = c.options.placement),
								c.orderedModifiers.forEach(function (_) {
									return (c.modifiersData[_.name] =
										Object.assign({}, _.data));
								});
							for (
								var f = 0;
								f < c.orderedModifiers.length;
								f++
							) {
								if (c.reset === !0) {
									(c.reset = !1), (f = -1);
									continue;
								}
								var v = c.orderedModifiers[f],
									m = v.fn,
									x = v.options,
									k = x === void 0 ? {} : x,
									C = v.name;
								typeof m == "function" &&
									(c =
										m({
											state: c,
											options: k,
											name: C,
											instance: p,
										}) || c);
							}
						}
					}
				},
				update: dS(function () {
					return new Promise(function (b) {
						p.forceUpdate(), b(c);
					});
				}),
				destroy: function () {
					y(), (h = !0);
				},
			};
		if (!mm(l, a)) return p;
		p.setOptions(u).then(function (b) {
			!h && u.onFirstUpdate && u.onFirstUpdate(b);
		});
		function g() {
			c.orderedModifiers.forEach(function (b) {
				var w = b.name,
					S = b.options,
					E = S === void 0 ? {} : S,
					f = b.effect;
				if (typeof f == "function") {
					var v = f({ state: c, name: w, instance: p, options: E }),
						m = function () {};
					d.push(v || m);
				}
			});
		}
		function y() {
			d.forEach(function (b) {
				return b();
			}),
				(d = []);
		}
		return p;
	};
}
var pS = [L8, tS, D8, ky, Z8, J8, oS, R8, Y8],
	Oy = hS({ defaultModifiers: pS });
const mS = {
		name: "Popover",
		inheritAttrs: !1,
		props: {
			show: { default: void 0 },
			trigger: { type: String, default: "click" },
			hoverDelay: { type: Number, default: 0 },
			leaveDelay: { type: Number, default: 0 },
			placement: { type: String, default: "bottom-start" },
			popoverClass: [String, Object, Array],
			transition: { default: null },
			hideOnBlur: { default: !0 },
		},
		emits: ["open", "close", "update:show"],
		expose: ["open", "close"],
		data() {
			return {
				showPopup: !1,
				targetWidth: null,
				pointerOverTargetOrPopup: !1,
			};
		},
		watch: {
			show(t) {
				t ? this.open() : this.close();
			},
		},
		created() {
			if (
				typeof window != "undefined" &&
				!document.getElementById("frappeui-popper-root")
			) {
				const t = document.createElement("div");
				(t.id = "frappeui-popper-root"), document.body.appendChild(t);
			}
		},
		mounted() {
			(this.listener = (t) => {
				[this.$refs.reference, this.$refs.popover].some(
					(r) => r && (t.target === r || r.contains(t.target))
				) || this.close();
			}),
				this.hideOnBlur &&
					document.addEventListener("click", this.listener),
				this.$nextTick(() => {
					this.targetWidth = this.$refs.target.clientWidth;
				});
		},
		beforeDestroy() {
			this.popper && this.popper.destroy(),
				document.removeEventListener("click", this.listener);
		},
		computed: {
			showPropPassed() {
				return this.show != null;
			},
			isOpen: {
				get() {
					return this.showPropPassed ? this.show : this.showPopup;
				},
				set(t) {
					(t = !!t),
						this.showPropPassed
							? this.$emit("update:show", t)
							: (this.showPopup = t),
						t === !1
							? this.$emit("close")
							: t === !0 && this.$emit("open");
				},
			},
			popupTransition() {
				let t = {
					default: {
						enterActiveClass: "transition duration-150 ease-out",
						enterFromClass: "translate-y-1 opacity-0",
						enterToClass: "translate-y-0 opacity-100",
						leaveActiveClass: "transition duration-150 ease-in",
						leaveFromClass: "translate-y-0 opacity-100",
						leaveToClass: "translate-y-1 opacity-0",
					},
				};
				return typeof this.transition == "string"
					? t[this.transition]
					: this.transition;
			},
		},
		methods: {
			setupPopper() {
				this.popper
					? this.updatePosition()
					: (this.popper = Oy(
							this.$refs.reference,
							this.$refs.popover,
							{ placement: this.placement }
					  ));
			},
			updatePosition() {
				this.popper && this.popper.update();
			},
			togglePopover(t) {
				t instanceof Event && (t = null),
					t == null && (t = !this.isOpen),
					(t = !!t),
					t ? this.open() : this.close();
			},
			open() {
				(this.isOpen = !0), this.$nextTick(() => this.setupPopper());
			},
			close() {
				this.isOpen = !1;
			},
			onMouseover() {
				(this.pointerOverTargetOrPopup = !0),
					this.leaveTimer &&
						(clearTimeout(this.leaveTimer),
						(this.leaveTimer = null)),
					this.trigger === "hover" &&
						(this.hoverDelay
							? (this.hoverTimer = setTimeout(() => {
									this.pointerOverTargetOrPopup &&
										this.open();
							  }, Number(this.hoverDelay) * 1e3))
							: this.open());
			},
			onMouseleave(t) {
				(this.pointerOverTargetOrPopup = !1),
					this.hoverTimer &&
						(clearTimeout(this.hoverTimer),
						(this.hoverTimer = null)),
					this.trigger === "hover" &&
						(this.leaveTimer && clearTimeout(this.leaveTimer),
						this.leaveDelay
							? (this.leaveTimer = setTimeout(() => {
									this.pointerOverTargetOrPopup ||
										this.close();
							  }, Number(this.leaveDelay) * 1e3))
							: this.pointerOverTargetOrPopup || this.close());
			},
		},
	},
	gS = { ref: "reference" },
	yS = { class: "rounded-lg border border-gray-100 bg-white shadow-xl" };
function vS(t, e, n, r, o, i) {
	return (
		j(),
		q(
			"div",
			gS,
			[
				U(
					"div",
					{
						ref: "target",
						class: we(["flex", t.$attrs.class]),
						onClick:
							e[0] ||
							(e[0] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onFocusin:
							e[1] ||
							(e[1] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onKeydown:
							e[2] ||
							(e[2] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onMouseover:
							e[3] ||
							(e[3] = (...s) =>
								i.onMouseover && i.onMouseover(...s)),
						onMouseleave:
							e[4] ||
							(e[4] = (...s) =>
								i.onMouseleave && i.onMouseleave(...s)),
					},
					[
						De(
							t.$slots,
							"target",
							Ut(
								en({
									togglePopover: i.togglePopover,
									updatePosition: i.updatePosition,
									open: i.open,
									close: i.close,
									isOpen: i.isOpen,
								})
							)
						),
					],
					34
				),
				(j(),
				Fe(bu, { to: "#frappeui-popper-root" }, [
					U(
						"div",
						{
							ref: "popover",
							class: we([
								n.popoverClass,
								"popover-container relative z-[100]",
							]),
							style: ao({
								minWidth: o.targetWidth
									? o.targetWidth + "px"
									: null,
							}),
							onMouseover:
								e[5] ||
								(e[5] = (s) =>
									(o.pointerOverTargetOrPopup = !0)),
							onMouseleave:
								e[6] ||
								(e[6] = (...s) =>
									i.onMouseleave && i.onMouseleave(...s)),
						},
						[
							be(
								Su,
								Ut(en(i.popupTransition)),
								{
									default: He(() => [
										e0(
											U(
												"div",
												null,
												[
													De(
														t.$slots,
														"body",
														Ut(
															en({
																togglePopover:
																	i.togglePopover,
																updatePosition:
																	i.updatePosition,
																open: i.open,
																close: i.close,
																isOpen: i.isOpen,
															})
														),
														() => [
															U("div", yS, [
																De(
																	t.$slots,
																	"body-main",
																	Ut(
																		en({
																			togglePopover:
																				i.togglePopover,
																			updatePosition:
																				i.updatePosition,
																			open: i.open,
																			close: i.close,
																			isOpen: i.isOpen,
																		})
																	)
																),
															]),
														]
													),
												],
												512
											),
											[[E0, i.isOpen]]
										),
									]),
									_: 3,
								},
								16
							),
						],
						38
					),
				])),
			],
			512
		)
	);
}
const Ru = je(mS, [["render", vS]]);
var Ry =
	typeof globalThis != "undefined"
		? globalThis
		: typeof window != "undefined"
		? window
		: typeof global != "undefined"
		? global
		: typeof self != "undefined"
		? self
		: {};
function Py(t) {
	return t &&
		t.__esModule &&
		Object.prototype.hasOwnProperty.call(t, "default")
		? t.default
		: t;
}
function Kj(t) {
	if (t.__esModule) return t;
	var e = t.default;
	if (typeof e == "function") {
		var n = function r() {
			return this instanceof r
				? Reflect.construct(e, arguments, this.constructor)
				: e.apply(this, arguments);
		};
		n.prototype = e.prototype;
	} else n = {};
	return (
		Object.defineProperty(n, "__esModule", { value: !0 }),
		Object.keys(t).forEach(function (r) {
			var o = Object.getOwnPropertyDescriptor(t, r);
			Object.defineProperty(
				n,
				r,
				o.get
					? o
					: {
							enumerable: !0,
							get: function () {
								return t[r];
							},
					  }
			);
		}),
		n
	);
}
var Iy = { exports: {} };
(function (t, e) {
	(function (r, o) {
		t.exports = o();
	})(typeof self != "undefined" ? self : Ry, function () {
		return (function (n) {
			var r = {};
			function o(i) {
				if (r[i]) return r[i].exports;
				var s = (r[i] = { i, l: !1, exports: {} });
				return (
					n[i].call(s.exports, s, s.exports, o), (s.l = !0), s.exports
				);
			}
			return (
				(o.m = n),
				(o.c = r),
				(o.d = function (i, s, l) {
					o.o(i, s) ||
						Object.defineProperty(i, s, {
							configurable: !1,
							enumerable: !0,
							get: l,
						});
				}),
				(o.r = function (i) {
					Object.defineProperty(i, "__esModule", { value: !0 });
				}),
				(o.n = function (i) {
					var s =
						i && i.__esModule
							? function () {
									return i.default;
							  }
							: function () {
									return i;
							  };
					return o.d(s, "a", s), s;
				}),
				(o.o = function (i, s) {
					return Object.prototype.hasOwnProperty.call(i, s);
				}),
				(o.p = ""),
				o((o.s = 0))
			);
		})({
			"./dist/icons.json": function (n) {
				n.exports = {
					activity:
						'<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>',
					airplay:
						'<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>',
					"alert-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
					"alert-octagon":
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
					"alert-triangle":
						'<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>',
					"align-center":
						'<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>',
					"align-justify":
						'<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>',
					"align-left":
						'<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>',
					"align-right":
						'<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>',
					anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>',
					aperture:
						'<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>',
					archive:
						'<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>',
					"arrow-down-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>',
					"arrow-down-left":
						'<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>',
					"arrow-down-right":
						'<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>',
					"arrow-down":
						'<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>',
					"arrow-left-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>',
					"arrow-left":
						'<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>',
					"arrow-right-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>',
					"arrow-right":
						'<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>',
					"arrow-up-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>',
					"arrow-up-left":
						'<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>',
					"arrow-up-right":
						'<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>',
					"arrow-up":
						'<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>',
					"at-sign":
						'<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>',
					award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>',
					"bar-chart-2":
						'<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>',
					"bar-chart":
						'<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>',
					"battery-charging":
						'<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>',
					battery:
						'<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>',
					"bell-off":
						'<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>',
					bluetooth:
						'<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>',
					bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>',
					"book-open":
						'<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>',
					book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>',
					bookmark:
						'<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>',
					box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					briefcase:
						'<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>',
					calendar:
						'<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>',
					"camera-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>',
					camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>',
					cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>',
					"check-circle":
						'<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>',
					"check-square":
						'<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>',
					check: '<polyline points="20 6 9 17 4 12"></polyline>',
					"chevron-down":
						'<polyline points="6 9 12 15 18 9"></polyline>',
					"chevron-left":
						'<polyline points="15 18 9 12 15 6"></polyline>',
					"chevron-right":
						'<polyline points="9 18 15 12 9 6"></polyline>',
					"chevron-up":
						'<polyline points="18 15 12 9 6 15"></polyline>',
					"chevrons-down":
						'<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>',
					"chevrons-left":
						'<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>',
					"chevrons-right":
						'<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>',
					"chevrons-up":
						'<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>',
					chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>',
					circle: '<circle cx="12" cy="12" r="10"></circle>',
					clipboard:
						'<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>',
					clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>',
					"cloud-drizzle":
						'<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
					"cloud-lightning":
						'<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>',
					"cloud-off":
						'<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					"cloud-rain":
						'<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
					"cloud-snow":
						'<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>',
					cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>',
					code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>',
					codepen:
						'<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>',
					codesandbox:
						'<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>',
					columns:
						'<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>',
					command:
						'<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>',
					compass:
						'<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>',
					copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>',
					"corner-down-left":
						'<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>',
					"corner-down-right":
						'<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>',
					"corner-left-down":
						'<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>',
					"corner-left-up":
						'<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>',
					"corner-right-down":
						'<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>',
					"corner-right-up":
						'<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>',
					"corner-up-left":
						'<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>',
					"corner-up-right":
						'<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>',
					cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>',
					"credit-card":
						'<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>',
					crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>',
					crosshair:
						'<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>',
					database:
						'<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>',
					delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>',
					disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>',
					"divide-circle":
						'<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>',
					"divide-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>',
					divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>',
					"dollar-sign":
						'<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>',
					"download-cloud":
						'<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>',
					download:
						'<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>',
					dribbble:
						'<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>',
					droplet:
						'<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>',
					"edit-2":
						'<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>',
					"edit-3":
						'<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>',
					edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>',
					"external-link":
						'<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>',
					"eye-off":
						'<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>',
					facebook:
						'<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>',
					"fast-forward":
						'<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>',
					feather:
						'<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>',
					figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>',
					"file-minus":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>',
					"file-plus":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>',
					"file-text":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>',
					file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>',
					film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>',
					filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>',
					flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>',
					"folder-minus":
						'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>',
					"folder-plus":
						'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>',
					folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>',
					framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>',
					frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>',
					"git-branch":
						'<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>',
					"git-commit":
						'<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>',
					"git-merge":
						'<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>',
					"git-pull-request":
						'<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>',
					github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>',
					gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>',
					globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>',
					grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>',
					"hard-drive":
						'<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>',
					hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>',
					headphones:
						'<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>',
					heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>',
					"help-circle":
						'<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>',
					hexagon:
						'<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>',
					home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>',
					image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>',
					inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>',
					info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>',
					instagram:
						'<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>',
					italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>',
					key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>',
					layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>',
					layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>',
					"life-buoy":
						'<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>',
					"link-2":
						'<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>',
					link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>',
					linkedin:
						'<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>',
					list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
					loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>',
					lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>',
					"log-in":
						'<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>',
					"log-out":
						'<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>',
					mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>',
					"map-pin":
						'<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>',
					map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>',
					"maximize-2":
						'<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
					maximize:
						'<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>',
					meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>',
					"message-circle":
						'<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>',
					"message-square":
						'<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>',
					"mic-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
					mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
					"minimize-2":
						'<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
					minimize:
						'<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>',
					"minus-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>',
					"minus-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>',
					minus: '<line x1="5" y1="12" x2="19" y2="12"></line>',
					monitor:
						'<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>',
					moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>',
					"more-horizontal":
						'<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>',
					"more-vertical":
						'<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>',
					"mouse-pointer":
						'<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>',
					move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>',
					music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>',
					"navigation-2":
						'<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>',
					navigation:
						'<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>',
					octagon:
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>',
					package:
						'<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					paperclip:
						'<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>',
					"pause-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>',
					pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>',
					"pen-tool":
						'<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>',
					percent:
						'<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>',
					"phone-call":
						'<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-forwarded":
						'<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-incoming":
						'<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-missed":
						'<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-off":
						'<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>',
					"phone-outgoing":
						'<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"pie-chart":
						'<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>',
					"play-circle":
						'<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>',
					play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>',
					"plus-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
					"plus-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
					plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>',
					pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>',
					power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>',
					printer:
						'<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>',
					radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>',
					"refresh-ccw":
						'<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>',
					"refresh-cw":
						'<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>',
					repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>',
					rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>',
					"rotate-ccw":
						'<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>',
					"rotate-cw":
						'<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>',
					rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>',
					save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>',
					scissors:
						'<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>',
					search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>',
					send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>',
					server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>',
					settings:
						'<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>',
					"share-2":
						'<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>',
					share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>',
					"shield-off":
						'<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>',
					"shopping-bag":
						'<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>',
					"shopping-cart":
						'<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>',
					shuffle:
						'<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>',
					sidebar:
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>',
					"skip-back":
						'<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>',
					"skip-forward":
						'<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>',
					slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>',
					slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>',
					sliders:
						'<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>',
					smartphone:
						'<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
					smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					speaker:
						'<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>',
					square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>',
					star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>',
					"stop-circle":
						'<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>',
					sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>',
					sunrise:
						'<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>',
					sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>',
					table: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>',
					tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
					tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>',
					target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>',
					terminal:
						'<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>',
					thermometer:
						'<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>',
					"thumbs-down":
						'<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>',
					"thumbs-up":
						'<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>',
					"toggle-left":
						'<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>',
					"toggle-right":
						'<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>',
					tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>',
					"trash-2":
						'<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>',
					trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>',
					trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>',
					"trending-down":
						'<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>',
					"trending-up":
						'<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>',
					triangle:
						'<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>',
					truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>',
					tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>',
					twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zM11 11V7M16 11V7"></path>',
					twitter:
						'<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>',
					type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>',
					umbrella:
						'<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>',
					underline:
						'<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>',
					unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>',
					"upload-cloud":
						'<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>',
					upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>',
					"user-check":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>',
					"user-minus":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>',
					"user-plus":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>',
					"user-x":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>',
					user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>',
					users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>',
					"video-off":
						'<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>',
					voicemail:
						'<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>',
					"volume-1":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
					"volume-2":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
					"volume-x":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>',
					volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>',
					watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>',
					"wifi-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
					wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
					wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>',
					"x-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
					"x-octagon":
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
					"x-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>',
					x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>',
					youtube:
						'<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>',
					"zap-off":
						'<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>',
					zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>',
					"zoom-in":
						'<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
					"zoom-out":
						'<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
				};
			},
			"./node_modules/classnames/dedupe.js": function (n, r, o) {
				var i, s;
				/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/ (function () {
					var l = (function () {
						function a() {}
						a.prototype = Object.create(null);
						function u(w, S) {
							for (var E = S.length, f = 0; f < E; ++f)
								y(w, S[f]);
						}
						var c = {}.hasOwnProperty;
						function d(w, S) {
							w[S] = !0;
						}
						function h(w, S) {
							for (var E in S) c.call(S, E) && (w[E] = !!S[E]);
						}
						var p = /\s+/;
						function g(w, S) {
							for (
								var E = S.split(p), f = E.length, v = 0;
								v < f;
								++v
							)
								w[E[v]] = !0;
						}
						function y(w, S) {
							if (S) {
								var E = typeof S;
								E === "string"
									? g(w, S)
									: Array.isArray(S)
									? u(w, S)
									: E === "object"
									? h(w, S)
									: E === "number" && d(w, S);
							}
						}
						function b() {
							for (
								var w = arguments.length, S = Array(w), E = 0;
								E < w;
								E++
							)
								S[E] = arguments[E];
							var f = new a();
							u(f, S);
							var v = [];
							for (var m in f) f[m] && v.push(m);
							return v.join(" ");
						}
						return b;
					})();
					typeof n != "undefined" && n.exports
						? (n.exports = l)
						: ((i = []),
						  (s = function () {
								return l;
						  }.apply(r, i)),
						  s !== void 0 && (n.exports = s));
				})();
			},
			"./node_modules/core-js/es/array/from.js": function (n, r, o) {
				o("./node_modules/core-js/modules/es.string.iterator.js"),
					o("./node_modules/core-js/modules/es.array.from.js");
				var i = o("./node_modules/core-js/internals/path.js");
				n.exports = i.Array.from;
			},
			"./node_modules/core-js/internals/a-function.js": function (n, r) {
				n.exports = function (o) {
					if (typeof o != "function")
						throw TypeError(String(o) + " is not a function");
					return o;
				};
			},
			"./node_modules/core-js/internals/an-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/is-object.js");
				n.exports = function (s) {
					if (!i(s)) throw TypeError(String(s) + " is not an object");
					return s;
				};
			},
			"./node_modules/core-js/internals/array-from.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/bind-context.js"),
					s = o("./node_modules/core-js/internals/to-object.js"),
					l = o(
						"./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
					),
					a = o(
						"./node_modules/core-js/internals/is-array-iterator-method.js"
					),
					u = o("./node_modules/core-js/internals/to-length.js"),
					c = o(
						"./node_modules/core-js/internals/create-property.js"
					),
					d = o(
						"./node_modules/core-js/internals/get-iterator-method.js"
					);
				n.exports = function (p) {
					var g = s(p),
						y = typeof this == "function" ? this : Array,
						b = arguments.length,
						w = b > 1 ? arguments[1] : void 0,
						S = w !== void 0,
						E = 0,
						f = d(g),
						v,
						m,
						x,
						k;
					if (
						(S && (w = i(w, b > 2 ? arguments[2] : void 0, 2)),
						f != null && !(y == Array && a(f)))
					)
						for (
							k = f.call(g), m = new y();
							!(x = k.next()).done;
							E++
						)
							c(m, E, S ? l(k, w, [x.value, E], !0) : x.value);
					else
						for (v = u(g.length), m = new y(v); v > E; E++)
							c(m, E, S ? w(g[E], E) : g[E]);
					return (m.length = E), m;
				};
			},
			"./node_modules/core-js/internals/array-includes.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/to-indexed-object.js"
					),
					s = o("./node_modules/core-js/internals/to-length.js"),
					l = o(
						"./node_modules/core-js/internals/to-absolute-index.js"
					);
				n.exports = function (a) {
					return function (u, c, d) {
						var h = i(u),
							p = s(h.length),
							g = l(d, p),
							y;
						if (a && c != c) {
							for (; p > g; )
								if (((y = h[g++]), y != y)) return !0;
						} else
							for (; p > g; g++)
								if ((a || g in h) && h[g] === c)
									return a || g || 0;
						return !a && -1;
					};
				};
			},
			"./node_modules/core-js/internals/bind-context.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/a-function.js");
				n.exports = function (s, l, a) {
					if ((i(s), l === void 0)) return s;
					switch (a) {
						case 0:
							return function () {
								return s.call(l);
							};
						case 1:
							return function (u) {
								return s.call(l, u);
							};
						case 2:
							return function (u, c) {
								return s.call(l, u, c);
							};
						case 3:
							return function (u, c, d) {
								return s.call(l, u, c, d);
							};
					}
					return function () {
						return s.apply(l, arguments);
					};
				};
			},
			"./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/an-object.js");
					n.exports = function (s, l, a, u) {
						try {
							return u ? l(i(a)[0], a[1]) : l(a);
						} catch (d) {
							var c = s.return;
							throw (c !== void 0 && i(c.call(s)), d);
						}
					};
				},
			"./node_modules/core-js/internals/check-correctness-of-iteration.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						s = i("iterator"),
						l = !1;
					try {
						var a = 0,
							u = {
								next: function () {
									return { done: !!a++ };
								},
								return: function () {
									l = !0;
								},
							};
						(u[s] = function () {
							return this;
						}),
							Array.from(u, function () {
								throw 2;
							});
					} catch (c) {}
					n.exports = function (c, d) {
						if (!d && !l) return !1;
						var h = !1;
						try {
							var p = {};
							(p[s] = function () {
								return {
									next: function () {
										return { done: (h = !0) };
									},
								};
							}),
								c(p);
						} catch (g) {}
						return h;
					};
				},
			"./node_modules/core-js/internals/classof-raw.js": function (n, r) {
				var o = {}.toString;
				n.exports = function (i) {
					return o.call(i).slice(8, -1);
				};
			},
			"./node_modules/core-js/internals/classof.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/classof-raw.js"),
					s = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					l = s("toStringTag"),
					a =
						i(
							(function () {
								return arguments;
							})()
						) == "Arguments",
					u = function (c, d) {
						try {
							return c[d];
						} catch (h) {}
					};
				n.exports = function (c) {
					var d, h, p;
					return c === void 0
						? "Undefined"
						: c === null
						? "Null"
						: typeof (h = u((d = Object(c)), l)) == "string"
						? h
						: a
						? i(d)
						: (p = i(d)) == "Object" &&
						  typeof d.callee == "function"
						? "Arguments"
						: p;
				};
			},
			"./node_modules/core-js/internals/copy-constructor-properties.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o("./node_modules/core-js/internals/own-keys.js"),
						l = o(
							"./node_modules/core-js/internals/object-get-own-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/object-define-property.js"
						);
					n.exports = function (u, c) {
						for (
							var d = s(c), h = a.f, p = l.f, g = 0;
							g < d.length;
							g++
						) {
							var y = d[g];
							i(u, y) || h(u, y, p(c, y));
						}
					};
				},
			"./node_modules/core-js/internals/correct-prototype-getter.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/fails.js");
					n.exports = !i(function () {
						function s() {}
						return (
							(s.prototype.constructor = null),
							Object.getPrototypeOf(new s()) !== s.prototype
						);
					});
				},
			"./node_modules/core-js/internals/create-iterator-constructor.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/iterators-core.js"
						).IteratorPrototype,
						s = o(
							"./node_modules/core-js/internals/object-create.js"
						),
						l = o(
							"./node_modules/core-js/internals/create-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/set-to-string-tag.js"
						),
						u = o("./node_modules/core-js/internals/iterators.js"),
						c = function () {
							return this;
						};
					n.exports = function (d, h, p) {
						var g = h + " Iterator";
						return (
							(d.prototype = s(i, { next: l(1, p) })),
							a(d, g, !1, !0),
							(u[g] = c),
							d
						);
					};
				},
			"./node_modules/core-js/internals/create-property-descriptor.js":
				function (n, r) {
					n.exports = function (o, i) {
						return {
							enumerable: !(o & 1),
							configurable: !(o & 2),
							writable: !(o & 4),
							value: i,
						};
					};
				},
			"./node_modules/core-js/internals/create-property.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-primitive.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-property.js"
					),
					l = o(
						"./node_modules/core-js/internals/create-property-descriptor.js"
					);
				n.exports = function (a, u, c) {
					var d = i(u);
					d in a ? s.f(a, d, l(0, c)) : (a[d] = c);
				};
			},
			"./node_modules/core-js/internals/define-iterator.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/export.js"),
					s = o(
						"./node_modules/core-js/internals/create-iterator-constructor.js"
					),
					l = o(
						"./node_modules/core-js/internals/object-get-prototype-of.js"
					),
					a = o(
						"./node_modules/core-js/internals/object-set-prototype-of.js"
					),
					u = o(
						"./node_modules/core-js/internals/set-to-string-tag.js"
					),
					c = o("./node_modules/core-js/internals/hide.js"),
					d = o("./node_modules/core-js/internals/redefine.js"),
					h = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					p = o("./node_modules/core-js/internals/is-pure.js"),
					g = o("./node_modules/core-js/internals/iterators.js"),
					y = o("./node_modules/core-js/internals/iterators-core.js"),
					b = y.IteratorPrototype,
					w = y.BUGGY_SAFARI_ITERATORS,
					S = h("iterator"),
					E = "keys",
					f = "values",
					v = "entries",
					m = function () {
						return this;
					};
				n.exports = function (x, k, C, _, T, R, P) {
					s(C, k, _);
					var N = function (Ce) {
							if (Ce === T && V) return V;
							if (!w && Ce in I) return I[Ce];
							switch (Ce) {
								case E:
									return function () {
										return new C(this, Ce);
									};
								case f:
									return function () {
										return new C(this, Ce);
									};
								case v:
									return function () {
										return new C(this, Ce);
									};
							}
							return function () {
								return new C(this);
							};
						},
						D = k + " Iterator",
						M = !1,
						I = x.prototype,
						$ = I[S] || I["@@iterator"] || (T && I[T]),
						V = (!w && $) || N(T),
						ie = (k == "Array" && I.entries) || $,
						Y,
						he,
						Le;
					if (
						(ie &&
							((Y = l(ie.call(new x()))),
							b !== Object.prototype &&
								Y.next &&
								(!p &&
									l(Y) !== b &&
									(a
										? a(Y, b)
										: typeof Y[S] != "function" &&
										  c(Y, S, m)),
								u(Y, D, !0, !0),
								p && (g[D] = m))),
						T == f &&
							$ &&
							$.name !== f &&
							((M = !0),
							(V = function () {
								return $.call(this);
							})),
						(!p || P) && I[S] !== V && c(I, S, V),
						(g[k] = V),
						T)
					)
						if (
							((he = {
								values: N(f),
								keys: R ? V : N(E),
								entries: N(v),
							}),
							P)
						)
							for (Le in he)
								(w || M || !(Le in I)) && d(I, Le, he[Le]);
						else i({ target: k, proto: !0, forced: w || M }, he);
					return he;
				};
			},
			"./node_modules/core-js/internals/descriptors.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js");
				n.exports = !i(function () {
					return (
						Object.defineProperty({}, "a", {
							get: function () {
								return 7;
							},
						}).a != 7
					);
				});
			},
			"./node_modules/core-js/internals/document-create-element.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/global.js"),
						s = o("./node_modules/core-js/internals/is-object.js"),
						l = i.document,
						a = s(l) && s(l.createElement);
					n.exports = function (u) {
						return a ? l.createElement(u) : {};
					};
				},
			"./node_modules/core-js/internals/enum-bug-keys.js": function (
				n,
				r
			) {
				n.exports = [
					"constructor",
					"hasOwnProperty",
					"isPrototypeOf",
					"propertyIsEnumerable",
					"toLocaleString",
					"toString",
					"valueOf",
				];
			},
			"./node_modules/core-js/internals/export.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/object-get-own-property-descriptor.js"
					).f,
					l = o("./node_modules/core-js/internals/hide.js"),
					a = o("./node_modules/core-js/internals/redefine.js"),
					u = o("./node_modules/core-js/internals/set-global.js"),
					c = o(
						"./node_modules/core-js/internals/copy-constructor-properties.js"
					),
					d = o("./node_modules/core-js/internals/is-forced.js");
				n.exports = function (h, p) {
					var g = h.target,
						y = h.global,
						b = h.stat,
						w,
						S,
						E,
						f,
						v,
						m;
					if (
						(y
							? (S = i)
							: b
							? (S = i[g] || u(g, {}))
							: (S = (i[g] || {}).prototype),
						S)
					)
						for (E in p) {
							if (
								((v = p[E]),
								h.noTargetGet
									? ((m = s(S, E)), (f = m && m.value))
									: (f = S[E]),
								(w = d(
									y ? E : g + (b ? "." : "#") + E,
									h.forced
								)),
								!w && f !== void 0)
							) {
								if (typeof v == typeof f) continue;
								c(v, f);
							}
							(h.sham || (f && f.sham)) && l(v, "sham", !0),
								a(S, E, v, h);
						}
				};
			},
			"./node_modules/core-js/internals/fails.js": function (n, r) {
				n.exports = function (o) {
					try {
						return !!o();
					} catch (i) {
						return !0;
					}
				};
			},
			"./node_modules/core-js/internals/function-to-string.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/shared.js");
				n.exports = i("native-function-to-string", Function.toString);
			},
			"./node_modules/core-js/internals/get-iterator-method.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/classof.js"),
						s = o("./node_modules/core-js/internals/iterators.js"),
						l = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						a = l("iterator");
					n.exports = function (u) {
						if (u != null)
							return u[a] || u["@@iterator"] || s[i(u)];
					};
				},
			"./node_modules/core-js/internals/global.js": function (n, r, o) {
				(function (i) {
					var s = "object",
						l = function (a) {
							return a && a.Math == Math && a;
						};
					n.exports =
						l(typeof globalThis == s && globalThis) ||
						l(typeof window == s && window) ||
						l(typeof self == s && self) ||
						l(typeof i == s && i) ||
						Function("return this")();
				}.call(this, o("./node_modules/webpack/buildin/global.js")));
			},
			"./node_modules/core-js/internals/has.js": function (n, r) {
				var o = {}.hasOwnProperty;
				n.exports = function (i, s) {
					return o.call(i, s);
				};
			},
			"./node_modules/core-js/internals/hidden-keys.js": function (n, r) {
				n.exports = {};
			},
			"./node_modules/core-js/internals/hide.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/descriptors.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-property.js"
					),
					l = o(
						"./node_modules/core-js/internals/create-property-descriptor.js"
					);
				n.exports = i
					? function (a, u, c) {
							return s.f(a, u, l(1, c));
					  }
					: function (a, u, c) {
							return (a[u] = c), a;
					  };
			},
			"./node_modules/core-js/internals/html.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = i.document;
				n.exports = s && s.documentElement;
			},
			"./node_modules/core-js/internals/ie8-dom-define.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/descriptors.js"),
					s = o("./node_modules/core-js/internals/fails.js"),
					l = o(
						"./node_modules/core-js/internals/document-create-element.js"
					);
				n.exports =
					!i &&
					!s(function () {
						return (
							Object.defineProperty(l("div"), "a", {
								get: function () {
									return 7;
								},
							}).a != 7
						);
					});
			},
			"./node_modules/core-js/internals/indexed-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js"),
					s = o("./node_modules/core-js/internals/classof-raw.js"),
					l = "".split;
				n.exports = i(function () {
					return !Object("z").propertyIsEnumerable(0);
				})
					? function (a) {
							return s(a) == "String" ? l.call(a, "") : Object(a);
					  }
					: Object;
			},
			"./node_modules/core-js/internals/internal-state.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/native-weak-map.js"
					),
					s = o("./node_modules/core-js/internals/global.js"),
					l = o("./node_modules/core-js/internals/is-object.js"),
					a = o("./node_modules/core-js/internals/hide.js"),
					u = o("./node_modules/core-js/internals/has.js"),
					c = o("./node_modules/core-js/internals/shared-key.js"),
					d = o("./node_modules/core-js/internals/hidden-keys.js"),
					h = s.WeakMap,
					p,
					g,
					y,
					b = function (x) {
						return y(x) ? g(x) : p(x, {});
					},
					w = function (x) {
						return function (k) {
							var C;
							if (!l(k) || (C = g(k)).type !== x)
								throw TypeError(
									"Incompatible receiver, " + x + " required"
								);
							return C;
						};
					};
				if (i) {
					var S = new h(),
						E = S.get,
						f = S.has,
						v = S.set;
					(p = function (x, k) {
						return v.call(S, x, k), k;
					}),
						(g = function (x) {
							return E.call(S, x) || {};
						}),
						(y = function (x) {
							return f.call(S, x);
						});
				} else {
					var m = c("state");
					(d[m] = !0),
						(p = function (x, k) {
							return a(x, m, k), k;
						}),
						(g = function (x) {
							return u(x, m) ? x[m] : {};
						}),
						(y = function (x) {
							return u(x, m);
						});
				}
				n.exports = {
					set: p,
					get: g,
					has: y,
					enforce: b,
					getterFor: w,
				};
			},
			"./node_modules/core-js/internals/is-array-iterator-method.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						s = o("./node_modules/core-js/internals/iterators.js"),
						l = i("iterator"),
						a = Array.prototype;
					n.exports = function (u) {
						return u !== void 0 && (s.Array === u || a[l] === u);
					};
				},
			"./node_modules/core-js/internals/is-forced.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js"),
					s = /#|\.prototype\./,
					l = function (h, p) {
						var g = u[a(h)];
						return g == d
							? !0
							: g == c
							? !1
							: typeof p == "function"
							? i(p)
							: !!p;
					},
					a = (l.normalize = function (h) {
						return String(h).replace(s, ".").toLowerCase();
					}),
					u = (l.data = {}),
					c = (l.NATIVE = "N"),
					d = (l.POLYFILL = "P");
				n.exports = l;
			},
			"./node_modules/core-js/internals/is-object.js": function (n, r) {
				n.exports = function (o) {
					return typeof o == "object"
						? o !== null
						: typeof o == "function";
				};
			},
			"./node_modules/core-js/internals/is-pure.js": function (n, r) {
				n.exports = !1;
			},
			"./node_modules/core-js/internals/iterators-core.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-get-prototype-of.js"
					),
					s = o("./node_modules/core-js/internals/hide.js"),
					l = o("./node_modules/core-js/internals/has.js"),
					a = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					u = o("./node_modules/core-js/internals/is-pure.js"),
					c = a("iterator"),
					d = !1,
					h = function () {
						return this;
					},
					p,
					g,
					y;
				[].keys &&
					((y = [].keys()),
					"next" in y
						? ((g = i(i(y))), g !== Object.prototype && (p = g))
						: (d = !0)),
					p == null && (p = {}),
					!u && !l(p, c) && s(p, c, h),
					(n.exports = {
						IteratorPrototype: p,
						BUGGY_SAFARI_ITERATORS: d,
					});
			},
			"./node_modules/core-js/internals/iterators.js": function (n, r) {
				n.exports = {};
			},
			"./node_modules/core-js/internals/native-symbol.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js");
				n.exports =
					!!Object.getOwnPropertySymbols &&
					!i(function () {
						return !String(Symbol());
					});
			},
			"./node_modules/core-js/internals/native-weak-map.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/function-to-string.js"
					),
					l = i.WeakMap;
				n.exports =
					typeof l == "function" && /native code/.test(s.call(l));
			},
			"./node_modules/core-js/internals/object-create.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/an-object.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-properties.js"
					),
					l = o("./node_modules/core-js/internals/enum-bug-keys.js"),
					a = o("./node_modules/core-js/internals/hidden-keys.js"),
					u = o("./node_modules/core-js/internals/html.js"),
					c = o(
						"./node_modules/core-js/internals/document-create-element.js"
					),
					d = o("./node_modules/core-js/internals/shared-key.js"),
					h = d("IE_PROTO"),
					p = "prototype",
					g = function () {},
					y = function () {
						var b = c("iframe"),
							w = l.length,
							S = "<",
							E = "script",
							f = ">",
							v = "java" + E + ":",
							m;
						for (
							b.style.display = "none",
								u.appendChild(b),
								b.src = String(v),
								m = b.contentWindow.document,
								m.open(),
								m.write(
									S +
										E +
										f +
										"document.F=Object" +
										S +
										"/" +
										E +
										f
								),
								m.close(),
								y = m.F;
							w--;

						)
							delete y[p][l[w]];
						return y();
					};
				(n.exports =
					Object.create ||
					function (w, S) {
						var E;
						return (
							w !== null
								? ((g[p] = i(w)),
								  (E = new g()),
								  (g[p] = null),
								  (E[h] = w))
								: (E = y()),
							S === void 0 ? E : s(E, S)
						);
					}),
					(a[h] = !0);
			},
			"./node_modules/core-js/internals/object-define-properties.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/object-define-property.js"
						),
						l = o("./node_modules/core-js/internals/an-object.js"),
						a = o(
							"./node_modules/core-js/internals/object-keys.js"
						);
					n.exports = i
						? Object.defineProperties
						: function (c, d) {
								l(c);
								for (
									var h = a(d), p = h.length, g = 0, y;
									p > g;

								)
									s.f(c, (y = h[g++]), d[y]);
								return c;
						  };
				},
			"./node_modules/core-js/internals/object-define-property.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/ie8-dom-define.js"
						),
						l = o("./node_modules/core-js/internals/an-object.js"),
						a = o(
							"./node_modules/core-js/internals/to-primitive.js"
						),
						u = Object.defineProperty;
					r.f = i
						? u
						: function (d, h, p) {
								if ((l(d), (h = a(h, !0)), l(p), s))
									try {
										return u(d, h, p);
									} catch (g) {}
								if ("get" in p || "set" in p)
									throw TypeError("Accessors not supported");
								return "value" in p && (d[h] = p.value), d;
						  };
				},
			"./node_modules/core-js/internals/object-get-own-property-descriptor.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/object-property-is-enumerable.js"
						),
						l = o(
							"./node_modules/core-js/internals/create-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/to-indexed-object.js"
						),
						u = o(
							"./node_modules/core-js/internals/to-primitive.js"
						),
						c = o("./node_modules/core-js/internals/has.js"),
						d = o(
							"./node_modules/core-js/internals/ie8-dom-define.js"
						),
						h = Object.getOwnPropertyDescriptor;
					r.f = i
						? h
						: function (g, y) {
								if (((g = a(g)), (y = u(y, !0)), d))
									try {
										return h(g, y);
									} catch (b) {}
								if (c(g, y)) return l(!s.f.call(g, y), g[y]);
						  };
				},
			"./node_modules/core-js/internals/object-get-own-property-names.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/object-keys-internal.js"
						),
						s = o(
							"./node_modules/core-js/internals/enum-bug-keys.js"
						),
						l = s.concat("length", "prototype");
					r.f =
						Object.getOwnPropertyNames ||
						function (u) {
							return i(u, l);
						};
				},
			"./node_modules/core-js/internals/object-get-own-property-symbols.js":
				function (n, r) {
					r.f = Object.getOwnPropertySymbols;
				},
			"./node_modules/core-js/internals/object-get-prototype-of.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o("./node_modules/core-js/internals/to-object.js"),
						l = o("./node_modules/core-js/internals/shared-key.js"),
						a = o(
							"./node_modules/core-js/internals/correct-prototype-getter.js"
						),
						u = l("IE_PROTO"),
						c = Object.prototype;
					n.exports = a
						? Object.getPrototypeOf
						: function (d) {
								return (
									(d = s(d)),
									i(d, u)
										? d[u]
										: typeof d.constructor == "function" &&
										  d instanceof d.constructor
										? d.constructor.prototype
										: d instanceof Object
										? c
										: null
								);
						  };
				},
			"./node_modules/core-js/internals/object-keys-internal.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o(
							"./node_modules/core-js/internals/to-indexed-object.js"
						),
						l = o(
							"./node_modules/core-js/internals/array-includes.js"
						),
						a = o(
							"./node_modules/core-js/internals/hidden-keys.js"
						),
						u = l(!1);
					n.exports = function (c, d) {
						var h = s(c),
							p = 0,
							g = [],
							y;
						for (y in h) !i(a, y) && i(h, y) && g.push(y);
						for (; d.length > p; )
							i(h, (y = d[p++])) && (~u(g, y) || g.push(y));
						return g;
					};
				},
			"./node_modules/core-js/internals/object-keys.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-keys-internal.js"
					),
					s = o("./node_modules/core-js/internals/enum-bug-keys.js");
				n.exports =
					Object.keys ||
					function (a) {
						return i(a, s);
					};
			},
			"./node_modules/core-js/internals/object-property-is-enumerable.js":
				function (n, r, o) {
					var i = {}.propertyIsEnumerable,
						s = Object.getOwnPropertyDescriptor,
						l = s && !i.call({ 1: 2 }, 1);
					r.f = l
						? function (u) {
								var c = s(this, u);
								return !!c && c.enumerable;
						  }
						: i;
				},
			"./node_modules/core-js/internals/object-set-prototype-of.js":
				function (n, r, o) {
					var i = o(
						"./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
					);
					n.exports =
						Object.setPrototypeOf ||
						("__proto__" in {}
							? (function () {
									var s = !1,
										l = {},
										a;
									try {
										(a = Object.getOwnPropertyDescriptor(
											Object.prototype,
											"__proto__"
										).set),
											a.call(l, []),
											(s = l instanceof Array);
									} catch (u) {}
									return function (c, d) {
										return (
											i(c, d),
											s
												? a.call(c, d)
												: (c.__proto__ = d),
											c
										);
									};
							  })()
							: void 0);
				},
			"./node_modules/core-js/internals/own-keys.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/object-get-own-property-names.js"
					),
					l = o(
						"./node_modules/core-js/internals/object-get-own-property-symbols.js"
					),
					a = o("./node_modules/core-js/internals/an-object.js"),
					u = i.Reflect;
				n.exports =
					(u && u.ownKeys) ||
					function (d) {
						var h = s.f(a(d)),
							p = l.f;
						return p ? h.concat(p(d)) : h;
					};
			},
			"./node_modules/core-js/internals/path.js": function (n, r, o) {
				n.exports = o("./node_modules/core-js/internals/global.js");
			},
			"./node_modules/core-js/internals/redefine.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/shared.js"),
					l = o("./node_modules/core-js/internals/hide.js"),
					a = o("./node_modules/core-js/internals/has.js"),
					u = o("./node_modules/core-js/internals/set-global.js"),
					c = o(
						"./node_modules/core-js/internals/function-to-string.js"
					),
					d = o("./node_modules/core-js/internals/internal-state.js"),
					h = d.get,
					p = d.enforce,
					g = String(c).split("toString");
				s("inspectSource", function (y) {
					return c.call(y);
				}),
					(n.exports = function (y, b, w, S) {
						var E = S ? !!S.unsafe : !1,
							f = S ? !!S.enumerable : !1,
							v = S ? !!S.noTargetGet : !1;
						if (
							(typeof w == "function" &&
								(typeof b == "string" &&
									!a(w, "name") &&
									l(w, "name", b),
								(p(w).source = g.join(
									typeof b == "string" ? b : ""
								))),
							y === i)
						) {
							f ? (y[b] = w) : u(b, w);
							return;
						} else E ? !v && y[b] && (f = !0) : delete y[b];
						f ? (y[b] = w) : l(y, b, w);
					})(Function.prototype, "toString", function () {
						return (
							(typeof this == "function" && h(this).source) ||
							c.call(this)
						);
					});
			},
			"./node_modules/core-js/internals/require-object-coercible.js":
				function (n, r) {
					n.exports = function (o) {
						if (o == null)
							throw TypeError("Can't call method on " + o);
						return o;
					};
				},
			"./node_modules/core-js/internals/set-global.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/hide.js");
				n.exports = function (l, a) {
					try {
						s(i, l, a);
					} catch (u) {
						i[l] = a;
					}
					return a;
				};
			},
			"./node_modules/core-js/internals/set-to-string-tag.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-define-property.js"
					).f,
					s = o("./node_modules/core-js/internals/has.js"),
					l = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					a = l("toStringTag");
				n.exports = function (u, c, d) {
					u &&
						!s((u = d ? u : u.prototype), a) &&
						i(u, a, { configurable: !0, value: c });
				};
			},
			"./node_modules/core-js/internals/shared-key.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/shared.js"),
					s = o("./node_modules/core-js/internals/uid.js"),
					l = i("keys");
				n.exports = function (a) {
					return l[a] || (l[a] = s(a));
				};
			},
			"./node_modules/core-js/internals/shared.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/set-global.js"),
					l = o("./node_modules/core-js/internals/is-pure.js"),
					a = "__core-js_shared__",
					u = i[a] || s(a, {});
				(n.exports = function (c, d) {
					return u[c] || (u[c] = d !== void 0 ? d : {});
				})("versions", []).push({
					version: "3.1.3",
					mode: l ? "pure" : "global",
					copyright: " 2019 Denis Pushkarev (zloirock.ru)",
				});
			},
			"./node_modules/core-js/internals/string-at.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = o(
						"./node_modules/core-js/internals/require-object-coercible.js"
					);
				n.exports = function (l, a, u) {
					var c = String(s(l)),
						d = i(a),
						h = c.length,
						p,
						g;
					return d < 0 || d >= h
						? u
							? ""
							: void 0
						: ((p = c.charCodeAt(d)),
						  p < 55296 ||
						  p > 56319 ||
						  d + 1 === h ||
						  (g = c.charCodeAt(d + 1)) < 56320 ||
						  g > 57343
								? u
									? c.charAt(d)
									: p
								: u
								? c.slice(d, d + 2)
								: ((p - 55296) << 10) + (g - 56320) + 65536);
				};
			},
			"./node_modules/core-js/internals/to-absolute-index.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = Math.max,
					l = Math.min;
				n.exports = function (a, u) {
					var c = i(a);
					return c < 0 ? s(c + u, 0) : l(c, u);
				};
			},
			"./node_modules/core-js/internals/to-indexed-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/indexed-object.js"),
					s = o(
						"./node_modules/core-js/internals/require-object-coercible.js"
					);
				n.exports = function (l) {
					return i(s(l));
				};
			},
			"./node_modules/core-js/internals/to-integer.js": function (n, r) {
				var o = Math.ceil,
					i = Math.floor;
				n.exports = function (s) {
					return isNaN((s = +s)) ? 0 : (s > 0 ? i : o)(s);
				};
			},
			"./node_modules/core-js/internals/to-length.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = Math.min;
				n.exports = function (l) {
					return l > 0 ? s(i(l), 9007199254740991) : 0;
				};
			},
			"./node_modules/core-js/internals/to-object.js": function (
				n,
				r,
				o
			) {
				var i = o(
					"./node_modules/core-js/internals/require-object-coercible.js"
				);
				n.exports = function (s) {
					return Object(i(s));
				};
			},
			"./node_modules/core-js/internals/to-primitive.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/is-object.js");
				n.exports = function (s, l) {
					if (!i(s)) return s;
					var a, u;
					if (
						(l &&
							typeof (a = s.toString) == "function" &&
							!i((u = a.call(s)))) ||
						(typeof (a = s.valueOf) == "function" &&
							!i((u = a.call(s)))) ||
						(!l &&
							typeof (a = s.toString) == "function" &&
							!i((u = a.call(s))))
					)
						return u;
					throw TypeError("Can't convert object to primitive value");
				};
			},
			"./node_modules/core-js/internals/uid.js": function (n, r) {
				var o = 0,
					i = Math.random();
				n.exports = function (s) {
					return "Symbol(".concat(
						s === void 0 ? "" : s,
						")_",
						(++o + i).toString(36)
					);
				};
			},
			"./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/is-object.js"),
						s = o("./node_modules/core-js/internals/an-object.js");
					n.exports = function (l, a) {
						if ((s(l), !i(a) && a !== null))
							throw TypeError(
								"Can't set " + String(a) + " as a prototype"
							);
					};
				},
			"./node_modules/core-js/internals/well-known-symbol.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/shared.js"),
					l = o("./node_modules/core-js/internals/uid.js"),
					a = o("./node_modules/core-js/internals/native-symbol.js"),
					u = i.Symbol,
					c = s("wks");
				n.exports = function (d) {
					return (
						c[d] ||
						(c[d] = (a && u[d]) || (a ? u : l)("Symbol." + d))
					);
				};
			},
			"./node_modules/core-js/modules/es.array.from.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/export.js"),
					s = o("./node_modules/core-js/internals/array-from.js"),
					l = o(
						"./node_modules/core-js/internals/check-correctness-of-iteration.js"
					),
					a = !l(function (u) {
						Array.from(u);
					});
				i({ target: "Array", stat: !0, forced: a }, { from: s });
			},
			"./node_modules/core-js/modules/es.string.iterator.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/string-at.js"),
					s = o("./node_modules/core-js/internals/internal-state.js"),
					l = o(
						"./node_modules/core-js/internals/define-iterator.js"
					),
					a = "String Iterator",
					u = s.set,
					c = s.getterFor(a);
				l(
					String,
					"String",
					function (d) {
						u(this, { type: a, string: String(d), index: 0 });
					},
					function () {
						var h = c(this),
							p = h.string,
							g = h.index,
							y;
						return g >= p.length
							? { value: void 0, done: !0 }
							: ((y = i(p, g, !0)),
							  (h.index += y.length),
							  { value: y, done: !1 });
					}
				);
			},
			"./node_modules/webpack/buildin/global.js": function (n, r) {
				var o;
				o = (function () {
					return this;
				})();
				try {
					o = o || Function("return this")() || (0, eval)("this");
				} catch (i) {
					typeof window == "object" && (o = window);
				}
				n.exports = o;
			},
			"./src/default-attrs.json": function (n) {
				n.exports = {
					xmlns: "http://www.w3.org/2000/svg",
					width: 24,
					height: 24,
					viewBox: "0 0 24 24",
					fill: "none",
					stroke: "currentColor",
					"stroke-width": 2,
					"stroke-linecap": "round",
					"stroke-linejoin": "round",
				};
			},
			"./src/icon.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i =
						Object.assign ||
						function (y) {
							for (var b = 1; b < arguments.length; b++) {
								var w = arguments[b];
								for (var S in w)
									Object.prototype.hasOwnProperty.call(
										w,
										S
									) && (y[S] = w[S]);
							}
							return y;
						},
					s = (function () {
						function y(b, w) {
							for (var S = 0; S < w.length; S++) {
								var E = w[S];
								(E.enumerable = E.enumerable || !1),
									(E.configurable = !0),
									"value" in E && (E.writable = !0),
									Object.defineProperty(b, E.key, E);
							}
						}
						return function (b, w, S) {
							return w && y(b.prototype, w), S && y(b, S), b;
						};
					})(),
					l = o("./node_modules/classnames/dedupe.js"),
					a = d(l),
					u = o("./src/default-attrs.json"),
					c = d(u);
				function d(y) {
					return y && y.__esModule ? y : { default: y };
				}
				function h(y, b) {
					if (!(y instanceof b))
						throw new TypeError(
							"Cannot call a class as a function"
						);
				}
				var p = (function () {
					function y(b, w) {
						var S =
							arguments.length > 2 && arguments[2] !== void 0
								? arguments[2]
								: [];
						h(this, y),
							(this.name = b),
							(this.contents = w),
							(this.tags = S),
							(this.attrs = i({}, c.default, {
								class: "feather feather-" + b,
							}));
					}
					return (
						s(y, [
							{
								key: "toSvg",
								value: function () {
									var w =
											arguments.length > 0 &&
											arguments[0] !== void 0
												? arguments[0]
												: {},
										S = i({}, this.attrs, w, {
											class: (0, a.default)(
												this.attrs.class,
												w.class
											),
										});
									return (
										"<svg " +
										g(S) +
										">" +
										this.contents +
										"</svg>"
									);
								},
							},
							{
								key: "toString",
								value: function () {
									return this.contents;
								},
							},
						]),
						y
					);
				})();
				function g(y) {
					return Object.keys(y)
						.map(function (b) {
							return b + '="' + y[b] + '"';
						})
						.join(" ");
				}
				r.default = p;
			},
			"./src/icons.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i = o("./src/icon.js"),
					s = d(i),
					l = o("./dist/icons.json"),
					a = d(l),
					u = o("./src/tags.json"),
					c = d(u);
				function d(h) {
					return h && h.__esModule ? h : { default: h };
				}
				r.default = Object.keys(a.default)
					.map(function (h) {
						return new s.default(h, a.default[h], c.default[h]);
					})
					.reduce(function (h, p) {
						return (h[p.name] = p), h;
					}, {});
			},
			"./src/index.js": function (n, r, o) {
				var i = o("./src/icons.js"),
					s = d(i),
					l = o("./src/to-svg.js"),
					a = d(l),
					u = o("./src/replace.js"),
					c = d(u);
				function d(h) {
					return h && h.__esModule ? h : { default: h };
				}
				n.exports = {
					icons: s.default,
					toSvg: a.default,
					replace: c.default,
				};
			},
			"./src/replace.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i =
						Object.assign ||
						function (g) {
							for (var y = 1; y < arguments.length; y++) {
								var b = arguments[y];
								for (var w in b)
									Object.prototype.hasOwnProperty.call(
										b,
										w
									) && (g[w] = b[w]);
							}
							return g;
						},
					s = o("./node_modules/classnames/dedupe.js"),
					l = c(s),
					a = o("./src/icons.js"),
					u = c(a);
				function c(g) {
					return g && g.__esModule ? g : { default: g };
				}
				function d() {
					var g =
						arguments.length > 0 && arguments[0] !== void 0
							? arguments[0]
							: {};
					if (typeof document == "undefined")
						throw new Error(
							"`feather.replace()` only works in a browser environment."
						);
					var y = document.querySelectorAll("[data-feather]");
					Array.from(y).forEach(function (b) {
						return h(b, g);
					});
				}
				function h(g) {
					var y =
							arguments.length > 1 && arguments[1] !== void 0
								? arguments[1]
								: {},
						b = p(g),
						w = b["data-feather"];
					delete b["data-feather"];
					var S = u.default[w].toSvg(
							i({}, y, b, {
								class: (0, l.default)(y.class, b.class),
							})
						),
						E = new DOMParser().parseFromString(S, "image/svg+xml"),
						f = E.querySelector("svg");
					g.parentNode.replaceChild(f, g);
				}
				function p(g) {
					return Array.from(g.attributes).reduce(function (y, b) {
						return (y[b.name] = b.value), y;
					}, {});
				}
				r.default = d;
			},
			"./src/tags.json": function (n) {
				n.exports = {
					activity: ["pulse", "health", "action", "motion"],
					airplay: ["stream", "cast", "mirroring"],
					"alert-circle": ["warning", "alert", "danger"],
					"alert-octagon": ["warning", "alert", "danger"],
					"alert-triangle": ["warning", "alert", "danger"],
					"align-center": ["text alignment", "center"],
					"align-justify": ["text alignment", "justified"],
					"align-left": ["text alignment", "left"],
					"align-right": ["text alignment", "right"],
					anchor: [],
					archive: ["index", "box"],
					"at-sign": ["mention", "at", "email", "message"],
					award: ["achievement", "badge"],
					aperture: ["camera", "photo"],
					"bar-chart": ["statistics", "diagram", "graph"],
					"bar-chart-2": ["statistics", "diagram", "graph"],
					battery: ["power", "electricity"],
					"battery-charging": ["power", "electricity"],
					bell: ["alarm", "notification", "sound"],
					"bell-off": ["alarm", "notification", "silent"],
					bluetooth: ["wireless"],
					"book-open": ["read", "library"],
					book: [
						"read",
						"dictionary",
						"booklet",
						"magazine",
						"library",
					],
					bookmark: ["read", "clip", "marker", "tag"],
					box: ["cube"],
					briefcase: ["work", "bag", "baggage", "folder"],
					calendar: ["date"],
					camera: ["photo"],
					cast: ["chromecast", "airplay"],
					"chevron-down": ["expand"],
					"chevron-up": ["collapse"],
					circle: ["off", "zero", "record"],
					clipboard: ["copy"],
					clock: ["time", "watch", "alarm"],
					"cloud-drizzle": ["weather", "shower"],
					"cloud-lightning": ["weather", "bolt"],
					"cloud-rain": ["weather"],
					"cloud-snow": ["weather", "blizzard"],
					cloud: ["weather"],
					codepen: ["logo"],
					codesandbox: ["logo"],
					code: ["source", "programming"],
					coffee: [
						"drink",
						"cup",
						"mug",
						"tea",
						"cafe",
						"hot",
						"beverage",
					],
					columns: ["layout"],
					command: ["keyboard", "cmd", "terminal", "prompt"],
					compass: ["navigation", "safari", "travel", "direction"],
					copy: ["clone", "duplicate"],
					"corner-down-left": ["arrow", "return"],
					"corner-down-right": ["arrow"],
					"corner-left-down": ["arrow"],
					"corner-left-up": ["arrow"],
					"corner-right-down": ["arrow"],
					"corner-right-up": ["arrow"],
					"corner-up-left": ["arrow"],
					"corner-up-right": ["arrow"],
					cpu: ["processor", "technology"],
					"credit-card": ["purchase", "payment", "cc"],
					crop: ["photo", "image"],
					crosshair: ["aim", "target"],
					database: ["storage", "memory"],
					delete: ["remove"],
					disc: ["album", "cd", "dvd", "music"],
					"dollar-sign": ["currency", "money", "payment"],
					droplet: ["water"],
					edit: ["pencil", "change"],
					"edit-2": ["pencil", "change"],
					"edit-3": ["pencil", "change"],
					eye: ["view", "watch"],
					"eye-off": ["view", "watch", "hide", "hidden"],
					"external-link": ["outbound"],
					facebook: ["logo", "social"],
					"fast-forward": ["music"],
					figma: ["logo", "design", "tool"],
					"file-minus": ["delete", "remove", "erase"],
					"file-plus": ["add", "create", "new"],
					"file-text": ["data", "txt", "pdf"],
					film: ["movie", "video"],
					filter: ["funnel", "hopper"],
					flag: ["report"],
					"folder-minus": ["directory"],
					"folder-plus": ["directory"],
					folder: ["directory"],
					framer: ["logo", "design", "tool"],
					frown: ["emoji", "face", "bad", "sad", "emotion"],
					gift: ["present", "box", "birthday", "party"],
					"git-branch": ["code", "version control"],
					"git-commit": ["code", "version control"],
					"git-merge": ["code", "version control"],
					"git-pull-request": ["code", "version control"],
					github: ["logo", "version control"],
					gitlab: ["logo", "version control"],
					globe: ["world", "browser", "language", "translate"],
					"hard-drive": ["computer", "server", "memory", "data"],
					hash: ["hashtag", "number", "pound"],
					headphones: ["music", "audio", "sound"],
					heart: ["like", "love", "emotion"],
					"help-circle": ["question mark"],
					hexagon: ["shape", "node.js", "logo"],
					home: ["house", "living"],
					image: ["picture"],
					inbox: ["email"],
					instagram: ["logo", "camera"],
					key: ["password", "login", "authentication", "secure"],
					layers: ["stack"],
					layout: ["window", "webpage"],
					"life-buoy": ["help", "life ring", "support"],
					link: ["chain", "url"],
					"link-2": ["chain", "url"],
					linkedin: ["logo", "social media"],
					list: ["options"],
					lock: ["security", "password", "secure"],
					"log-in": ["sign in", "arrow", "enter"],
					"log-out": ["sign out", "arrow", "exit"],
					mail: ["email", "message"],
					"map-pin": ["location", "navigation", "travel", "marker"],
					map: ["location", "navigation", "travel"],
					maximize: ["fullscreen"],
					"maximize-2": ["fullscreen", "arrows", "expand"],
					meh: ["emoji", "face", "neutral", "emotion"],
					menu: ["bars", "navigation", "hamburger"],
					"message-circle": ["comment", "chat"],
					"message-square": ["comment", "chat"],
					"mic-off": ["record", "sound", "mute"],
					mic: ["record", "sound", "listen"],
					minimize: ["exit fullscreen", "close"],
					"minimize-2": ["exit fullscreen", "arrows", "close"],
					minus: ["subtract"],
					monitor: ["tv", "screen", "display"],
					moon: ["dark", "night"],
					"more-horizontal": ["ellipsis"],
					"more-vertical": ["ellipsis"],
					"mouse-pointer": ["arrow", "cursor"],
					move: ["arrows"],
					music: ["note"],
					navigation: ["location", "travel"],
					"navigation-2": ["location", "travel"],
					octagon: ["stop"],
					package: ["box", "container"],
					paperclip: ["attachment"],
					pause: ["music", "stop"],
					"pause-circle": ["music", "audio", "stop"],
					"pen-tool": ["vector", "drawing"],
					percent: ["discount"],
					"phone-call": ["ring"],
					"phone-forwarded": ["call"],
					"phone-incoming": ["call"],
					"phone-missed": ["call"],
					"phone-off": ["call", "mute"],
					"phone-outgoing": ["call"],
					phone: ["call"],
					play: ["music", "start"],
					"pie-chart": ["statistics", "diagram"],
					"play-circle": ["music", "start"],
					plus: ["add", "new"],
					"plus-circle": ["add", "new"],
					"plus-square": ["add", "new"],
					pocket: ["logo", "save"],
					power: ["on", "off"],
					printer: ["fax", "office", "device"],
					radio: ["signal"],
					"refresh-cw": ["synchronise", "arrows"],
					"refresh-ccw": ["arrows"],
					repeat: ["loop", "arrows"],
					rewind: ["music"],
					"rotate-ccw": ["arrow"],
					"rotate-cw": ["arrow"],
					rss: ["feed", "subscribe"],
					save: ["floppy disk"],
					scissors: ["cut"],
					search: ["find", "magnifier", "magnifying glass"],
					send: [
						"message",
						"mail",
						"email",
						"paper airplane",
						"paper aeroplane",
					],
					settings: ["cog", "edit", "gear", "preferences"],
					"share-2": ["network", "connections"],
					shield: ["security", "secure"],
					"shield-off": ["security", "insecure"],
					"shopping-bag": ["ecommerce", "cart", "purchase", "store"],
					"shopping-cart": ["ecommerce", "cart", "purchase", "store"],
					shuffle: ["music"],
					"skip-back": ["music"],
					"skip-forward": ["music"],
					slack: ["logo"],
					slash: ["ban", "no"],
					sliders: ["settings", "controls"],
					smartphone: ["cellphone", "device"],
					smile: ["emoji", "face", "happy", "good", "emotion"],
					speaker: ["audio", "music"],
					star: ["bookmark", "favorite", "like"],
					"stop-circle": ["media", "music"],
					sun: ["brightness", "weather", "light"],
					sunrise: ["weather", "time", "morning", "day"],
					sunset: ["weather", "time", "evening", "night"],
					tablet: ["device"],
					tag: ["label"],
					target: ["logo", "bullseye"],
					terminal: ["code", "command line", "prompt"],
					thermometer: [
						"temperature",
						"celsius",
						"fahrenheit",
						"weather",
					],
					"thumbs-down": ["dislike", "bad", "emotion"],
					"thumbs-up": ["like", "good", "emotion"],
					"toggle-left": ["on", "off", "switch"],
					"toggle-right": ["on", "off", "switch"],
					tool: ["settings", "spanner"],
					trash: ["garbage", "delete", "remove", "bin"],
					"trash-2": ["garbage", "delete", "remove", "bin"],
					triangle: ["delta"],
					truck: [
						"delivery",
						"van",
						"shipping",
						"transport",
						"lorry",
					],
					tv: ["television", "stream"],
					twitch: ["logo"],
					twitter: ["logo", "social"],
					type: ["text"],
					umbrella: ["rain", "weather"],
					unlock: ["security"],
					"user-check": ["followed", "subscribed"],
					"user-minus": [
						"delete",
						"remove",
						"unfollow",
						"unsubscribe",
					],
					"user-plus": [
						"new",
						"add",
						"create",
						"follow",
						"subscribe",
					],
					"user-x": [
						"delete",
						"remove",
						"unfollow",
						"unsubscribe",
						"unavailable",
					],
					user: ["person", "account"],
					users: ["group"],
					"video-off": ["camera", "movie", "film"],
					video: ["camera", "movie", "film"],
					voicemail: ["phone"],
					volume: ["music", "sound", "mute"],
					"volume-1": ["music", "sound"],
					"volume-2": ["music", "sound"],
					"volume-x": ["music", "sound", "mute"],
					watch: ["clock", "time"],
					"wifi-off": ["disabled"],
					wifi: ["connection", "signal", "wireless"],
					wind: ["weather", "air"],
					"x-circle": [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					"x-octagon": [
						"delete",
						"stop",
						"alert",
						"warning",
						"times",
						"clear",
					],
					"x-square": [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					x: [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					youtube: ["logo", "video", "play"],
					"zap-off": ["flash", "camera", "lightning"],
					zap: ["flash", "camera", "lightning"],
					"zoom-in": ["magnifying glass"],
					"zoom-out": ["magnifying glass"],
				};
			},
			"./src/to-svg.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i = o("./src/icons.js"),
					s = l(i);
				function l(u) {
					return u && u.__esModule ? u : { default: u };
				}
				function a(u) {
					var c =
						arguments.length > 1 && arguments[1] !== void 0
							? arguments[1]
							: {};
					if (
						(console.warn(
							"feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."
						),
						!u)
					)
						throw new Error(
							"The required `key` (icon name) parameter is missing."
						);
					if (!s.default[u])
						throw new Error(
							"No icon matching '" +
								u +
								"'. See the complete list of icons at https://feathericons.com"
						);
					return s.default[u].toSvg(c);
				}
				r.default = a;
			},
			0: function (n, r, o) {
				o("./node_modules/core-js/es/array/from.js"),
					(n.exports = o("./src/index.js"));
			},
		});
	});
})(Iy);
var bS = Iy.exports;
const wd = Py(bS),
	gm = Object.keys(wd.icons),
	eo = {
		props: {
			name: {
				type: String,
				required: !0,
				validator(t) {
					const e = gm.includes(t);
					return (
						e ||
							(console.groupCollapsed(
								"[frappe-ui] name property for feather-icon must be one of "
							),
							console.dir(gm),
							console.groupEnd()),
						e
					);
				},
			},
			color: { type: String, default: null },
			strokeWidth: { type: Number, default: 1.5 },
		},
		render() {
			let t = wd.icons[this.name];
			return (
				t || (t = wd.icons.circle),
				Ue(
					"svg",
					Ht(
						t.attrs,
						{
							fill: "none",
							stroke: "currentColor",
							color: this.color,
							"stroke-linecap": "round",
							"stroke-linejoin": "round",
							"stroke-width": this.strokeWidth,
							width: null,
							height: null,
							class: [t.attrs.class, "shrink-0"],
							innerHTML: t.contents,
						},
						this.$attrs
					)
				)
			);
		},
	},
	wS = { name: "LoadingIndicator" },
	xS = {
		class: "max-w-xs animate-spin",
		xmlns: "http://www.w3.org/2000/svg",
		fill: "none",
		viewBox: "0 0 24 24",
	},
	kS = U(
		"circle",
		{
			class: "opacity-25",
			cx: "12",
			cy: "12",
			r: "10",
			stroke: "currentColor",
			"stroke-width": "4",
		},
		null,
		-1
	),
	SS = U(
		"path",
		{
			class: "opacity-75",
			fill: "currentColor",
			d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
		},
		null,
		-1
	),
	_S = [kS, SS];
function CS(t, e, n, r, o, i) {
	return j(), q("svg", xS, _S);
}
const MS = je(wS, [["render", CS]]),
	ES = ["disabled", "ariaLabel"],
	Os = Re({
		__name: "Button",
		props: {
			theme: { default: "gray" },
			size: { default: "sm" },
			variant: { default: "subtle" },
			label: {},
			icon: {},
			iconLeft: {},
			iconRight: {},
			loading: { type: Boolean, default: !1 },
			loadingText: {},
			disabled: { type: Boolean, default: !1 },
			route: {},
			link: {},
		},
		setup(t) {
			const e = t,
				n = l0(),
				r = F0(),
				o = H(() => {
					let c = {
							gray: "text-white bg-gray-900 hover:bg-gray-800 active:bg-gray-700",
							blue: "text-white bg-blue-500 hover:bg-blue-600 active:bg-blue-700",
							green: "text-white bg-green-600 hover:bg-green-700 active:bg-green-800",
							red: "text-white bg-red-600 hover:bg-red-700 active:bg-red-800",
						}[e.theme],
						d = {
							gray: "text-gray-800 bg-gray-100 hover:bg-gray-200 active:bg-gray-300",
							blue: "text-blue-600 bg-blue-100 hover:bg-blue-200 active:bg-blue-300",
							green: "text-green-800 bg-green-100 hover:bg-green-200 active:bg-green-300",
							red: "text-red-700 bg-red-100 hover:bg-red-200 active:bg-red-300",
						}[e.theme],
						h = {
							gray: "text-gray-800 bg-white border border-gray-300 hover:border-gray-400 active:border-gray-400 active:bg-gray-300",
							blue: "text-blue-600 bg-white border border-blue-300 hover:border-blue-400 active:border-blue-400 active:bg-blue-300",
							green: "text-green-800 bg-white border border-green-400 hover:border-green-500 active:border-green-500 active:bg-green-300",
							red: "text-red-700 bg-white border border-red-300 hover:border-red-400 active:border-red-400 active:bg-red-200",
						}[e.theme],
						p = {
							gray: "text-gray-800 bg-transparent hover:bg-gray-200 active:bg-gray-300",
							blue: "text-blue-600 bg-transparent hover:bg-blue-200 active:bg-blue-300",
							green: "text-green-800 bg-transparent hover:bg-green-200 active:bg-green-300",
							red: "text-red-700 bg-transparent hover:bg-red-200 active:bg-red-300",
						}[e.theme],
						g = {
							gray: "focus-visible:ring focus-visible:ring-gray-400",
							blue: "focus-visible:ring focus-visible:ring-blue-400",
							green: "focus-visible:ring focus-visible:ring-green-400",
							red: "focus-visible:ring focus-visible:ring-red-400",
						}[e.theme],
						y = { subtle: d, solid: c, outline: h, ghost: p }[
							e.variant
						],
						b = `${e.theme}-${e.variant}`,
						w = {
							gray: "bg-gray-100 text-gray-500",
							"gray-outline":
								"bg-gray-100 text-gray-500 border border-gray-300",
							"gray-ghost": "text-gray-500",
							"blue-solid": "bg-blue-300 text-white",
							"blue-subtle": "bg-blue-100 text-blue-400",
							"blue-outline":
								"bg-blue-100 text-blue-400 border border-blue-300",
							"blue-ghost": "text-blue-400",
							green: "bg-green-100 text-green-500",
							"green-outline":
								"bg-green-100 text-green-500 border border-green-400",
							"green-ghost": "text-green-500",
							red: "bg-red-100 text-red-400",
							"red-outline":
								"bg-red-100 text-red-400 border border-red-300",
							"red-ghost": "text-red-400",
						},
						S = w[b] || w[e.theme],
						E = {
							sm: "h-7 text-base px-2 rounded",
							md: "h-8 text-base font-medium px-2.5 rounded",
							lg: "h-10 text-lg font-medium px-3 rounded-md",
							xl: "h-11.5 text-xl font-medium px-3.5 rounded-lg",
							"2xl": "h-13 text-2xl font-medium px-3.5 rounded-xl",
						}[e.size];
					return (
						a.value &&
							(E = {
								sm: "h-7 w-7 rounded",
								md: "h-8 w-8 rounded",
								lg: "h-10 w-10 rounded-md",
								xl: "h-11.5 w-11.5 rounded-lg",
								"2xl": "h-13 w-13 rounded-xl",
							}[e.size]),
						[
							"inline-flex items-center justify-center gap-2 transition-colors focus:outline-none",
							s.value ? S : y,
							g,
							E,
						]
					);
				}),
				i = H(
					() =>
						({
							sm: "h-4",
							md: "h-4.5",
							lg: "h-5",
							xl: "h-6",
							"2xl": "h-6",
						}[e.size])
				),
				s = H(() => e.disabled || e.loading),
				l = H(() => (a.value ? e.label : null)),
				a = H(() => e.icon || n.icon),
				u = () => {
					if (e.route) return r.push(e.route);
					if (e.link) return window.open(e.link, "_blank");
				};
			return (c, d) => (
				j(),
				q(
					"button",
					Ht(c.$attrs, {
						class: o.value,
						onClick: u,
						disabled: s.value,
						ariaLabel: l.value,
					}),
					[
						c.loading
							? (j(),
							  Fe(
									MS,
									{
										key: 0,
										class: we({
											"h-3 w-3": c.size == "sm",
											"h-[13.5px] w-[13.5px]":
												c.size == "md",
											"h-[15px] w-[15px]": c.size == "lg",
											"h-4.5 w-4.5":
												c.size == "xl" ||
												c.size == "2xl",
										}),
									},
									null,
									8,
									["class"]
							  ))
							: c.$slots.prefix || c.iconLeft
							? De(c.$slots, "prefix", { key: 1 }, () => [
									c.iconLeft
										? (j(),
										  Fe(
												eo,
												{
													key: 0,
													name: c.iconLeft,
													class: we(i.value),
													"aria-hidden": "true",
												},
												null,
												8,
												["name", "class"]
										  ))
										: Ve("", !0),
							  ])
							: Ve("", !0),
						c.loading && c.loadingText
							? (j(),
							  q(Ne, { key: 2 }, [_r(Qe(c.loadingText), 1)], 64))
							: a.value && !c.loading
							? (j(),
							  q(
									Ne,
									{ key: 3 },
									[
										c.icon
											? (j(),
											  Fe(
													eo,
													{
														key: 0,
														name: c.icon,
														class: we(i.value),
														"aria-label": c.label,
													},
													null,
													8,
													[
														"name",
														"class",
														"aria-label",
													]
											  ))
											: c.$slots.icon
											? De(c.$slots, "icon", { key: 1 })
											: Ve("", !0),
									],
									64
							  ))
							: (j(),
							  q(
									"span",
									{
										key: 4,
										class: we({ "sr-only": a.value }),
									},
									[
										De(c.$slots, "default", {}, () => [
											_r(Qe(c.label), 1),
										]),
									],
									2
							  )),
						De(c.$slots, "suffix", {}, () => [
							c.iconRight
								? (j(),
								  Fe(
										eo,
										{
											key: 0,
											name: c.iconRight,
											class: we(i.value),
											"aria-hidden": "true",
										},
										null,
										8,
										["name", "class"]
								  ))
								: Ve("", !0),
						]),
					],
					16,
					ES
				)
			);
		},
	}),
	TS = ["src"],
	qj = Re({
		__name: "Avatar",
		props: {
			image: {},
			label: {},
			size: { default: "md" },
			shape: { default: "circle" },
		},
		setup(t) {
			const e = t,
				n = H(
					() =>
						({
							circle: "rounded-full",
							square: {
								xs: "rounded-[4px]",
								sm: "rounded-[5px]",
								md: "rounded-[5px]",
								lg: "rounded-[6px]",
								xl: "rounded-[6px]",
								"2xl": "rounded-[8px]",
								"3xl": "rounded-[10px]",
							}[e.size],
						}[e.shape])
				),
				r = H(
					() =>
						({
							xs: "w-4 h-4",
							sm: "w-5 h-5",
							md: "w-6 h-6",
							lg: "w-7 h-7",
							xl: "w-8 h-8",
							"2xl": "w-10 h-10",
							"3xl": "w-11.5 h-11.5",
						}[e.size])
				),
				o = H(() => [
					"font-medium",
					{
						xs: "text-2xs",
						sm: "text-sm",
						md: "text-base",
						lg: "text-base",
						xl: "text-lg",
						"2xl": "text-xl",
						"3xl": "text-2xl",
					}[e.size],
				]),
				i = H(
					() =>
						({
							xs: "-mr-[.1rem] -mb-[.1rem] h-2 w-2",
							sm: "-mr-[.1rem] -mb-[.1rem] h-[9px] w-[9px]",
							md: "-mr-[.1rem] -mb-[.1rem] h-2.5 w-2.5",
							lg: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
							xl: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
							"2xl": "-mr-[.1rem] -mb-[.1rem] h-3.5 w-3.5",
							"3xl": "-mr-[.2rem] -mb-[.2rem] h-4 w-4",
						}[e.size])
				),
				s = H(
					() =>
						({
							xs: "h-1 w-1",
							sm: "h-[5px] w-[5px]",
							md: "h-1.5 w-1.5",
							lg: "h-2 w-2",
							xl: "h-2 w-2",
							"2xl": "h-2.5 w-2.5",
							"3xl": "h-3 w-3",
						}[e.size])
				),
				l = H(
					() =>
						({
							xs: "h-2.5 w-2.5",
							sm: "h-3 w-3",
							md: "h-4 w-4",
							lg: "h-4 w-4",
							xl: "h-4 w-4",
							"2xl": "h-5 w-5",
							"3xl": "h-5 w-5",
						}[e.size])
				);
			return (a, u) => (
				j(),
				q(
					"div",
					{
						class: we([
							"relative inline-block shrink-0",
							[r.value, n.value],
						]),
					},
					[
						a.image
							? (j(),
							  q(
									"img",
									{
										key: 0,
										src: a.image,
										class: we([
											n.value,
											"h-full w-full object-cover",
										]),
									},
									null,
									10,
									TS
							  ))
							: (j(),
							  q(
									"div",
									{
										key: 1,
										class: we([
											"flex h-full w-full items-center justify-center bg-gray-100 uppercase text-gray-600",
											[o.value, n.value],
										]),
									},
									[
										a.$slots.default
											? (j(),
											  q(
													"div",
													{
														key: 0,
														class: we(l.value),
													},
													[De(a.$slots, "default")],
													2
											  ))
											: (j(),
											  q(
													Ne,
													{ key: 1 },
													[
														_r(
															Qe(
																a.label &&
																	a.label[0]
															),
															1
														),
													],
													64
											  )),
									],
									2
							  )),
						a.$slots.indicator
							? (j(),
							  q(
									"div",
									{
										key: 2,
										class: we([
											"absolute bottom-0 right-0 grid place-items-center rounded-full bg-white",
											i.value,
										]),
									},
									[
										U(
											"div",
											{ class: we(s.value) },
											[De(a.$slots, "indicator")],
											2
										),
									],
									2
							  ))
							: Ve("", !0),
					],
					2
				)
			);
		},
	}),
	Jj = Re({
		__name: "Badge",
		props: {
			theme: { default: "gray" },
			size: { default: "md" },
			variant: { default: "subtle" },
			label: {},
		},
		setup(t) {
			const e = t,
				n = H(() => {
					let r = {
							gray: "text-white bg-gray-900",
							blue: "text-white bg-blue-500",
							green: "text-white bg-green-600",
							orange: "text-white bg-amber-600",
							red: "text-white bg-red-600",
						}[e.theme],
						o = {
							gray: "text-gray-700 bg-gray-100",
							blue: "text-blue-600 bg-blue-100",
							green: "text-green-800 bg-green-200",
							orange: "text-amber-700 bg-amber-100",
							red: "text-red-600 bg-red-100",
						}[e.theme],
						i = {
							gray: "text-gray-700 bg-white border border-gray-300",
							blue: "text-blue-600 bg-white border border-blue-300",
							green: "text-green-800 bg-white border border-green-300",
							orange: "text-amber-700 bg-white border border-amber-300",
							red: "text-red-600 bg-white border border-red-300",
						}[e.theme],
						s = {
							gray: "text-gray-700 bg-transparent",
							blue: "text-blue-600 bg-transparent",
							green: "text-green-800 bg-transparent",
							orange: "text-amber-700 bg-transparent",
							red: "text-red-600 bg-transparent",
						}[e.theme],
						l = { subtle: o, solid: r, outline: i, ghost: s }[
							e.variant
						],
						a = {
							sm: "h-4 text-xs px-1.5",
							md: "h-5 text-xs px-1.5",
							lg: "h-6 text-sm px-2",
						}[e.size];
					return [l, a];
				});
			return (r, o) => (
				j(),
				q(
					"div",
					{
						class: we([
							"inline-flex select-none items-center gap-1 rounded-full",
							n.value,
						]),
					},
					[
						r.$slots.prefix
							? (j(),
							  q(
									"div",
									{
										key: 0,
										class: we([
											e.size == "lg"
												? "max-h-6"
												: "max-h-4",
										]),
									},
									[De(r.$slots, "prefix")],
									2
							  ))
							: Ve("", !0),
						De(r.$slots, "default", {}, () => {
							var i;
							return [
								_r(
									Qe(
										(i = e.label) == null
											? void 0
											: i.toString()
									),
									1
								),
							];
						}),
						r.$slots.suffix
							? (j(),
							  q(
									"div",
									{
										key: 1,
										class: we([
											e.size == "lg"
												? "max-h-6"
												: "max-h-4",
										]),
									},
									[De(r.$slots, "suffix")],
									2
							  ))
							: Ve("", !0),
					],
					2
				)
			);
		},
	});
function Rs(t) {
	return C1() ? (M1(t), !0) : !1;
}
function Mr(t) {
	return typeof t == "function" ? t() : ue(t);
}
const xd = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" &&
	globalThis instanceof WorkerGlobalScope;
const AS = Object.prototype.toString,
	OS = (t) => AS.call(t) === "[object Object]",
	kd = () => {};
function RS(t, e) {
	function n(...r) {
		return new Promise((o, i) => {
			Promise.resolve(
				t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })
			)
				.then(o)
				.catch(i);
		});
	}
	return n;
}
const Ny = (t) => t();
function PS(t, e = {}) {
	let n,
		r,
		o = kd;
	const i = (l) => {
		clearTimeout(l), o(), (o = kd);
	};
	return (l) => {
		const a = Mr(t),
			u = Mr(e.maxWait);
		return (
			n && i(n),
			a <= 0 || (u !== void 0 && u <= 0)
				? (r && (i(r), (r = null)), Promise.resolve(l()))
				: new Promise((c, d) => {
						(o = e.rejectOnCancel ? d : c),
							u &&
								!r &&
								(r = setTimeout(() => {
									n && i(n), (r = null), c(l());
								}, u)),
							(n = setTimeout(() => {
								r && i(r), (r = null), c(l());
							}, a));
				  })
		);
	};
}
function IS(t = Ny) {
	const e = X(!0);
	function n() {
		e.value = !1;
	}
	function r() {
		e.value = !0;
	}
	const o = (...i) => {
		e.value && t(...i);
	};
	return { isActive: fu(e), pause: n, resume: r, eventFilter: o };
}
function NS(t) {
	return t || uo();
}
function Dy(t, e, n = {}) {
	const i = n,
		{ eventFilter: r = Ny } = i,
		o = et(i, ["eventFilter"]);
	return it(t, RS(r, e), o);
}
function DS(t, e, n = {}) {
	const c = n,
		{ eventFilter: r } = c,
		o = et(c, ["eventFilter"]),
		{ eventFilter: i, pause: s, resume: l, isActive: a } = IS(r);
	return {
		stop: Dy(t, e, ye(z({}, o), { eventFilter: i })),
		pause: s,
		resume: l,
		isActive: a,
	};
}
function jy(t, e = !0, n) {
	NS() ? Xe(t, n) : e ? t() : zt(t);
}
function jS(t, e = 1e3, n = {}) {
	const { immediate: r = !0, immediateCallback: o = !1 } = n;
	let i = null;
	const s = X(!1);
	function l() {
		i && (clearInterval(i), (i = null));
	}
	function a() {
		(s.value = !1), l();
	}
	function u() {
		const c = Mr(e);
		c <= 0 || ((s.value = !0), o && t(), l(), (i = setInterval(t, c)));
	}
	if ((r && xd && u(), qt(e) || typeof e == "function")) {
		const c = it(e, () => {
			s.value && xd && u();
		});
		Rs(c);
	}
	return Rs(a), { isActive: s, pause: a, resume: u };
}
function Gj(t, e, n = {}) {
	const s = n,
		{ debounce: r = 0, maxWait: o = void 0 } = s,
		i = et(s, ["debounce", "maxWait"]);
	return Dy(t, e, ye(z({}, i), { eventFilter: PS(r, { maxWait: o }) }));
}
function LS(t) {
	var e;
	const n = Mr(t);
	return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const Ti = xd ? window : void 0;
function Sd(...t) {
	let e, n, r, o;
	if (
		(typeof t[0] == "string" || Array.isArray(t[0])
			? (([n, r, o] = t), (e = Ti))
			: ([e, n, r, o] = t),
		!e)
	)
		return kd;
	Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
	const i = [],
		s = () => {
			i.forEach((c) => c()), (i.length = 0);
		},
		l = (c, d, h, p) => (
			c.addEventListener(d, h, p), () => c.removeEventListener(d, h, p)
		),
		a = it(
			() => [LS(e), Mr(o)],
			([c, d]) => {
				if ((s(), !c)) return;
				const h = OS(d) ? z({}, d) : d;
				i.push(...n.flatMap((p) => r.map((g) => l(c, p, g, h))));
			},
			{ immediate: !0, flush: "post" }
		),
		u = () => {
			a(), s();
		};
	return Rs(u), u;
}
function $S() {
	const t = X(!1);
	return (
		uo() &&
			Xe(() => {
				t.value = !0;
			}),
		t
	);
}
function BS(t) {
	const e = $S();
	return H(() => (e.value, !!t()));
}
function zS(t, e = {}) {
	const { immediate: n = !0, fpsLimit: r = void 0, window: o = Ti } = e,
		i = X(!1),
		s = r ? 1e3 / r : null;
	let l = 0,
		a = null;
	function u(h) {
		if (!i.value || !o) return;
		const p = h - (l || h);
		if (s && p < s) {
			a = o.requestAnimationFrame(u);
			return;
		}
		t({ delta: p, timestamp: h }),
			(l = h),
			(a = o.requestAnimationFrame(u));
	}
	function c() {
		!i.value && o && ((i.value = !0), (a = o.requestAnimationFrame(u)));
	}
	function d() {
		(i.value = !1),
			a != null && o && (o.cancelAnimationFrame(a), (a = null));
	}
	return n && c(), Rs(d), { isActive: fu(i), pause: d, resume: c };
}
function HS(t, e = {}) {
	const { window: n = Ti } = e,
		r = BS(
			() => n && "matchMedia" in n && typeof n.matchMedia == "function"
		);
	let o;
	const i = X(!1),
		s = (u) => {
			i.value = u.matches;
		},
		l = () => {
			o &&
				("removeEventListener" in o
					? o.removeEventListener("change", s)
					: o.removeListener(s));
		},
		a = bt(() => {
			r.value &&
				(l(),
				(o = n.matchMedia(Mr(t))),
				"addEventListener" in o
					? o.addEventListener("change", s)
					: o.addListener(s),
				(i.value = o.matches));
		});
	return (
		Rs(() => {
			a(), l(), (o = void 0);
		}),
		i
	);
}
const xl =
		typeof globalThis != "undefined"
			? globalThis
			: typeof window != "undefined"
			? window
			: typeof global != "undefined"
			? global
			: typeof self != "undefined"
			? self
			: {},
	kl = "__vueuse_ssr_handlers__",
	FS = VS();
function VS() {
	return kl in xl || (xl[kl] = xl[kl] || {}), xl[kl];
}
function WS(t, e) {
	return FS[t] || e;
}
function US(t) {
	return t == null
		? "any"
		: t instanceof Set
		? "set"
		: t instanceof Map
		? "map"
		: t instanceof Date
		? "date"
		: typeof t == "boolean"
		? "boolean"
		: typeof t == "string"
		? "string"
		: typeof t == "object"
		? "object"
		: Number.isNaN(t)
		? "any"
		: "number";
}
const KS = {
		boolean: { read: (t) => t === "true", write: (t) => String(t) },
		object: { read: (t) => JSON.parse(t), write: (t) => JSON.stringify(t) },
		number: { read: (t) => Number.parseFloat(t), write: (t) => String(t) },
		any: { read: (t) => t, write: (t) => String(t) },
		string: { read: (t) => t, write: (t) => String(t) },
		map: {
			read: (t) => new Map(JSON.parse(t)),
			write: (t) => JSON.stringify(Array.from(t.entries())),
		},
		set: {
			read: (t) => new Set(JSON.parse(t)),
			write: (t) => JSON.stringify(Array.from(t)),
		},
		date: { read: (t) => new Date(t), write: (t) => t.toISOString() },
	},
	ym = "vueuse-storage";
function Yj(t, e, n, r = {}) {
	var o;
	const {
			flush: i = "pre",
			deep: s = !0,
			listenToStorageChanges: l = !0,
			writeDefaults: a = !0,
			mergeDefaults: u = !1,
			shallow: c,
			window: d = Ti,
			eventFilter: h,
			onError: p = (C) => {
				console.error(C);
			},
			initOnMounted: g,
		} = r,
		y = (c ? pu : X)(typeof e == "function" ? e() : e);
	if (!n)
		try {
			n = WS("getDefaultStorage", () => {
				var C;
				return (C = Ti) == null ? void 0 : C.localStorage;
			})();
		} catch (C) {
			p(C);
		}
	if (!n) return y;
	const b = Mr(e),
		w = US(b),
		S = (o = r.serializer) != null ? o : KS[w],
		{ pause: E, resume: f } = DS(y, () => v(y.value), {
			flush: i,
			deep: s,
			eventFilter: h,
		});
	return (
		d &&
			l &&
			jy(() => {
				Sd(d, "storage", k), Sd(d, ym, x), g && k();
			}),
		g || k(),
		y
	);
	function v(C) {
		try {
			if (C == null) n.removeItem(t);
			else {
				const _ = S.write(C),
					T = n.getItem(t);
				T !== _ &&
					(n.setItem(t, _),
					d &&
						d.dispatchEvent(
							new CustomEvent(ym, {
								detail: {
									key: t,
									oldValue: T,
									newValue: _,
									storageArea: n,
								},
							})
						));
			}
		} catch (_) {
			p(_);
		}
	}
	function m(C) {
		const _ = C ? C.newValue : n.getItem(t);
		if (_ == null) return a && b != null && n.setItem(t, S.write(b)), b;
		if (!C && u) {
			const T = S.read(_);
			return typeof u == "function"
				? u(T, b)
				: w === "object" && !Array.isArray(T)
				? z(z({}, b), T)
				: T;
		} else return typeof _ != "string" ? _ : S.read(_);
	}
	function x(C) {
		k(C.detail);
	}
	function k(C) {
		if (!(C && C.storageArea !== n)) {
			if (C && C.key == null) {
				y.value = b;
				return;
			}
			if (!(C && C.key !== t)) {
				E();
				try {
					(C == null ? void 0 : C.newValue) !== S.write(y.value) &&
						(y.value = m(C));
				} catch (_) {
					p(_);
				} finally {
					C ? zt(f) : f();
				}
			}
		}
	}
}
function qS(t = {}) {
	const { controls: e = !1, interval: n = "requestAnimationFrame" } = t,
		r = X(new Date()),
		o = () => (r.value = new Date()),
		i =
			n === "requestAnimationFrame"
				? zS(o, { immediate: !0 })
				: jS(o, n, { immediate: !0 });
	return e ? z({ now: r }, i) : r;
}
const JS = [
		{ max: 6e4, value: 1e3, name: "second" },
		{ max: 276e4, value: 6e4, name: "minute" },
		{ max: 72e6, value: 36e5, name: "hour" },
		{ max: 5184e5, value: 864e5, name: "day" },
		{ max: 24192e5, value: 6048e5, name: "week" },
		{ max: 28512e6, value: 2592e6, name: "month" },
		{ max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" },
	],
	GS = {
		justNow: "just now",
		past: (t) => (t.match(/\d/) ? `${t} ago` : t),
		future: (t) => (t.match(/\d/) ? `in ${t}` : t),
		month: (t, e) =>
			t === 1
				? e
					? "last month"
					: "next month"
				: `${t} month${t > 1 ? "s" : ""}`,
		year: (t, e) =>
			t === 1
				? e
					? "last year"
					: "next year"
				: `${t} year${t > 1 ? "s" : ""}`,
		day: (t, e) =>
			t === 1
				? e
					? "yesterday"
					: "tomorrow"
				: `${t} day${t > 1 ? "s" : ""}`,
		week: (t, e) =>
			t === 1
				? e
					? "last week"
					: "next week"
				: `${t} week${t > 1 ? "s" : ""}`,
		hour: (t) => `${t} hour${t > 1 ? "s" : ""}`,
		minute: (t) => `${t} minute${t > 1 ? "s" : ""}`,
		second: (t) => `${t} second${t > 1 ? "s" : ""}`,
		invalid: "",
	};
function YS(t) {
	return t.toISOString().slice(0, 10);
}
function Qj(t, e = {}) {
	const { controls: n = !1, updateInterval: r = 3e4 } = e,
		l = qS({ interval: r, controls: !0 }),
		{ now: o } = l,
		i = et(l, ["now"]),
		s = H(() => QS(new Date(Mr(t)), e, Mr(o)));
	return n ? z({ timeAgo: s }, i) : s;
}
function QS(t, e = {}, n = Date.now()) {
	var r;
	const {
			max: o,
			messages: i = GS,
			fullDateFormatter: s = YS,
			units: l = JS,
			showSecond: a = !1,
			rounding: u = "round",
		} = e,
		c = typeof u == "number" ? (b) => +b.toFixed(u) : Math[u],
		d = +n - +t,
		h = Math.abs(d);
	function p(b, w) {
		return c(Math.abs(b) / w.value);
	}
	function g(b, w) {
		const S = p(b, w),
			E = b > 0,
			f = y(w.name, S, E);
		return y(E ? "past" : "future", f, E);
	}
	function y(b, w, S) {
		const E = i[b];
		return typeof E == "function"
			? E(w, S)
			: E.replace("{0}", w.toString());
	}
	if (h < 6e4 && !a) return i.justNow;
	if (typeof o == "number" && h > o) return s(new Date(t));
	if (typeof o == "string") {
		const b = (r = l.find((w) => w.name === o)) == null ? void 0 : r.max;
		if (b && h > b) return s(new Date(t));
	}
	for (const [b, w] of l.entries()) {
		if (p(d, w) <= 0 && l[b - 1]) return g(d, l[b - 1]);
		if (h < w.max) return g(d, w);
	}
	return i.invalid;
}
function XS(t = {}) {
	const {
			window: e = Ti,
			initialWidth: n = Number.POSITIVE_INFINITY,
			initialHeight: r = Number.POSITIVE_INFINITY,
			listenOrientation: o = !0,
			includeScrollbar: i = !0,
		} = t,
		s = X(n),
		l = X(r),
		a = () => {
			e &&
				(i
					? ((s.value = e.innerWidth), (l.value = e.innerHeight))
					: ((s.value = e.document.documentElement.clientWidth),
					  (l.value = e.document.documentElement.clientHeight)));
		};
	if ((a(), jy(a), Sd("resize", a, { passive: !0 }), o)) {
		const u = HS("(orientation: portrait)");
		it(u, () => a());
	}
	return { width: s, height: l };
}
const ZS = {
		name: "Dropdown",
		props: {
			button: { type: Object, default: null },
			options: { type: Array, default: () => [] },
			placement: { type: String, default: "left" },
		},
		components: {
			Menu: Kk,
			MenuButton: qk,
			MenuItems: Jk,
			MenuItem: Gk,
			Button: Os,
			FeatherIcon: eo,
			Popover: Ru,
		},
		methods: {
			normalizeDropdownItem(t) {
				let e = t.onClick || null;
				return (
					!e &&
						t.route &&
						this.$router &&
						(e = () => this.$router.push(t.route)),
					{
						label: t.label,
						icon: t.icon,
						group: t.group,
						component: t.component,
						onClick: e,
					}
				);
			},
			filterOptions(t) {
				return (t || [])
					.filter(Boolean)
					.filter((e) => (e.condition ? e.condition() : !0))
					.map((e) => this.normalizeDropdownItem(e));
			},
		},
		computed: {
			groups() {
				var e;
				return (
					(e = this.options[0]) != null && e.group
						? this.options
						: [{ group: "", items: this.options }]
				).map((n, r) => ({
					key: r,
					group: n.group,
					hideLabel: n.hideLabel || !1,
					items: this.filterOptions(n.items),
				}));
			},
			dropdownTransition() {
				return {
					enterActiveClass: "transition duration-100 ease-out",
					enterFromClass: "transform scale-95 opacity-0",
					enterToClass: "transform scale-100 opacity-100",
					leaveActiveClass: "transition duration-75 ease-in",
					leaveFromClass: "transform scale-100 opacity-100",
					leaveToClass: "transform scale-95 opacity-0",
				};
			},
			popoverPlacement() {
				return this.placement === "left"
					? "bottom-start"
					: this.placement === "right"
					? "bottom-end"
					: this.placement === "center"
					? "bottom-center"
					: "bottom";
			},
		},
	},
	e_ = {
		key: 0,
		class: "flex h-7 items-center px-2 text-sm font-medium text-gray-500",
	},
	t_ = ["onClick"],
	n_ = { class: "whitespace-nowrap" };
function r_(t, e, n, r, o, i) {
	const s = nt("Button"),
		l = nt("MenuButton"),
		a = nt("FeatherIcon"),
		u = nt("MenuItem"),
		c = nt("MenuItems"),
		d = nt("Popover"),
		h = nt("Menu");
	return (
		j(),
		Fe(
			h,
			{ as: "div", class: "relative inline-block text-left" },
			{
				default: He(({ open: p }) => [
					be(
						d,
						{
							transition: i.dropdownTransition,
							show: p,
							placement: i.popoverPlacement,
						},
						{
							target: He(() => [
								be(
									l,
									{ as: "div" },
									{
										default: He(() => [
											t.$slots.default
												? De(
														t.$slots,
														"default",
														Ut(
															Ht(
																{ key: 0 },
																{ open: p }
															)
														)
												  )
												: (j(),
												  Fe(
														s,
														Ht(
															{
																key: 1,
																active: p,
															},
															n.button
														),
														{
															default: He(() => {
																var g;
																return [
																	_r(
																		Qe(
																			n.button
																				? ((g =
																						n.button) ==
																				  null
																						? void 0
																						: g.label) ||
																						null
																				: "Options"
																		),
																		1
																	),
																];
															}),
															_: 2,
														},
														1040,
														["active"]
												  )),
										]),
										_: 2,
									},
									1024
								),
							]),
							body: He(() => [
								be(
									c,
									{
										class: we([
											"mt-2 min-w-40 divide-y divide-gray-100 rounded-lg bg-white shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none",
											{
												"left-0 origin-top-left":
													n.placement == "left",
												"right-0 origin-top-right":
													n.placement == "right",
												"inset-x-0 origin-top":
													n.placement == "center",
											},
										]),
									},
									{
										default: He(() => [
											(j(!0),
											q(
												Ne,
												null,
												Pt(
													i.groups,
													(g) => (
														j(),
														q(
															"div",
															{
																key: g.key,
																class: "p-1.5",
															},
															[
																g.group &&
																!g.hideLabel
																	? (j(),
																	  q(
																			"div",
																			e_,
																			Qe(
																				g.group
																			),
																			1
																	  ))
																	: Ve(
																			"",
																			!0
																	  ),
																(j(!0),
																q(
																	Ne,
																	null,
																	Pt(
																		g.items,
																		(y) => (
																			j(),
																			Fe(
																				u,
																				{
																					key: y.label,
																				},
																				{
																					default:
																						He(
																							({
																								active: b,
																							}) => [
																								y.component
																									? (j(),
																									  Fe(
																											zn(
																												y.component
																											),
																											{
																												key: 0,
																												active: b,
																											},
																											null,
																											8,
																											[
																												"active",
																											]
																									  ))
																									: (j(),
																									  q(
																											"button",
																											{
																												key: 1,
																												class: we(
																													[
																														b
																															? "bg-gray-100"
																															: "text-gray-800",
																														"group flex h-7 w-full items-center rounded px-2 text-base",
																													]
																												),
																												onClick:
																													y.onClick,
																											},
																											[
																												y.icon &&
																												typeof y.icon ==
																													"string"
																													? (j(),
																													  Fe(
																															a,
																															{
																																key: 0,
																																name: y.icon,
																																class: "mr-2 h-4 w-4 flex-shrink-0 text-gray-700",
																																"aria-hidden":
																																	"true",
																															},
																															null,
																															8,
																															[
																																"name",
																															]
																													  ))
																													: y.icon
																													? (j(),
																													  Fe(
																															zn(
																																y.icon
																															),
																															{
																																key: 1,
																																class: "mr-2 h-4 w-4 flex-shrink-0 text-gray-700",
																															}
																													  ))
																													: Ve(
																															"",
																															!0
																													  ),
																												U(
																													"span",
																													n_,
																													Qe(
																														y.label
																													),
																													1
																												),
																											],
																											10,
																											t_
																									  )),
																							]
																						),
																					_: 2,
																				},
																				1024
																			)
																		)
																	),
																	128
																)),
															]
														)
													)
												),
												128
											)),
										]),
										_: 1,
									},
									8,
									["class"]
								),
							]),
							_: 2,
						},
						1032,
						["transition", "show", "placement"]
					),
				]),
				_: 3,
			}
		)
	);
}
const o_ = je(ZS, [["render", r_]]),
	i_ = { class: "flex min-w-0 items-center" },
	s_ = U(
		"svg",
		{
			class: "w-4 text-gray-600",
			xmlns: "http://www.w3.org/2000/svg",
			width: "24",
			height: "24",
			viewBox: "0 0 24 24",
			fill: "none",
			stroke: "currentColor",
			"stroke-width": "2",
			"stroke-linecap": "round",
			"stroke-linejoin": "round",
		},
		[
			U("circle", { cx: "12", cy: "12", r: "1" }),
			U("circle", { cx: "19", cy: "12", r: "1" }),
			U("circle", { cx: "5", cy: "12", r: "1" }),
		],
		-1
	),
	l_ = U(
		"span",
		{ class: "ml-1 mr-0.5 text-base text-gray-500", "aria-hidden": "true" },
		" / ",
		-1
	),
	a_ = {
		class: "flex min-w-0 items-center overflow-hidden text-ellipsis whitespace-nowrap",
	},
	u_ = {
		key: 0,
		class: "mx-0.5 text-base text-gray-500",
		"aria-hidden": "true",
	},
	Xj = Re({
		__name: "Breadcrumbs",
		props: { items: {} },
		setup(t) {
			const e = t,
				n = F0(),
				{ width: r } = XS(),
				o = H(() => (e.items || []).filter(Boolean)),
				i = H(() =>
					r.value > 640
						? []
						: o.value.slice(0, -2).map((a) => {
								let u = a.onClick
									? a.onClick
									: () => n.push(a.route);
								return ye(z({}, a), {
									icon: null,
									label: a.label,
									onClick: u,
								});
						  })
				),
				s = H(() => (r.value > 640 ? o.value : o.value.slice(-2)));
			return (l, a) => (
				j(),
				q("div", i_, [
					i.value.length
						? (j(),
						  q(
								Ne,
								{ key: 0 },
								[
									be(
										o_,
										{ class: "h-7", options: i.value },
										{
											default: He(() => [
												be(
													Os,
													{ variant: "ghost" },
													{
														icon: He(() => [s_]),
														_: 1,
													}
												),
											]),
											_: 1,
										},
										8,
										["options"]
									),
									l_,
								],
								64
						  ))
						: Ve("", !0),
					U("div", a_, [
						(j(!0),
						q(
							Ne,
							null,
							Pt(
								s.value,
								(u, c) => (
									j(),
									q(
										Ne,
										{ key: u.label },
										[
											(j(),
											Fe(
												zn(
													u.route
														? "router-link"
														: "button"
												),
												Ht(
													{
														class: [
															"flex items-center rounded px-0.5 py-1 text-lg font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-gray-400",
															[
																c ==
																s.value.length -
																	1
																	? "text-gray-900"
																	: "text-gray-600 hover:text-gray-700",
															],
														],
													},
													u.route
														? { to: u.route }
														: { onClick: u.onClick }
												),
												{
													default: He(() => [
														De(l.$slots, "prefix", {
															item: u,
														}),
														U(
															"span",
															null,
															Qe(u.label),
															1
														),
													]),
													_: 2,
												},
												1040,
												["class"]
											)),
											c != s.value.length - 1
												? (j(), q("span", u_, " / "))
												: Ve("", !0),
										],
										64
									)
								)
							),
							128
						)),
					]),
				])
			);
		},
	});
let c_ = 0;
function d_() {
	return ++c_;
}
function f_() {
	return "frappe-ui-" + d_();
}
const h_ = ["disabled", "id", "checked"],
	p_ = ["for"],
	th = Re({
		__name: "Checkbox",
		props: {
			size: { default: "sm" },
			label: {},
			checked: { type: Boolean },
			disabled: { type: Boolean },
			padding: { type: Boolean, default: !1 },
			modelValue: { type: Boolean },
			id: {},
		},
		setup(t) {
			var s;
			const e = t,
				n = Rf(),
				r = (s = e.id) != null ? s : f_(),
				o = H(() => [
					{ sm: "text-base font-medium", md: "text-lg font-medium" }[
						e.size
					],
					e.disabled ? "text-gray-500" : "text-gray-800",
					"select-none",
				]),
				i = H(() => {
					let l = e.disabled
							? "border-gray-300 bg-gray-50 text-gray-400"
							: "border-gray-500 text-gray-900 hover:border-gray-600 focus:ring-offset-0 focus:border-gray-900 active:border-gray-700 transition",
						a = e.disabled
							? ""
							: e.padding
							? "focus:ring-0"
							: "hover:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400 active:bg-gray-100",
						u = { sm: "w-3.5 h-3.5", md: "w-4 h-4" }[e.size];
					return [l, a, u];
				});
			return (l, a) => (
				j(),
				q(
					"div",
					{
						class: we([
							"inline-flex items-center space-x-2 rounded transition",
							{
								"px-2.5 py-1.5": l.padding && l.size === "sm",
								"px-3 py-2": l.padding && l.size === "md",
								"focus-within:bg-gray-100 focus-within:ring-2 focus-within:ring-gray-400 hover:bg-gray-200 active:bg-gray-300":
									l.padding && !l.disabled,
							},
						]),
					},
					[
						U(
							"input",
							Ht(
								{
									class: ["rounded-sm", i.value],
									type: "checkbox",
									disabled: l.disabled,
									id: ue(r),
									checked: !!l.modelValue,
									onChange:
										a[0] ||
										(a[0] = (u) =>
											l.$emit(
												"update:modelValue",
												u.target.checked
											)),
								},
								ue(n)
							),
							null,
							16,
							h_
						),
						l.label
							? (j(),
							  q(
									"label",
									{
										key: 0,
										class: we(["block", o.value]),
										for: ue(r),
									},
									Qe(l.label),
									11,
									p_
							  ))
							: Ve("", !0),
					],
					2
				)
			);
		},
	});
function nh(t, e, n) {
	var r;
	return function () {
		var o = this,
			i = arguments,
			s = function () {
				(r = void 0), n || t.apply(o, i);
			},
			l = n && !r;
		clearTimeout(r), (r = window.setTimeout(s, e)), l && t.apply(o, i);
	};
}
const m_ = {
		name: "Input",
		inheritAttrs: !1,
		expose: ["getInputValue"],
		components: { FeatherIcon: eo },
		props: {
			label: { type: String },
			type: {
				type: String,
				default: "text",
				validator(t) {
					let e = [
						"text",
						"number",
						"checkbox",
						"textarea",
						"select",
						"email",
						"password",
						"date",
					].includes(t);
					return (
						e ||
							console.warn(
								`Invalid value "${t}" for "type" prop for Input`
							),
						e
					);
				},
			},
			modelValue: { type: [String, Number, Boolean, Object, Array] },
			inputClass: { type: [String, Array, Object] },
			debounce: { type: Number },
			options: { type: Array },
			disabled: { type: Boolean },
			rows: { type: Number, default: 3 },
			placeholder: { type: String },
			iconLeft: { type: String },
		},
		emits: ["input", "change", "update:modelValue"],
		methods: {
			focus() {
				this.$refs.input.focus();
			},
			blur() {
				this.$refs.input.blur();
			},
			getInputValue(t) {
				let e = t ? t.target : this.$refs.input,
					n = e.value;
				return this.type == "checkbox" && (n = e.checked), n;
			},
		},
		computed: {
			passedInputValue() {
				return "value" in this.$attrs
					? this.$attrs.value
					: this.modelValue || null;
			},
			inputAttributes() {
				let t = {},
					e = (n) => {
						this.$emit("input", this.getInputValue(n));
					};
				return (
					this.debounce && (e = nh(e, this.debounce)),
					this.type == "checkbox" &&
						(t.checked = this.passedInputValue),
					Object.assign(t, this.$attrs, {
						onInput: e,
						onChange: (n) => {
							this.$emit("change", this.getInputValue(n)),
								this.$emit(
									"update:modelValue",
									this.getInputValue(n)
								);
						},
					})
				);
			},
			selectOptions() {
				return this.options
					.map((t) =>
						typeof t == "string" ? { label: t, value: t } : t
					)
					.filter(Boolean);
			},
			isNormalInput() {
				return [
					"text",
					"number",
					"checkbox",
					"email",
					"password",
					"date",
				].includes(this.type);
			},
		},
	},
	g_ = { key: 0, class: "mb-2 block text-sm leading-4 text-gray-700" },
	y_ = ["type", "disabled", "placeholder", "value"],
	v_ = ["placeholder", "value", "disabled", "rows"],
	b_ = ["disabled"],
	w_ = ["value", "disabled", "selected"],
	x_ = { key: 1, class: "ml-2 inline-block text-base leading-4" };
function k_(t, e, n, r, o, i) {
	const s = nt("FeatherIcon");
	return (
		j(),
		q(
			"label",
			{
				class: we([
					n.type == "checkbox" ? "flex" : "block",
					t.$attrs.class,
				]),
			},
			[
				n.label && n.type != "checkbox"
					? (j(), q("span", g_, Qe(n.label), 1))
					: Ve("", !0),
				U(
					"div",
					{
						class: we([
							"relative flex",
							{
								"items-center":
									i.isNormalInput || n.type == "select",
							},
						]),
					},
					[
						n.iconLeft && n.type != "checkbox"
							? (j(),
							  Fe(
									s,
									{
										key: 0,
										name: n.iconLeft,
										class: we([
											"absolute mx-2 h-4 w-4 text-gray-600",
											{ "mt-2": n.type == "textarea" },
										]),
									},
									null,
									8,
									["name", "class"]
							  ))
							: Ve("", !0),
						i.isNormalInput
							? (j(),
							  q(
									"input",
									Ht({ key: 1 }, i.inputAttributes, {
										class: [
											"border-gray-400 placeholder-gray-500",
											[
												{
													"form-input block w-full":
														n.type != "checkbox",
													"form-checkbox":
														n.type == "checkbox",
													"pl-8":
														n.iconLeft &&
														n.type != "checkbox",
												},
												n.inputClass,
											],
										],
										ref: "input",
										type: n.type || "text",
										disabled: n.disabled,
										placeholder: n.placeholder,
										value: i.passedInputValue,
									}),
									null,
									16,
									y_
							  ))
							: Ve("", !0),
						n.type === "textarea"
							? (j(),
							  q(
									"textarea",
									Ht({ key: 2 }, i.inputAttributes, {
										placeholder: n.placeholder,
										class: [
											"placeholder-gray-500",
											[
												"form-textarea block w-full resize-none",
												n.inputClass,
												{ "pl-8": n.iconLeft },
											],
										],
										ref: "input",
										value: i.passedInputValue,
										disabled: n.disabled,
										rows: n.rows,
									}),
									null,
									16,
									v_
							  ))
							: Ve("", !0),
						n.type === "select"
							? (j(),
							  q(
									"select",
									Ht({ key: 3 }, i.inputAttributes, {
										class: [
											"form-select block w-full",
											{ "pl-8": n.iconLeft },
										],
										ref: "input",
										disabled: n.disabled,
									}),
									[
										(j(!0),
										q(
											Ne,
											null,
											Pt(
												i.selectOptions,
												(l) => (
													j(),
													q(
														"option",
														{
															key: l.value,
															value: l.value,
															disabled:
																l.disabled ||
																!1,
															selected:
																i.passedInputValue ===
																l.value,
														},
														Qe(l.label),
														9,
														w_
													)
												)
											),
											128
										)),
									],
									16,
									b_
							  ))
							: Ve("", !0),
					],
					2
				),
				n.label && n.type == "checkbox"
					? (j(), q("span", x_, Qe(n.label), 1))
					: Ve("", !0),
			],
			2
		)
	);
}
const S_ = je(m_, [["render", k_]]),
	__ = {
		name: "DatePicker",
		props: [
			"modelValue",
			"placeholder",
			"readonly",
			"formatValue",
			"inputClass",
		],
		emits: ["update:modelValue"],
		components: { Input: S_, FeatherIcon: eo, Popover: Ru },
		data() {
			return { currentYear: null, currentMonth: null };
		},
		created() {
			this.selectCurrentMonthYear();
		},
		computed: {
			today() {
				return this.getDate();
			},
			datesAsWeeks() {
				let t = [],
					e = this.dates.slice();
				for (; e.length; ) {
					let n = e.splice(0, 7);
					t.push(n);
				}
				return t;
			},
			dates() {
				if (!(this.currentYear && this.currentMonth)) return [];
				let t = this.currentMonth - 1,
					e = this.currentYear,
					n = this.getDate(e, t, 1),
					r = this.getDate(e, t + 1, 0),
					o = n.getDay(),
					i = 6 - r.getDay(),
					s = this.getDatesAfter(n, -o),
					l = this.getDatesAfter(r, i),
					a = this.getDaysInMonth(t, e),
					u = this.getDatesAfter(n, a - 1),
					c = [...s, n, ...u, ...l];
				if (c.length < 42) {
					const d = this.getDatesAfter(c.at(-1), 42 - c.length);
					c = c.concat(...d);
				}
				return c;
			},
			formatMonth() {
				return this.getDate(
					this.currentYear,
					this.currentMonth - 1,
					1
				).toLocaleString("en-US", { month: "short", year: "numeric" });
			},
		},
		methods: {
			selectDate(t) {
				this.$emit("update:modelValue", this.toValue(t));
			},
			selectCurrentMonthYear() {
				let t = this.modelValue
					? this.getDate(this.modelValue)
					: this.getDate();
				(this.currentYear = t.getFullYear()),
					(this.currentMonth = t.getMonth() + 1);
			},
			prevMonth() {
				this.changeMonth(-1);
			},
			nextMonth() {
				this.changeMonth(1);
			},
			changeMonth(t) {
				(this.currentMonth = this.currentMonth + t),
					this.currentMonth < 1 &&
						((this.currentMonth = 12),
						(this.currentYear = this.currentYear - 1)),
					this.currentMonth > 12 &&
						((this.currentMonth = 1),
						(this.currentYear = this.currentYear + 1));
			},
			getDatesAfter(t, e) {
				let n = 1;
				e < 0 && ((n = -1), (e = Math.abs(e)));
				let r = [];
				for (; e; )
					(t = this.getDate(
						t.getFullYear(),
						t.getMonth(),
						t.getDate() + n
					)),
						r.push(t),
						e--;
				return n === -1 ? r.reverse() : r;
			},
			getDaysInMonth(t, e) {
				let r = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t];
				return t === 1 && this.isLeapYear(e) ? 29 : r;
			},
			isLeapYear(t) {
				return t % 400 === 0 ? !0 : t % 100 === 0 ? !1 : t % 4 === 0;
			},
			toValue(t) {
				return t
					? (t.setHours(0, -t.getTimezoneOffset(), 0, 0),
					  t.toISOString().slice(0, 10))
					: "";
			},
			getDate(...t) {
				return new Date(...t);
			},
		},
	},
	C_ = { class: "mt-1 select-none p-3 text-left" },
	M_ = { class: "flex items-center justify-between" },
	E_ = { class: "text-base font-medium text-blue-500" },
	T_ = { class: "flex" },
	A_ = {
		class: "grid h-5 w-5 cursor-pointer place-items-center rounded-md hover:bg-gray-100",
	},
	O_ = {
		class: "ml-2 grid h-5 w-5 cursor-pointer place-items-center rounded-md hover:bg-gray-100",
	},
	R_ = { class: "mt-2 text-sm" },
	P_ = { class: "grid w-full grid-cols-7 place-items-center text-gray-600" },
	I_ = { class: "grid w-full grid-cols-7 place-items-center gap-1" },
	N_ = ["onClick"],
	D_ = { class: "mt-2 flex w-full justify-end" },
	j_ = ["onClick"];
function L_(t, e, n, r, o, i) {
	const s = nt("Input"),
		l = nt("FeatherIcon"),
		a = nt("Popover");
	return (
		j(),
		Fe(
			a,
			{ onOpen: i.selectCurrentMonthYear, transition: "default" },
			{
				target: He(({ togglePopover: u }) => [
					be(
						s,
						{
							type: "text",
							"icon-left": "calendar",
							class: we(n.inputClass),
							value:
								n.modelValue && n.formatValue
									? n.formatValue(n.modelValue)
									: n.modelValue || "",
							placeholder: n.placeholder,
							onFocus: (c) => (n.readonly ? null : u()),
							readonly: "",
						},
						null,
						8,
						["class", "value", "placeholder", "onFocus"]
					),
				]),
				"body-main": He(({ togglePopover: u }) => [
					U("div", C_, [
						U("div", M_, [
							U("span", E_, Qe(i.formatMonth), 1),
							U("span", T_, [
								U("div", A_, [
									be(
										l,
										{
											onClick: i.prevMonth,
											name: "chevron-left",
											class: "h-4 w-4",
										},
										null,
										8,
										["onClick"]
									),
								]),
								U("div", O_, [
									be(
										l,
										{
											onClick: i.nextMonth,
											name: "chevron-right",
											class: "h-4 w-4",
										},
										null,
										8,
										["onClick"]
									),
								]),
							]),
						]),
						U("div", R_, [
							U("div", P_, [
								(j(),
								q(
									Ne,
									null,
									Pt(
										["S", "M", "T", "W", "T", "F", "S"],
										(c, d) =>
											U(
												"div",
												{
													class: "grid h-6 w-6 place-items-center gap-1 text-center",
													key: d,
												},
												Qe(c),
												1
											)
									),
									64
								)),
							]),
							(j(!0),
							q(
								Ne,
								null,
								Pt(
									i.datesAsWeeks,
									(c, d) => (
										j(),
										q("div", { key: d, class: "mt-1" }, [
											U("div", I_, [
												(j(!0),
												q(
													Ne,
													null,
													Pt(
														c,
														(h) => (
															j(),
															q(
																"div",
																{
																	key: i.toValue(
																		h
																	),
																	class: we([
																		"grid h-6 w-6 cursor-pointer place-items-center rounded-md hover:bg-blue-100 hover:text-blue-700",
																		{
																			"text-gray-600":
																				h.getMonth() !==
																				o.currentMonth -
																					1,
																			"text-blue-500":
																				i.toValue(
																					h
																				) ===
																				i.toValue(
																					i.today
																				),
																			"bg-blue-100 font-semibold text-blue-500":
																				i.toValue(
																					h
																				) ===
																				n.modelValue,
																		},
																	]),
																	onClick:
																		() => {
																			i.selectDate(
																				h
																			),
																				u();
																		},
																},
																Qe(h.getDate()),
																11,
																N_
															)
														)
													),
													128
												)),
											]),
										])
									)
								),
								128
							)),
						]),
						U("div", D_, [
							U(
								"div",
								{
									class: "cursor-pointer rounded-md px-2 py-1 text-sm hover:bg-gray-100",
									onClick: () => {
										i.selectDate(""), u();
									},
								},
								" Clear ",
								8,
								j_
							),
						]),
					]),
				]),
				_: 1,
			},
			8,
			["onOpen"]
		)
	);
}
const Zj = je(__, [["render", L_]]),
	$_ = {
		name: "Dialog",
		props: {
			modelValue: { type: Boolean, required: !0 },
			options: {
				type: Object,
				default() {
					return {};
				},
			},
		},
		emits: ["update:modelValue", "close", "after-leave"],
		components: {
			HDialog: jk,
			DialogPanel: Lk,
			DialogTitle: $k,
			TransitionChild: vy,
			TransitionRoot: by,
			Button: Os,
			FeatherIcon: eo,
		},
		data() {
			return { dialogActions: [] };
		},
		watch: {
			"options.actions": {
				handler(t) {
					t &&
						(this.dialogActions = t.map((e) => {
							let n = X(!1);
							return ye(z({}, e), {
								loading: n,
								onClick: e.onClick
									? () =>
											hr(this, null, function* () {
												n.value = !0;
												try {
													yield e.onClick(this.close);
												} finally {
													n.value = !1;
												}
											})
									: this.close,
							});
						}));
				},
				immediate: !0,
			},
		},
		methods: {
			close() {
				this.open = !1;
			},
		},
		computed: {
			open: {
				get() {
					return this.modelValue;
				},
				set(t) {
					this.$emit("update:modelValue", t),
						t || this.$emit("close");
				},
			},
			icon() {
				var e;
				if (!((e = this.options) != null && e.icon)) return null;
				let t = this.options.icon;
				return typeof t == "string" && (t = { name: t }), t;
			},
			dialogPositionClasses() {
				var e;
				let t =
					((e = this.options) == null ? void 0 : e.position) ||
					"center";
				return {
					"justify-center": t === "center",
					"pt-[20vh]": t === "top",
				};
			},
		},
	},
	B_ = ["data-dialog"],
	z_ = { class: "bg-white px-4 pb-6 pt-5 sm:px-6" },
	H_ = { class: "flex" },
	F_ = { class: "flex-1" },
	V_ = { class: "mb-6 flex items-center justify-between" },
	W_ = { class: "flex items-center space-x-2" },
	U_ = { class: "text-2xl font-semibold leading-6 text-gray-900" },
	K_ = U(
		"svg",
		{
			width: "16",
			height: "16",
			viewBox: "0 0 16 16",
			fill: "none",
			xmlns: "http://www.w3.org/2000/svg",
		},
		[
			U("path", {
				"fill-rule": "evenodd",
				"clip-rule": "evenodd",
				d: "M12.8567 3.85355C13.052 3.65829 13.052 3.34171 12.8567 3.14645C12.6615 2.95118 12.3449 2.95118 12.1496 3.14645L8.00201 7.29405L3.85441 3.14645C3.65914 2.95118 3.34256 2.95118 3.1473 3.14645C2.95204 3.34171 2.95204 3.65829 3.1473 3.85355L7.29491 8.00116L3.14645 12.1496C2.95118 12.3449 2.95118 12.6615 3.14645 12.8567C3.34171 13.052 3.65829 13.052 3.85355 12.8567L8.00201 8.70827L12.1505 12.8567C12.3457 13.052 12.6623 13.052 12.8576 12.8567C13.0528 12.6615 13.0528 12.3449 12.8576 12.1496L8.70912 8.00116L12.8567 3.85355Z",
				fill: "#383838",
			}),
		],
		-1
	),
	q_ = { key: 0, class: "text-p-base text-gray-700" },
	J_ = { key: 0, class: "px-4 pb-7 pt-4 sm:px-6" },
	G_ = { class: "space-y-2" };
function Y_(t, e, n, r, o, i) {
	const s = nt("TransitionChild"),
		l = nt("FeatherIcon"),
		a = nt("DialogTitle"),
		u = nt("Button"),
		c = nt("DialogPanel"),
		d = nt("HDialog"),
		h = nt("TransitionRoot");
	return (
		j(),
		Fe(
			h,
			{
				as: "template",
				show: i.open,
				onAfterLeave: e[0] || (e[0] = (p) => t.$emit("after-leave")),
			},
			{
				default: He(() => [
					be(
						d,
						{
							as: "div",
							class: "fixed inset-0 z-10 overflow-y-auto",
							onClose: i.close,
						},
						{
							default: He(() => [
								U(
									"div",
									{
										class: we([
											"flex min-h-screen flex-col items-center px-4 py-4 text-center",
											i.dialogPositionClasses,
										]),
									},
									[
										be(
											s,
											{
												as: "template",
												enter: "ease-out duration-150",
												"enter-from": "opacity-0",
												"enter-to": "opacity-100",
												leave: "ease-in duration-150",
												"leave-from": "opacity-100",
												"leave-to": "opacity-0",
											},
											{
												default: He(() => [
													U(
														"div",
														{
															class: "fixed inset-0 bg-black-overlay-200 transition-opacity",
															"data-dialog":
																n.options.title,
														},
														null,
														8,
														B_
													),
												]),
												_: 1,
											}
										),
										be(
											s,
											{
												as: "template",
												enter: "ease-out duration-150",
												"enter-from":
													"opacity-50 translate-y-2 scale-95",
												"enter-to":
													"opacity-100 translate-y-0 scale-100",
												leave: "ease-in duration-150",
												"leave-from":
													"opacity-100 translate-y-0 scale-100",
												"leave-to":
													"opacity-50 translate-y-4 translate-y-4 scale-95",
											},
											{
												default: He(() => [
													be(
														c,
														{
															class: we([
																"my-8 inline-block w-full transform overflow-hidden rounded-xl bg-white text-left align-middle shadow-xl transition-all",
																{
																	"max-w-7xl":
																		n
																			.options
																			.size ===
																		"7xl",
																	"max-w-6xl":
																		n
																			.options
																			.size ===
																		"6xl",
																	"max-w-5xl":
																		n
																			.options
																			.size ===
																		"5xl",
																	"max-w-4xl":
																		n
																			.options
																			.size ===
																		"4xl",
																	"max-w-3xl":
																		n
																			.options
																			.size ===
																		"3xl",
																	"max-w-2xl":
																		n
																			.options
																			.size ===
																		"2xl",
																	"max-w-xl":
																		n
																			.options
																			.size ===
																		"xl",
																	"max-w-lg":
																		n
																			.options
																			.size ===
																			"lg" ||
																		!n
																			.options
																			.size,
																	"max-w-md":
																		n
																			.options
																			.size ===
																		"md",
																	"max-w-sm":
																		n
																			.options
																			.size ===
																		"sm",
																	"max-w-xs":
																		n
																			.options
																			.size ===
																		"xs",
																},
															]),
														},
														{
															default: He(() => [
																De(
																	t.$slots,
																	"body",
																	{},
																	() => [
																		De(
																			t.$slots,
																			"body-main",
																			{},
																			() => [
																				U(
																					"div",
																					z_,
																					[
																						U(
																							"div",
																							H_,
																							[
																								U(
																									"div",
																									F_,
																									[
																										U(
																											"div",
																											V_,
																											[
																												U(
																													"div",
																													W_,
																													[
																														i.icon
																															? (j(),
																															  q(
																																	"div",
																																	{
																																		key: 0,
																																		class: we(
																																			[
																																				"flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full",
																																				{
																																					"bg-gray-100":
																																						!i
																																							.icon
																																							.appearance,
																																					"bg-yellow-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"warning",
																																					"bg-blue-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"info",
																																					"bg-red-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"danger",
																																					"bg-green-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"success",
																																				},
																																			]
																																		),
																																	},
																																	[
																																		be(
																																			l,
																																			{
																																				name: i
																																					.icon
																																					.name,
																																				class: we(
																																					[
																																						"h-4 w-4",
																																						{
																																							"text-gray-600":
																																								!i
																																									.icon
																																									.appearance,
																																							"text-yellow-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"warning",
																																							"text-blue-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"info",
																																							"text-red-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"danger",
																																							"text-green-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"success",
																																						},
																																					]
																																				),
																																				"aria-hidden":
																																					"true",
																																			},
																																			null,
																																			8,
																																			[
																																				"name",
																																				"class",
																																			]
																																		),
																																	],
																																	2
																															  ))
																															: Ve(
																																	"",
																																	!0
																															  ),
																														be(
																															a,
																															{
																																as: "header",
																															},
																															{
																																default:
																																	He(
																																		() => [
																																			De(
																																				t.$slots,
																																				"body-title",
																																				{},
																																				() => [
																																					U(
																																						"h3",
																																						U_,
																																						Qe(
																																							n
																																								.options
																																								.title ||
																																								"Untitled"
																																						),
																																						1
																																					),
																																				]
																																			),
																																		]
																																	),
																																_: 3,
																															}
																														),
																													]
																												),
																												be(
																													u,
																													{
																														variant:
																															"ghost",
																														onClick:
																															i.close,
																													},
																													{
																														icon: He(
																															() => [
																																K_,
																															]
																														),
																														_: 1,
																													},
																													8,
																													[
																														"onClick",
																													]
																												),
																											]
																										),
																										De(
																											t.$slots,
																											"body-content",
																											{},
																											() => [
																												n
																													.options
																													.message
																													? (j(),
																													  q(
																															"p",
																															q_,
																															Qe(
																																n
																																	.options
																																	.message
																															),
																															1
																													  ))
																													: Ve(
																															"",
																															!0
																													  ),
																											]
																										),
																									]
																								),
																							]
																						),
																					]
																				),
																			]
																		),
																		o
																			.dialogActions
																			.length ||
																		t.$slots
																			.actions
																			? (j(),
																			  q(
																					"div",
																					J_,
																					[
																						De(
																							t.$slots,
																							"actions",
																							Ut(
																								en(
																									{
																										close: i.close,
																									}
																								)
																							),
																							() => [
																								U(
																									"div",
																									G_,
																									[
																										(j(
																											!0
																										),
																										q(
																											Ne,
																											null,
																											Pt(
																												o.dialogActions,
																												(
																													p
																												) => (
																													j(),
																													Fe(
																														u,
																														Ht(
																															{
																																class: "w-full",
																																key: p.label,
																															},
																															p
																														),
																														{
																															default:
																																He(
																																	() => [
																																		_r(
																																			Qe(
																																				p.label
																																			),
																																			1
																																		),
																																	]
																																),
																															_: 2,
																														},
																														1040
																													)
																												)
																											),
																											128
																										)),
																									]
																								),
																							]
																						),
																					]
																			  ))
																			: Ve(
																					"",
																					!0
																			  ),
																	]
																),
															]),
															_: 3,
														},
														8,
														["class"]
													),
												]),
												_: 3,
											}
										),
									],
									2
								),
							]),
							_: 3,
						},
						8,
						["onClose"]
					),
				]),
				_: 3,
			},
			8,
			["show"]
		)
	);
}
const eL = je($_, [["render", Y_]]),
	Q_ = {
		name: "ErrorMessage",
		props: ["message"],
		computed: {
			errorMessage() {
				return this.message
					? this.message instanceof Error
						? this.message.messages || this.message.message
						: this.message
					: "";
			},
		},
	},
	X_ = ["innerHTML"];
function Z_(t, e, n, r, o, i) {
	return n.message
		? (j(),
		  q(
				"div",
				{
					key: 0,
					class: "whitespace-pre-line text-sm text-red-600",
					role: "alert",
					innerHTML: i.errorMessage,
				},
				null,
				8,
				X_
		  ))
		: Ve("", !0);
}
const tL = je(Q_, [["render", Z_]]);
class eC {
	constructor() {
		(this.listeners = {}), (this.failed = !1);
	}
	on(e, n) {
		(this.listeners[e] = this.listeners[e] || []),
			this.listeners[e].push(n);
	}
	trigger(e, n) {
		(this.listeners[e] || []).forEach((o) => {
			o.call(this, n);
		});
	}
	upload(e, n) {
		return new Promise((r, o) => {
			let i = new XMLHttpRequest();
			i.upload.addEventListener("loadstart", () => {
				this.trigger("start");
			}),
				i.upload.addEventListener("progress", (a) => {
					a.lengthComputable &&
						this.trigger("progress", {
							uploaded: a.loaded,
							total: a.total,
						});
				}),
				i.upload.addEventListener("load", () => {
					this.trigger("finish");
				}),
				i.addEventListener("error", () => {
					this.trigger("error"), o();
				}),
				(i.onreadystatechange = () => {
					if (i.readyState == XMLHttpRequest.DONE) {
						let a;
						if (i.status === 200) {
							let u = null;
							try {
								u = JSON.parse(i.responseText);
							} catch (d) {
								u = i.responseText;
							}
							let c = u.message || u;
							r(c);
						} else if (i.status === 403)
							a = JSON.parse(i.responseText);
						else {
							this.failed = !0;
							try {
								a = JSON.parse(i.responseText);
							} catch (u) {}
						}
						a && a.exc && console.error(JSON.parse(a.exc)[0]), o(a);
					}
				});
			const s = n.upload_endpoint || "/api/method/upload_file";
			i.open("POST", s, !0),
				i.setRequestHeader("Accept", "application/json"),
				window.csrf_token &&
					window.csrf_token !== "{{ csrf_token }}" &&
					i.setRequestHeader(
						"X-Frappe-CSRF-Token",
						window.csrf_token
					);
			let l = new FormData();
			e && l.append("file", e, e.name),
				l.append("is_private", n.private ? "1" : "0"),
				l.append("folder", n.folder || "Home"),
				n.file_url && l.append("file_url", n.file_url),
				n.doctype && l.append("doctype", n.doctype),
				n.docname && l.append("docname", n.docname),
				n.fieldname && l.append("fieldname", n.fieldname),
				n.method && l.append("method", n.method),
				n.type && l.append("type", n.type),
				i.send(l);
		});
	}
}
const tC = {
		name: "FileUploader",
		props: ["fileTypes", "uploadArgs", "validateFile"],
		data() {
			return {
				uploader: null,
				uploading: !1,
				uploaded: 0,
				error: null,
				message: "",
				total: 0,
				file: null,
				finishedUploading: !1,
			};
		},
		computed: {
			progress() {
				let t = Math.floor((this.uploaded / this.total) * 100);
				return isNaN(t) ? 0 : t;
			},
			success() {
				return this.finishedUploading && !this.error;
			},
		},
		methods: {
			openFileSelector() {
				this.$refs.input.click();
			},
			onFileAdd(t) {
				return hr(this, null, function* () {
					if (
						((this.error = null),
						(this.file = t.target.files[0]),
						this.file && this.validateFile)
					)
						try {
							let e = yield this.validateFile(this.file);
							e && (this.error = e);
						} catch (e) {
							this.error = e;
						}
					this.error || this.uploadFile(this.file);
				});
			},
			uploadFile(t) {
				return hr(this, null, function* () {
					(this.error = null),
						(this.uploaded = 0),
						(this.total = 0),
						(this.uploader = new eC()),
						this.uploader.on("start", () => {
							this.uploading = !0;
						}),
						this.uploader.on("progress", (e) => {
							(this.uploaded = e.uploaded),
								(this.total = e.total);
						}),
						this.uploader.on("error", () => {
							(this.uploading = !1),
								(this.error = "Error Uploading File");
						}),
						this.uploader.on("finish", () => {
							(this.uploading = !1),
								(this.finishedUploading = !0);
						}),
						this.uploader
							.upload(t, this.uploadArgs || {})
							.then((e) => {
								this.$emit("success", e);
							})
							.catch((e) => {
								this.uploading = !1;
								let n = "Error Uploading File";
								e != null && e._server_messages
									? (n = JSON.parse(
											JSON.parse(e._server_messages)[0]
									  ).message)
									: e != null &&
									  e.exc &&
									  (n = JSON.parse(e.exc)[0]
											.split(
												`
`
											)
											.slice(-2, -1)[0]),
									(this.error = n),
									this.$emit("failure", e);
							});
				});
			},
		},
	},
	nC = ["accept"];
function rC(t, e, n, r, o, i) {
	return (
		j(),
		q("div", null, [
			U(
				"input",
				{
					ref: "input",
					type: "file",
					accept: n.fileTypes,
					class: "hidden",
					onChange:
						e[0] ||
						(e[0] = (...s) => i.onFileAdd && i.onFileAdd(...s)),
				},
				null,
				40,
				nC
			),
			De(
				t.$slots,
				"default",
				Ut(
					en({
						file: o.file,
						uploading: o.uploading,
						progress: i.progress,
						uploaded: o.uploaded,
						message: o.message,
						error: o.error,
						total: o.total,
						success: i.success,
						openFileSelector: i.openFileSelector,
					})
				)
			),
		])
	);
}
const nL = je(tC, [["render", rC]]),
	oC = { class: "relative flex items-center" },
	iC = ["disabled", "id", "value"],
	sC = ["value", "disabled", "selected"],
	rL = Re({
		__name: "Select",
		props: {
			size: { default: "sm" },
			variant: { default: "subtle" },
			placeholder: {},
			disabled: { type: Boolean },
			id: {},
			modelValue: {},
			options: {},
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			const n = t,
				r = e,
				o = l0(),
				i = Rf();
			function s(d) {
				r("update:modelValue", d.target.value);
			}
			const l = H(() => {
					var d;
					return (
						((d = n.options) == null
							? void 0
							: d
									.map((h) =>
										typeof h == "string"
											? { label: h, value: h }
											: h
									)
									.filter(Boolean)) || []
					);
				}),
				a = H(() => (n.disabled ? "text-gray-500" : "text-gray-800")),
				u = H(() => {
					let d = {
							sm: "text-base rounded h-7",
							md: "text-base rounded h-8",
							lg: "text-lg rounded-md h-10",
							xl: "text-xl rounded-md h-10",
						}[n.size],
						h = {
							sm: ["py-0", o.prefix ? "pl-8" : "pl-2"],
							md: ["py-0", o.prefix ? "pl-9" : "pl-2.5"],
							lg: ["py-0", o.prefix ? "pl-10" : "pl-3"],
							xl: ["py-0", o.prefix ? "pl-10" : "pl-3"],
						}[n.size],
						p = n.disabled ? "disabled" : n.variant,
						g = {
							subtle: "border border-gray-100 bg-gray-100 hover:border-gray-200 hover:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							outline:
								"border border-gray-300 bg-white hover:border-gray-400 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							ghost: "bg-transparent border-transparent hover:bg-gray-200 focus:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							disabled: [
								"border",
								n.variant !== "ghost" ? "bg-gray-50" : "",
								n.variant === "outline"
									? "border-gray-300"
									: "border-transparent",
							],
						}[p];
					return [d, h, g, a.value, "transition-colors w-full"];
				});
			let c = H(
				() =>
					({ sm: "pl-2", md: "pl-2.5", lg: "pl-3", xl: "pl-3" }[
						n.size
					])
			);
			return (d, h) => (
				j(),
				q("div", oC, [
					d.$slots.prefix
						? (j(),
						  q(
								"div",
								{
									key: 0,
									class: we([
										"absolute inset-y-0 left-0 flex items-center",
										a.value,
										ue(c),
									]),
								},
								[De(d.$slots, "prefix")],
								2
						  ))
						: Ve("", !0),
					U(
						"select",
						Ht(
							{
								class: u.value,
								disabled: d.disabled,
								id: d.id,
								value: d.modelValue,
								onChange: s,
							},
							ue(i)
						),
						[
							(j(!0),
							q(
								Ne,
								null,
								Pt(
									l.value,
									(p) => (
										j(),
										q(
											"option",
											{
												key: p.value,
												value: p.value,
												disabled: p.disabled || !1,
												selected:
													d.modelValue === p.value,
											},
											Qe(p.label),
											9,
											sC
										)
									)
								),
								128
							)),
						],
						16,
						iC
					),
				])
			);
		},
	}),
	lC = ["placeholder", "disabled", "id", "value", "rows"],
	oL = Re({
		__name: "Textarea",
		props: {
			size: { default: "sm" },
			variant: { default: "subtle" },
			placeholder: {},
			disabled: { type: Boolean },
			id: {},
			modelValue: {},
			debounce: {},
			rows: { default: 3 },
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			const n = t,
				r = e,
				o = Rf(),
				i = H(() => {
					let a = {
							sm: "text-base rounded",
							md: "text-base rounded",
							lg: "text-lg rounded-md",
							xl: "text-xl rounded-md",
						}[n.size],
						u = {
							sm: ["py-1.5 px-2"],
							md: ["py-1.5 px-2.5"],
							lg: ["py-1.5 px-3"],
							xl: ["py-1.5 px-3"],
						}[n.size],
						c = n.disabled ? "disabled" : n.variant,
						d = {
							subtle: "border border-gray-100 bg-gray-100 placeholder-gray-500 hover:border-gray-200 hover:bg-gray-200 focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							outline:
								"border border-gray-300 bg-white placeholder-gray-500 hover:border-gray-400 hover:shadow-sm focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							disabled: [
								"border bg-gray-50 placeholder-gray-400",
								n.variant === "outline"
									? "border-gray-300"
									: "border-transparent",
							],
						}[c];
					return [
						a,
						u,
						d,
						n.disabled ? "text-gray-600" : "text-gray-800",
						"transition-colors w-full block",
					];
				});
			let s = (a) => {
				r("update:modelValue", a);
			};
			n.debounce && (s = nh(s, n.debounce));
			let l = (a) => {
				s(a.target.value);
			};
			return (a, u) => (
				j(),
				q(
					"textarea",
					Ht(
						{
							placeholder: a.placeholder,
							class: i.value,
							disabled: a.disabled,
							id: a.id,
							value: a.modelValue,
							rows: a.rows,
							onInput:
								u[0] || (u[0] = (...c) => ue(l) && ue(l)(...c)),
							onChange:
								u[1] || (u[1] = (...c) => ue(l) && ue(l)(...c)),
						},
						ue(o)
					),
					null,
					16,
					lC
				)
			);
		},
	}),
	iL = {
		__name: "Tabs",
		props: {
			tabs: { type: Array, required: !0 },
			modelValue: { type: Number, default: 0 },
			tablistClass: { type: String, default: "" },
			tabPanelClass: { type: String, default: "" },
			options: { type: Object, default: () => ({ indicatorLeft: 20 }) },
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			var d, h;
			const n = t,
				r = e,
				o = H({
					get: () => n.modelValue,
					set: (p) => r("update:modelValue", p),
				}),
				i = X([]),
				s = X(null),
				l = X((d = n.tabs) == null ? void 0 : d.length),
				a = X((h = n.options) == null ? void 0 : h.indicatorLeft),
				u = X("");
			function c(p) {
				p >= l.value && (p = l.value - 1);
				const g = i.value[p].el;
				(s.value.style.width = `${g.offsetWidth}px`),
					(a.value = g.offsetLeft);
			}
			return (
				it(o, (p) => {
					p >= l.value && (o.value = l.value - 1), zt(() => c(p));
				}),
				Xe(() => {
					c(o.value),
						zt(() => {
							u.value = "transition-all duration-300 ease-in-out";
						});
				}),
				(p, g) => (
					j(),
					Fe(
						ue(Zk),
						{
							as: "div",
							class: "flex flex-1 flex-col",
							defaultIndex: o.value,
							selectedIndex: o.value,
							onChange: g[0] || (g[0] = (y) => (o.value = y)),
						},
						{
							default: He(() => [
								be(
									ue(e8),
									{
										class: we([
											"relative flex items-center gap-6 overflow-x-auto border-b pl-5",
											t.tablistClass,
										]),
									},
									{
										default: He(() => [
											(j(!0),
											q(
												Ne,
												null,
												Pt(
													t.tabs,
													(y, b) => (
														j(),
														Fe(
															ue(t8),
															{
																ref_for: !0,
																ref_key:
																	"tabRef",
																ref: i,
																as: "template",
																key: b,
																class: "focus:outline-none focus:transition-none",
															},
															{
																default: He(
																	({
																		selected:
																			w,
																	}) => [
																		De(
																			p.$slots,
																			"tab",
																			Ut(
																				en(
																					{
																						tab: y,
																						selected:
																							w,
																					}
																				)
																			),
																			() => [
																				U(
																					"button",
																					{
																						class: we(
																							[
																								"flex items-center gap-2 border-b border-transparent py-2.5 text-base text-gray-600 duration-300 ease-in-out hover:border-gray-400 hover:text-gray-900",
																								{
																									"text-gray-900":
																										w,
																								},
																							]
																						),
																					},
																					[
																						y.icon
																							? (j(),
																							  Fe(
																									zn(
																										y.icon
																									),
																									{
																										key: 0,
																										class: "h-5",
																									}
																							  ))
																							: Ve(
																									"",
																									!0
																							  ),
																						_r(
																							" " +
																								Qe(
																									y.label
																								),
																							1
																						),
																					],
																					2
																				),
																			]
																		),
																	]
																),
																_: 2,
															},
															1024
														)
													)
												),
												128
											)),
											U(
												"div",
												{
													ref_key: "indicator",
													ref: s,
													class: we([
														"absolute bottom-0 h-px bg-gray-900",
														u.value,
													]),
													style: ao({
														left: `${a.value}px`,
													}),
												},
												null,
												6
											),
										]),
										_: 3,
									},
									8,
									["class"]
								),
								be(
									ue(n8),
									{
										class: we([
											"flex flex-1 overflow-hidden",
											t.tabPanelClass,
										]),
									},
									{
										default: He(() => [
											(j(!0),
											q(
												Ne,
												null,
												Pt(
													t.tabs,
													(y, b) => (
														j(),
														Fe(
															ue(r8),
															{
																class: "flex flex-1 flex-col overflow-y-auto focus:outline-none",
																key: b,
															},
															{
																default: He(
																	() => [
																		De(
																			p.$slots,
																			"default",
																			Ut(
																				en(
																					{
																						tab: y,
																					}
																				)
																			)
																		),
																	]
																),
																_: 2,
															},
															1024
														)
													)
												),
												128
											)),
										]),
										_: 3,
									},
									8,
									["class"]
								),
							]),
							_: 3,
						},
						8,
						["defaultIndex", "selectedIndex"]
					)
				)
			);
		},
	};
function Lt(t) {
	this.content = t;
}
Lt.prototype = {
	constructor: Lt,
	find: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			if (this.content[e] === t) return e;
		return -1;
	},
	get: function (t) {
		var e = this.find(t);
		return e == -1 ? void 0 : this.content[e + 1];
	},
	update: function (t, e, n) {
		var r = n && n != t ? this.remove(n) : this,
			o = r.find(t),
			i = r.content.slice();
		return (
			o == -1 ? i.push(n || t, e) : ((i[o + 1] = e), n && (i[o] = n)),
			new Lt(i)
		);
	},
	remove: function (t) {
		var e = this.find(t);
		if (e == -1) return this;
		var n = this.content.slice();
		return n.splice(e, 2), new Lt(n);
	},
	addToStart: function (t, e) {
		return new Lt([t, e].concat(this.remove(t).content));
	},
	addToEnd: function (t, e) {
		var n = this.remove(t).content.slice();
		return n.push(t, e), new Lt(n);
	},
	addBefore: function (t, e, n) {
		var r = this.remove(e),
			o = r.content.slice(),
			i = r.find(t);
		return o.splice(i == -1 ? o.length : i, 0, e, n), new Lt(o);
	},
	forEach: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			t(this.content[e], this.content[e + 1]);
	},
	prepend: function (t) {
		return (
			(t = Lt.from(t)),
			t.size ? new Lt(t.content.concat(this.subtract(t).content)) : this
		);
	},
	append: function (t) {
		return (
			(t = Lt.from(t)),
			t.size ? new Lt(this.subtract(t).content.concat(t.content)) : this
		);
	},
	subtract: function (t) {
		var e = this;
		t = Lt.from(t);
		for (var n = 0; n < t.content.length; n += 2)
			e = e.remove(t.content[n]);
		return e;
	},
	toObject: function () {
		var t = {};
		return (
			this.forEach(function (e, n) {
				t[e] = n;
			}),
			t
		);
	},
	get size() {
		return this.content.length >> 1;
	},
};
Lt.from = function (t) {
	if (t instanceof Lt) return t;
	var e = [];
	if (t) for (var n in t) e.push(n, t[n]);
	return new Lt(e);
};
function Ly(t, e, n) {
	for (let r = 0; ; r++) {
		if (r == t.childCount || r == e.childCount)
			return t.childCount == e.childCount ? null : n;
		let o = t.child(r),
			i = e.child(r);
		if (o == i) {
			n += o.nodeSize;
			continue;
		}
		if (!o.sameMarkup(i)) return n;
		if (o.isText && o.text != i.text) {
			for (let s = 0; o.text[s] == i.text[s]; s++) n++;
			return n;
		}
		if (o.content.size || i.content.size) {
			let s = Ly(o.content, i.content, n + 1);
			if (s != null) return s;
		}
		n += o.nodeSize;
	}
}
function $y(t, e, n, r) {
	for (let o = t.childCount, i = e.childCount; ; ) {
		if (o == 0 || i == 0) return o == i ? null : { a: n, b: r };
		let s = t.child(--o),
			l = e.child(--i),
			a = s.nodeSize;
		if (s == l) {
			(n -= a), (r -= a);
			continue;
		}
		if (!s.sameMarkup(l)) return { a: n, b: r };
		if (s.isText && s.text != l.text) {
			let u = 0,
				c = Math.min(s.text.length, l.text.length);
			for (
				;
				u < c &&
				s.text[s.text.length - u - 1] == l.text[l.text.length - u - 1];

			)
				u++, n--, r--;
			return { a: n, b: r };
		}
		if (s.content.size || l.content.size) {
			let u = $y(s.content, l.content, n - 1, r - 1);
			if (u) return u;
		}
		(n -= a), (r -= a);
	}
}
class J {
	constructor(e, n) {
		if (((this.content = e), (this.size = n || 0), n == null))
			for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
	}
	nodesBetween(e, n, r, o = 0, i) {
		for (let s = 0, l = 0; l < n; s++) {
			let a = this.content[s],
				u = l + a.nodeSize;
			if (u > e && r(a, o + l, i || null, s) !== !1 && a.content.size) {
				let c = l + 1;
				a.nodesBetween(
					Math.max(0, e - c),
					Math.min(a.content.size, n - c),
					r,
					o + c
				);
			}
			l = u;
		}
	}
	descendants(e) {
		this.nodesBetween(0, this.size, e);
	}
	textBetween(e, n, r, o) {
		let i = "",
			s = !0;
		return (
			this.nodesBetween(
				e,
				n,
				(l, a) => {
					let u = l.isText
						? l.text.slice(Math.max(e, a) - a, n - a)
						: l.isLeaf
						? o
							? typeof o == "function"
								? o(l)
								: o
							: l.type.spec.leafText
							? l.type.spec.leafText(l)
							: ""
						: "";
					l.isBlock &&
						((l.isLeaf && u) || l.isTextblock) &&
						r &&
						(s ? (s = !1) : (i += r)),
						(i += u);
				},
				0
			),
			i
		);
	}
	append(e) {
		if (!e.size) return this;
		if (!this.size) return e;
		let n = this.lastChild,
			r = e.firstChild,
			o = this.content.slice(),
			i = 0;
		for (
			n.isText &&
			n.sameMarkup(r) &&
			((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
			i < e.content.length;
			i++
		)
			o.push(e.content[i]);
		return new J(o, this.size + e.size);
	}
	cut(e, n = this.size) {
		if (e == 0 && n == this.size) return this;
		let r = [],
			o = 0;
		if (n > e)
			for (let i = 0, s = 0; s < n; i++) {
				let l = this.content[i],
					a = s + l.nodeSize;
				a > e &&
					((s < e || a > n) &&
						(l.isText
							? (l = l.cut(
									Math.max(0, e - s),
									Math.min(l.text.length, n - s)
							  ))
							: (l = l.cut(
									Math.max(0, e - s - 1),
									Math.min(l.content.size, n - s - 1)
							  ))),
					r.push(l),
					(o += l.nodeSize)),
					(s = a);
			}
		return new J(r, o);
	}
	cutByIndex(e, n) {
		return e == n
			? J.empty
			: e == 0 && n == this.content.length
			? this
			: new J(this.content.slice(e, n));
	}
	replaceChild(e, n) {
		let r = this.content[e];
		if (r == n) return this;
		let o = this.content.slice(),
			i = this.size + n.nodeSize - r.nodeSize;
		return (o[e] = n), new J(o, i);
	}
	addToStart(e) {
		return new J([e].concat(this.content), this.size + e.nodeSize);
	}
	addToEnd(e) {
		return new J(this.content.concat(e), this.size + e.nodeSize);
	}
	eq(e) {
		if (this.content.length != e.content.length) return !1;
		for (let n = 0; n < this.content.length; n++)
			if (!this.content[n].eq(e.content[n])) return !1;
		return !0;
	}
	get firstChild() {
		return this.content.length ? this.content[0] : null;
	}
	get lastChild() {
		return this.content.length
			? this.content[this.content.length - 1]
			: null;
	}
	get childCount() {
		return this.content.length;
	}
	child(e) {
		let n = this.content[e];
		if (!n)
			throw new RangeError("Index " + e + " out of range for " + this);
		return n;
	}
	maybeChild(e) {
		return this.content[e] || null;
	}
	forEach(e) {
		for (let n = 0, r = 0; n < this.content.length; n++) {
			let o = this.content[n];
			e(o, r, n), (r += o.nodeSize);
		}
	}
	findDiffStart(e, n = 0) {
		return Ly(this, e, n);
	}
	findDiffEnd(e, n = this.size, r = e.size) {
		return $y(this, e, n, r);
	}
	findIndex(e, n = -1) {
		if (e == 0) return Sl(0, e);
		if (e == this.size) return Sl(this.content.length, e);
		if (e > this.size || e < 0)
			throw new RangeError(`Position ${e} outside of fragment (${this})`);
		for (let r = 0, o = 0; ; r++) {
			let i = this.child(r),
				s = o + i.nodeSize;
			if (s >= e) return s == e || n > 0 ? Sl(r + 1, s) : Sl(r, o);
			o = s;
		}
	}
	toString() {
		return "<" + this.toStringInner() + ">";
	}
	toStringInner() {
		return this.content.join(", ");
	}
	toJSON() {
		return this.content.length ? this.content.map((e) => e.toJSON()) : null;
	}
	static fromJSON(e, n) {
		if (!n) return J.empty;
		if (!Array.isArray(n))
			throw new RangeError("Invalid input for Fragment.fromJSON");
		return new J(n.map(e.nodeFromJSON));
	}
	static fromArray(e) {
		if (!e.length) return J.empty;
		let n,
			r = 0;
		for (let o = 0; o < e.length; o++) {
			let i = e[o];
			(r += i.nodeSize),
				o && i.isText && e[o - 1].sameMarkup(i)
					? (n || (n = e.slice(0, o)),
					  (n[n.length - 1] = i.withText(
							n[n.length - 1].text + i.text
					  )))
					: n && n.push(i);
		}
		return new J(n || e, r);
	}
	static from(e) {
		if (!e) return J.empty;
		if (e instanceof J) return e;
		if (Array.isArray(e)) return this.fromArray(e);
		if (e.attrs) return new J([e], e.nodeSize);
		throw new RangeError(
			"Can not convert " +
				e +
				" to a Fragment" +
				(e.nodesBetween
					? " (looks like multiple versions of prosemirror-model were loaded)"
					: "")
		);
	}
}
J.empty = new J([], 0);
const gc = { index: 0, offset: 0 };
function Sl(t, e) {
	return (gc.index = t), (gc.offset = e), gc;
}
function ga(t, e) {
	if (t === e) return !0;
	if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
	let n = Array.isArray(t);
	if (Array.isArray(e) != n) return !1;
	if (n) {
		if (t.length != e.length) return !1;
		for (let r = 0; r < t.length; r++) if (!ga(t[r], e[r])) return !1;
	} else {
		for (let r in t) if (!(r in e) || !ga(t[r], e[r])) return !1;
		for (let r in e) if (!(r in t)) return !1;
	}
	return !0;
}
let ot = class _d {
	constructor(e, n) {
		(this.type = e), (this.attrs = n);
	}
	addToSet(e) {
		let n,
			r = !1;
		for (let o = 0; o < e.length; o++) {
			let i = e[o];
			if (this.eq(i)) return e;
			if (this.type.excludes(i.type)) n || (n = e.slice(0, o));
			else {
				if (i.type.excludes(this.type)) return e;
				!r &&
					i.type.rank > this.type.rank &&
					(n || (n = e.slice(0, o)), n.push(this), (r = !0)),
					n && n.push(i);
			}
		}
		return n || (n = e.slice()), r || n.push(this), n;
	}
	removeFromSet(e) {
		for (let n = 0; n < e.length; n++)
			if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
		return !1;
	}
	eq(e) {
		return this == e || (this.type == e.type && ga(this.attrs, e.attrs));
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return e;
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
		let r = e.marks[n.type];
		if (!r)
			throw new RangeError(
				`There is no mark type ${n.type} in this schema`
			);
		return r.create(n.attrs);
	}
	static sameSet(e, n) {
		if (e == n) return !0;
		if (e.length != n.length) return !1;
		for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
		return !0;
	}
	static setFrom(e) {
		if (!e || (Array.isArray(e) && e.length == 0)) return _d.none;
		if (e instanceof _d) return [e];
		let n = e.slice();
		return n.sort((r, o) => r.type.rank - o.type.rank), n;
	}
};
ot.none = [];
class ya extends Error {}
class se {
	constructor(e, n, r) {
		(this.content = e), (this.openStart = n), (this.openEnd = r);
	}
	get size() {
		return this.content.size - this.openStart - this.openEnd;
	}
	insertAt(e, n) {
		let r = zy(this.content, e + this.openStart, n);
		return r && new se(r, this.openStart, this.openEnd);
	}
	removeBetween(e, n) {
		return new se(
			By(this.content, e + this.openStart, n + this.openStart),
			this.openStart,
			this.openEnd
		);
	}
	eq(e) {
		return (
			this.content.eq(e.content) &&
			this.openStart == e.openStart &&
			this.openEnd == e.openEnd
		);
	}
	toString() {
		return this.content + "(" + this.openStart + "," + this.openEnd + ")";
	}
	toJSON() {
		if (!this.content.size) return null;
		let e = { content: this.content.toJSON() };
		return (
			this.openStart > 0 && (e.openStart = this.openStart),
			this.openEnd > 0 && (e.openEnd = this.openEnd),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) return se.empty;
		let r = n.openStart || 0,
			o = n.openEnd || 0;
		if (typeof r != "number" || typeof o != "number")
			throw new RangeError("Invalid input for Slice.fromJSON");
		return new se(J.fromJSON(e, n.content), r, o);
	}
	static maxOpen(e, n = !0) {
		let r = 0,
			o = 0;
		for (
			let i = e.firstChild;
			i && !i.isLeaf && (n || !i.type.spec.isolating);
			i = i.firstChild
		)
			r++;
		for (
			let i = e.lastChild;
			i && !i.isLeaf && (n || !i.type.spec.isolating);
			i = i.lastChild
		)
			o++;
		return new se(e, r, o);
	}
}
se.empty = new se(J.empty, 0, 0);
function By(t, e, n) {
	let { index: r, offset: o } = t.findIndex(e),
		i = t.maybeChild(r),
		{ index: s, offset: l } = t.findIndex(n);
	if (o == e || i.isText) {
		if (l != n && !t.child(s).isText)
			throw new RangeError("Removing non-flat range");
		return t.cut(0, e).append(t.cut(n));
	}
	if (r != s) throw new RangeError("Removing non-flat range");
	return t.replaceChild(r, i.copy(By(i.content, e - o - 1, n - o - 1)));
}
function zy(t, e, n, r) {
	let { index: o, offset: i } = t.findIndex(e),
		s = t.maybeChild(o);
	if (i == e || s.isText)
		return r && !r.canReplace(o, o, n)
			? null
			: t.cut(0, e).append(n).append(t.cut(e));
	let l = zy(s.content, e - i - 1, n);
	return l && t.replaceChild(o, s.copy(l));
}
function aC(t, e, n) {
	if (n.openStart > t.depth)
		throw new ya("Inserted content deeper than insertion position");
	if (t.depth - n.openStart != e.depth - n.openEnd)
		throw new ya("Inconsistent open depths");
	return Hy(t, e, n, 0);
}
function Hy(t, e, n, r) {
	let o = t.index(r),
		i = t.node(r);
	if (o == e.index(r) && r < t.depth - n.openStart) {
		let s = Hy(t, e, n, r + 1);
		return i.copy(i.content.replaceChild(o, s));
	} else if (n.content.size)
		if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
			let s = t.parent,
				l = s.content;
			return Io(
				s,
				l
					.cut(0, t.parentOffset)
					.append(n.content)
					.append(l.cut(e.parentOffset))
			);
		} else {
			let { start: s, end: l } = uC(n, t);
			return Io(i, Vy(t, s, l, e, r));
		}
	else return Io(i, va(t, e, r));
}
function Fy(t, e) {
	if (!e.type.compatibleContent(t.type))
		throw new ya("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Cd(t, e, n) {
	let r = t.node(n);
	return Fy(r, e.node(n)), r;
}
function Po(t, e) {
	let n = e.length - 1;
	n >= 0 && t.isText && t.sameMarkup(e[n])
		? (e[n] = t.withText(e[n].text + t.text))
		: e.push(t);
}
function cs(t, e, n, r) {
	let o = (e || t).node(n),
		i = 0,
		s = e ? e.index(n) : o.childCount;
	t &&
		((i = t.index(n)),
		t.depth > n ? i++ : t.textOffset && (Po(t.nodeAfter, r), i++));
	for (let l = i; l < s; l++) Po(o.child(l), r);
	e && e.depth == n && e.textOffset && Po(e.nodeBefore, r);
}
function Io(t, e) {
	return t.type.checkContent(e), t.copy(e);
}
function Vy(t, e, n, r, o) {
	let i = t.depth > o && Cd(t, e, o + 1),
		s = r.depth > o && Cd(n, r, o + 1),
		l = [];
	return (
		cs(null, t, o, l),
		i && s && e.index(o) == n.index(o)
			? (Fy(i, s), Po(Io(i, Vy(t, e, n, r, o + 1)), l))
			: (i && Po(Io(i, va(t, e, o + 1)), l),
			  cs(e, n, o, l),
			  s && Po(Io(s, va(n, r, o + 1)), l)),
		cs(r, null, o, l),
		new J(l)
	);
}
function va(t, e, n) {
	let r = [];
	if ((cs(null, t, n, r), t.depth > n)) {
		let o = Cd(t, e, n + 1);
		Po(Io(o, va(t, e, n + 1)), r);
	}
	return cs(e, null, n, r), new J(r);
}
function uC(t, e) {
	let n = e.depth - t.openStart,
		o = e.node(n).copy(t.content);
	for (let i = n - 1; i >= 0; i--) o = e.node(i).copy(J.from(o));
	return {
		start: o.resolveNoCache(t.openStart + n),
		end: o.resolveNoCache(o.content.size - t.openEnd - n),
	};
}
class Ps {
	constructor(e, n, r) {
		(this.pos = e),
			(this.path = n),
			(this.parentOffset = r),
			(this.depth = n.length / 3 - 1);
	}
	resolveDepth(e) {
		return e == null ? this.depth : e < 0 ? this.depth + e : e;
	}
	get parent() {
		return this.node(this.depth);
	}
	get doc() {
		return this.node(0);
	}
	node(e) {
		return this.path[this.resolveDepth(e) * 3];
	}
	index(e) {
		return this.path[this.resolveDepth(e) * 3 + 1];
	}
	indexAfter(e) {
		return (
			(e = this.resolveDepth(e)),
			this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
		);
	}
	start(e) {
		return (
			(e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1
		);
	}
	end(e) {
		return (
			(e = this.resolveDepth(e)),
			this.start(e) + this.node(e).content.size
		);
	}
	before(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position before the top-level node"
			);
		return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
	}
	after(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position after the top-level node"
			);
		return e == this.depth + 1
			? this.pos
			: this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
	}
	get textOffset() {
		return this.pos - this.path[this.path.length - 1];
	}
	get nodeAfter() {
		let e = this.parent,
			n = this.index(this.depth);
		if (n == e.childCount) return null;
		let r = this.pos - this.path[this.path.length - 1],
			o = e.child(n);
		return r ? e.child(n).cut(r) : o;
	}
	get nodeBefore() {
		let e = this.index(this.depth),
			n = this.pos - this.path[this.path.length - 1];
		return n
			? this.parent.child(e).cut(0, n)
			: e == 0
			? null
			: this.parent.child(e - 1);
	}
	posAtIndex(e, n) {
		n = this.resolveDepth(n);
		let r = this.path[n * 3],
			o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
		for (let i = 0; i < e; i++) o += r.child(i).nodeSize;
		return o;
	}
	marks() {
		let e = this.parent,
			n = this.index();
		if (e.content.size == 0) return ot.none;
		if (this.textOffset) return e.child(n).marks;
		let r = e.maybeChild(n - 1),
			o = e.maybeChild(n);
		if (!r) {
			let l = r;
			(r = o), (o = l);
		}
		let i = r.marks;
		for (var s = 0; s < i.length; s++)
			i[s].type.spec.inclusive === !1 &&
				(!o || !i[s].isInSet(o.marks)) &&
				(i = i[s--].removeFromSet(i));
		return i;
	}
	marksAcross(e) {
		let n = this.parent.maybeChild(this.index());
		if (!n || !n.isInline) return null;
		let r = n.marks,
			o = e.parent.maybeChild(e.index());
		for (var i = 0; i < r.length; i++)
			r[i].type.spec.inclusive === !1 &&
				(!o || !r[i].isInSet(o.marks)) &&
				(r = r[i--].removeFromSet(r));
		return r;
	}
	sharedDepth(e) {
		for (let n = this.depth; n > 0; n--)
			if (this.start(n) <= e && this.end(n) >= e) return n;
		return 0;
	}
	blockRange(e = this, n) {
		if (e.pos < this.pos) return e.blockRange(this);
		for (
			let r =
				this.depth -
				(this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
			r >= 0;
			r--
		)
			if (e.pos <= this.end(r) && (!n || n(this.node(r))))
				return new ba(this, e, r);
		return null;
	}
	sameParent(e) {
		return this.pos - this.parentOffset == e.pos - e.parentOffset;
	}
	max(e) {
		return e.pos > this.pos ? e : this;
	}
	min(e) {
		return e.pos < this.pos ? e : this;
	}
	toString() {
		let e = "";
		for (let n = 1; n <= this.depth; n++)
			e +=
				(e ? "/" : "") +
				this.node(n).type.name +
				"_" +
				this.index(n - 1);
		return e + ":" + this.parentOffset;
	}
	static resolve(e, n) {
		if (!(n >= 0 && n <= e.content.size))
			throw new RangeError("Position " + n + " out of range");
		let r = [],
			o = 0,
			i = n;
		for (let s = e; ; ) {
			let { index: l, offset: a } = s.content.findIndex(i),
				u = i - a;
			if ((r.push(s, l, o + a), !u || ((s = s.child(l)), s.isText)))
				break;
			(i = u - 1), (o += a + 1);
		}
		return new Ps(n, r, i);
	}
	static resolveCached(e, n) {
		for (let o = 0; o < yc.length; o++) {
			let i = yc[o];
			if (i.pos == n && i.doc == e) return i;
		}
		let r = (yc[vc] = Ps.resolve(e, n));
		return (vc = (vc + 1) % cC), r;
	}
}
let yc = [],
	vc = 0,
	cC = 12;
class ba {
	constructor(e, n, r) {
		(this.$from = e), (this.$to = n), (this.depth = r);
	}
	get start() {
		return this.$from.before(this.depth + 1);
	}
	get end() {
		return this.$to.after(this.depth + 1);
	}
	get parent() {
		return this.$from.node(this.depth);
	}
	get startIndex() {
		return this.$from.index(this.depth);
	}
	get endIndex() {
		return this.$to.indexAfter(this.depth);
	}
}
const dC = Object.create(null);
let No = class Md {
	constructor(e, n, r, o = ot.none) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = o),
			(this.content = r || J.empty);
	}
	get nodeSize() {
		return this.isLeaf ? 1 : 2 + this.content.size;
	}
	get childCount() {
		return this.content.childCount;
	}
	child(e) {
		return this.content.child(e);
	}
	maybeChild(e) {
		return this.content.maybeChild(e);
	}
	forEach(e) {
		this.content.forEach(e);
	}
	nodesBetween(e, n, r, o = 0) {
		this.content.nodesBetween(e, n, r, o, this);
	}
	descendants(e) {
		this.nodesBetween(0, this.content.size, e);
	}
	get textContent() {
		return this.isLeaf && this.type.spec.leafText
			? this.type.spec.leafText(this)
			: this.textBetween(0, this.content.size, "");
	}
	textBetween(e, n, r, o) {
		return this.content.textBetween(e, n, r, o);
	}
	get firstChild() {
		return this.content.firstChild;
	}
	get lastChild() {
		return this.content.lastChild;
	}
	eq(e) {
		return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
	}
	sameMarkup(e) {
		return this.hasMarkup(e.type, e.attrs, e.marks);
	}
	hasMarkup(e, n, r) {
		return (
			this.type == e &&
			ga(this.attrs, n || e.defaultAttrs || dC) &&
			ot.sameSet(this.marks, r || ot.none)
		);
	}
	copy(e = null) {
		return e == this.content
			? this
			: new Md(this.type, this.attrs, e, this.marks);
	}
	mark(e) {
		return e == this.marks
			? this
			: new Md(this.type, this.attrs, this.content, e);
	}
	cut(e, n = this.content.size) {
		return e == 0 && n == this.content.size
			? this
			: this.copy(this.content.cut(e, n));
	}
	slice(e, n = this.content.size, r = !1) {
		if (e == n) return se.empty;
		let o = this.resolve(e),
			i = this.resolve(n),
			s = r ? 0 : o.sharedDepth(n),
			l = o.start(s),
			u = o.node(s).content.cut(o.pos - l, i.pos - l);
		return new se(u, o.depth - s, i.depth - s);
	}
	replace(e, n, r) {
		return aC(this.resolve(e), this.resolve(n), r);
	}
	nodeAt(e) {
		for (let n = this; ; ) {
			let { index: r, offset: o } = n.content.findIndex(e);
			if (((n = n.maybeChild(r)), !n)) return null;
			if (o == e || n.isText) return n;
			e -= o + 1;
		}
	}
	childAfter(e) {
		let { index: n, offset: r } = this.content.findIndex(e);
		return { node: this.content.maybeChild(n), index: n, offset: r };
	}
	childBefore(e) {
		if (e == 0) return { node: null, index: 0, offset: 0 };
		let { index: n, offset: r } = this.content.findIndex(e);
		if (r < e) return { node: this.content.child(n), index: n, offset: r };
		let o = this.content.child(n - 1);
		return { node: o, index: n - 1, offset: r - o.nodeSize };
	}
	resolve(e) {
		return Ps.resolveCached(this, e);
	}
	resolveNoCache(e) {
		return Ps.resolve(this, e);
	}
	rangeHasMark(e, n, r) {
		let o = !1;
		return (
			n > e &&
				this.nodesBetween(
					e,
					n,
					(i) => (r.isInSet(i.marks) && (o = !0), !o)
				),
			o
		);
	}
	get isBlock() {
		return this.type.isBlock;
	}
	get isTextblock() {
		return this.type.isTextblock;
	}
	get inlineContent() {
		return this.type.inlineContent;
	}
	get isInline() {
		return this.type.isInline;
	}
	get isText() {
		return this.type.isText;
	}
	get isLeaf() {
		return this.type.isLeaf;
	}
	get isAtom() {
		return this.type.isAtom;
	}
	toString() {
		if (this.type.spec.toDebugString)
			return this.type.spec.toDebugString(this);
		let e = this.type.name;
		return (
			this.content.size &&
				(e += "(" + this.content.toStringInner() + ")"),
			Wy(this.marks, e)
		);
	}
	contentMatchAt(e) {
		let n = this.type.contentMatch.matchFragment(this.content, 0, e);
		if (!n)
			throw new Error(
				"Called contentMatchAt on a node with invalid content"
			);
		return n;
	}
	canReplace(e, n, r = J.empty, o = 0, i = r.childCount) {
		let s = this.contentMatchAt(e).matchFragment(r, o, i),
			l = s && s.matchFragment(this.content, n);
		if (!l || !l.validEnd) return !1;
		for (let a = o; a < i; a++)
			if (!this.type.allowsMarks(r.child(a).marks)) return !1;
		return !0;
	}
	canReplaceWith(e, n, r, o) {
		if (o && !this.type.allowsMarks(o)) return !1;
		let i = this.contentMatchAt(e).matchType(r),
			s = i && i.matchFragment(this.content, n);
		return s ? s.validEnd : !1;
	}
	canAppend(e) {
		return e.content.size
			? this.canReplace(this.childCount, this.childCount, e.content)
			: this.type.compatibleContent(e.type);
	}
	check() {
		this.type.checkContent(this.content);
		let e = ot.none;
		for (let n = 0; n < this.marks.length; n++)
			e = this.marks[n].addToSet(e);
		if (!ot.sameSet(e, this.marks))
			throw new RangeError(
				`Invalid collection of marks for node ${
					this.type.name
				}: ${this.marks.map((n) => n.type.name)}`
			);
		this.content.forEach((n) => n.check());
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return (
			this.content.size && (e.content = this.content.toJSON()),
			this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Node.fromJSON");
		let r = null;
		if (n.marks) {
			if (!Array.isArray(n.marks))
				throw new RangeError("Invalid mark data for Node.fromJSON");
			r = n.marks.map(e.markFromJSON);
		}
		if (n.type == "text") {
			if (typeof n.text != "string")
				throw new RangeError("Invalid text node in JSON");
			return e.text(n.text, r);
		}
		let o = J.fromJSON(e, n.content);
		return e.nodeType(n.type).create(n.attrs, o, r);
	}
};
No.prototype.text = void 0;
class wa extends No {
	constructor(e, n, r, o) {
		if ((super(e, n, null, o), !r))
			throw new RangeError("Empty text nodes are not allowed");
		this.text = r;
	}
	toString() {
		return this.type.spec.toDebugString
			? this.type.spec.toDebugString(this)
			: Wy(this.marks, JSON.stringify(this.text));
	}
	get textContent() {
		return this.text;
	}
	textBetween(e, n) {
		return this.text.slice(e, n);
	}
	get nodeSize() {
		return this.text.length;
	}
	mark(e) {
		return e == this.marks
			? this
			: new wa(this.type, this.attrs, this.text, e);
	}
	withText(e) {
		return e == this.text
			? this
			: new wa(this.type, this.attrs, e, this.marks);
	}
	cut(e = 0, n = this.text.length) {
		return e == 0 && n == this.text.length
			? this
			: this.withText(this.text.slice(e, n));
	}
	eq(e) {
		return this.sameMarkup(e) && this.text == e.text;
	}
	toJSON() {
		let e = super.toJSON();
		return (e.text = this.text), e;
	}
}
function Wy(t, e) {
	for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
	return e;
}
class Bo {
	constructor(e) {
		(this.validEnd = e), (this.next = []), (this.wrapCache = []);
	}
	static parse(e, n) {
		let r = new fC(e, n);
		if (r.next == null) return Bo.empty;
		let o = Uy(r);
		r.next && r.err("Unexpected trailing text");
		let i = bC(vC(o));
		return wC(i, r), i;
	}
	matchType(e) {
		for (let n = 0; n < this.next.length; n++)
			if (this.next[n].type == e) return this.next[n].next;
		return null;
	}
	matchFragment(e, n = 0, r = e.childCount) {
		let o = this;
		for (let i = n; o && i < r; i++) o = o.matchType(e.child(i).type);
		return o;
	}
	get inlineContent() {
		return this.next.length != 0 && this.next[0].type.isInline;
	}
	get defaultType() {
		for (let e = 0; e < this.next.length; e++) {
			let { type: n } = this.next[e];
			if (!(n.isText || n.hasRequiredAttrs())) return n;
		}
		return null;
	}
	compatible(e) {
		for (let n = 0; n < this.next.length; n++)
			for (let r = 0; r < e.next.length; r++)
				if (this.next[n].type == e.next[r].type) return !0;
		return !1;
	}
	fillBefore(e, n = !1, r = 0) {
		let o = [this];
		function i(s, l) {
			let a = s.matchFragment(e, r);
			if (a && (!n || a.validEnd))
				return J.from(l.map((u) => u.createAndFill()));
			for (let u = 0; u < s.next.length; u++) {
				let { type: c, next: d } = s.next[u];
				if (!(c.isText || c.hasRequiredAttrs()) && o.indexOf(d) == -1) {
					o.push(d);
					let h = i(d, l.concat(c));
					if (h) return h;
				}
			}
			return null;
		}
		return i(this, []);
	}
	findWrapping(e) {
		for (let r = 0; r < this.wrapCache.length; r += 2)
			if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
		let n = this.computeWrapping(e);
		return this.wrapCache.push(e, n), n;
	}
	computeWrapping(e) {
		let n = Object.create(null),
			r = [{ match: this, type: null, via: null }];
		for (; r.length; ) {
			let o = r.shift(),
				i = o.match;
			if (i.matchType(e)) {
				let s = [];
				for (let l = o; l.type; l = l.via) s.push(l.type);
				return s.reverse();
			}
			for (let s = 0; s < i.next.length; s++) {
				let { type: l, next: a } = i.next[s];
				!l.isLeaf &&
					!l.hasRequiredAttrs() &&
					!(l.name in n) &&
					(!o.type || a.validEnd) &&
					(r.push({ match: l.contentMatch, type: l, via: o }),
					(n[l.name] = !0));
			}
		}
		return null;
	}
	get edgeCount() {
		return this.next.length;
	}
	edge(e) {
		if (e >= this.next.length)
			throw new RangeError(
				`There's no ${e}th edge in this content match`
			);
		return this.next[e];
	}
	toString() {
		let e = [];
		function n(r) {
			e.push(r);
			for (let o = 0; o < r.next.length; o++)
				e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
		}
		return (
			n(this),
			e.map((r, o) => {
				let i = o + (r.validEnd ? "*" : " ") + " ";
				for (let s = 0; s < r.next.length; s++)
					i +=
						(s ? ", " : "") +
						r.next[s].type.name +
						"->" +
						e.indexOf(r.next[s].next);
				return i;
			}).join(`
`)
		);
	}
}
Bo.empty = new Bo(!0);
class fC {
	constructor(e, n) {
		(this.string = e),
			(this.nodeTypes = n),
			(this.inline = null),
			(this.pos = 0),
			(this.tokens = e.split(/\s*(?=\b|\W|$)/)),
			this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
			this.tokens[0] == "" && this.tokens.shift();
	}
	get next() {
		return this.tokens[this.pos];
	}
	eat(e) {
		return this.next == e && (this.pos++ || !0);
	}
	err(e) {
		throw new SyntaxError(
			e + " (in content expression '" + this.string + "')"
		);
	}
}
function Uy(t) {
	let e = [];
	do e.push(hC(t));
	while (t.eat("|"));
	return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function hC(t) {
	let e = [];
	do e.push(pC(t));
	while (t.next && t.next != ")" && t.next != "|");
	return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function pC(t) {
	let e = yC(t);
	for (;;)
		if (t.eat("+")) e = { type: "plus", expr: e };
		else if (t.eat("*")) e = { type: "star", expr: e };
		else if (t.eat("?")) e = { type: "opt", expr: e };
		else if (t.eat("{")) e = mC(t, e);
		else break;
	return e;
}
function vm(t) {
	/\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
	let e = Number(t.next);
	return t.pos++, e;
}
function mC(t, e) {
	let n = vm(t),
		r = n;
	return (
		t.eat(",") && (t.next != "}" ? (r = vm(t)) : (r = -1)),
		t.eat("}") || t.err("Unclosed braced range"),
		{ type: "range", min: n, max: r, expr: e }
	);
}
function gC(t, e) {
	let n = t.nodeTypes,
		r = n[e];
	if (r) return [r];
	let o = [];
	for (let i in n) {
		let s = n[i];
		s.groups.indexOf(e) > -1 && o.push(s);
	}
	return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function yC(t) {
	if (t.eat("(")) {
		let e = Uy(t);
		return t.eat(")") || t.err("Missing closing paren"), e;
	} else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
	else {
		let e = gC(t, t.next).map(
			(n) => (
				t.inline == null
					? (t.inline = n.isInline)
					: t.inline != n.isInline &&
					  t.err("Mixing inline and block content"),
				{ type: "name", value: n }
			)
		);
		return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
	}
}
function vC(t) {
	let e = [[]];
	return o(i(t, 0), n()), e;
	function n() {
		return e.push([]) - 1;
	}
	function r(s, l, a) {
		let u = { term: a, to: l };
		return e[s].push(u), u;
	}
	function o(s, l) {
		s.forEach((a) => (a.to = l));
	}
	function i(s, l) {
		if (s.type == "choice")
			return s.exprs.reduce((a, u) => a.concat(i(u, l)), []);
		if (s.type == "seq")
			for (let a = 0; ; a++) {
				let u = i(s.exprs[a], l);
				if (a == s.exprs.length - 1) return u;
				o(u, (l = n()));
			}
		else if (s.type == "star") {
			let a = n();
			return r(l, a), o(i(s.expr, a), a), [r(a)];
		} else if (s.type == "plus") {
			let a = n();
			return o(i(s.expr, l), a), o(i(s.expr, a), a), [r(a)];
		} else {
			if (s.type == "opt") return [r(l)].concat(i(s.expr, l));
			if (s.type == "range") {
				let a = l;
				for (let u = 0; u < s.min; u++) {
					let c = n();
					o(i(s.expr, a), c), (a = c);
				}
				if (s.max == -1) o(i(s.expr, a), a);
				else
					for (let u = s.min; u < s.max; u++) {
						let c = n();
						r(a, c), o(i(s.expr, a), c), (a = c);
					}
				return [r(a)];
			} else {
				if (s.type == "name") return [r(l, void 0, s.value)];
				throw new Error("Unknown expr type");
			}
		}
	}
}
function Ky(t, e) {
	return e - t;
}
function bm(t, e) {
	let n = [];
	return r(e), n.sort(Ky);
	function r(o) {
		let i = t[o];
		if (i.length == 1 && !i[0].term) return r(i[0].to);
		n.push(o);
		for (let s = 0; s < i.length; s++) {
			let { term: l, to: a } = i[s];
			!l && n.indexOf(a) == -1 && r(a);
		}
	}
}
function bC(t) {
	let e = Object.create(null);
	return n(bm(t, 0));
	function n(r) {
		let o = [];
		r.forEach((s) => {
			t[s].forEach(({ term: l, to: a }) => {
				if (!l) return;
				let u;
				for (let c = 0; c < o.length; c++)
					o[c][0] == l && (u = o[c][1]);
				bm(t, a).forEach((c) => {
					u || o.push([l, (u = [])]), u.indexOf(c) == -1 && u.push(c);
				});
			});
		});
		let i = (e[r.join(",")] = new Bo(r.indexOf(t.length - 1) > -1));
		for (let s = 0; s < o.length; s++) {
			let l = o[s][1].sort(Ky);
			i.next.push({ type: o[s][0], next: e[l.join(",")] || n(l) });
		}
		return i;
	}
}
function wC(t, e) {
	for (let n = 0, r = [t]; n < r.length; n++) {
		let o = r[n],
			i = !o.validEnd,
			s = [];
		for (let l = 0; l < o.next.length; l++) {
			let { type: a, next: u } = o.next[l];
			s.push(a.name),
				i && !(a.isText || a.hasRequiredAttrs()) && (i = !1),
				r.indexOf(u) == -1 && r.push(u);
		}
		i &&
			e.err(
				"Only non-generatable nodes (" +
					s.join(", ") +
					") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
			);
	}
}
function qy(t) {
	let e = Object.create(null);
	for (let n in t) {
		let r = t[n];
		if (!r.hasDefault) return null;
		e[n] = r.default;
	}
	return e;
}
function Jy(t, e) {
	let n = Object.create(null);
	for (let r in t) {
		let o = e && e[r];
		if (o === void 0) {
			let i = t[r];
			if (i.hasDefault) o = i.default;
			else throw new RangeError("No value supplied for attribute " + r);
		}
		n[r] = o;
	}
	return n;
}
function Gy(t) {
	let e = Object.create(null);
	if (t) for (let n in t) e[n] = new xC(t[n]);
	return e;
}
let wm = class Yy {
	constructor(e, n, r) {
		(this.name = e),
			(this.schema = n),
			(this.spec = r),
			(this.markSet = null),
			(this.groups = r.group ? r.group.split(" ") : []),
			(this.attrs = Gy(r.attrs)),
			(this.defaultAttrs = qy(this.attrs)),
			(this.contentMatch = null),
			(this.inlineContent = null),
			(this.isBlock = !(r.inline || e == "text")),
			(this.isText = e == "text");
	}
	get isInline() {
		return !this.isBlock;
	}
	get isTextblock() {
		return this.isBlock && this.inlineContent;
	}
	get isLeaf() {
		return this.contentMatch == Bo.empty;
	}
	get isAtom() {
		return this.isLeaf || !!this.spec.atom;
	}
	get whitespace() {
		return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
	}
	hasRequiredAttrs() {
		for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
		return !1;
	}
	compatibleContent(e) {
		return this == e || this.contentMatch.compatible(e.contentMatch);
	}
	computeAttrs(e) {
		return !e && this.defaultAttrs ? this.defaultAttrs : Jy(this.attrs, e);
	}
	create(e = null, n, r) {
		if (this.isText)
			throw new Error("NodeType.create can't construct text nodes");
		return new No(this, this.computeAttrs(e), J.from(n), ot.setFrom(r));
	}
	createChecked(e = null, n, r) {
		return (
			(n = J.from(n)),
			this.checkContent(n),
			new No(this, this.computeAttrs(e), n, ot.setFrom(r))
		);
	}
	createAndFill(e = null, n, r) {
		if (((e = this.computeAttrs(e)), (n = J.from(n)), n.size)) {
			let s = this.contentMatch.fillBefore(n);
			if (!s) return null;
			n = s.append(n);
		}
		let o = this.contentMatch.matchFragment(n),
			i = o && o.fillBefore(J.empty, !0);
		return i ? new No(this, e, n.append(i), ot.setFrom(r)) : null;
	}
	validContent(e) {
		let n = this.contentMatch.matchFragment(e);
		if (!n || !n.validEnd) return !1;
		for (let r = 0; r < e.childCount; r++)
			if (!this.allowsMarks(e.child(r).marks)) return !1;
		return !0;
	}
	checkContent(e) {
		if (!this.validContent(e))
			throw new RangeError(
				`Invalid content for node ${this.name}: ${e
					.toString()
					.slice(0, 50)}`
			);
	}
	allowsMarkType(e) {
		return this.markSet == null || this.markSet.indexOf(e) > -1;
	}
	allowsMarks(e) {
		if (this.markSet == null) return !0;
		for (let n = 0; n < e.length; n++)
			if (!this.allowsMarkType(e[n].type)) return !1;
		return !0;
	}
	allowedMarks(e) {
		if (this.markSet == null) return e;
		let n;
		for (let r = 0; r < e.length; r++)
			this.allowsMarkType(e[r].type)
				? n && n.push(e[r])
				: n || (n = e.slice(0, r));
		return n ? (n.length ? n : ot.none) : e;
	}
	static compile(e, n) {
		let r = Object.create(null);
		e.forEach((i, s) => (r[i] = new Yy(i, n, s)));
		let o = n.spec.topNode || "doc";
		if (!r[o])
			throw new RangeError(
				"Schema is missing its top node type ('" + o + "')"
			);
		if (!r.text) throw new RangeError("Every schema needs a 'text' type");
		for (let i in r.text.attrs)
			throw new RangeError(
				"The text node type should not have attributes"
			);
		return r;
	}
};
class xC {
	constructor(e) {
		(this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default")),
			(this.default = e.default);
	}
	get isRequired() {
		return !this.hasDefault;
	}
}
class Pu {
	constructor(e, n, r, o) {
		(this.name = e),
			(this.rank = n),
			(this.schema = r),
			(this.spec = o),
			(this.attrs = Gy(o.attrs)),
			(this.excluded = null);
		let i = qy(this.attrs);
		this.instance = i ? new ot(this, i) : null;
	}
	create(e = null) {
		return !e && this.instance
			? this.instance
			: new ot(this, Jy(this.attrs, e));
	}
	static compile(e, n) {
		let r = Object.create(null),
			o = 0;
		return e.forEach((i, s) => (r[i] = new Pu(i, o++, n, s))), r;
	}
	removeFromSet(e) {
		for (var n = 0; n < e.length; n++)
			e[n].type == this &&
				((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
	}
	excludes(e) {
		return this.excluded.indexOf(e) > -1;
	}
}
class kC {
	constructor(e) {
		this.cached = Object.create(null);
		let n = (this.spec = {});
		for (let o in e) n[o] = e[o];
		(n.nodes = Lt.from(e.nodes)),
			(n.marks = Lt.from(e.marks || {})),
			(this.nodes = wm.compile(this.spec.nodes, this)),
			(this.marks = Pu.compile(this.spec.marks, this));
		let r = Object.create(null);
		for (let o in this.nodes) {
			if (o in this.marks)
				throw new RangeError(o + " can not be both a node and a mark");
			let i = this.nodes[o],
				s = i.spec.content || "",
				l = i.spec.marks;
			(i.contentMatch = r[s] || (r[s] = Bo.parse(s, this.nodes))),
				(i.inlineContent = i.contentMatch.inlineContent),
				(i.markSet =
					l == "_"
						? null
						: l
						? xm(this, l.split(" "))
						: l == "" || !i.inlineContent
						? []
						: null);
		}
		for (let o in this.marks) {
			let i = this.marks[o],
				s = i.spec.excludes;
			i.excluded =
				s == null ? [i] : s == "" ? [] : xm(this, s.split(" "));
		}
		(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
			(this.markFromJSON = this.markFromJSON.bind(this)),
			(this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
			(this.cached.wrappings = Object.create(null));
	}
	node(e, n = null, r, o) {
		if (typeof e == "string") e = this.nodeType(e);
		else if (e instanceof wm) {
			if (e.schema != this)
				throw new RangeError(
					"Node type from different schema used (" + e.name + ")"
				);
		} else throw new RangeError("Invalid node type: " + e);
		return e.createChecked(n, r, o);
	}
	text(e, n) {
		let r = this.nodes.text;
		return new wa(r, r.defaultAttrs, e, ot.setFrom(n));
	}
	mark(e, n) {
		return typeof e == "string" && (e = this.marks[e]), e.create(n);
	}
	nodeFromJSON(e) {
		return No.fromJSON(this, e);
	}
	markFromJSON(e) {
		return ot.fromJSON(this, e);
	}
	nodeType(e) {
		let n = this.nodes[e];
		if (!n) throw new RangeError("Unknown node type: " + e);
		return n;
	}
}
function xm(t, e) {
	let n = [];
	for (let r = 0; r < e.length; r++) {
		let o = e[r],
			i = t.marks[o],
			s = i;
		if (i) n.push(i);
		else
			for (let l in t.marks) {
				let a = t.marks[l];
				(o == "_" ||
					(a.spec.group &&
						a.spec.group.split(" ").indexOf(o) > -1)) &&
					n.push((s = a));
			}
		if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
	}
	return n;
}
let Iu = class Ed {
	constructor(e, n) {
		(this.schema = e),
			(this.rules = n),
			(this.tags = []),
			(this.styles = []),
			n.forEach((r) => {
				r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
			}),
			(this.normalizeLists = !this.tags.some((r) => {
				if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return !1;
				let o = e.nodes[r.node];
				return o.contentMatch.matchType(o);
			}));
	}
	parse(e, n = {}) {
		let r = new Sm(this, n, !1);
		return r.addAll(e, n.from, n.to), r.finish();
	}
	parseSlice(e, n = {}) {
		let r = new Sm(this, n, !0);
		return r.addAll(e, n.from, n.to), se.maxOpen(r.finish());
	}
	matchTag(e, n, r) {
		for (
			let o = r ? this.tags.indexOf(r) + 1 : 0;
			o < this.tags.length;
			o++
		) {
			let i = this.tags[o];
			if (
				CC(e, i.tag) &&
				(i.namespace === void 0 || e.namespaceURI == i.namespace) &&
				(!i.context || n.matchesContext(i.context))
			) {
				if (i.getAttrs) {
					let s = i.getAttrs(e);
					if (s === !1) continue;
					i.attrs = s || void 0;
				}
				return i;
			}
		}
	}
	matchStyle(e, n, r, o) {
		for (
			let i = o ? this.styles.indexOf(o) + 1 : 0;
			i < this.styles.length;
			i++
		) {
			let s = this.styles[i],
				l = s.style;
			if (
				!(
					l.indexOf(e) != 0 ||
					(s.context && !r.matchesContext(s.context)) ||
					(l.length > e.length &&
						(l.charCodeAt(e.length) != 61 ||
							l.slice(e.length + 1) != n))
				)
			) {
				if (s.getAttrs) {
					let a = s.getAttrs(n);
					if (a === !1) continue;
					s.attrs = a || void 0;
				}
				return s;
			}
		}
	}
	static schemaRules(e) {
		let n = [];
		function r(o) {
			let i = o.priority == null ? 50 : o.priority,
				s = 0;
			for (; s < n.length; s++) {
				let l = n[s];
				if ((l.priority == null ? 50 : l.priority) < i) break;
			}
			n.splice(s, 0, o);
		}
		for (let o in e.marks) {
			let i = e.marks[o].spec.parseDOM;
			i &&
				i.forEach((s) => {
					r((s = _m(s))),
						s.mark || s.ignore || s.clearMark || (s.mark = o);
				});
		}
		for (let o in e.nodes) {
			let i = e.nodes[o].spec.parseDOM;
			i &&
				i.forEach((s) => {
					r((s = _m(s))),
						s.node || s.ignore || s.mark || (s.node = o);
				});
		}
		return n;
	}
	static fromSchema(e) {
		return (
			e.cached.domParser ||
			(e.cached.domParser = new Ed(e, Ed.schemaRules(e)))
		);
	}
};
const Qy = {
		address: !0,
		article: !0,
		aside: !0,
		blockquote: !0,
		canvas: !0,
		dd: !0,
		div: !0,
		dl: !0,
		fieldset: !0,
		figcaption: !0,
		figure: !0,
		footer: !0,
		form: !0,
		h1: !0,
		h2: !0,
		h3: !0,
		h4: !0,
		h5: !0,
		h6: !0,
		header: !0,
		hgroup: !0,
		hr: !0,
		li: !0,
		noscript: !0,
		ol: !0,
		output: !0,
		p: !0,
		pre: !0,
		section: !0,
		table: !0,
		tfoot: !0,
		ul: !0,
	},
	SC = {
		head: !0,
		noscript: !0,
		object: !0,
		script: !0,
		style: !0,
		title: !0,
	},
	Xy = { ol: !0, ul: !0 },
	xa = 1,
	ka = 2,
	ds = 4;
function km(t, e, n) {
	return e != null
		? (e ? xa : 0) | (e === "full" ? ka : 0)
		: t && t.whitespace == "pre"
		? xa | ka
		: n & ~ds;
}
class _l {
	constructor(e, n, r, o, i, s, l) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = r),
			(this.pendingMarks = o),
			(this.solid = i),
			(this.options = l),
			(this.content = []),
			(this.activeMarks = ot.none),
			(this.stashMarks = []),
			(this.match = s || (l & ds ? null : e.contentMatch));
	}
	findWrapping(e) {
		if (!this.match) {
			if (!this.type) return [];
			let n = this.type.contentMatch.fillBefore(J.from(e));
			if (n) this.match = this.type.contentMatch.matchFragment(n);
			else {
				let r = this.type.contentMatch,
					o;
				return (o = r.findWrapping(e.type))
					? ((this.match = r), o)
					: null;
			}
		}
		return this.match.findWrapping(e.type);
	}
	finish(e) {
		if (!(this.options & xa)) {
			let r = this.content[this.content.length - 1],
				o;
			if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
				let i = r;
				r.text.length == o[0].length
					? this.content.pop()
					: (this.content[this.content.length - 1] = i.withText(
							i.text.slice(0, i.text.length - o[0].length)
					  ));
			}
		}
		let n = J.from(this.content);
		return (
			!e &&
				this.match &&
				(n = n.append(this.match.fillBefore(J.empty, !0))),
			this.type ? this.type.create(this.attrs, n, this.marks) : n
		);
	}
	popFromStashMark(e) {
		for (let n = this.stashMarks.length - 1; n >= 0; n--)
			if (e.eq(this.stashMarks[n]))
				return this.stashMarks.splice(n, 1)[0];
	}
	applyPending(e) {
		for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
			let o = r[n];
			(this.type ? this.type.allowsMarkType(o.type) : EC(o.type, e)) &&
				!o.isInSet(this.activeMarks) &&
				((this.activeMarks = o.addToSet(this.activeMarks)),
				(this.pendingMarks = o.removeFromSet(this.pendingMarks)));
		}
	}
	inlineContext(e) {
		return this.type
			? this.type.inlineContent
			: this.content.length
			? this.content[0].isInline
			: e.parentNode &&
			  !Qy.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
	}
}
class Sm {
	constructor(e, n, r) {
		(this.parser = e),
			(this.options = n),
			(this.isOpen = r),
			(this.open = 0);
		let o = n.topNode,
			i,
			s = km(null, n.preserveWhitespace, 0) | (r ? ds : 0);
		o
			? (i = new _l(
					o.type,
					o.attrs,
					ot.none,
					ot.none,
					!0,
					n.topMatch || o.type.contentMatch,
					s
			  ))
			: r
			? (i = new _l(null, null, ot.none, ot.none, !0, null, s))
			: (i = new _l(
					e.schema.topNodeType,
					null,
					ot.none,
					ot.none,
					!0,
					null,
					s
			  )),
			(this.nodes = [i]),
			(this.find = n.findPositions),
			(this.needsBlock = !1);
	}
	get top() {
		return this.nodes[this.open];
	}
	addDOM(e) {
		e.nodeType == 3
			? this.addTextNode(e)
			: e.nodeType == 1 && this.addElement(e);
	}
	withStyleRules(e, n) {
		let r = e.getAttribute("style");
		if (!r) return n();
		let o = this.readStyles(MC(r));
		if (!o) return;
		let [i, s] = o,
			l = this.top;
		for (let a = 0; a < s.length; a++) this.removePendingMark(s[a], l);
		for (let a = 0; a < i.length; a++) this.addPendingMark(i[a]);
		n();
		for (let a = 0; a < i.length; a++) this.removePendingMark(i[a], l);
		for (let a = 0; a < s.length; a++) this.addPendingMark(s[a]);
	}
	addTextNode(e) {
		let n = e.nodeValue,
			r = this.top;
		if (
			r.options & ka ||
			r.inlineContext(e) ||
			/[^ \t\r\n\u000c]/.test(n)
		) {
			if (r.options & xa)
				r.options & ka
					? (n = n.replace(
							/\r\n?/g,
							`
`
					  ))
					: (n = n.replace(/\r?\n|\r/g, " "));
			else if (
				((n = n.replace(/[ \t\r\n\u000c]+/g, " ")),
				/^[ \t\r\n\u000c]/.test(n) &&
					this.open == this.nodes.length - 1)
			) {
				let o = r.content[r.content.length - 1],
					i = e.previousSibling;
				(!o ||
					(i && i.nodeName == "BR") ||
					(o.isText && /[ \t\r\n\u000c]$/.test(o.text))) &&
					(n = n.slice(1));
			}
			n && this.insertNode(this.parser.schema.text(n)),
				this.findInText(e);
		} else this.findInside(e);
	}
	addElement(e, n) {
		let r = e.nodeName.toLowerCase(),
			o;
		Xy.hasOwnProperty(r) && this.parser.normalizeLists && _C(e);
		let i =
			(this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
			(o = this.parser.matchTag(e, this, n));
		if (i ? i.ignore : SC.hasOwnProperty(r))
			this.findInside(e), this.ignoreFallback(e);
		else if (!i || i.skip || i.closeParent) {
			i && i.closeParent
				? (this.open = Math.max(0, this.open - 1))
				: i && i.skip.nodeType && (e = i.skip);
			let s,
				l = this.top,
				a = this.needsBlock;
			if (Qy.hasOwnProperty(r))
				l.content.length &&
					l.content[0].isInline &&
					this.open &&
					(this.open--, (l = this.top)),
					(s = !0),
					l.type || (this.needsBlock = !0);
			else if (!e.firstChild) {
				this.leafFallback(e);
				return;
			}
			i && i.skip
				? this.addAll(e)
				: this.withStyleRules(e, () => this.addAll(e)),
				s && this.sync(l),
				(this.needsBlock = a);
		} else
			this.withStyleRules(e, () => {
				this.addElementByRule(e, i, i.consuming === !1 ? o : void 0);
			});
	}
	leafFallback(e) {
		e.nodeName == "BR" &&
			this.top.type &&
			this.top.type.inlineContent &&
			this.addTextNode(
				e.ownerDocument.createTextNode(`
`)
			);
	}
	ignoreFallback(e) {
		e.nodeName == "BR" &&
			(!this.top.type || !this.top.type.inlineContent) &&
			this.findPlace(this.parser.schema.text("-"));
	}
	readStyles(e) {
		let n = ot.none,
			r = ot.none;
		for (let o = 0; o < e.length; o += 2)
			for (let i = void 0; ; ) {
				let s = this.parser.matchStyle(e[o], e[o + 1], this, i);
				if (!s) break;
				if (s.ignore) return null;
				if (
					(s.clearMark
						? this.top.pendingMarks
								.concat(this.top.activeMarks)
								.forEach((l) => {
									s.clearMark(l) && (r = l.addToSet(r));
								})
						: (n = this.parser.schema.marks[s.mark]
								.create(s.attrs)
								.addToSet(n)),
					s.consuming === !1)
				)
					i = s;
				else break;
			}
		return [n, r];
	}
	addElementByRule(e, n, r) {
		let o, i, s;
		n.node
			? ((i = this.parser.schema.nodes[n.node]),
			  i.isLeaf
					? this.insertNode(i.create(n.attrs)) || this.leafFallback(e)
					: (o = this.enter(
							i,
							n.attrs || null,
							n.preserveWhitespace
					  )))
			: ((s = this.parser.schema.marks[n.mark].create(n.attrs)),
			  this.addPendingMark(s));
		let l = this.top;
		if (i && i.isLeaf) this.findInside(e);
		else if (r) this.addElement(e, r);
		else if (n.getContent)
			this.findInside(e),
				n
					.getContent(e, this.parser.schema)
					.forEach((a) => this.insertNode(a));
		else {
			let a = e;
			typeof n.contentElement == "string"
				? (a = e.querySelector(n.contentElement))
				: typeof n.contentElement == "function"
				? (a = n.contentElement(e))
				: n.contentElement && (a = n.contentElement),
				this.findAround(e, a, !0),
				this.addAll(a);
		}
		o && this.sync(l) && this.open--, s && this.removePendingMark(s, l);
	}
	addAll(e, n, r) {
		let o = n || 0;
		for (
			let i = n ? e.childNodes[n] : e.firstChild,
				s = r == null ? null : e.childNodes[r];
			i != s;
			i = i.nextSibling, ++o
		)
			this.findAtPoint(e, o), this.addDOM(i);
		this.findAtPoint(e, o);
	}
	findPlace(e) {
		let n, r;
		for (let o = this.open; o >= 0; o--) {
			let i = this.nodes[o],
				s = i.findWrapping(e);
			if (
				(s &&
					(!n || n.length > s.length) &&
					((n = s), (r = i), !s.length)) ||
				i.solid
			)
				break;
		}
		if (!n) return !1;
		this.sync(r);
		for (let o = 0; o < n.length; o++) this.enterInner(n[o], null, !1);
		return !0;
	}
	insertNode(e) {
		if (e.isInline && this.needsBlock && !this.top.type) {
			let n = this.textblockFromContext();
			n && this.enterInner(n);
		}
		if (this.findPlace(e)) {
			this.closeExtra();
			let n = this.top;
			n.applyPending(e.type),
				n.match && (n.match = n.match.matchType(e.type));
			let r = n.activeMarks;
			for (let o = 0; o < e.marks.length; o++)
				(!n.type || n.type.allowsMarkType(e.marks[o].type)) &&
					(r = e.marks[o].addToSet(r));
			return n.content.push(e.mark(r)), !0;
		}
		return !1;
	}
	enter(e, n, r) {
		let o = this.findPlace(e.create(n));
		return o && this.enterInner(e, n, !0, r), o;
	}
	enterInner(e, n = null, r = !1, o) {
		this.closeExtra();
		let i = this.top;
		i.applyPending(e), (i.match = i.match && i.match.matchType(e));
		let s = km(e, o, i.options);
		i.options & ds && i.content.length == 0 && (s |= ds),
			this.nodes.push(
				new _l(e, n, i.activeMarks, i.pendingMarks, r, null, s)
			),
			this.open++;
	}
	closeExtra(e = !1) {
		let n = this.nodes.length - 1;
		if (n > this.open) {
			for (; n > this.open; n--)
				this.nodes[n - 1].content.push(this.nodes[n].finish(e));
			this.nodes.length = this.open + 1;
		}
	}
	finish() {
		return (
			(this.open = 0),
			this.closeExtra(this.isOpen),
			this.nodes[0].finish(this.isOpen || this.options.topOpen)
		);
	}
	sync(e) {
		for (let n = this.open; n >= 0; n--)
			if (this.nodes[n] == e) return (this.open = n), !0;
		return !1;
	}
	get currentPos() {
		this.closeExtra();
		let e = 0;
		for (let n = this.open; n >= 0; n--) {
			let r = this.nodes[n].content;
			for (let o = r.length - 1; o >= 0; o--) e += r[o].nodeSize;
			n && e++;
		}
		return e;
	}
	findAtPoint(e, n) {
		if (this.find)
			for (let r = 0; r < this.find.length; r++)
				this.find[r].node == e &&
					this.find[r].offset == n &&
					(this.find[r].pos = this.currentPos);
	}
	findInside(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[n].node) &&
					(this.find[n].pos = this.currentPos);
	}
	findAround(e, n, r) {
		if (e != n && this.find)
			for (let o = 0; o < this.find.length; o++)
				this.find[o].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[o].node) &&
					n.compareDocumentPosition(this.find[o].node) &
						(r ? 2 : 4) &&
					(this.find[o].pos = this.currentPos);
	}
	findInText(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].node == e &&
					(this.find[n].pos =
						this.currentPos -
						(e.nodeValue.length - this.find[n].offset));
	}
	matchesContext(e) {
		if (e.indexOf("|") > -1)
			return e.split(/\s*\|\s*/).some(this.matchesContext, this);
		let n = e.split("/"),
			r = this.options.context,
			o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
			i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
			s = (l, a) => {
				for (; l >= 0; l--) {
					let u = n[l];
					if (u == "") {
						if (l == n.length - 1 || l == 0) continue;
						for (; a >= i; a--) if (s(l - 1, a)) return !0;
						return !1;
					} else {
						let c =
							a > 0 || (a == 0 && o)
								? this.nodes[a].type
								: r && a >= i
								? r.node(a - i).type
								: null;
						if (!c || (c.name != u && c.groups.indexOf(u) == -1))
							return !1;
						a--;
					}
				}
				return !0;
			};
		return s(n.length - 1, this.open);
	}
	textblockFromContext() {
		let e = this.options.context;
		if (e)
			for (let n = e.depth; n >= 0; n--) {
				let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
				if (r && r.isTextblock && r.defaultAttrs) return r;
			}
		for (let n in this.parser.schema.nodes) {
			let r = this.parser.schema.nodes[n];
			if (r.isTextblock && r.defaultAttrs) return r;
		}
	}
	addPendingMark(e) {
		let n = TC(e, this.top.pendingMarks);
		n && this.top.stashMarks.push(n),
			(this.top.pendingMarks = e.addToSet(this.top.pendingMarks));
	}
	removePendingMark(e, n) {
		for (let r = this.open; r >= 0; r--) {
			let o = this.nodes[r];
			if (o.pendingMarks.lastIndexOf(e) > -1)
				o.pendingMarks = e.removeFromSet(o.pendingMarks);
			else {
				o.activeMarks = e.removeFromSet(o.activeMarks);
				let s = o.popFromStashMark(e);
				s &&
					o.type &&
					o.type.allowsMarkType(s.type) &&
					(o.activeMarks = s.addToSet(o.activeMarks));
			}
			if (o == n) break;
		}
	}
}
function _C(t) {
	for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
		let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
		r && Xy.hasOwnProperty(r) && n
			? (n.appendChild(e), (e = n))
			: r == "li"
			? (n = e)
			: r && (n = null);
	}
}
function CC(t, e) {
	return (
		t.matches ||
		t.msMatchesSelector ||
		t.webkitMatchesSelector ||
		t.mozMatchesSelector
	).call(t, e);
}
function MC(t) {
	let e = /\s*([\w-]+)\s*:\s*([^;]+)/g,
		n,
		r = [];
	for (; (n = e.exec(t)); ) r.push(n[1], n[2].trim());
	return r;
}
function _m(t) {
	let e = {};
	for (let n in t) e[n] = t[n];
	return e;
}
function EC(t, e) {
	let n = e.schema.nodes;
	for (let r in n) {
		let o = n[r];
		if (!o.allowsMarkType(t)) continue;
		let i = [],
			s = (l) => {
				i.push(l);
				for (let a = 0; a < l.edgeCount; a++) {
					let { type: u, next: c } = l.edge(a);
					if (u == e || (i.indexOf(c) < 0 && s(c))) return !0;
				}
			};
		if (s(o.contentMatch)) return !0;
	}
}
function TC(t, e) {
	for (let n = 0; n < e.length; n++) if (t.eq(e[n])) return e[n];
}
class tr {
	constructor(e, n) {
		(this.nodes = e), (this.marks = n);
	}
	serializeFragment(e, n = {}, r) {
		r || (r = bc(n).createDocumentFragment());
		let o = r,
			i = [];
		return (
			e.forEach((s) => {
				if (i.length || s.marks.length) {
					let l = 0,
						a = 0;
					for (; l < i.length && a < s.marks.length; ) {
						let u = s.marks[a];
						if (!this.marks[u.type.name]) {
							a++;
							continue;
						}
						if (!u.eq(i[l][0]) || u.type.spec.spanning === !1)
							break;
						l++, a++;
					}
					for (; l < i.length; ) o = i.pop()[1];
					for (; a < s.marks.length; ) {
						let u = s.marks[a++],
							c = this.serializeMark(u, s.isInline, n);
						c &&
							(i.push([u, o]),
							o.appendChild(c.dom),
							(o = c.contentDOM || c.dom));
					}
				}
				o.appendChild(this.serializeNodeInner(s, n));
			}),
			r
		);
	}
	serializeNodeInner(e, n) {
		let { dom: r, contentDOM: o } = tr.renderSpec(
			bc(n),
			this.nodes[e.type.name](e)
		);
		if (o) {
			if (e.isLeaf)
				throw new RangeError(
					"Content hole not allowed in a leaf node spec"
				);
			this.serializeFragment(e.content, n, o);
		}
		return r;
	}
	serializeNode(e, n = {}) {
		let r = this.serializeNodeInner(e, n);
		for (let o = e.marks.length - 1; o >= 0; o--) {
			let i = this.serializeMark(e.marks[o], e.isInline, n);
			i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom));
		}
		return r;
	}
	serializeMark(e, n, r = {}) {
		let o = this.marks[e.type.name];
		return o && tr.renderSpec(bc(r), o(e, n));
	}
	static renderSpec(e, n, r = null) {
		if (typeof n == "string") return { dom: e.createTextNode(n) };
		if (n.nodeType != null) return { dom: n };
		if (n.dom && n.dom.nodeType != null) return n;
		let o = n[0],
			i = o.indexOf(" ");
		i > 0 && ((r = o.slice(0, i)), (o = o.slice(i + 1)));
		let s,
			l = r ? e.createElementNS(r, o) : e.createElement(o),
			a = n[1],
			u = 1;
		if (
			a &&
			typeof a == "object" &&
			a.nodeType == null &&
			!Array.isArray(a)
		) {
			u = 2;
			for (let c in a)
				if (a[c] != null) {
					let d = c.indexOf(" ");
					d > 0
						? l.setAttributeNS(c.slice(0, d), c.slice(d + 1), a[c])
						: l.setAttribute(c, a[c]);
				}
		}
		for (let c = u; c < n.length; c++) {
			let d = n[c];
			if (d === 0) {
				if (c < n.length - 1 || c > u)
					throw new RangeError(
						"Content hole must be the only child of its parent node"
					);
				return { dom: l, contentDOM: l };
			} else {
				let { dom: h, contentDOM: p } = tr.renderSpec(e, d, r);
				if ((l.appendChild(h), p)) {
					if (s) throw new RangeError("Multiple content holes");
					s = p;
				}
			}
		}
		return { dom: l, contentDOM: s };
	}
	static fromSchema(e) {
		return (
			e.cached.domSerializer ||
			(e.cached.domSerializer = new tr(
				this.nodesFromSchema(e),
				this.marksFromSchema(e)
			))
		);
	}
	static nodesFromSchema(e) {
		let n = Cm(e.nodes);
		return n.text || (n.text = (r) => r.text), n;
	}
	static marksFromSchema(e) {
		return Cm(e.marks);
	}
}
function Cm(t) {
	let e = {};
	for (let n in t) {
		let r = t[n].spec.toDOM;
		r && (e[n] = r);
	}
	return e;
}
function bc(t) {
	return t.document || window.document;
}
const Zy = 65535,
	ev = Math.pow(2, 16);
function AC(t, e) {
	return t + e * ev;
}
function Mm(t) {
	return t & Zy;
}
function OC(t) {
	return (t - (t & Zy)) / ev;
}
const tv = 1,
	nv = 2,
	Wl = 4,
	rv = 8;
class Td {
	constructor(e, n, r) {
		(this.pos = e), (this.delInfo = n), (this.recover = r);
	}
	get deleted() {
		return (this.delInfo & rv) > 0;
	}
	get deletedBefore() {
		return (this.delInfo & (tv | Wl)) > 0;
	}
	get deletedAfter() {
		return (this.delInfo & (nv | Wl)) > 0;
	}
	get deletedAcross() {
		return (this.delInfo & Wl) > 0;
	}
}
class gn {
	constructor(e, n = !1) {
		if (((this.ranges = e), (this.inverted = n), !e.length && gn.empty))
			return gn.empty;
	}
	recover(e) {
		let n = 0,
			r = Mm(e);
		if (!this.inverted)
			for (let o = 0; o < r; o++)
				n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
		return this.ranges[r * 3] + n + OC(e);
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	map(e, n = 1) {
		return this._map(e, n, !0);
	}
	_map(e, n, r) {
		let o = 0,
			i = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let l = 0; l < this.ranges.length; l += 3) {
			let a = this.ranges[l] - (this.inverted ? o : 0);
			if (a > e) break;
			let u = this.ranges[l + i],
				c = this.ranges[l + s],
				d = a + u;
			if (e <= d) {
				let h = u ? (e == a ? -1 : e == d ? 1 : n) : n,
					p = a + o + (h < 0 ? 0 : c);
				if (r) return p;
				let g = e == (n < 0 ? a : d) ? null : AC(l / 3, e - a),
					y = e == a ? nv : e == d ? tv : Wl;
				return (n < 0 ? e != a : e != d) && (y |= rv), new Td(p, y, g);
			}
			o += c - u;
		}
		return r ? e + o : new Td(e + o, 0, null);
	}
	touches(e, n) {
		let r = 0,
			o = Mm(n),
			i = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let l = 0; l < this.ranges.length; l += 3) {
			let a = this.ranges[l] - (this.inverted ? r : 0);
			if (a > e) break;
			let u = this.ranges[l + i],
				c = a + u;
			if (e <= c && l == o * 3) return !0;
			r += this.ranges[l + s] - u;
		}
		return !1;
	}
	forEach(e) {
		let n = this.inverted ? 2 : 1,
			r = this.inverted ? 1 : 2;
		for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
			let s = this.ranges[o],
				l = s - (this.inverted ? i : 0),
				a = s + (this.inverted ? 0 : i),
				u = this.ranges[o + n],
				c = this.ranges[o + r];
			e(l, l + u, a, a + c), (i += c - u);
		}
	}
	invert() {
		return new gn(this.ranges, !this.inverted);
	}
	toString() {
		return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
	}
	static offset(e) {
		return e == 0 ? gn.empty : new gn(e < 0 ? [0, -e, 0] : [0, 0, e]);
	}
}
gn.empty = new gn([]);
class hi {
	constructor(e = [], n, r = 0, o = e.length) {
		(this.maps = e), (this.mirror = n), (this.from = r), (this.to = o);
	}
	slice(e = 0, n = this.maps.length) {
		return new hi(this.maps, this.mirror, e, n);
	}
	copy() {
		return new hi(
			this.maps.slice(),
			this.mirror && this.mirror.slice(),
			this.from,
			this.to
		);
	}
	appendMap(e, n) {
		(this.to = this.maps.push(e)),
			n != null && this.setMirror(this.maps.length - 1, n);
	}
	appendMapping(e) {
		for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
			let o = e.getMirror(n);
			this.appendMap(e.maps[n], o != null && o < n ? r + o : void 0);
		}
	}
	getMirror(e) {
		if (this.mirror) {
			for (let n = 0; n < this.mirror.length; n++)
				if (this.mirror[n] == e)
					return this.mirror[n + (n % 2 ? -1 : 1)];
		}
	}
	setMirror(e, n) {
		this.mirror || (this.mirror = []), this.mirror.push(e, n);
	}
	appendMappingInverted(e) {
		for (
			let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
			n >= 0;
			n--
		) {
			let o = e.getMirror(n);
			this.appendMap(
				e.maps[n].invert(),
				o != null && o > n ? r - o - 1 : void 0
			);
		}
	}
	invert() {
		let e = new hi();
		return e.appendMappingInverted(this), e;
	}
	map(e, n = 1) {
		if (this.mirror) return this._map(e, n, !0);
		for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
		return e;
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	_map(e, n, r) {
		let o = 0;
		for (let i = this.from; i < this.to; i++) {
			let s = this.maps[i],
				l = s.mapResult(e, n);
			if (l.recover != null) {
				let a = this.getMirror(i);
				if (a != null && a > i && a < this.to) {
					(i = a), (e = this.maps[a].recover(l.recover));
					continue;
				}
			}
			(o |= l.delInfo), (e = l.pos);
		}
		return r ? e : new Td(e, o, null);
	}
}
const wc = Object.create(null);
class Yt {
	getMap() {
		return gn.empty;
	}
	merge(e) {
		return null;
	}
	static fromJSON(e, n) {
		if (!n || !n.stepType)
			throw new RangeError("Invalid input for Step.fromJSON");
		let r = wc[n.stepType];
		if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in wc) throw new RangeError("Duplicate use of step JSON ID " + e);
		return (wc[e] = n), (n.prototype.jsonID = e), n;
	}
}
class Mt {
	constructor(e, n) {
		(this.doc = e), (this.failed = n);
	}
	static ok(e) {
		return new Mt(e, null);
	}
	static fail(e) {
		return new Mt(null, e);
	}
	static fromReplace(e, n, r, o) {
		try {
			return Mt.ok(e.replace(n, r, o));
		} catch (i) {
			if (i instanceof ya) return Mt.fail(i.message);
			throw i;
		}
	}
}
function rh(t, e, n) {
	let r = [];
	for (let o = 0; o < t.childCount; o++) {
		let i = t.child(o);
		i.content.size && (i = i.copy(rh(i.content, e, i))),
			i.isInline && (i = e(i, n, o)),
			r.push(i);
	}
	return J.fromArray(r);
}
class Jr extends Yt {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = e.resolve(this.from),
			o = r.node(r.sharedDepth(this.to)),
			i = new se(
				rh(
					n.content,
					(s, l) =>
						!s.isAtom || !l.type.allowsMarkType(this.mark.type)
							? s
							: s.mark(this.mark.addToSet(s.marks)),
					o
				),
				n.openStart,
				n.openEnd
			);
		return Mt.fromReplace(e, this.from, this.to, i);
	}
	invert() {
		return new nr(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new Jr(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof Jr &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new Jr(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark
			  )
			: null;
	}
	toJSON() {
		return {
			stepType: "addMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for AddMarkStep.fromJSON");
		return new Jr(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Yt.jsonID("addMark", Jr);
class nr extends Yt {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = new se(
				rh(
					n.content,
					(o) => o.mark(this.mark.removeFromSet(o.marks)),
					e
				),
				n.openStart,
				n.openEnd
			);
		return Mt.fromReplace(e, this.from, this.to, r);
	}
	invert() {
		return new Jr(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new nr(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof nr &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new nr(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark
			  )
			: null;
	}
	toJSON() {
		return {
			stepType: "removeMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
		return new nr(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Yt.jsonID("removeMark", nr);
class Gr extends Yt {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Mt.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
		return Mt.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new se(J.from(r), 0, n.isLeaf ? 0 : 1)
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		if (n) {
			let r = this.mark.addToSet(n.marks);
			if (r.length == n.marks.length) {
				for (let o = 0; o < n.marks.length; o++)
					if (!n.marks[o].isInSet(r))
						return new Gr(this.pos, n.marks[o]);
				return new Gr(this.pos, this.mark);
			}
		}
		return new Ai(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new Gr(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "addNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
		return new Gr(n.pos, e.markFromJSON(n.mark));
	}
}
Yt.jsonID("addNodeMark", Gr);
class Ai extends Yt {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Mt.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
		return Mt.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new se(J.from(r), 0, n.isLeaf ? 0 : 1)
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		return !n || !this.mark.isInSet(n.marks)
			? this
			: new Gr(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new Ai(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "removeNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError(
				"Invalid input for RemoveNodeMarkStep.fromJSON"
			);
		return new Ai(n.pos, e.markFromJSON(n.mark));
	}
}
Yt.jsonID("removeNodeMark", Ai);
class $t extends Yt {
	constructor(e, n, r, o = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.slice = r),
			(this.structure = o);
	}
	apply(e) {
		return this.structure && Ad(e, this.from, this.to)
			? Mt.fail("Structure replace would overwrite content")
			: Mt.fromReplace(e, this.from, this.to, this.slice);
	}
	getMap() {
		return new gn([this.from, this.to - this.from, this.slice.size]);
	}
	invert(e) {
		return new $t(
			this.from,
			this.from + this.slice.size,
			e.slice(this.from, this.to)
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return n.deletedAcross && r.deletedAcross
			? null
			: new $t(n.pos, Math.max(n.pos, r.pos), this.slice);
	}
	merge(e) {
		if (!(e instanceof $t) || e.structure || this.structure) return null;
		if (
			this.from + this.slice.size == e.from &&
			!this.slice.openEnd &&
			!e.slice.openStart
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? se.empty
					: new se(
							this.slice.content.append(e.slice.content),
							this.slice.openStart,
							e.slice.openEnd
					  );
			return new $t(
				this.from,
				this.to + (e.to - e.from),
				n,
				this.structure
			);
		} else if (
			e.to == this.from &&
			!this.slice.openStart &&
			!e.slice.openEnd
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? se.empty
					: new se(
							e.slice.content.append(this.slice.content),
							e.slice.openStart,
							this.slice.openEnd
					  );
			return new $t(e.from, this.to, n, this.structure);
		} else return null;
	}
	toJSON() {
		let e = { stepType: "replace", from: this.from, to: this.to };
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for ReplaceStep.fromJSON");
		return new $t(n.from, n.to, se.fromJSON(e, n.slice), !!n.structure);
	}
}
Yt.jsonID("replace", $t);
class It extends Yt {
	constructor(e, n, r, o, i, s, l = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.gapFrom = r),
			(this.gapTo = o),
			(this.slice = i),
			(this.insert = s),
			(this.structure = l);
	}
	apply(e) {
		if (
			this.structure &&
			(Ad(e, this.from, this.gapFrom) || Ad(e, this.gapTo, this.to))
		)
			return Mt.fail("Structure gap-replace would overwrite content");
		let n = e.slice(this.gapFrom, this.gapTo);
		if (n.openStart || n.openEnd) return Mt.fail("Gap is not a flat range");
		let r = this.slice.insertAt(this.insert, n.content);
		return r
			? Mt.fromReplace(e, this.from, this.to, r)
			: Mt.fail("Content does not fit in gap");
	}
	getMap() {
		return new gn([
			this.from,
			this.gapFrom - this.from,
			this.insert,
			this.gapTo,
			this.to - this.gapTo,
			this.slice.size - this.insert,
		]);
	}
	invert(e) {
		let n = this.gapTo - this.gapFrom;
		return new It(
			this.from,
			this.from + this.slice.size + n,
			this.from + this.insert,
			this.from + this.insert + n,
			e
				.slice(this.from, this.to)
				.removeBetween(
					this.gapFrom - this.from,
					this.gapTo - this.from
				),
			this.gapFrom - this.from,
			this.structure
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1),
			o = e.map(this.gapFrom, -1),
			i = e.map(this.gapTo, 1);
		return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
			? null
			: new It(
					n.pos,
					r.pos,
					o,
					i,
					this.slice,
					this.insert,
					this.structure
			  );
	}
	toJSON() {
		let e = {
			stepType: "replaceAround",
			from: this.from,
			to: this.to,
			gapFrom: this.gapFrom,
			gapTo: this.gapTo,
			insert: this.insert,
		};
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (
			typeof n.from != "number" ||
			typeof n.to != "number" ||
			typeof n.gapFrom != "number" ||
			typeof n.gapTo != "number" ||
			typeof n.insert != "number"
		)
			throw new RangeError(
				"Invalid input for ReplaceAroundStep.fromJSON"
			);
		return new It(
			n.from,
			n.to,
			n.gapFrom,
			n.gapTo,
			se.fromJSON(e, n.slice),
			n.insert,
			!!n.structure
		);
	}
}
Yt.jsonID("replaceAround", It);
function Ad(t, e, n) {
	let r = t.resolve(e),
		o = n - e,
		i = r.depth;
	for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
		i--, o--;
	if (o > 0) {
		let s = r.node(i).maybeChild(r.indexAfter(i));
		for (; o > 0; ) {
			if (!s || s.isLeaf) return !0;
			(s = s.firstChild), o--;
		}
	}
	return !1;
}
function RC(t, e, n, r) {
	let o = [],
		i = [],
		s,
		l;
	t.doc.nodesBetween(e, n, (a, u, c) => {
		if (!a.isInline) return;
		let d = a.marks;
		if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
			let h = Math.max(u, e),
				p = Math.min(u + a.nodeSize, n),
				g = r.addToSet(d);
			for (let y = 0; y < d.length; y++)
				d[y].isInSet(g) ||
					(s && s.to == h && s.mark.eq(d[y])
						? (s.to = p)
						: o.push((s = new nr(h, p, d[y]))));
			l && l.to == h ? (l.to = p) : i.push((l = new Jr(h, p, r)));
		}
	}),
		o.forEach((a) => t.step(a)),
		i.forEach((a) => t.step(a));
}
function PC(t, e, n, r) {
	let o = [],
		i = 0;
	t.doc.nodesBetween(e, n, (s, l) => {
		if (!s.isInline) return;
		i++;
		let a = null;
		if (r instanceof Pu) {
			let u = s.marks,
				c;
			for (; (c = r.isInSet(u)); )
				(a || (a = [])).push(c), (u = c.removeFromSet(u));
		} else r ? r.isInSet(s.marks) && (a = [r]) : (a = s.marks);
		if (a && a.length) {
			let u = Math.min(l + s.nodeSize, n);
			for (let c = 0; c < a.length; c++) {
				let d = a[c],
					h;
				for (let p = 0; p < o.length; p++) {
					let g = o[p];
					g.step == i - 1 && d.eq(o[p].style) && (h = g);
				}
				h
					? ((h.to = u), (h.step = i))
					: o.push({
							style: d,
							from: Math.max(l, e),
							to: u,
							step: i,
					  });
			}
		}
	}),
		o.forEach((s) => t.step(new nr(s.from, s.to, s.style)));
}
function IC(t, e, n, r = n.contentMatch) {
	let o = t.doc.nodeAt(e),
		i = [],
		s = e + 1;
	for (let l = 0; l < o.childCount; l++) {
		let a = o.child(l),
			u = s + a.nodeSize,
			c = r.matchType(a.type);
		if (!c) i.push(new $t(s, u, se.empty));
		else {
			r = c;
			for (let d = 0; d < a.marks.length; d++)
				n.allowsMarkType(a.marks[d].type) ||
					t.step(new nr(s, u, a.marks[d]));
			if (a.isText && !n.spec.code) {
				let d,
					h = /\r?\n|\r/g,
					p;
				for (; (d = h.exec(a.text)); )
					p ||
						(p = new se(
							J.from(n.schema.text(" ", n.allowedMarks(a.marks))),
							0,
							0
						)),
						i.push(
							new $t(s + d.index, s + d.index + d[0].length, p)
						);
			}
		}
		s = u;
	}
	if (!r.validEnd) {
		let l = r.fillBefore(J.empty, !0);
		t.replace(s, s, new se(l, 0, 0));
	}
	for (let l = i.length - 1; l >= 0; l--) t.step(i[l]);
}
function NC(t, e, n) {
	return (
		(e == 0 || t.canReplace(e, t.childCount)) &&
		(n == t.childCount || t.canReplace(0, n))
	);
}
function Li(t) {
	let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
	for (let r = t.depth; ; --r) {
		let o = t.$from.node(r),
			i = t.$from.index(r),
			s = t.$to.indexAfter(r);
		if (r < t.depth && o.canReplace(i, s, n)) return r;
		if (r == 0 || o.type.spec.isolating || !NC(o, i, s)) break;
	}
	return null;
}
function DC(t, e, n) {
	let { $from: r, $to: o, depth: i } = e,
		s = r.before(i + 1),
		l = o.after(i + 1),
		a = s,
		u = l,
		c = J.empty,
		d = 0;
	for (let g = i, y = !1; g > n; g--)
		y || r.index(g) > 0
			? ((y = !0), (c = J.from(r.node(g).copy(c))), d++)
			: a--;
	let h = J.empty,
		p = 0;
	for (let g = i, y = !1; g > n; g--)
		y || o.after(g + 1) < o.end(g)
			? ((y = !0), (h = J.from(o.node(g).copy(h))), p++)
			: u++;
	t.step(new It(a, u, s, l, new se(c.append(h), d, p), c.size - d, !0));
}
function oh(t, e, n = null, r = t) {
	let o = jC(t, e),
		i = o && LC(r, e);
	return i ? o.map(Em).concat({ type: e, attrs: n }).concat(i.map(Em)) : null;
}
function Em(t) {
	return { type: t, attrs: null };
}
function jC(t, e) {
	let { parent: n, startIndex: r, endIndex: o } = t,
		i = n.contentMatchAt(r).findWrapping(e);
	if (!i) return null;
	let s = i.length ? i[0] : e;
	return n.canReplaceWith(r, o, s) ? i : null;
}
function LC(t, e) {
	let { parent: n, startIndex: r, endIndex: o } = t,
		i = n.child(r),
		s = e.contentMatch.findWrapping(i.type);
	if (!s) return null;
	let a = (s.length ? s[s.length - 1] : e).contentMatch;
	for (let u = r; a && u < o; u++) a = a.matchType(n.child(u).type);
	return !a || !a.validEnd ? null : s;
}
function $C(t, e, n) {
	let r = J.empty;
	for (let s = n.length - 1; s >= 0; s--) {
		if (r.size) {
			let l = n[s].type.contentMatch.matchFragment(r);
			if (!l || !l.validEnd)
				throw new RangeError(
					"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
				);
		}
		r = J.from(n[s].type.create(n[s].attrs, r));
	}
	let o = e.start,
		i = e.end;
	t.step(new It(o, i, o, i, new se(r, 0, 0), n.length, !0));
}
function BC(t, e, n, r, o) {
	if (!r.isTextblock)
		throw new RangeError(
			"Type given to setBlockType should be a textblock"
		);
	let i = t.steps.length;
	t.doc.nodesBetween(e, n, (s, l) => {
		if (
			s.isTextblock &&
			!s.hasMarkup(r, o) &&
			zC(t.doc, t.mapping.slice(i).map(l), r)
		) {
			t.clearIncompatible(t.mapping.slice(i).map(l, 1), r);
			let a = t.mapping.slice(i),
				u = a.map(l, 1),
				c = a.map(l + s.nodeSize, 1);
			return (
				t.step(
					new It(
						u,
						c,
						u + 1,
						c - 1,
						new se(J.from(r.create(o, null, s.marks)), 0, 0),
						1,
						!0
					)
				),
				!1
			);
		}
	});
}
function zC(t, e, n) {
	let r = t.resolve(e),
		o = r.index();
	return r.parent.canReplaceWith(o, o + 1, n);
}
function HC(t, e, n, r, o) {
	let i = t.doc.nodeAt(e);
	if (!i) throw new RangeError("No node at given position");
	n || (n = i.type);
	let s = n.create(r, null, o || i.marks);
	if (i.isLeaf) return t.replaceWith(e, e + i.nodeSize, s);
	if (!n.validContent(i.content))
		throw new RangeError("Invalid content for node type " + n.name);
	t.step(
		new It(
			e,
			e + i.nodeSize,
			e + 1,
			e + i.nodeSize - 1,
			new se(J.from(s), 0, 0),
			1,
			!0
		)
	);
}
function pi(t, e, n = 1, r) {
	let o = t.resolve(e),
		i = o.depth - n,
		s = (r && r[r.length - 1]) || o.parent;
	if (
		i < 0 ||
		o.parent.type.spec.isolating ||
		!o.parent.canReplace(o.index(), o.parent.childCount) ||
		!s.type.validContent(
			o.parent.content.cutByIndex(o.index(), o.parent.childCount)
		)
	)
		return !1;
	for (let u = o.depth - 1, c = n - 2; u > i; u--, c--) {
		let d = o.node(u),
			h = o.index(u);
		if (d.type.spec.isolating) return !1;
		let p = d.content.cutByIndex(h, d.childCount),
			g = r && r[c + 1];
		g && (p = p.replaceChild(0, g.type.create(g.attrs)));
		let y = (r && r[c]) || d;
		if (!d.canReplace(h + 1, d.childCount) || !y.type.validContent(p))
			return !1;
	}
	let l = o.indexAfter(i),
		a = r && r[0];
	return o.node(i).canReplaceWith(l, l, a ? a.type : o.node(i + 1).type);
}
function FC(t, e, n = 1, r) {
	let o = t.doc.resolve(e),
		i = J.empty,
		s = J.empty;
	for (let l = o.depth, a = o.depth - n, u = n - 1; l > a; l--, u--) {
		i = J.from(o.node(l).copy(i));
		let c = r && r[u];
		s = J.from(c ? c.type.create(c.attrs, s) : o.node(l).copy(s));
	}
	t.step(new $t(e, e, new se(i.append(s), n, n), !0));
}
function fo(t, e) {
	let n = t.resolve(e),
		r = n.index();
	return ov(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function ov(t, e) {
	return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function Nu(t, e, n = -1) {
	let r = t.resolve(e);
	for (let o = r.depth; ; o--) {
		let i,
			s,
			l = r.index(o);
		if (
			(o == r.depth
				? ((i = r.nodeBefore), (s = r.nodeAfter))
				: n > 0
				? ((i = r.node(o + 1)), l++, (s = r.node(o).maybeChild(l)))
				: ((i = r.node(o).maybeChild(l - 1)), (s = r.node(o + 1))),
			i && !i.isTextblock && ov(i, s) && r.node(o).canReplace(l, l + 1))
		)
			return e;
		if (o == 0) break;
		e = n < 0 ? r.before(o) : r.after(o);
	}
}
function VC(t, e, n) {
	let r = new $t(e - n, e + n, se.empty, !0);
	t.step(r);
}
function WC(t, e, n) {
	let r = t.resolve(e);
	if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
	if (r.parentOffset == 0)
		for (let o = r.depth - 1; o >= 0; o--) {
			let i = r.index(o);
			if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1);
			if (i > 0) return null;
		}
	if (r.parentOffset == r.parent.content.size)
		for (let o = r.depth - 1; o >= 0; o--) {
			let i = r.indexAfter(o);
			if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1);
			if (i < r.node(o).childCount) return null;
		}
	return null;
}
function iv(t, e, n) {
	let r = t.resolve(e);
	if (!n.content.size) return e;
	let o = n.content;
	for (let i = 0; i < n.openStart; i++) o = o.firstChild.content;
	for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
		for (let s = r.depth; s >= 0; s--) {
			let l =
					s == r.depth
						? 0
						: r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
						? -1
						: 1,
				a = r.index(s) + (l > 0 ? 1 : 0),
				u = r.node(s),
				c = !1;
			if (i == 1) c = u.canReplace(a, a, o);
			else {
				let d = u.contentMatchAt(a).findWrapping(o.firstChild.type);
				c = d && u.canReplaceWith(a, a, d[0]);
			}
			if (c)
				return l == 0
					? r.pos
					: l < 0
					? r.before(s + 1)
					: r.after(s + 1);
		}
	return null;
}
function ih(t, e, n = e, r = se.empty) {
	if (e == n && !r.size) return null;
	let o = t.resolve(e),
		i = t.resolve(n);
	return sv(o, i, r) ? new $t(e, n, r) : new UC(o, i, r).fit();
}
function sv(t, e, n) {
	return (
		!n.openStart &&
		!n.openEnd &&
		t.start() == e.start() &&
		t.parent.canReplace(t.index(), e.index(), n.content)
	);
}
class UC {
	constructor(e, n, r) {
		(this.$from = e),
			(this.$to = n),
			(this.unplaced = r),
			(this.frontier = []),
			(this.placed = J.empty);
		for (let o = 0; o <= e.depth; o++) {
			let i = e.node(o);
			this.frontier.push({
				type: i.type,
				match: i.contentMatchAt(e.indexAfter(o)),
			});
		}
		for (let o = e.depth; o > 0; o--)
			this.placed = J.from(e.node(o).copy(this.placed));
	}
	get depth() {
		return this.frontier.length - 1;
	}
	fit() {
		for (; this.unplaced.size; ) {
			let u = this.findFittable();
			u ? this.placeNodes(u) : this.openMore() || this.dropNode();
		}
		let e = this.mustMoveInline(),
			n = this.placed.size - this.depth - this.$from.depth,
			r = this.$from,
			o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
		if (!o) return null;
		let i = this.placed,
			s = r.depth,
			l = o.depth;
		for (; s && l && i.childCount == 1; )
			(i = i.firstChild.content), s--, l--;
		let a = new se(i, s, l);
		return e > -1
			? new It(r.pos, e, this.$to.pos, this.$to.end(), a, n)
			: a.size || r.pos != this.$to.pos
			? new $t(r.pos, o.pos, a)
			: null;
	}
	findFittable() {
		let e = this.unplaced.openStart;
		for (
			let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
			r < e;
			r++
		) {
			let i = n.firstChild;
			if (
				(n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)
			) {
				e = r;
				break;
			}
			n = i.content;
		}
		for (let n = 1; n <= 2; n++)
			for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
				let o,
					i = null;
				r
					? ((i = xc(this.unplaced.content, r - 1).firstChild),
					  (o = i.content))
					: (o = this.unplaced.content);
				let s = o.firstChild;
				for (let l = this.depth; l >= 0; l--) {
					let { type: a, match: u } = this.frontier[l],
						c,
						d = null;
					if (
						n == 1 &&
						(s
							? u.matchType(s.type) ||
							  (d = u.fillBefore(J.from(s), !1))
							: i && a.compatibleContent(i.type))
					)
						return {
							sliceDepth: r,
							frontierDepth: l,
							parent: i,
							inject: d,
						};
					if (n == 2 && s && (c = u.findWrapping(s.type)))
						return {
							sliceDepth: r,
							frontierDepth: l,
							parent: i,
							wrap: c,
						};
					if (i && u.matchType(i.type)) break;
				}
			}
	}
	openMore() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			o = xc(e, n);
		return !o.childCount || o.firstChild.isLeaf
			? !1
			: ((this.unplaced = new se(
					e,
					n + 1,
					Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)
			  )),
			  !0);
	}
	dropNode() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			o = xc(e, n);
		if (o.childCount <= 1 && n > 0) {
			let i = e.size - n <= n + o.size;
			this.unplaced = new se(Qi(e, n - 1, 1), n - 1, i ? n - 1 : r);
		} else this.unplaced = new se(Qi(e, n, 1), n, r);
	}
	placeNodes({
		sliceDepth: e,
		frontierDepth: n,
		parent: r,
		inject: o,
		wrap: i,
	}) {
		for (; this.depth > n; ) this.closeFrontierNode();
		if (i) for (let y = 0; y < i.length; y++) this.openFrontierNode(i[y]);
		let s = this.unplaced,
			l = r ? r.content : s.content,
			a = s.openStart - e,
			u = 0,
			c = [],
			{ match: d, type: h } = this.frontier[n];
		if (o) {
			for (let y = 0; y < o.childCount; y++) c.push(o.child(y));
			d = d.matchFragment(o);
		}
		let p = l.size + e - (s.content.size - s.openEnd);
		for (; u < l.childCount; ) {
			let y = l.child(u),
				b = d.matchType(y.type);
			if (!b) break;
			u++,
				(u > 1 || a == 0 || y.content.size) &&
					((d = b),
					c.push(
						lv(
							y.mark(h.allowedMarks(y.marks)),
							u == 1 ? a : 0,
							u == l.childCount ? p : -1
						)
					));
		}
		let g = u == l.childCount;
		g || (p = -1),
			(this.placed = Xi(this.placed, n, J.from(c))),
			(this.frontier[n].match = d),
			g &&
				p < 0 &&
				r &&
				r.type == this.frontier[this.depth].type &&
				this.frontier.length > 1 &&
				this.closeFrontierNode();
		for (let y = 0, b = l; y < p; y++) {
			let w = b.lastChild;
			this.frontier.push({
				type: w.type,
				match: w.contentMatchAt(w.childCount),
			}),
				(b = w.content);
		}
		this.unplaced = g
			? e == 0
				? se.empty
				: new se(
						Qi(s.content, e - 1, 1),
						e - 1,
						p < 0 ? s.openEnd : e - 1
				  )
			: new se(Qi(s.content, e, u), s.openStart, s.openEnd);
	}
	mustMoveInline() {
		if (!this.$to.parent.isTextblock) return -1;
		let e = this.frontier[this.depth],
			n;
		if (
			!e.type.isTextblock ||
			!kc(this.$to, this.$to.depth, e.type, e.match, !1) ||
			(this.$to.depth == this.depth &&
				(n = this.findCloseLevel(this.$to)) &&
				n.depth == this.depth)
		)
			return -1;
		let { depth: r } = this.$to,
			o = this.$to.after(r);
		for (; r > 1 && o == this.$to.end(--r); ) ++o;
		return o;
	}
	findCloseLevel(e) {
		e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
			let { match: r, type: o } = this.frontier[n],
				i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
				s = kc(e, n, o, r, i);
			if (s) {
				for (let l = n - 1; l >= 0; l--) {
					let { match: a, type: u } = this.frontier[l],
						c = kc(e, l, u, a, !0);
					if (!c || c.childCount) continue e;
				}
				return {
					depth: n,
					fit: s,
					move: i ? e.doc.resolve(e.after(n + 1)) : e,
				};
			}
		}
	}
	close(e) {
		let n = this.findCloseLevel(e);
		if (!n) return null;
		for (; this.depth > n.depth; ) this.closeFrontierNode();
		n.fit.childCount && (this.placed = Xi(this.placed, n.depth, n.fit)),
			(e = n.move);
		for (let r = n.depth + 1; r <= e.depth; r++) {
			let o = e.node(r),
				i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
			this.openFrontierNode(o.type, o.attrs, i);
		}
		return e;
	}
	openFrontierNode(e, n = null, r) {
		let o = this.frontier[this.depth];
		(o.match = o.match.matchType(e)),
			(this.placed = Xi(this.placed, this.depth, J.from(e.create(n, r)))),
			this.frontier.push({ type: e, match: e.contentMatch });
	}
	closeFrontierNode() {
		let n = this.frontier.pop().match.fillBefore(J.empty, !0);
		n.childCount &&
			(this.placed = Xi(this.placed, this.frontier.length, n));
	}
}
function Qi(t, e, n) {
	return e == 0
		? t.cutByIndex(n, t.childCount)
		: t.replaceChild(
				0,
				t.firstChild.copy(Qi(t.firstChild.content, e - 1, n))
		  );
}
function Xi(t, e, n) {
	return e == 0
		? t.append(n)
		: t.replaceChild(
				t.childCount - 1,
				t.lastChild.copy(Xi(t.lastChild.content, e - 1, n))
		  );
}
function xc(t, e) {
	for (let n = 0; n < e; n++) t = t.firstChild.content;
	return t;
}
function lv(t, e, n) {
	if (e <= 0) return t;
	let r = t.content;
	return (
		e > 1 &&
			(r = r.replaceChild(
				0,
				lv(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
			)),
		e > 0 &&
			((r = t.type.contentMatch.fillBefore(r).append(r)),
			n <= 0 &&
				(r = r.append(
					t.type.contentMatch.matchFragment(r).fillBefore(J.empty, !0)
				))),
		t.copy(r)
	);
}
function kc(t, e, n, r, o) {
	let i = t.node(e),
		s = o ? t.indexAfter(e) : t.index(e);
	if (s == i.childCount && !n.compatibleContent(i.type)) return null;
	let l = r.fillBefore(i.content, !0, s);
	return l && !KC(n, i.content, s) ? l : null;
}
function KC(t, e, n) {
	for (let r = n; r < e.childCount; r++)
		if (!t.allowsMarks(e.child(r).marks)) return !0;
	return !1;
}
function qC(t) {
	return t.spec.defining || t.spec.definingForContent;
}
function JC(t, e, n, r) {
	if (!r.size) return t.deleteRange(e, n);
	let o = t.doc.resolve(e),
		i = t.doc.resolve(n);
	if (sv(o, i, r)) return t.step(new $t(e, n, r));
	let s = uv(o, t.doc.resolve(n));
	s[s.length - 1] == 0 && s.pop();
	let l = -(o.depth + 1);
	s.unshift(l);
	for (let h = o.depth, p = o.pos - 1; h > 0; h--, p--) {
		let g = o.node(h).type.spec;
		if (g.defining || g.definingAsContext || g.isolating) break;
		s.indexOf(h) > -1 ? (l = h) : o.before(h) == p && s.splice(1, 0, -h);
	}
	let a = s.indexOf(l),
		u = [],
		c = r.openStart;
	for (let h = r.content, p = 0; ; p++) {
		let g = h.firstChild;
		if ((u.push(g), p == r.openStart)) break;
		h = g.content;
	}
	for (let h = c - 1; h >= 0; h--) {
		let p = u[h],
			g = qC(p.type);
		if (g && !p.sameMarkup(o.node(Math.abs(l) - 1))) c = h;
		else if (g || !p.type.isTextblock) break;
	}
	for (let h = r.openStart; h >= 0; h--) {
		let p = (h + c + 1) % (r.openStart + 1),
			g = u[p];
		if (g)
			for (let y = 0; y < s.length; y++) {
				let b = s[(y + a) % s.length],
					w = !0;
				b < 0 && ((w = !1), (b = -b));
				let S = o.node(b - 1),
					E = o.index(b - 1);
				if (S.canReplaceWith(E, E, g.type, g.marks))
					return t.replace(
						o.before(b),
						w ? i.after(b) : n,
						new se(av(r.content, 0, r.openStart, p), p, r.openEnd)
					);
			}
	}
	let d = t.steps.length;
	for (
		let h = s.length - 1;
		h >= 0 && (t.replace(e, n, r), !(t.steps.length > d));
		h--
	) {
		let p = s[h];
		p < 0 || ((e = o.before(p)), (n = i.after(p)));
	}
}
function av(t, e, n, r, o) {
	if (e < n) {
		let i = t.firstChild;
		t = t.replaceChild(0, i.copy(av(i.content, e + 1, n, r, i)));
	}
	if (e > r) {
		let i = o.contentMatchAt(0),
			s = i.fillBefore(t).append(t);
		t = s.append(i.matchFragment(s).fillBefore(J.empty, !0));
	}
	return t;
}
function GC(t, e, n, r) {
	if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
		let o = WC(t.doc, e, r.type);
		o != null && (e = n = o);
	}
	t.replaceRange(e, n, new se(J.from(r), 0, 0));
}
function YC(t, e, n) {
	let r = t.doc.resolve(e),
		o = t.doc.resolve(n),
		i = uv(r, o);
	for (let s = 0; s < i.length; s++) {
		let l = i[s],
			a = s == i.length - 1;
		if ((a && l == 0) || r.node(l).type.contentMatch.validEnd)
			return t.delete(r.start(l), o.end(l));
		if (
			l > 0 &&
			(a || r.node(l - 1).canReplace(r.index(l - 1), o.indexAfter(l - 1)))
		)
			return t.delete(r.before(l), o.after(l));
	}
	for (let s = 1; s <= r.depth && s <= o.depth; s++)
		if (
			e - r.start(s) == r.depth - s &&
			n > r.end(s) &&
			o.end(s) - n != o.depth - s
		)
			return t.delete(r.before(s), n);
	t.delete(e, n);
}
function uv(t, e) {
	let n = [],
		r = Math.min(t.depth, e.depth);
	for (let o = r; o >= 0; o--) {
		let i = t.start(o);
		if (
			i < t.pos - (t.depth - o) ||
			e.end(o) > e.pos + (e.depth - o) ||
			t.node(o).type.spec.isolating ||
			e.node(o).type.spec.isolating
		)
			break;
		(i == e.start(o) ||
			(o == t.depth &&
				o == e.depth &&
				t.parent.inlineContent &&
				e.parent.inlineContent &&
				o &&
				e.start(o - 1) == i - 1)) &&
			n.push(o);
	}
	return n;
}
class mi extends Yt {
	constructor(e, n, r) {
		super(), (this.pos = e), (this.attr = n), (this.value = r);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Mt.fail("No node at attribute step's position");
		let r = Object.create(null);
		for (let i in n.attrs) r[i] = n.attrs[i];
		r[this.attr] = this.value;
		let o = n.type.create(r, null, n.marks);
		return Mt.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new se(J.from(o), 0, n.isLeaf ? 0 : 1)
		);
	}
	getMap() {
		return gn.empty;
	}
	invert(e) {
		return new mi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new mi(n.pos, this.attr, this.value);
	}
	toJSON() {
		return {
			stepType: "attr",
			pos: this.pos,
			attr: this.attr,
			value: this.value,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number" || typeof n.attr != "string")
			throw new RangeError("Invalid input for AttrStep.fromJSON");
		return new mi(n.pos, n.attr, n.value);
	}
}
Yt.jsonID("attr", mi);
class Is extends Yt {
	constructor(e, n) {
		super(), (this.attr = e), (this.value = n);
	}
	apply(e) {
		let n = Object.create(null);
		for (let o in e.attrs) n[o] = e.attrs[o];
		n[this.attr] = this.value;
		let r = e.type.create(n, e.content, e.marks);
		return Mt.ok(r);
	}
	getMap() {
		return gn.empty;
	}
	invert(e) {
		return new Is(this.attr, e.attrs[this.attr]);
	}
	map(e) {
		return this;
	}
	toJSON() {
		return { stepType: "docAttr", attr: this.attr, value: this.value };
	}
	static fromJSON(e, n) {
		if (typeof n.attr != "string")
			throw new RangeError("Invalid input for DocAttrStep.fromJSON");
		return new Is(n.attr, n.value);
	}
}
Yt.jsonID("docAttr", Is);
let Oi = class extends Error {};
Oi = function t(e) {
	let n = Error.call(this, e);
	return (n.__proto__ = t.prototype), n;
};
Oi.prototype = Object.create(Error.prototype);
Oi.prototype.constructor = Oi;
Oi.prototype.name = "TransformError";
class sh {
	constructor(e) {
		(this.doc = e),
			(this.steps = []),
			(this.docs = []),
			(this.mapping = new hi());
	}
	get before() {
		return this.docs.length ? this.docs[0] : this.doc;
	}
	step(e) {
		let n = this.maybeStep(e);
		if (n.failed) throw new Oi(n.failed);
		return this;
	}
	maybeStep(e) {
		let n = e.apply(this.doc);
		return n.failed || this.addStep(e, n.doc), n;
	}
	get docChanged() {
		return this.steps.length > 0;
	}
	addStep(e, n) {
		this.docs.push(this.doc),
			this.steps.push(e),
			this.mapping.appendMap(e.getMap()),
			(this.doc = n);
	}
	replace(e, n = e, r = se.empty) {
		let o = ih(this.doc, e, n, r);
		return o && this.step(o), this;
	}
	replaceWith(e, n, r) {
		return this.replace(e, n, new se(J.from(r), 0, 0));
	}
	delete(e, n) {
		return this.replace(e, n, se.empty);
	}
	insert(e, n) {
		return this.replaceWith(e, e, n);
	}
	replaceRange(e, n, r) {
		return JC(this, e, n, r), this;
	}
	replaceRangeWith(e, n, r) {
		return GC(this, e, n, r), this;
	}
	deleteRange(e, n) {
		return YC(this, e, n), this;
	}
	lift(e, n) {
		return DC(this, e, n), this;
	}
	join(e, n = 1) {
		return VC(this, e, n), this;
	}
	wrap(e, n) {
		return $C(this, e, n), this;
	}
	setBlockType(e, n = e, r, o = null) {
		return BC(this, e, n, r, o), this;
	}
	setNodeMarkup(e, n, r = null, o) {
		return HC(this, e, n, r, o), this;
	}
	setNodeAttribute(e, n, r) {
		return this.step(new mi(e, n, r)), this;
	}
	setDocAttribute(e, n) {
		return this.step(new Is(e, n)), this;
	}
	addNodeMark(e, n) {
		return this.step(new Gr(e, n)), this;
	}
	removeNodeMark(e, n) {
		if (!(n instanceof ot)) {
			let r = this.doc.nodeAt(e);
			if (!r) throw new RangeError("No node at position " + e);
			if (((n = n.isInSet(r.marks)), !n)) return this;
		}
		return this.step(new Ai(e, n)), this;
	}
	split(e, n = 1, r) {
		return FC(this, e, n, r), this;
	}
	addMark(e, n, r) {
		return RC(this, e, n, r), this;
	}
	removeMark(e, n, r) {
		return PC(this, e, n, r), this;
	}
	clearIncompatible(e, n, r) {
		return IC(this, e, n, r), this;
	}
}
const Sc = Object.create(null);
class _e {
	constructor(e, n, r) {
		(this.$anchor = e),
			(this.$head = n),
			(this.ranges = r || [new cv(e.min(n), e.max(n))]);
	}
	get anchor() {
		return this.$anchor.pos;
	}
	get head() {
		return this.$head.pos;
	}
	get from() {
		return this.$from.pos;
	}
	get to() {
		return this.$to.pos;
	}
	get $from() {
		return this.ranges[0].$from;
	}
	get $to() {
		return this.ranges[0].$to;
	}
	get empty() {
		let e = this.ranges;
		for (let n = 0; n < e.length; n++)
			if (e[n].$from.pos != e[n].$to.pos) return !1;
		return !0;
	}
	content() {
		return this.$from.doc.slice(this.from, this.to, !0);
	}
	replace(e, n = se.empty) {
		let r = n.content.lastChild,
			o = null;
		for (let l = 0; l < n.openEnd; l++) (o = r), (r = r.lastChild);
		let i = e.steps.length,
			s = this.ranges;
		for (let l = 0; l < s.length; l++) {
			let { $from: a, $to: u } = s[l],
				c = e.mapping.slice(i);
			e.replaceRange(c.map(a.pos), c.map(u.pos), l ? se.empty : n),
				l == 0 &&
					Om(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
		}
	}
	replaceWith(e, n) {
		let r = e.steps.length,
			o = this.ranges;
		for (let i = 0; i < o.length; i++) {
			let { $from: s, $to: l } = o[i],
				a = e.mapping.slice(r),
				u = a.map(s.pos),
				c = a.map(l.pos);
			i
				? e.deleteRange(u, c)
				: (e.replaceRangeWith(u, c, n), Om(e, r, n.isInline ? -1 : 1));
		}
	}
	static findFrom(e, n, r = !1) {
		let o = e.parent.inlineContent
			? new ke(e)
			: ti(e.node(0), e.parent, e.pos, e.index(), n, r);
		if (o) return o;
		for (let i = e.depth - 1; i >= 0; i--) {
			let s =
				n < 0
					? ti(
							e.node(0),
							e.node(i),
							e.before(i + 1),
							e.index(i),
							n,
							r
					  )
					: ti(
							e.node(0),
							e.node(i),
							e.after(i + 1),
							e.index(i) + 1,
							n,
							r
					  );
			if (s) return s;
		}
		return null;
	}
	static near(e, n = 1) {
		return this.findFrom(e, n) || this.findFrom(e, -n) || new Hn(e.node(0));
	}
	static atStart(e) {
		return ti(e, e, 0, 0, 1) || new Hn(e);
	}
	static atEnd(e) {
		return ti(e, e, e.content.size, e.childCount, -1) || new Hn(e);
	}
	static fromJSON(e, n) {
		if (!n || !n.type)
			throw new RangeError("Invalid input for Selection.fromJSON");
		let r = Sc[n.type];
		if (!r) throw new RangeError(`No selection type ${n.type} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in Sc)
			throw new RangeError("Duplicate use of selection JSON ID " + e);
		return (Sc[e] = n), (n.prototype.jsonID = e), n;
	}
	getBookmark() {
		return ke.between(this.$anchor, this.$head).getBookmark();
	}
}
_e.prototype.visible = !0;
class cv {
	constructor(e, n) {
		(this.$from = e), (this.$to = n);
	}
}
let Tm = !1;
function Am(t) {
	!Tm &&
		!t.parent.inlineContent &&
		((Tm = !0),
		console.warn(
			"TextSelection endpoint not pointing into a node with inline content (" +
				t.parent.type.name +
				")"
		));
}
class ke extends _e {
	constructor(e, n = e) {
		Am(e), Am(n), super(e, n);
	}
	get $cursor() {
		return this.$anchor.pos == this.$head.pos ? this.$head : null;
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		if (!r.parent.inlineContent) return _e.near(r);
		let o = e.resolve(n.map(this.anchor));
		return new ke(o.parent.inlineContent ? o : r, r);
	}
	replace(e, n = se.empty) {
		if ((super.replace(e, n), n == se.empty)) {
			let r = this.$from.marksAcross(this.$to);
			r && e.ensureMarks(r);
		}
	}
	eq(e) {
		return (
			e instanceof ke && e.anchor == this.anchor && e.head == this.head
		);
	}
	getBookmark() {
		return new Du(this.anchor, this.head);
	}
	toJSON() {
		return { type: "text", anchor: this.anchor, head: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number" || typeof n.head != "number")
			throw new RangeError("Invalid input for TextSelection.fromJSON");
		return new ke(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		let o = e.resolve(n);
		return new this(o, r == n ? o : e.resolve(r));
	}
	static between(e, n, r) {
		let o = e.pos - n.pos;
		if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
			let i = _e.findFrom(n, r, !0) || _e.findFrom(n, -r, !0);
			if (i) n = i.$head;
			else return _e.near(n, r);
		}
		return (
			e.parent.inlineContent ||
				(o == 0
					? (e = n)
					: ((e = (_e.findFrom(e, -r, !0) || _e.findFrom(e, r, !0))
							.$anchor),
					  e.pos < n.pos != o < 0 && (e = n))),
			new ke(e, n)
		);
	}
}
_e.jsonID("text", ke);
class Du {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new Du(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		return ke.between(e.resolve(this.anchor), e.resolve(this.head));
	}
}
class ve extends _e {
	constructor(e) {
		let n = e.nodeAfter,
			r = e.node(0).resolve(e.pos + n.nodeSize);
		super(e, r), (this.node = n);
	}
	map(e, n) {
		let { deleted: r, pos: o } = n.mapResult(this.anchor),
			i = e.resolve(o);
		return r ? _e.near(i) : new ve(i);
	}
	content() {
		return new se(J.from(this.node), 0, 0);
	}
	eq(e) {
		return e instanceof ve && e.anchor == this.anchor;
	}
	toJSON() {
		return { type: "node", anchor: this.anchor };
	}
	getBookmark() {
		return new lh(this.anchor);
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number")
			throw new RangeError("Invalid input for NodeSelection.fromJSON");
		return new ve(e.resolve(n.anchor));
	}
	static create(e, n) {
		return new ve(e.resolve(n));
	}
	static isSelectable(e) {
		return !e.isText && e.type.spec.selectable !== !1;
	}
}
ve.prototype.visible = !1;
_e.jsonID("node", ve);
class lh {
	constructor(e) {
		this.anchor = e;
	}
	map(e) {
		let { deleted: n, pos: r } = e.mapResult(this.anchor);
		return n ? new Du(r, r) : new lh(r);
	}
	resolve(e) {
		let n = e.resolve(this.anchor),
			r = n.nodeAfter;
		return r && ve.isSelectable(r) ? new ve(n) : _e.near(n);
	}
}
class Hn extends _e {
	constructor(e) {
		super(e.resolve(0), e.resolve(e.content.size));
	}
	replace(e, n = se.empty) {
		if (n == se.empty) {
			e.delete(0, e.doc.content.size);
			let r = _e.atStart(e.doc);
			r.eq(e.selection) || e.setSelection(r);
		} else super.replace(e, n);
	}
	toJSON() {
		return { type: "all" };
	}
	static fromJSON(e) {
		return new Hn(e);
	}
	map(e) {
		return new Hn(e);
	}
	eq(e) {
		return e instanceof Hn;
	}
	getBookmark() {
		return QC;
	}
}
_e.jsonID("all", Hn);
const QC = {
	map() {
		return this;
	},
	resolve(t) {
		return new Hn(t);
	},
};
function ti(t, e, n, r, o, i = !1) {
	if (e.inlineContent) return ke.create(t, n);
	for (
		let s = r - (o > 0 ? 0 : 1);
		o > 0 ? s < e.childCount : s >= 0;
		s += o
	) {
		let l = e.child(s);
		if (l.isAtom) {
			if (!i && ve.isSelectable(l))
				return ve.create(t, n - (o < 0 ? l.nodeSize : 0));
		} else {
			let a = ti(t, l, n + o, o < 0 ? l.childCount : 0, o, i);
			if (a) return a;
		}
		n += l.nodeSize * o;
	}
	return null;
}
function Om(t, e, n) {
	let r = t.steps.length - 1;
	if (r < e) return;
	let o = t.steps[r];
	if (!(o instanceof $t || o instanceof It)) return;
	let i = t.mapping.maps[r],
		s;
	i.forEach((l, a, u, c) => {
		s == null && (s = c);
	}),
		t.setSelection(_e.near(t.doc.resolve(s), n));
}
const Rm = 1,
	Cl = 2,
	Pm = 4;
class XC extends sh {
	constructor(e) {
		super(e.doc),
			(this.curSelectionFor = 0),
			(this.updated = 0),
			(this.meta = Object.create(null)),
			(this.time = Date.now()),
			(this.curSelection = e.selection),
			(this.storedMarks = e.storedMarks);
	}
	get selection() {
		return (
			this.curSelectionFor < this.steps.length &&
				((this.curSelection = this.curSelection.map(
					this.doc,
					this.mapping.slice(this.curSelectionFor)
				)),
				(this.curSelectionFor = this.steps.length)),
			this.curSelection
		);
	}
	setSelection(e) {
		if (e.$from.doc != this.doc)
			throw new RangeError(
				"Selection passed to setSelection must point at the current document"
			);
		return (
			(this.curSelection = e),
			(this.curSelectionFor = this.steps.length),
			(this.updated = (this.updated | Rm) & ~Cl),
			(this.storedMarks = null),
			this
		);
	}
	get selectionSet() {
		return (this.updated & Rm) > 0;
	}
	setStoredMarks(e) {
		return (this.storedMarks = e), (this.updated |= Cl), this;
	}
	ensureMarks(e) {
		return (
			ot.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
				this.setStoredMarks(e),
			this
		);
	}
	addStoredMark(e) {
		return this.ensureMarks(
			e.addToSet(this.storedMarks || this.selection.$head.marks())
		);
	}
	removeStoredMark(e) {
		return this.ensureMarks(
			e.removeFromSet(this.storedMarks || this.selection.$head.marks())
		);
	}
	get storedMarksSet() {
		return (this.updated & Cl) > 0;
	}
	addStep(e, n) {
		super.addStep(e, n),
			(this.updated = this.updated & ~Cl),
			(this.storedMarks = null);
	}
	setTime(e) {
		return (this.time = e), this;
	}
	replaceSelection(e) {
		return this.selection.replace(this, e), this;
	}
	replaceSelectionWith(e, n = !0) {
		let r = this.selection;
		return (
			n &&
				(e = e.mark(
					this.storedMarks ||
						(r.empty
							? r.$from.marks()
							: r.$from.marksAcross(r.$to) || ot.none)
				)),
			r.replaceWith(this, e),
			this
		);
	}
	deleteSelection() {
		return this.selection.replace(this), this;
	}
	insertText(e, n, r) {
		let o = this.doc.type.schema;
		if (n == null)
			return e
				? this.replaceSelectionWith(o.text(e), !0)
				: this.deleteSelection();
		{
			if ((r == null && (r = n), (r = r == null ? n : r), !e))
				return this.deleteRange(n, r);
			let i = this.storedMarks;
			if (!i) {
				let s = this.doc.resolve(n);
				i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
			}
			return (
				this.replaceRangeWith(n, r, o.text(e, i)),
				this.selection.empty ||
					this.setSelection(_e.near(this.selection.$to)),
				this
			);
		}
	}
	setMeta(e, n) {
		return (this.meta[typeof e == "string" ? e : e.key] = n), this;
	}
	getMeta(e) {
		return this.meta[typeof e == "string" ? e : e.key];
	}
	get isGeneric() {
		for (let e in this.meta) return !1;
		return !0;
	}
	scrollIntoView() {
		return (this.updated |= Pm), this;
	}
	get scrolledIntoView() {
		return (this.updated & Pm) > 0;
	}
}
function Im(t, e) {
	return !e || !t ? t : t.bind(e);
}
class Zi {
	constructor(e, n, r) {
		(this.name = e),
			(this.init = Im(n.init, r)),
			(this.apply = Im(n.apply, r));
	}
}
const ZC = [
	new Zi("doc", {
		init(t) {
			return t.doc || t.schema.topNodeType.createAndFill();
		},
		apply(t) {
			return t.doc;
		},
	}),
	new Zi("selection", {
		init(t, e) {
			return t.selection || _e.atStart(e.doc);
		},
		apply(t) {
			return t.selection;
		},
	}),
	new Zi("storedMarks", {
		init(t) {
			return t.storedMarks || null;
		},
		apply(t, e, n, r) {
			return r.selection.$cursor ? t.storedMarks : null;
		},
	}),
	new Zi("scrollToSelection", {
		init() {
			return 0;
		},
		apply(t, e) {
			return t.scrolledIntoView ? e + 1 : e;
		},
	}),
];
class _c {
	constructor(e, n) {
		(this.schema = e),
			(this.plugins = []),
			(this.pluginsByKey = Object.create(null)),
			(this.fields = ZC.slice()),
			n &&
				n.forEach((r) => {
					if (this.pluginsByKey[r.key])
						throw new RangeError(
							"Adding different instances of a keyed plugin (" +
								r.key +
								")"
						);
					this.plugins.push(r),
						(this.pluginsByKey[r.key] = r),
						r.spec.state &&
							this.fields.push(new Zi(r.key, r.spec.state, r));
				});
	}
}
class li {
	constructor(e) {
		this.config = e;
	}
	get schema() {
		return this.config.schema;
	}
	get plugins() {
		return this.config.plugins;
	}
	apply(e) {
		return this.applyTransaction(e).state;
	}
	filterTransaction(e, n = -1) {
		for (let r = 0; r < this.config.plugins.length; r++)
			if (r != n) {
				let o = this.config.plugins[r];
				if (
					o.spec.filterTransaction &&
					!o.spec.filterTransaction.call(o, e, this)
				)
					return !1;
			}
		return !0;
	}
	applyTransaction(e) {
		if (!this.filterTransaction(e))
			return { state: this, transactions: [] };
		let n = [e],
			r = this.applyInner(e),
			o = null;
		for (;;) {
			let i = !1;
			for (let s = 0; s < this.config.plugins.length; s++) {
				let l = this.config.plugins[s];
				if (l.spec.appendTransaction) {
					let a = o ? o[s].n : 0,
						u = o ? o[s].state : this,
						c =
							a < n.length &&
							l.spec.appendTransaction.call(
								l,
								a ? n.slice(a) : n,
								u,
								r
							);
					if (c && r.filterTransaction(c, s)) {
						if ((c.setMeta("appendedTransaction", e), !o)) {
							o = [];
							for (let d = 0; d < this.config.plugins.length; d++)
								o.push(
									d < s
										? { state: r, n: n.length }
										: { state: this, n: 0 }
								);
						}
						n.push(c), (r = r.applyInner(c)), (i = !0);
					}
					o && (o[s] = { state: r, n: n.length });
				}
			}
			if (!i) return { state: r, transactions: n };
		}
	}
	applyInner(e) {
		if (!e.before.eq(this.doc))
			throw new RangeError("Applying a mismatched transaction");
		let n = new li(this.config),
			r = this.config.fields;
		for (let o = 0; o < r.length; o++) {
			let i = r[o];
			n[i.name] = i.apply(e, this[i.name], this, n);
		}
		return n;
	}
	get tr() {
		return new XC(this);
	}
	static create(e) {
		let n = new _c(e.doc ? e.doc.type.schema : e.schema, e.plugins),
			r = new li(n);
		for (let o = 0; o < n.fields.length; o++)
			r[n.fields[o].name] = n.fields[o].init(e, r);
		return r;
	}
	reconfigure(e) {
		let n = new _c(this.schema, e.plugins),
			r = n.fields,
			o = new li(n);
		for (let i = 0; i < r.length; i++) {
			let s = r[i].name;
			o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
		}
		return o;
	}
	toJSON(e) {
		let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
		if (
			(this.storedMarks &&
				(n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
			e && typeof e == "object")
		)
			for (let r in e) {
				if (r == "doc" || r == "selection")
					throw new RangeError(
						"The JSON fields `doc` and `selection` are reserved"
					);
				let o = e[r],
					i = o.spec.state;
				i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
			}
		return n;
	}
	static fromJSON(e, n, r) {
		if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
		if (!e.schema)
			throw new RangeError("Required config field 'schema' missing");
		let o = new _c(e.schema, e.plugins),
			i = new li(o);
		return (
			o.fields.forEach((s) => {
				if (s.name == "doc") i.doc = No.fromJSON(e.schema, n.doc);
				else if (s.name == "selection")
					i.selection = _e.fromJSON(i.doc, n.selection);
				else if (s.name == "storedMarks")
					n.storedMarks &&
						(i.storedMarks = n.storedMarks.map(
							e.schema.markFromJSON
						));
				else {
					if (r)
						for (let l in r) {
							let a = r[l],
								u = a.spec.state;
							if (
								a.key == s.name &&
								u &&
								u.fromJSON &&
								Object.prototype.hasOwnProperty.call(n, l)
							) {
								i[s.name] = u.fromJSON.call(a, e, n[l], i);
								return;
							}
						}
					i[s.name] = s.init(e, i);
				}
			}),
			i
		);
	}
}
function dv(t, e, n) {
	for (let r in t) {
		let o = t[r];
		o instanceof Function
			? (o = o.bind(e))
			: r == "handleDOMEvents" && (o = dv(o, e, {})),
			(n[r] = o);
	}
	return n;
}
class wt {
	constructor(e) {
		(this.spec = e),
			(this.props = {}),
			e.props && dv(e.props, this, this.props),
			(this.key = e.key ? e.key.key : fv("plugin"));
	}
	getState(e) {
		return e[this.key];
	}
}
const Cc = Object.create(null);
function fv(t) {
	return t in Cc ? t + "$" + ++Cc[t] : ((Cc[t] = 0), t + "$");
}
class Rt {
	constructor(e = "key") {
		this.key = fv(e);
	}
	get(e) {
		return e.config.pluginsByKey[this.key];
	}
	getState(e) {
		return e[this.key];
	}
}
const Zt = function (t) {
		for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
	},
	Ns = function (t) {
		let e = t.assignedSlot || t.parentNode;
		return e && e.nodeType == 11 ? e.host : e;
	};
let Nm = null;
const br = function (t, e, n) {
		let r = Nm || (Nm = document.createRange());
		return (
			r.setEnd(t, n == null ? t.nodeValue.length : n),
			r.setStart(t, e || 0),
			r
		);
	},
	zo = function (t, e, n, r) {
		return n && (Dm(t, e, n, r, -1) || Dm(t, e, n, r, 1));
	},
	eM = /^(img|br|input|textarea|hr)$/i;
function Dm(t, e, n, r, o) {
	for (;;) {
		if (t == n && e == r) return !0;
		if (e == (o < 0 ? 0 : er(t))) {
			let i = t.parentNode;
			if (
				!i ||
				i.nodeType != 1 ||
				ah(t) ||
				eM.test(t.nodeName) ||
				t.contentEditable == "false"
			)
				return !1;
			(e = Zt(t) + (o < 0 ? 0 : 1)), (t = i);
		} else if (t.nodeType == 1) {
			if (
				((t = t.childNodes[e + (o < 0 ? -1 : 0)]),
				t.contentEditable == "false")
			)
				return !1;
			e = o < 0 ? er(t) : 0;
		} else return !1;
	}
}
function er(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function tM(t, e, n) {
	for (let r = e == 0, o = e == er(t); r || o; ) {
		if (t == n) return !0;
		let i = Zt(t);
		if (((t = t.parentNode), !t)) return !1;
		(r = r && i == 0), (o = o && i == er(t));
	}
}
function ah(t) {
	let e;
	for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
	return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const ju = function (t) {
	return (
		t.focusNode &&
		zo(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
	);
};
function So(t, e) {
	let n = document.createEvent("Event");
	return (
		n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
	);
}
function nM(t) {
	let e = t.activeElement;
	for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
	return e;
}
function rM(t, e, n) {
	if (t.caretPositionFromPoint)
		try {
			let r = t.caretPositionFromPoint(e, n);
			if (r) return { node: r.offsetNode, offset: r.offset };
		} catch (r) {}
	if (t.caretRangeFromPoint) {
		let r = t.caretRangeFromPoint(e, n);
		if (r) return { node: r.startContainer, offset: r.startOffset };
	}
}
const ar = typeof navigator != "undefined" ? navigator : null,
	jm = typeof document != "undefined" ? document : null,
	ho = (ar && ar.userAgent) || "",
	Od = /Edge\/(\d+)/.exec(ho),
	hv = /MSIE \d/.exec(ho),
	Rd = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ho),
	un = !!(hv || Rd || Od),
	to = hv ? document.documentMode : Rd ? +Rd[1] : Od ? +Od[1] : 0,
	Wn = !un && /gecko\/(\d+)/i.test(ho);
Wn && +(/Firefox\/(\d+)/.exec(ho) || [0, 0])[1];
const Pd = !un && /Chrome\/(\d+)/.exec(ho),
	Wt = !!Pd,
	oM = Pd ? +Pd[1] : 0,
	tn = !un && !!ar && /Apple Computer/.test(ar.vendor),
	Ri = tn && (/Mobile\/\w+/.test(ho) || (!!ar && ar.maxTouchPoints > 2)),
	Sn = Ri || (ar ? /Mac/.test(ar.platform) : !1),
	iM = ar ? /Win/.test(ar.platform) : !1,
	Dn = /Android \d/.test(ho),
	Zs = !!jm && "webkitFontSmoothing" in jm.documentElement.style,
	sM = Zs
		? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
		: 0;
function lM(t) {
	return {
		left: 0,
		right: t.documentElement.clientWidth,
		top: 0,
		bottom: t.documentElement.clientHeight,
	};
}
function mr(t, e) {
	return typeof t == "number" ? t : t[e];
}
function aM(t) {
	let e = t.getBoundingClientRect(),
		n = e.width / t.offsetWidth || 1,
		r = e.height / t.offsetHeight || 1;
	return {
		left: e.left,
		right: e.left + t.clientWidth * n,
		top: e.top,
		bottom: e.top + t.clientHeight * r,
	};
}
function Lm(t, e, n) {
	let r = t.someProp("scrollThreshold") || 0,
		o = t.someProp("scrollMargin") || 5,
		i = t.dom.ownerDocument;
	for (let s = n || t.dom; s; s = Ns(s)) {
		if (s.nodeType != 1) continue;
		let l = s,
			a = l == i.body,
			u = a ? lM(i) : aM(l),
			c = 0,
			d = 0;
		if (
			(e.top < u.top + mr(r, "top")
				? (d = -(u.top - e.top + mr(o, "top")))
				: e.bottom > u.bottom - mr(r, "bottom") &&
				  (d =
						e.bottom - e.top > u.bottom - u.top
							? e.top + mr(o, "top") - u.top
							: e.bottom - u.bottom + mr(o, "bottom")),
			e.left < u.left + mr(r, "left")
				? (c = -(u.left - e.left + mr(o, "left")))
				: e.right > u.right - mr(r, "right") &&
				  (c = e.right - u.right + mr(o, "right")),
			c || d)
		)
			if (a) i.defaultView.scrollBy(c, d);
			else {
				let h = l.scrollLeft,
					p = l.scrollTop;
				d && (l.scrollTop += d), c && (l.scrollLeft += c);
				let g = l.scrollLeft - h,
					y = l.scrollTop - p;
				e = {
					left: e.left - g,
					top: e.top - y,
					right: e.right - g,
					bottom: e.bottom - y,
				};
			}
		if (a || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
	}
}
function uM(t) {
	let e = t.dom.getBoundingClientRect(),
		n = Math.max(0, e.top),
		r,
		o;
	for (
		let i = (e.left + e.right) / 2, s = n + 1;
		s < Math.min(innerHeight, e.bottom);
		s += 5
	) {
		let l = t.root.elementFromPoint(i, s);
		if (!l || l == t.dom || !t.dom.contains(l)) continue;
		let a = l.getBoundingClientRect();
		if (a.top >= n - 20) {
			(r = l), (o = a.top);
			break;
		}
	}
	return { refDOM: r, refTop: o, stack: pv(t.dom) };
}
function pv(t) {
	let e = [],
		n = t.ownerDocument;
	for (
		let r = t;
		r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
		r = Ns(r)
	);
	return e;
}
function cM({ refDOM: t, refTop: e, stack: n }) {
	let r = t ? t.getBoundingClientRect().top : 0;
	mv(n, r == 0 ? 0 : r - e);
}
function mv(t, e) {
	for (let n = 0; n < t.length; n++) {
		let { dom: r, top: o, left: i } = t[n];
		r.scrollTop != o + e && (r.scrollTop = o + e),
			r.scrollLeft != i && (r.scrollLeft = i);
	}
}
let Yo = null;
function dM(t) {
	if (t.setActive) return t.setActive();
	if (Yo) return t.focus(Yo);
	let e = pv(t);
	t.focus(
		Yo == null
			? {
					get preventScroll() {
						return (Yo = { preventScroll: !0 }), !0;
					},
			  }
			: void 0
	),
		Yo || ((Yo = !1), mv(e, 0));
}
function gv(t, e) {
	let n,
		r = 2e8,
		o,
		i = 0,
		s = e.top,
		l = e.top,
		a,
		u;
	for (let c = t.firstChild, d = 0; c; c = c.nextSibling, d++) {
		let h;
		if (c.nodeType == 1) h = c.getClientRects();
		else if (c.nodeType == 3) h = br(c).getClientRects();
		else continue;
		for (let p = 0; p < h.length; p++) {
			let g = h[p];
			if (g.top <= s && g.bottom >= l) {
				(s = Math.max(g.bottom, s)), (l = Math.min(g.top, l));
				let y =
					g.left > e.left
						? g.left - e.left
						: g.right < e.left
						? e.left - g.right
						: 0;
				if (y < r) {
					(n = c),
						(r = y),
						(o =
							y && n.nodeType == 3
								? {
										left:
											g.right < e.left ? g.right : g.left,
										top: e.top,
								  }
								: e),
						c.nodeType == 1 &&
							y &&
							(i =
								d + (e.left >= (g.left + g.right) / 2 ? 1 : 0));
					continue;
				}
			} else
				g.top > e.top &&
					!a &&
					g.left <= e.left &&
					g.right >= e.left &&
					((a = c),
					(u = {
						left: Math.max(g.left, Math.min(g.right, e.left)),
						top: g.top,
					}));
			!n &&
				((e.left >= g.right && e.top >= g.top) ||
					(e.left >= g.left && e.top >= g.bottom)) &&
				(i = d + 1);
		}
	}
	return (
		!n && a && ((n = a), (o = u), (r = 0)),
		n && n.nodeType == 3
			? fM(n, o)
			: !n || (r && n.nodeType == 1)
			? { node: t, offset: i }
			: gv(n, o)
	);
}
function fM(t, e) {
	let n = t.nodeValue.length,
		r = document.createRange();
	for (let o = 0; o < n; o++) {
		r.setEnd(t, o + 1), r.setStart(t, o);
		let i = Nr(r, 1);
		if (i.top != i.bottom && uh(e, i))
			return {
				node: t,
				offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0),
			};
	}
	return { node: t, offset: 0 };
}
function uh(t, e) {
	return (
		t.left >= e.left - 1 &&
		t.left <= e.right + 1 &&
		t.top >= e.top - 1 &&
		t.top <= e.bottom + 1
	);
}
function hM(t, e) {
	let n = t.parentNode;
	return n &&
		/^li$/i.test(n.nodeName) &&
		e.left < t.getBoundingClientRect().left
		? n
		: t;
}
function pM(t, e, n) {
	let { node: r, offset: o } = gv(e, n),
		i = -1;
	if (r.nodeType == 1 && !r.firstChild) {
		let s = r.getBoundingClientRect();
		i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
	}
	return t.docView.posFromDOM(r, o, i);
}
function mM(t, e, n, r) {
	let o = -1;
	for (let i = e, s = !1; i != t.dom; ) {
		let l = t.docView.nearestDesc(i, !0);
		if (!l) return null;
		if (
			l.dom.nodeType == 1 &&
			((l.node.isBlock && l.parent && !s) || !l.contentDOM)
		) {
			let a = l.dom.getBoundingClientRect();
			if (
				(l.node.isBlock &&
					l.parent &&
					!s &&
					((s = !0),
					a.left > r.left || a.top > r.top
						? (o = l.posBefore)
						: (a.right < r.left || a.bottom < r.top) &&
						  (o = l.posAfter)),
				!l.contentDOM && o < 0 && !l.node.isText)
			)
				return (
					l.node.isBlock
						? r.top < (a.top + a.bottom) / 2
						: r.left < (a.left + a.right) / 2
				)
					? l.posBefore
					: l.posAfter;
		}
		i = l.dom.parentNode;
	}
	return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function yv(t, e, n) {
	let r = t.childNodes.length;
	if (r && n.top < n.bottom)
		for (
			let o = Math.max(
					0,
					Math.min(
						r - 1,
						Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) -
							2
					)
				),
				i = o;
			;

		) {
			let s = t.childNodes[i];
			if (s.nodeType == 1) {
				let l = s.getClientRects();
				for (let a = 0; a < l.length; a++) {
					let u = l[a];
					if (uh(e, u)) return yv(s, e, u);
				}
			}
			if ((i = (i + 1) % r) == o) break;
		}
	return t;
}
function gM(t, e) {
	let n = t.dom.ownerDocument,
		r,
		o = 0,
		i = rM(n, e.left, e.top);
	i && ({ node: r, offset: o } = i);
	let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
			e.left,
			e.top
		),
		l;
	if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
		let u = t.dom.getBoundingClientRect();
		if (!uh(e, u) || ((s = yv(t.dom, e, u)), !s)) return null;
	}
	if (tn) for (let u = s; r && u; u = Ns(u)) u.draggable && (r = void 0);
	if (((s = hM(s, e)), r)) {
		if (
			Wn &&
			r.nodeType == 1 &&
			((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
		) {
			let c = r.childNodes[o],
				d;
			c.nodeName == "IMG" &&
				(d = c.getBoundingClientRect()).right <= e.left &&
				d.bottom > e.top &&
				o++;
		}
		let u;
		Zs &&
			o &&
			r.nodeType == 1 &&
			(u = r.childNodes[o - 1]).nodeType == 1 &&
			u.contentEditable == "false" &&
			u.getBoundingClientRect().top >= e.top &&
			o--,
			r == t.dom &&
			o == r.childNodes.length - 1 &&
			r.lastChild.nodeType == 1 &&
			e.top > r.lastChild.getBoundingClientRect().bottom
				? (l = t.state.doc.content.size)
				: (o == 0 ||
						r.nodeType != 1 ||
						r.childNodes[o - 1].nodeName != "BR") &&
				  (l = mM(t, r, o, e));
	}
	l == null && (l = pM(t, s, e));
	let a = t.docView.nearestDesc(s, !0);
	return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function $m(t) {
	return t.top < t.bottom || t.left < t.right;
}
function Nr(t, e) {
	let n = t.getClientRects();
	if (n.length) {
		let r = n[e < 0 ? 0 : n.length - 1];
		if ($m(r)) return r;
	}
	return Array.prototype.find.call(n, $m) || t.getBoundingClientRect();
}
const yM = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function vv(t, e, n) {
	let {
			node: r,
			offset: o,
			atom: i,
		} = t.docView.domFromPos(e, n < 0 ? -1 : 1),
		s = Zs || Wn;
	if (r.nodeType == 3)
		if (
			s &&
			(yM.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))
		) {
			let a = Nr(br(r, o, o), n);
			if (
				Wn &&
				o &&
				/\s/.test(r.nodeValue[o - 1]) &&
				o < r.nodeValue.length
			) {
				let u = Nr(br(r, o - 1, o - 1), -1);
				if (u.top == a.top) {
					let c = Nr(br(r, o, o + 1), -1);
					if (c.top != a.top) return qi(c, c.left < u.left);
				}
			}
			return a;
		} else {
			let a = o,
				u = o,
				c = n < 0 ? 1 : -1;
			return (
				n < 0 && !o
					? (u++, (c = -1))
					: n >= 0 && o == r.nodeValue.length
					? (a--, (c = 1))
					: n < 0
					? a--
					: u++,
				qi(Nr(br(r, a, u), c), c < 0)
			);
		}
	if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
		if (i == null && o && (n < 0 || o == er(r))) {
			let a = r.childNodes[o - 1];
			if (a.nodeType == 1) return Mc(a.getBoundingClientRect(), !1);
		}
		if (i == null && o < er(r)) {
			let a = r.childNodes[o];
			if (a.nodeType == 1) return Mc(a.getBoundingClientRect(), !0);
		}
		return Mc(r.getBoundingClientRect(), n >= 0);
	}
	if (i == null && o && (n < 0 || o == er(r))) {
		let a = r.childNodes[o - 1],
			u =
				a.nodeType == 3
					? br(a, er(a) - (s ? 0 : 1))
					: a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling)
					? a
					: null;
		if (u) return qi(Nr(u, 1), !1);
	}
	if (i == null && o < er(r)) {
		let a = r.childNodes[o];
		for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
			a = a.nextSibling;
		let u = a
			? a.nodeType == 3
				? br(a, 0, s ? 0 : 1)
				: a.nodeType == 1
				? a
				: null
			: null;
		if (u) return qi(Nr(u, -1), !0);
	}
	return qi(Nr(r.nodeType == 3 ? br(r) : r, -n), n >= 0);
}
function qi(t, e) {
	if (t.width == 0) return t;
	let n = e ? t.left : t.right;
	return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function Mc(t, e) {
	if (t.height == 0) return t;
	let n = e ? t.top : t.bottom;
	return { top: n, bottom: n, left: t.left, right: t.right };
}
function bv(t, e, n) {
	let r = t.state,
		o = t.root.activeElement;
	r != e && t.updateState(e), o != t.dom && t.focus();
	try {
		return n();
	} finally {
		r != e && t.updateState(r), o != t.dom && o && o.focus();
	}
}
function vM(t, e, n) {
	let r = e.selection,
		o = n == "up" ? r.$from : r.$to;
	return bv(t, e, () => {
		let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
		for (;;) {
			let l = t.docView.nearestDesc(i, !0);
			if (!l) break;
			if (l.node.isBlock) {
				i = l.contentDOM || l.dom;
				break;
			}
			i = l.dom.parentNode;
		}
		let s = vv(t, o.pos, 1);
		for (let l = i.firstChild; l; l = l.nextSibling) {
			let a;
			if (l.nodeType == 1) a = l.getClientRects();
			else if (l.nodeType == 3)
				a = br(l, 0, l.nodeValue.length).getClientRects();
			else continue;
			for (let u = 0; u < a.length; u++) {
				let c = a[u];
				if (
					c.bottom > c.top + 1 &&
					(n == "up"
						? s.top - c.top > (c.bottom - s.top) * 2
						: c.bottom - s.bottom > (s.bottom - c.top) * 2)
				)
					return !1;
			}
		}
		return !0;
	});
}
const bM = /[\u0590-\u08ac]/;
function wM(t, e, n) {
	let { $head: r } = e.selection;
	if (!r.parent.isTextblock) return !1;
	let o = r.parentOffset,
		i = !o,
		s = o == r.parent.content.size,
		l = t.domSelection();
	return !bM.test(r.parent.textContent) || !l.modify
		? n == "left" || n == "backward"
			? i
			: s
		: bv(t, e, () => {
				let {
						focusNode: a,
						focusOffset: u,
						anchorNode: c,
						anchorOffset: d,
					} = t.domSelectionRange(),
					h = l.caretBidiLevel;
				l.modify("move", n, "character");
				let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
					{ focusNode: g, focusOffset: y } = t.domSelectionRange(),
					b =
						(g &&
							!p.contains(g.nodeType == 1 ? g : g.parentNode)) ||
						(a == g && u == y);
				try {
					l.collapse(c, d),
						a && (a != c || u != d) && l.extend && l.extend(a, u);
				} catch (w) {}
				return h != null && (l.caretBidiLevel = h), b;
		  });
}
let Bm = null,
	zm = null,
	Hm = !1;
function xM(t, e, n) {
	return Bm == e && zm == n
		? Hm
		: ((Bm = e),
		  (zm = n),
		  (Hm = n == "up" || n == "down" ? vM(t, e, n) : wM(t, e, n)));
}
const On = 0,
	Fm = 1,
	Mo = 2,
	ur = 3;
class el {
	constructor(e, n, r, o) {
		(this.parent = e),
			(this.children = n),
			(this.dom = r),
			(this.contentDOM = o),
			(this.dirty = On),
			(r.pmViewDesc = this);
	}
	matchesWidget(e) {
		return !1;
	}
	matchesMark(e) {
		return !1;
	}
	matchesNode(e, n, r) {
		return !1;
	}
	matchesHack(e) {
		return !1;
	}
	parseRule() {
		return null;
	}
	stopEvent(e) {
		return !1;
	}
	get size() {
		let e = 0;
		for (let n = 0; n < this.children.length; n++)
			e += this.children[n].size;
		return e;
	}
	get border() {
		return 0;
	}
	destroy() {
		(this.parent = void 0),
			this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
		for (let e = 0; e < this.children.length; e++)
			this.children[e].destroy();
	}
	posBeforeChild(e) {
		for (let n = 0, r = this.posAtStart; ; n++) {
			let o = this.children[n];
			if (o == e) return r;
			r += o.size;
		}
	}
	get posBefore() {
		return this.parent.posBeforeChild(this);
	}
	get posAtStart() {
		return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
	}
	get posAfter() {
		return this.posBefore + this.size;
	}
	get posAtEnd() {
		return this.posAtStart + this.size - 2 * this.border;
	}
	localPosFromDOM(e, n, r) {
		if (
			this.contentDOM &&
			this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
		)
			if (r < 0) {
				let i, s;
				if (e == this.contentDOM) i = e.childNodes[n - 1];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					i = e.previousSibling;
				}
				for (; i && !((s = i.pmViewDesc) && s.parent == this); )
					i = i.previousSibling;
				return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
			} else {
				let i, s;
				if (e == this.contentDOM) i = e.childNodes[n];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					i = e.nextSibling;
				}
				for (; i && !((s = i.pmViewDesc) && s.parent == this); )
					i = i.nextSibling;
				return i ? this.posBeforeChild(s) : this.posAtEnd;
			}
		let o;
		if (e == this.dom && this.contentDOM) o = n > Zt(this.contentDOM);
		else if (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			this.dom.contains(this.contentDOM)
		)
			o = e.compareDocumentPosition(this.contentDOM) & 2;
		else if (this.dom.firstChild) {
			if (n == 0)
				for (let i = e; ; i = i.parentNode) {
					if (i == this.dom) {
						o = !1;
						break;
					}
					if (i.previousSibling) break;
				}
			if (o == null && n == e.childNodes.length)
				for (let i = e; ; i = i.parentNode) {
					if (i == this.dom) {
						o = !0;
						break;
					}
					if (i.nextSibling) break;
				}
		}
		return (o == null ? r > 0 : o) ? this.posAtEnd : this.posAtStart;
	}
	nearestDesc(e, n = !1) {
		for (let r = !0, o = e; o; o = o.parentNode) {
			let i = this.getDesc(o),
				s;
			if (i && (!n || i.node))
				if (
					r &&
					(s = i.nodeDOM) &&
					!(s.nodeType == 1
						? s.contains(e.nodeType == 1 ? e : e.parentNode)
						: s == e)
				)
					r = !1;
				else return i;
		}
	}
	getDesc(e) {
		let n = e.pmViewDesc;
		for (let r = n; r; r = r.parent) if (r == this) return n;
	}
	posFromDOM(e, n, r) {
		for (let o = e; o; o = o.parentNode) {
			let i = this.getDesc(o);
			if (i) return i.localPosFromDOM(e, n, r);
		}
		return -1;
	}
	descAt(e) {
		for (let n = 0, r = 0; n < this.children.length; n++) {
			let o = this.children[n],
				i = r + o.size;
			if (r == e && i != r) {
				for (; !o.border && o.children.length; ) o = o.children[0];
				return o;
			}
			if (e < i) return o.descAt(e - r - o.border);
			r = i;
		}
	}
	domFromPos(e, n) {
		if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
		let r = 0,
			o = 0;
		for (let i = 0; r < this.children.length; r++) {
			let s = this.children[r],
				l = i + s.size;
			if (l > e || s instanceof xv) {
				o = e - i;
				break;
			}
			i = l;
		}
		if (o)
			return this.children[r].domFromPos(o - this.children[r].border, n);
		for (
			let i;
			r &&
			!(i = this.children[r - 1]).size &&
			i instanceof wv &&
			i.side >= 0;
			r--
		);
		if (n <= 0) {
			let i,
				s = !0;
			for (
				;
				(i = r ? this.children[r - 1] : null),
					!(!i || i.dom.parentNode == this.contentDOM);
				r--, s = !1
			);
			return i && n && s && !i.border && !i.domAtom
				? i.domFromPos(i.size, n)
				: { node: this.contentDOM, offset: i ? Zt(i.dom) + 1 : 0 };
		} else {
			let i,
				s = !0;
			for (
				;
				(i = r < this.children.length ? this.children[r] : null),
					!(!i || i.dom.parentNode == this.contentDOM);
				r++, s = !1
			);
			return i && s && !i.border && !i.domAtom
				? i.domFromPos(0, n)
				: {
						node: this.contentDOM,
						offset: i
							? Zt(i.dom)
							: this.contentDOM.childNodes.length,
				  };
		}
	}
	parseRange(e, n, r = 0) {
		if (this.children.length == 0)
			return {
				node: this.contentDOM,
				from: e,
				to: n,
				fromOffset: 0,
				toOffset: this.contentDOM.childNodes.length,
			};
		let o = -1,
			i = -1;
		for (let s = r, l = 0; ; l++) {
			let a = this.children[l],
				u = s + a.size;
			if (o == -1 && e <= u) {
				let c = s + a.border;
				if (
					e >= c &&
					n <= u - a.border &&
					a.node &&
					a.contentDOM &&
					this.contentDOM.contains(a.contentDOM)
				)
					return a.parseRange(e, n, c);
				e = s;
				for (let d = l; d > 0; d--) {
					let h = this.children[d - 1];
					if (
						h.size &&
						h.dom.parentNode == this.contentDOM &&
						!h.emptyChildAt(1)
					) {
						o = Zt(h.dom) + 1;
						break;
					}
					e -= h.size;
				}
				o == -1 && (o = 0);
			}
			if (o > -1 && (u > n || l == this.children.length - 1)) {
				n = u;
				for (let c = l + 1; c < this.children.length; c++) {
					let d = this.children[c];
					if (
						d.size &&
						d.dom.parentNode == this.contentDOM &&
						!d.emptyChildAt(-1)
					) {
						i = Zt(d.dom);
						break;
					}
					n += d.size;
				}
				i == -1 && (i = this.contentDOM.childNodes.length);
				break;
			}
			s = u;
		}
		return {
			node: this.contentDOM,
			from: e,
			to: n,
			fromOffset: o,
			toOffset: i,
		};
	}
	emptyChildAt(e) {
		if (this.border || !this.contentDOM || !this.children.length) return !1;
		let n = this.children[e < 0 ? 0 : this.children.length - 1];
		return n.size == 0 || n.emptyChildAt(e);
	}
	domAfterPos(e) {
		let { node: n, offset: r } = this.domFromPos(e, 0);
		if (n.nodeType != 1 || r == n.childNodes.length)
			throw new RangeError("No node after pos " + e);
		return n.childNodes[r];
	}
	setSelection(e, n, r, o = !1) {
		let i = Math.min(e, n),
			s = Math.max(e, n);
		for (let h = 0, p = 0; h < this.children.length; h++) {
			let g = this.children[h],
				y = p + g.size;
			if (i > p && s < y)
				return g.setSelection(e - p - g.border, n - p - g.border, r, o);
			p = y;
		}
		let l = this.domFromPos(e, e ? -1 : 1),
			a = n == e ? l : this.domFromPos(n, n ? -1 : 1),
			u = r.getSelection(),
			c = !1;
		if ((Wn || tn) && e == n) {
			let { node: h, offset: p } = l;
			if (h.nodeType == 3) {
				if (
					((c = !!(
						p &&
						h.nodeValue[p - 1] ==
							`
`
					)),
					c && p == h.nodeValue.length)
				)
					for (let g = h, y; g; g = g.parentNode) {
						if ((y = g.nextSibling)) {
							y.nodeName == "BR" &&
								(l = a =
									{ node: y.parentNode, offset: Zt(y) + 1 });
							break;
						}
						let b = g.pmViewDesc;
						if (b && b.node && b.node.isBlock) break;
					}
			} else {
				let g = h.childNodes[p - 1];
				c = g && (g.nodeName == "BR" || g.contentEditable == "false");
			}
		}
		if (
			Wn &&
			u.focusNode &&
			u.focusNode != a.node &&
			u.focusNode.nodeType == 1
		) {
			let h = u.focusNode.childNodes[u.focusOffset];
			h && h.contentEditable == "false" && (o = !0);
		}
		if (
			!(o || (c && tn)) &&
			zo(l.node, l.offset, u.anchorNode, u.anchorOffset) &&
			zo(a.node, a.offset, u.focusNode, u.focusOffset)
		)
			return;
		let d = !1;
		if ((u.extend || e == n) && !c) {
			u.collapse(l.node, l.offset);
			try {
				e != n && u.extend(a.node, a.offset), (d = !0);
			} catch (h) {}
		}
		if (!d) {
			if (e > n) {
				let p = l;
				(l = a), (a = p);
			}
			let h = document.createRange();
			h.setEnd(a.node, a.offset),
				h.setStart(l.node, l.offset),
				u.removeAllRanges(),
				u.addRange(h);
		}
	}
	ignoreMutation(e) {
		return !this.contentDOM && e.type != "selection";
	}
	get contentLost() {
		return (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			!this.dom.contains(this.contentDOM)
		);
	}
	markDirty(e, n) {
		for (let r = 0, o = 0; o < this.children.length; o++) {
			let i = this.children[o],
				s = r + i.size;
			if (r == s ? e <= s && n >= r : e < s && n > r) {
				let l = r + i.border,
					a = s - i.border;
				if (e >= l && n <= a) {
					(this.dirty = e == r || n == s ? Mo : Fm),
						e == l &&
						n == a &&
						(i.contentLost || i.dom.parentNode != this.contentDOM)
							? (i.dirty = ur)
							: i.markDirty(e - l, n - l);
					return;
				} else
					i.dirty =
						i.dom == i.contentDOM &&
						i.dom.parentNode == this.contentDOM &&
						!i.children.length
							? Mo
							: ur;
			}
			r = s;
		}
		this.dirty = Mo;
	}
	markParentsDirty() {
		let e = 1;
		for (let n = this.parent; n; n = n.parent, e++) {
			let r = e == 1 ? Mo : Fm;
			n.dirty < r && (n.dirty = r);
		}
	}
	get domAtom() {
		return !1;
	}
	get ignoreForCoords() {
		return !1;
	}
}
class wv extends el {
	constructor(e, n, r, o) {
		let i,
			s = n.type.toDOM;
		if (
			(typeof s == "function" &&
				(s = s(r, () => {
					if (!i) return o;
					if (i.parent) return i.parent.posBeforeChild(i);
				})),
			!n.type.spec.raw)
		) {
			if (s.nodeType != 1) {
				let l = document.createElement("span");
				l.appendChild(s), (s = l);
			}
			(s.contentEditable = "false"),
				s.classList.add("ProseMirror-widget");
		}
		super(e, [], s, null), (this.widget = n), (this.widget = n), (i = this);
	}
	matchesWidget(e) {
		return this.dirty == On && e.type.eq(this.widget.type);
	}
	parseRule() {
		return { ignore: !0 };
	}
	stopEvent(e) {
		let n = this.widget.spec.stopEvent;
		return n ? n(e) : !1;
	}
	ignoreMutation(e) {
		return e.type != "selection" || this.widget.spec.ignoreSelection;
	}
	destroy() {
		this.widget.type.destroy(this.dom), super.destroy();
	}
	get domAtom() {
		return !0;
	}
	get side() {
		return this.widget.type.side;
	}
}
class kM extends el {
	constructor(e, n, r, o) {
		super(e, [], n, null), (this.textDOM = r), (this.text = o);
	}
	get size() {
		return this.text.length;
	}
	localPosFromDOM(e, n) {
		return e != this.textDOM
			? this.posAtStart + (n ? this.size : 0)
			: this.posAtStart + n;
	}
	domFromPos(e) {
		return { node: this.textDOM, offset: e };
	}
	ignoreMutation(e) {
		return e.type === "characterData" && e.target.nodeValue == e.oldValue;
	}
}
class Ho extends el {
	constructor(e, n, r, o) {
		super(e, [], r, o), (this.mark = n);
	}
	static create(e, n, r, o) {
		let i = o.nodeViews[n.type.name],
			s = i && i(n, o, r);
		return (
			(!s || !s.dom) &&
				(s = tr.renderSpec(document, n.type.spec.toDOM(n, r))),
			new Ho(e, n, s.dom, s.contentDOM || s.dom)
		);
	}
	parseRule() {
		return this.dirty & ur || this.mark.type.spec.reparseInView
			? null
			: {
					mark: this.mark.type.name,
					attrs: this.mark.attrs,
					contentElement: this.contentDOM,
			  };
	}
	matchesMark(e) {
		return this.dirty != ur && this.mark.eq(e);
	}
	markDirty(e, n) {
		if ((super.markDirty(e, n), this.dirty != On)) {
			let r = this.parent;
			for (; !r.node; ) r = r.parent;
			r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = On);
		}
	}
	slice(e, n, r) {
		let o = Ho.create(this.parent, this.mark, !0, r),
			i = this.children,
			s = this.size;
		n < s && (i = Dd(i, n, s, r)), e > 0 && (i = Dd(i, 0, e, r));
		for (let l = 0; l < i.length; l++) i[l].parent = o;
		return (o.children = i), o;
	}
}
class no extends el {
	constructor(e, n, r, o, i, s, l, a, u) {
		super(e, [], i, s),
			(this.node = n),
			(this.outerDeco = r),
			(this.innerDeco = o),
			(this.nodeDOM = l);
	}
	static create(e, n, r, o, i, s) {
		let l = i.nodeViews[n.type.name],
			a,
			u =
				l &&
				l(
					n,
					i,
					() => {
						if (!a) return s;
						if (a.parent) return a.parent.posBeforeChild(a);
					},
					r,
					o
				),
			c = u && u.dom,
			d = u && u.contentDOM;
		if (n.isText) {
			if (!c) c = document.createTextNode(n.text);
			else if (c.nodeType != 3)
				throw new RangeError(
					"Text must be rendered as a DOM text node"
				);
		} else
			c ||
				({ dom: c, contentDOM: d } = tr.renderSpec(
					document,
					n.type.spec.toDOM(n)
				));
		!d &&
			!n.isText &&
			c.nodeName != "BR" &&
			(c.hasAttribute("contenteditable") || (c.contentEditable = "false"),
			n.type.spec.draggable && (c.draggable = !0));
		let h = c;
		return (
			(c = _v(c, r, n)),
			u
				? (a = new SM(e, n, r, o, c, d || null, h, u, i, s + 1))
				: n.isText
				? new Lu(e, n, r, o, c, h, i)
				: new no(e, n, r, o, c, d || null, h, i, s + 1)
		);
	}
	parseRule() {
		if (this.node.type.spec.reparseInView) return null;
		let e = { node: this.node.type.name, attrs: this.node.attrs };
		if (
			(this.node.type.whitespace == "pre" &&
				(e.preserveWhitespace = "full"),
			!this.contentDOM)
		)
			e.getContent = () => this.node.content;
		else if (!this.contentLost) e.contentElement = this.contentDOM;
		else {
			for (let n = this.children.length - 1; n >= 0; n--) {
				let r = this.children[n];
				if (this.dom.contains(r.dom.parentNode)) {
					e.contentElement = r.dom.parentNode;
					break;
				}
			}
			e.contentElement || (e.getContent = () => J.empty);
		}
		return e;
	}
	matchesNode(e, n, r) {
		return (
			this.dirty == On &&
			e.eq(this.node) &&
			Nd(n, this.outerDeco) &&
			r.eq(this.innerDeco)
		);
	}
	get size() {
		return this.node.nodeSize;
	}
	get border() {
		return this.node.isLeaf ? 0 : 1;
	}
	updateChildren(e, n) {
		let r = this.node.inlineContent,
			o = n,
			i = e.composing ? this.localCompositionInfo(e, n) : null,
			s = i && i.pos > -1 ? i : null,
			l = i && i.pos < 0,
			a = new CM(this, s && s.node, e);
		TM(
			this.node,
			this.innerDeco,
			(u, c, d) => {
				u.spec.marks
					? a.syncToMarks(u.spec.marks, r, e)
					: u.type.side >= 0 &&
					  !d &&
					  a.syncToMarks(
							c == this.node.childCount
								? ot.none
								: this.node.child(c).marks,
							r,
							e
					  ),
					a.placeWidget(u, e, o);
			},
			(u, c, d, h) => {
				a.syncToMarks(u.marks, r, e);
				let p;
				a.findNodeMatch(u, c, d, h) ||
					(l &&
						e.state.selection.from > o &&
						e.state.selection.to < o + u.nodeSize &&
						(p = a.findIndexWithChild(i.node)) > -1 &&
						a.updateNodeAt(u, c, d, p, e)) ||
					a.updateNextNode(u, c, d, e, h, o) ||
					a.addNode(u, c, d, e, o),
					(o += u.nodeSize);
			}
		),
			a.syncToMarks([], r, e),
			this.node.isTextblock && a.addTextblockHacks(),
			a.destroyRest(),
			(a.changed || this.dirty == Mo) &&
				(s && this.protectLocalComposition(e, s),
				kv(this.contentDOM, this.children, e),
				Ri && AM(this.dom));
	}
	localCompositionInfo(e, n) {
		let { from: r, to: o } = e.state.selection;
		if (
			!(e.state.selection instanceof ke) ||
			r < n ||
			o > n + this.node.content.size
		)
			return null;
		let i = e.domSelectionRange(),
			s = OM(i.focusNode, i.focusOffset);
		if (!s || !this.dom.contains(s.parentNode)) return null;
		if (this.node.inlineContent) {
			let l = s.nodeValue,
				a = RM(this.node.content, l, r - n, o - n);
			return a < 0 ? null : { node: s, pos: a, text: l };
		} else return { node: s, pos: -1, text: "" };
	}
	protectLocalComposition(e, { node: n, pos: r, text: o }) {
		if (this.getDesc(n)) return;
		let i = n;
		for (; i.parentNode != this.contentDOM; i = i.parentNode) {
			for (; i.previousSibling; )
				i.parentNode.removeChild(i.previousSibling);
			for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling);
			i.pmViewDesc && (i.pmViewDesc = void 0);
		}
		let s = new kM(this, i, n, o);
		e.input.compositionNodes.push(s),
			(this.children = Dd(this.children, r, r + o.length, e, s));
	}
	update(e, n, r, o) {
		return this.dirty == ur || !e.sameMarkup(this.node)
			? !1
			: (this.updateInner(e, n, r, o), !0);
	}
	updateInner(e, n, r, o) {
		this.updateOuterDeco(n),
			(this.node = e),
			(this.innerDeco = r),
			this.contentDOM && this.updateChildren(o, this.posAtStart),
			(this.dirty = On);
	}
	updateOuterDeco(e) {
		if (Nd(e, this.outerDeco)) return;
		let n = this.nodeDOM.nodeType != 1,
			r = this.dom;
		(this.dom = Sv(
			this.dom,
			this.nodeDOM,
			Id(this.outerDeco, this.node, n),
			Id(e, this.node, n)
		)),
			this.dom != r &&
				((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
			(this.outerDeco = e);
	}
	selectNode() {
		this.nodeDOM.nodeType == 1 &&
			this.nodeDOM.classList.add("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				(this.dom.draggable = !0);
	}
	deselectNode() {
		this.nodeDOM.nodeType == 1 &&
			this.nodeDOM.classList.remove("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				this.dom.removeAttribute("draggable");
	}
	get domAtom() {
		return this.node.isAtom;
	}
}
function Vm(t, e, n, r, o) {
	_v(r, e, t);
	let i = new no(void 0, t, e, n, r, r, r, o, 0);
	return i.contentDOM && i.updateChildren(o, 0), i;
}
class Lu extends no {
	constructor(e, n, r, o, i, s, l) {
		super(e, n, r, o, i, null, s, l, 0);
	}
	parseRule() {
		let e = this.nodeDOM.parentNode;
		for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
		return { skip: e || !0 };
	}
	update(e, n, r, o) {
		return this.dirty == ur ||
			(this.dirty != On && !this.inParent()) ||
			!e.sameMarkup(this.node)
			? !1
			: (this.updateOuterDeco(n),
			  (this.dirty != On || e.text != this.node.text) &&
					e.text != this.nodeDOM.nodeValue &&
					((this.nodeDOM.nodeValue = e.text),
					o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
			  (this.node = e),
			  (this.dirty = On),
			  !0);
	}
	inParent() {
		let e = this.parent.contentDOM;
		for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
		return !1;
	}
	domFromPos(e) {
		return { node: this.nodeDOM, offset: e };
	}
	localPosFromDOM(e, n, r) {
		return e == this.nodeDOM
			? this.posAtStart + Math.min(n, this.node.text.length)
			: super.localPosFromDOM(e, n, r);
	}
	ignoreMutation(e) {
		return e.type != "characterData" && e.type != "selection";
	}
	slice(e, n, r) {
		let o = this.node.cut(e, n),
			i = document.createTextNode(o.text);
		return new Lu(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
	}
	markDirty(e, n) {
		super.markDirty(e, n),
			this.dom != this.nodeDOM &&
				(e == 0 || n == this.nodeDOM.nodeValue.length) &&
				(this.dirty = ur);
	}
	get domAtom() {
		return !1;
	}
}
class xv extends el {
	parseRule() {
		return { ignore: !0 };
	}
	matchesHack(e) {
		return this.dirty == On && this.dom.nodeName == e;
	}
	get domAtom() {
		return !0;
	}
	get ignoreForCoords() {
		return this.dom.nodeName == "IMG";
	}
}
class SM extends no {
	constructor(e, n, r, o, i, s, l, a, u, c) {
		super(e, n, r, o, i, s, l, u, c), (this.spec = a);
	}
	update(e, n, r, o) {
		if (this.dirty == ur) return !1;
		if (this.spec.update) {
			let i = this.spec.update(e, n, r);
			return i && this.updateInner(e, n, r, o), i;
		} else
			return !this.contentDOM && !e.isLeaf
				? !1
				: super.update(e, n, r, o);
	}
	selectNode() {
		this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
	}
	deselectNode() {
		this.spec.deselectNode
			? this.spec.deselectNode()
			: super.deselectNode();
	}
	setSelection(e, n, r, o) {
		this.spec.setSelection
			? this.spec.setSelection(e, n, r)
			: super.setSelection(e, n, r, o);
	}
	destroy() {
		this.spec.destroy && this.spec.destroy(), super.destroy();
	}
	stopEvent(e) {
		return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
	}
	ignoreMutation(e) {
		return this.spec.ignoreMutation
			? this.spec.ignoreMutation(e)
			: super.ignoreMutation(e);
	}
}
function kv(t, e, n) {
	let r = t.firstChild,
		o = !1;
	for (let i = 0; i < e.length; i++) {
		let s = e[i],
			l = s.dom;
		if (l.parentNode == t) {
			for (; l != r; ) (r = Wm(r)), (o = !0);
			r = r.nextSibling;
		} else (o = !0), t.insertBefore(l, r);
		if (s instanceof Ho) {
			let a = r ? r.previousSibling : t.lastChild;
			kv(s.contentDOM, s.children, n),
				(r = a ? a.nextSibling : t.firstChild);
		}
	}
	for (; r; ) (r = Wm(r)), (o = !0);
	o && n.trackWrites == t && (n.trackWrites = null);
}
const fs = function (t) {
	t && (this.nodeName = t);
};
fs.prototype = Object.create(null);
const Eo = [new fs()];
function Id(t, e, n) {
	if (t.length == 0) return Eo;
	let r = n ? Eo[0] : new fs(),
		o = [r];
	for (let i = 0; i < t.length; i++) {
		let s = t[i].type.attrs;
		if (s) {
			s.nodeName && o.push((r = new fs(s.nodeName)));
			for (let l in s) {
				let a = s[l];
				a != null &&
					(n &&
						o.length == 1 &&
						o.push((r = new fs(e.isInline ? "span" : "div"))),
					l == "class"
						? (r.class = (r.class ? r.class + " " : "") + a)
						: l == "style"
						? (r.style = (r.style ? r.style + ";" : "") + a)
						: l != "nodeName" && (r[l] = a));
			}
		}
	}
	return o;
}
function Sv(t, e, n, r) {
	if (n == Eo && r == Eo) return e;
	let o = e;
	for (let i = 0; i < r.length; i++) {
		let s = r[i],
			l = n[i];
		if (i) {
			let a;
			(l &&
				l.nodeName == s.nodeName &&
				o != t &&
				(a = o.parentNode) &&
				a.nodeName.toLowerCase() == s.nodeName) ||
				((a = document.createElement(s.nodeName)),
				(a.pmIsDeco = !0),
				a.appendChild(o),
				(l = Eo[0])),
				(o = a);
		}
		_M(o, l || Eo[0], s);
	}
	return o;
}
function _M(t, e, n) {
	for (let r in e)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			!(r in n) &&
			t.removeAttribute(r);
	for (let r in n)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			n[r] != e[r] &&
			t.setAttribute(r, n[r]);
	if (e.class != n.class) {
		let r = e.class ? e.class.split(" ").filter(Boolean) : [],
			o = n.class ? n.class.split(" ").filter(Boolean) : [];
		for (let i = 0; i < r.length; i++)
			o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
		for (let i = 0; i < o.length; i++)
			r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
		t.classList.length == 0 && t.removeAttribute("class");
	}
	if (e.style != n.style) {
		if (e.style) {
			let r =
					/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
				o;
			for (; (o = r.exec(e.style)); ) t.style.removeProperty(o[1]);
		}
		n.style && (t.style.cssText += n.style);
	}
}
function _v(t, e, n) {
	return Sv(t, t, Eo, Id(e, n, t.nodeType != 1));
}
function Nd(t, e) {
	if (t.length != e.length) return !1;
	for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
	return !0;
}
function Wm(t) {
	let e = t.nextSibling;
	return t.parentNode.removeChild(t), e;
}
class CM {
	constructor(e, n, r) {
		(this.lock = n),
			(this.view = r),
			(this.index = 0),
			(this.stack = []),
			(this.changed = !1),
			(this.top = e),
			(this.preMatch = MM(e.node.content, e));
	}
	destroyBetween(e, n) {
		if (e != n) {
			for (let r = e; r < n; r++) this.top.children[r].destroy();
			this.top.children.splice(e, n - e), (this.changed = !0);
		}
	}
	destroyRest() {
		this.destroyBetween(this.index, this.top.children.length);
	}
	syncToMarks(e, n, r) {
		let o = 0,
			i = this.stack.length >> 1,
			s = Math.min(i, e.length);
		for (
			;
			o < s &&
			(o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(
				e[o]
			) &&
			e[o].type.spec.spanning !== !1;

		)
			o++;
		for (; o < i; )
			this.destroyRest(),
				(this.top.dirty = On),
				(this.index = this.stack.pop()),
				(this.top = this.stack.pop()),
				i--;
		for (; i < e.length; ) {
			this.stack.push(this.top, this.index + 1);
			let l = -1;
			for (
				let a = this.index;
				a < Math.min(this.index + 3, this.top.children.length);
				a++
			) {
				let u = this.top.children[a];
				if (u.matchesMark(e[i]) && !this.isLocked(u.dom)) {
					l = a;
					break;
				}
			}
			if (l > -1)
				l > this.index &&
					((this.changed = !0), this.destroyBetween(this.index, l)),
					(this.top = this.top.children[this.index]);
			else {
				let a = Ho.create(this.top, e[i], n, r);
				this.top.children.splice(this.index, 0, a),
					(this.top = a),
					(this.changed = !0);
			}
			(this.index = 0), i++;
		}
	}
	findNodeMatch(e, n, r, o) {
		let i = -1,
			s;
		if (
			o >= this.preMatch.index &&
			(s = this.preMatch.matches[o - this.preMatch.index]).parent ==
				this.top &&
			s.matchesNode(e, n, r)
		)
			i = this.top.children.indexOf(s, this.index);
		else
			for (
				let l = this.index,
					a = Math.min(this.top.children.length, l + 5);
				l < a;
				l++
			) {
				let u = this.top.children[l];
				if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
					i = l;
					break;
				}
			}
		return i < 0
			? !1
			: (this.destroyBetween(this.index, i), this.index++, !0);
	}
	updateNodeAt(e, n, r, o, i) {
		let s = this.top.children[o];
		return (
			s.dirty == ur && s.dom == s.contentDOM && (s.dirty = Mo),
			s.update(e, n, r, i)
				? (this.destroyBetween(this.index, o), this.index++, !0)
				: !1
		);
	}
	findIndexWithChild(e) {
		for (;;) {
			let n = e.parentNode;
			if (!n) return -1;
			if (n == this.top.contentDOM) {
				let r = e.pmViewDesc;
				if (r) {
					for (let o = this.index; o < this.top.children.length; o++)
						if (this.top.children[o] == r) return o;
				}
				return -1;
			}
			e = n;
		}
	}
	updateNextNode(e, n, r, o, i, s) {
		for (let l = this.index; l < this.top.children.length; l++) {
			let a = this.top.children[l];
			if (a instanceof no) {
				let u = this.preMatch.matched.get(a);
				if (u != null && u != i) return !1;
				let c = a.dom,
					d,
					h =
						this.isLocked(c) &&
						!(
							e.isText &&
							a.node &&
							a.node.isText &&
							a.nodeDOM.nodeValue == e.text &&
							a.dirty != ur &&
							Nd(n, a.outerDeco)
						);
				if (!h && a.update(e, n, r, o))
					return (
						this.destroyBetween(this.index, l),
						a.dom != c && (this.changed = !0),
						this.index++,
						!0
					);
				if (!h && (d = this.recreateWrapper(a, e, n, r, o, s)))
					return (
						(this.top.children[this.index] = d),
						d.contentDOM &&
							((d.dirty = Mo),
							d.updateChildren(o, s + 1),
							(d.dirty = On)),
						(this.changed = !0),
						this.index++,
						!0
					);
				break;
			}
		}
		return !1;
	}
	recreateWrapper(e, n, r, o, i, s) {
		if (
			e.dirty ||
			n.isAtom ||
			!e.children.length ||
			!e.node.content.eq(n.content)
		)
			return null;
		let l = no.create(this.top, n, r, o, i, s);
		if (l.contentDOM) {
			(l.children = e.children), (e.children = []);
			for (let a of l.children) a.parent = l;
		}
		return e.destroy(), l;
	}
	addNode(e, n, r, o, i) {
		let s = no.create(this.top, e, n, r, o, i);
		s.contentDOM && s.updateChildren(o, i + 1),
			this.top.children.splice(this.index++, 0, s),
			(this.changed = !0);
	}
	placeWidget(e, n, r) {
		let o =
			this.index < this.top.children.length
				? this.top.children[this.index]
				: null;
		if (
			o &&
			o.matchesWidget(e) &&
			(e == o.widget || !o.widget.type.toDOM.parentNode)
		)
			this.index++;
		else {
			let i = new wv(this.top, e, n, r);
			this.top.children.splice(this.index++, 0, i), (this.changed = !0);
		}
	}
	addTextblockHacks() {
		let e = this.top.children[this.index - 1],
			n = this.top;
		for (; e instanceof Ho; )
			(n = e), (e = n.children[n.children.length - 1]);
		(!e ||
			!(e instanceof Lu) ||
			/\n$/.test(e.node.text) ||
			(this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
			((tn || Wt) &&
				e &&
				e.dom.contentEditable == "false" &&
				this.addHackNode("IMG", n),
			this.addHackNode("BR", this.top));
	}
	addHackNode(e, n) {
		if (
			n == this.top &&
			this.index < n.children.length &&
			n.children[this.index].matchesHack(e)
		)
			this.index++;
		else {
			let r = document.createElement(e);
			e == "IMG" &&
				((r.className = "ProseMirror-separator"), (r.alt = "")),
				e == "BR" && (r.className = "ProseMirror-trailingBreak");
			let o = new xv(this.top, [], r, null);
			n != this.top
				? n.children.push(o)
				: n.children.splice(this.index++, 0, o),
				(this.changed = !0);
		}
	}
	isLocked(e) {
		return (
			this.lock &&
			(e == this.lock ||
				(e.nodeType == 1 && e.contains(this.lock.parentNode)))
		);
	}
}
function MM(t, e) {
	let n = e,
		r = n.children.length,
		o = t.childCount,
		i = new Map(),
		s = [];
	e: for (; o > 0; ) {
		let l;
		for (;;)
			if (r) {
				let u = n.children[r - 1];
				if (u instanceof Ho) (n = u), (r = u.children.length);
				else {
					(l = u), r--;
					break;
				}
			} else {
				if (n == e) break e;
				(r = n.parent.children.indexOf(n)), (n = n.parent);
			}
		let a = l.node;
		if (a) {
			if (a != t.child(o - 1)) break;
			--o, i.set(l, o), s.push(l);
		}
	}
	return { index: o, matched: i, matches: s.reverse() };
}
function EM(t, e) {
	return t.type.side - e.type.side;
}
function TM(t, e, n, r) {
	let o = e.locals(t),
		i = 0;
	if (o.length == 0) {
		for (let u = 0; u < t.childCount; u++) {
			let c = t.child(u);
			r(c, o, e.forChild(i, c), u), (i += c.nodeSize);
		}
		return;
	}
	let s = 0,
		l = [],
		a = null;
	for (let u = 0; ; ) {
		let c, d;
		for (; s < o.length && o[s].to == i; ) {
			let b = o[s++];
			b.widget && (c ? (d || (d = [c])).push(b) : (c = b));
		}
		if (c)
			if (d) {
				d.sort(EM);
				for (let b = 0; b < d.length; b++) n(d[b], u, !!a);
			} else n(c, u, !!a);
		let h, p;
		if (a) (p = -1), (h = a), (a = null);
		else if (u < t.childCount) (p = u), (h = t.child(u++));
		else break;
		for (let b = 0; b < l.length; b++) l[b].to <= i && l.splice(b--, 1);
		for (; s < o.length && o[s].from <= i && o[s].to > i; ) l.push(o[s++]);
		let g = i + h.nodeSize;
		if (h.isText) {
			let b = g;
			s < o.length && o[s].from < b && (b = o[s].from);
			for (let w = 0; w < l.length; w++) l[w].to < b && (b = l[w].to);
			b < g &&
				((a = h.cut(b - i)), (h = h.cut(0, b - i)), (g = b), (p = -1));
		} else for (; s < o.length && o[s].to < g; ) s++;
		let y =
			h.isInline && !h.isLeaf ? l.filter((b) => !b.inline) : l.slice();
		r(h, y, e.forChild(i, h), p), (i = g);
	}
}
function AM(t) {
	if (t.nodeName == "UL" || t.nodeName == "OL") {
		let e = t.style.cssText;
		(t.style.cssText = e + "; list-style: square !important"),
			window.getComputedStyle(t).listStyle,
			(t.style.cssText = e);
	}
}
function OM(t, e) {
	for (;;) {
		if (t.nodeType == 3) return t;
		if (t.nodeType == 1 && e > 0) {
			if (t.childNodes.length > e && t.childNodes[e].nodeType == 3)
				return t.childNodes[e];
			(t = t.childNodes[e - 1]), (e = er(t));
		} else if (t.nodeType == 1 && e < t.childNodes.length)
			(t = t.childNodes[e]), (e = 0);
		else return null;
	}
}
function RM(t, e, n, r) {
	for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
		let s = t.child(o++),
			l = i;
		if (((i += s.nodeSize), !s.isText)) continue;
		let a = s.text;
		for (; o < t.childCount; ) {
			let u = t.child(o++);
			if (((i += u.nodeSize), !u.isText)) break;
			a += u.text;
		}
		if (i >= n) {
			if (i >= r && a.slice(r - e.length - l, r - l) == e)
				return r - e.length;
			let u = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
			if (u >= 0 && u + e.length + l >= n) return l + u;
			if (
				n == r &&
				a.length >= r + e.length - l &&
				a.slice(r - l, r - l + e.length) == e
			)
				return r;
		}
	}
	return -1;
}
function Dd(t, e, n, r, o) {
	let i = [];
	for (let s = 0, l = 0; s < t.length; s++) {
		let a = t[s],
			u = l,
			c = (l += a.size);
		u >= n || c <= e
			? i.push(a)
			: (u < e && i.push(a.slice(0, e - u, r)),
			  o && (i.push(o), (o = void 0)),
			  c > n && i.push(a.slice(n - u, a.size, r)));
	}
	return i;
}
function ch(t, e = null) {
	let n = t.domSelectionRange(),
		r = t.state.doc;
	if (!n.focusNode) return null;
	let o = t.docView.nearestDesc(n.focusNode),
		i = o && o.size == 0,
		s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
	if (s < 0) return null;
	let l = r.resolve(s),
		a,
		u;
	if (ju(n)) {
		for (a = l; o && !o.node; ) o = o.parent;
		let c = o.node;
		if (
			o &&
			c.isAtom &&
			ve.isSelectable(c) &&
			o.parent &&
			!(c.isInline && tM(n.focusNode, n.focusOffset, o.dom))
		) {
			let d = o.posBefore;
			u = new ve(s == d ? l : r.resolve(d));
		}
	} else {
		let c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
		if (c < 0) return null;
		a = r.resolve(c);
	}
	if (!u) {
		let c =
			e == "pointer" || (t.state.selection.head < l.pos && !i) ? 1 : -1;
		u = dh(t, a, l, c);
	}
	return u;
}
function Cv(t) {
	return t.editable
		? t.hasFocus()
		: Ev(t) &&
				document.activeElement &&
				document.activeElement.contains(t.dom);
}
function Sr(t, e = !1) {
	let n = t.state.selection;
	if ((Mv(t, n), !!Cv(t))) {
		if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Wt) {
			let r = t.domSelectionRange(),
				o = t.domObserver.currentSelection;
			if (
				r.anchorNode &&
				o.anchorNode &&
				zo(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
			) {
				(t.input.mouseDown.delayedSelectionSync = !0),
					t.domObserver.setCurSelection();
				return;
			}
		}
		if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) IM(t);
		else {
			let { anchor: r, head: o } = n,
				i,
				s;
			Um &&
				!(n instanceof ke) &&
				(n.$from.parent.inlineContent || (i = Km(t, n.from)),
				!n.empty && !n.$from.parent.inlineContent && (s = Km(t, n.to))),
				t.docView.setSelection(r, o, t.root, e),
				Um && (i && qm(i), s && qm(s)),
				n.visible
					? t.dom.classList.remove("ProseMirror-hideselection")
					: (t.dom.classList.add("ProseMirror-hideselection"),
					  "onselectionchange" in document && PM(t));
		}
		t.domObserver.setCurSelection(), t.domObserver.connectSelection();
	}
}
const Um = tn || (Wt && oM < 63);
function Km(t, e) {
	let { node: n, offset: r } = t.docView.domFromPos(e, 0),
		o = r < n.childNodes.length ? n.childNodes[r] : null,
		i = r ? n.childNodes[r - 1] : null;
	if (tn && o && o.contentEditable == "false") return Ec(o);
	if (
		(!o || o.contentEditable == "false") &&
		(!i || i.contentEditable == "false")
	) {
		if (o) return Ec(o);
		if (i) return Ec(i);
	}
}
function Ec(t) {
	return (
		(t.contentEditable = "true"),
		tn && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
		t
	);
}
function qm(t) {
	(t.contentEditable = "false"),
		t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function PM(t) {
	let e = t.dom.ownerDocument;
	e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
	let n = t.domSelectionRange(),
		r = n.anchorNode,
		o = n.anchorOffset;
	e.addEventListener(
		"selectionchange",
		(t.input.hideSelectionGuard = () => {
			(n.anchorNode != r || n.anchorOffset != o) &&
				(e.removeEventListener(
					"selectionchange",
					t.input.hideSelectionGuard
				),
				setTimeout(() => {
					(!Cv(t) || t.state.selection.visible) &&
						t.dom.classList.remove("ProseMirror-hideselection");
				}, 20));
		})
	);
}
function IM(t) {
	let e = t.domSelection(),
		n = document.createRange(),
		r = t.cursorWrapper.dom,
		o = r.nodeName == "IMG";
	o ? n.setEnd(r.parentNode, Zt(r) + 1) : n.setEnd(r, 0),
		n.collapse(!1),
		e.removeAllRanges(),
		e.addRange(n),
		!o &&
			!t.state.selection.visible &&
			un &&
			to <= 11 &&
			((r.disabled = !0), (r.disabled = !1));
}
function Mv(t, e) {
	if (e instanceof ve) {
		let n = t.docView.descAt(e.from);
		n != t.lastSelectedViewDesc &&
			(Jm(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
	} else Jm(t);
}
function Jm(t) {
	t.lastSelectedViewDesc &&
		(t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
		(t.lastSelectedViewDesc = void 0));
}
function dh(t, e, n, r) {
	return (
		t.someProp("createSelectionBetween", (o) => o(t, e, n)) ||
		ke.between(e, n, r)
	);
}
function Gm(t) {
	return t.editable && !t.hasFocus() ? !1 : Ev(t);
}
function Ev(t) {
	let e = t.domSelectionRange();
	if (!e.anchorNode) return !1;
	try {
		return (
			t.dom.contains(
				e.anchorNode.nodeType == 3
					? e.anchorNode.parentNode
					: e.anchorNode
			) &&
			(t.editable ||
				t.dom.contains(
					e.focusNode.nodeType == 3
						? e.focusNode.parentNode
						: e.focusNode
				))
		);
	} catch (n) {
		return !1;
	}
}
function NM(t) {
	let e = t.docView.domFromPos(t.state.selection.anchor, 0),
		n = t.domSelectionRange();
	return zo(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function jd(t, e) {
	let { $anchor: n, $head: r } = t.selection,
		o = e > 0 ? n.max(r) : n.min(r),
		i = o.parent.inlineContent
			? o.depth
				? t.doc.resolve(e > 0 ? o.after() : o.before())
				: null
			: o;
	return i && _e.findFrom(i, e);
}
function zr(t, e) {
	return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Ym(t, e, n) {
	let r = t.state.selection;
	if (r instanceof ke)
		if (n.indexOf("s") > -1) {
			let { $head: o } = r,
				i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
			if (!i || i.isText || !i.isLeaf) return !1;
			let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
			return zr(t, new ke(r.$anchor, s));
		} else if (r.empty) {
			if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
				let o = jd(t.state, e);
				return o && o instanceof ve ? zr(t, o) : !1;
			} else if (!(Sn && n.indexOf("m") > -1)) {
				let o = r.$head,
					i = o.textOffset
						? null
						: e < 0
						? o.nodeBefore
						: o.nodeAfter,
					s;
				if (!i || i.isText) return !1;
				let l = e < 0 ? o.pos - i.nodeSize : o.pos;
				return i.isAtom || ((s = t.docView.descAt(l)) && !s.contentDOM)
					? ve.isSelectable(i)
						? zr(
								t,
								new ve(
									e < 0
										? t.state.doc.resolve(
												o.pos - i.nodeSize
										  )
										: o
								)
						  )
						: Zs
						? zr(
								t,
								new ke(
									t.state.doc.resolve(
										e < 0 ? l : l + i.nodeSize
									)
								)
						  )
						: !1
					: !1;
			}
		} else return !1;
	else {
		if (r instanceof ve && r.node.isInline)
			return zr(t, new ke(e > 0 ? r.$to : r.$from));
		{
			let o = jd(t.state, e);
			return o ? zr(t, o) : !1;
		}
	}
}
function Sa(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function hs(t, e) {
	let n = t.pmViewDesc;
	return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Qo(t, e) {
	return e < 0 ? DM(t) : jM(t);
}
function DM(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let o,
		i,
		s = !1;
	for (
		Wn &&
		n.nodeType == 1 &&
		r < Sa(n) &&
		hs(n.childNodes[r], -1) &&
		(s = !0);
		;

	)
		if (r > 0) {
			if (n.nodeType != 1) break;
			{
				let l = n.childNodes[r - 1];
				if (hs(l, -1)) (o = n), (i = --r);
				else if (l.nodeType == 3) (n = l), (r = n.nodeValue.length);
				else break;
			}
		} else {
			if (Tv(n)) break;
			{
				let l = n.previousSibling;
				for (; l && hs(l, -1); )
					(o = n.parentNode), (i = Zt(l)), (l = l.previousSibling);
				if (l) (n = l), (r = Sa(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = 0;
				}
			}
		}
	s ? Ld(t, n, r) : o && Ld(t, o, i);
}
function jM(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let o = Sa(n),
		i,
		s;
	for (;;)
		if (r < o) {
			if (n.nodeType != 1) break;
			let l = n.childNodes[r];
			if (hs(l, 1)) (i = n), (s = ++r);
			else break;
		} else {
			if (Tv(n)) break;
			{
				let l = n.nextSibling;
				for (; l && hs(l, 1); )
					(i = l.parentNode), (s = Zt(l) + 1), (l = l.nextSibling);
				if (l) (n = l), (r = 0), (o = Sa(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = o = 0;
				}
			}
		}
	i && Ld(t, i, s);
}
function Tv(t) {
	let e = t.pmViewDesc;
	return e && e.node && e.node.isBlock;
}
function LM(t, e) {
	for (; t && e == t.childNodes.length && !ah(t); )
		(e = Zt(t) + 1), (t = t.parentNode);
	for (; t && e < t.childNodes.length; ) {
		let n = t.childNodes[e];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = 0);
	}
}
function $M(t, e) {
	for (; t && !e && !ah(t); ) (e = Zt(t)), (t = t.parentNode);
	for (; t && e; ) {
		let n = t.childNodes[e - 1];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = t.childNodes.length);
	}
}
function Ld(t, e, n) {
	if (e.nodeType != 3) {
		let i, s;
		(s = LM(e, n))
			? ((e = s), (n = 0))
			: (i = $M(e, n)) && ((e = i), (n = i.nodeValue.length));
	}
	let r = t.domSelection();
	if (ju(r)) {
		let i = document.createRange();
		i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
	} else r.extend && r.extend(e, n);
	t.domObserver.setCurSelection();
	let { state: o } = t;
	setTimeout(() => {
		t.state == o && Sr(t);
	}, 50);
}
function Qm(t, e) {
	let n = t.state.doc.resolve(e);
	if (!(Wt || iM) && n.parent.inlineContent) {
		let o = t.coordsAtPos(e);
		if (e > n.start()) {
			let i = t.coordsAtPos(e - 1),
				s = (i.top + i.bottom) / 2;
			if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
				return i.left < o.left ? "ltr" : "rtl";
		}
		if (e < n.end()) {
			let i = t.coordsAtPos(e + 1),
				s = (i.top + i.bottom) / 2;
			if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
				return i.left > o.left ? "ltr" : "rtl";
		}
	}
	return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Xm(t, e, n) {
	let r = t.state.selection;
	if (
		(r instanceof ke && !r.empty) ||
		n.indexOf("s") > -1 ||
		(Sn && n.indexOf("m") > -1)
	)
		return !1;
	let { $from: o, $to: i } = r;
	if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
		let s = jd(t.state, e);
		if (s && s instanceof ve) return zr(t, s);
	}
	if (!o.parent.inlineContent) {
		let s = e < 0 ? o : i,
			l = r instanceof Hn ? _e.near(s, e) : _e.findFrom(s, e);
		return l ? zr(t, l) : !1;
	}
	return !1;
}
function Zm(t, e) {
	if (!(t.state.selection instanceof ke)) return !0;
	let { $head: n, $anchor: r, empty: o } = t.state.selection;
	if (!n.sameParent(r)) return !0;
	if (!o) return !1;
	if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
	let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
	if (i && !i.isText) {
		let s = t.state.tr;
		return (
			e < 0
				? s.delete(n.pos - i.nodeSize, n.pos)
				: s.delete(n.pos, n.pos + i.nodeSize),
			t.dispatch(s),
			!0
		);
	}
	return !1;
}
function eg(t, e, n) {
	t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function BM(t) {
	if (!tn || t.state.selection.$head.parentOffset > 0) return !1;
	let { focusNode: e, focusOffset: n } = t.domSelectionRange();
	if (
		e &&
		e.nodeType == 1 &&
		n == 0 &&
		e.firstChild &&
		e.firstChild.contentEditable == "false"
	) {
		let r = e.firstChild;
		eg(t, r, "true"), setTimeout(() => eg(t, r, "false"), 20);
	}
	return !1;
}
function zM(t) {
	let e = "";
	return (
		t.ctrlKey && (e += "c"),
		t.metaKey && (e += "m"),
		t.altKey && (e += "a"),
		t.shiftKey && (e += "s"),
		e
	);
}
function HM(t, e) {
	let n = e.keyCode,
		r = zM(e);
	if (n == 8 || (Sn && n == 72 && r == "c")) return Zm(t, -1) || Qo(t, -1);
	if ((n == 46 && !e.shiftKey) || (Sn && n == 68 && r == "c"))
		return Zm(t, 1) || Qo(t, 1);
	if (n == 13 || n == 27) return !0;
	if (n == 37 || (Sn && n == 66 && r == "c")) {
		let o =
			n == 37 ? (Qm(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
		return Ym(t, o, r) || Qo(t, o);
	} else if (n == 39 || (Sn && n == 70 && r == "c")) {
		let o = n == 39 ? (Qm(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
		return Ym(t, o, r) || Qo(t, o);
	} else {
		if (n == 38 || (Sn && n == 80 && r == "c"))
			return Xm(t, -1, r) || Qo(t, -1);
		if (n == 40 || (Sn && n == 78 && r == "c"))
			return BM(t) || Xm(t, 1, r) || Qo(t, 1);
		if (r == (Sn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
			return !0;
	}
	return !1;
}
function Av(t, e) {
	t.someProp("transformCopied", (p) => {
		e = p(e, t);
	});
	let n = [],
		{ content: r, openStart: o, openEnd: i } = e;
	for (
		;
		o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

	) {
		o--, i--;
		let p = r.firstChild;
		n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null),
			(r = p.content);
	}
	let s = t.someProp("clipboardSerializer") || tr.fromSchema(t.state.schema),
		l = Dv(),
		a = l.createElement("div");
	a.appendChild(s.serializeFragment(r, { document: l }));
	let u = a.firstChild,
		c,
		d = 0;
	for (; u && u.nodeType == 1 && (c = Nv[u.nodeName.toLowerCase()]); ) {
		for (let p = c.length - 1; p >= 0; p--) {
			let g = l.createElement(c[p]);
			for (; a.firstChild; ) g.appendChild(a.firstChild);
			a.appendChild(g), d++;
		}
		u = a.firstChild;
	}
	u &&
		u.nodeType == 1 &&
		u.setAttribute(
			"data-pm-slice",
			`${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`
		);
	let h =
		t.someProp("clipboardTextSerializer", (p) => p(e, t)) ||
		e.content.textBetween(
			0,
			e.content.size,
			`

`
		);
	return { dom: a, text: h };
}
function Ov(t, e, n, r, o) {
	let i = o.parent.type.spec.code,
		s,
		l;
	if (!n && !e) return null;
	let a = e && (r || i || !n);
	if (a) {
		if (
			(t.someProp("transformPastedText", (h) => {
				e = h(e, i || r, t);
			}),
			i)
		)
			return e
				? new se(
						J.from(
							t.state.schema.text(
								e.replace(
									/\r\n?/g,
									`
`
								)
							)
						),
						0,
						0
				  )
				: se.empty;
		let d = t.someProp("clipboardTextParser", (h) => h(e, o, r, t));
		if (d) l = d;
		else {
			let h = o.marks(),
				{ schema: p } = t.state,
				g = tr.fromSchema(p);
			(s = document.createElement("div")),
				e.split(/(?:\r\n?|\n)+/).forEach((y) => {
					let b = s.appendChild(document.createElement("p"));
					y && b.appendChild(g.serializeNode(p.text(y, h)));
				});
		}
	} else
		t.someProp("transformPastedHTML", (d) => {
			n = d(n, t);
		}),
			(s = WM(n)),
			Zs && UM(s);
	let u = s && s.querySelector("[data-pm-slice]"),
		c =
			u &&
			/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
				u.getAttribute("data-pm-slice") || ""
			);
	if (c && c[3])
		for (let d = +c[3]; d > 0; d--) {
			let h = s.firstChild;
			for (; h && h.nodeType != 1; ) h = h.nextSibling;
			if (!h) break;
			s = h;
		}
	if (
		(l ||
			(l = (
				t.someProp("clipboardParser") ||
				t.someProp("domParser") ||
				Iu.fromSchema(t.state.schema)
			).parseSlice(s, {
				preserveWhitespace: !!(a || c),
				context: o,
				ruleFromNode(h) {
					return h.nodeName == "BR" &&
						!h.nextSibling &&
						h.parentNode &&
						!FM.test(h.parentNode.nodeName)
						? { ignore: !0 }
						: null;
				},
			})),
		c)
	)
		l = KM(tg(l, +c[1], +c[2]), c[4]);
	else if (
		((l = se.maxOpen(VM(l.content, o), !0)), l.openStart || l.openEnd)
	) {
		let d = 0,
			h = 0;
		for (
			let p = l.content.firstChild;
			d < l.openStart && !p.type.spec.isolating;
			d++, p = p.firstChild
		);
		for (
			let p = l.content.lastChild;
			h < l.openEnd && !p.type.spec.isolating;
			h++, p = p.lastChild
		);
		l = tg(l, d, h);
	}
	return (
		t.someProp("transformPasted", (d) => {
			l = d(l, t);
		}),
		l
	);
}
const FM =
	/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function VM(t, e) {
	if (t.childCount < 2) return t;
	for (let n = e.depth; n >= 0; n--) {
		let o = e.node(n).contentMatchAt(e.index(n)),
			i,
			s = [];
		if (
			(t.forEach((l) => {
				if (!s) return;
				let a = o.findWrapping(l.type),
					u;
				if (!a) return (s = null);
				if (
					(u =
						s.length && i.length && Pv(a, i, l, s[s.length - 1], 0))
				)
					s[s.length - 1] = u;
				else {
					s.length &&
						(s[s.length - 1] = Iv(s[s.length - 1], i.length));
					let c = Rv(l, a);
					s.push(c), (o = o.matchType(c.type)), (i = a);
				}
			}),
			s)
		)
			return J.from(s);
	}
	return t;
}
function Rv(t, e, n = 0) {
	for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, J.from(t));
	return t;
}
function Pv(t, e, n, r, o) {
	if (o < t.length && o < e.length && t[o] == e[o]) {
		let i = Pv(t, e, n, r.lastChild, o + 1);
		if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i));
		if (
			r
				.contentMatchAt(r.childCount)
				.matchType(o == t.length - 1 ? n.type : t[o + 1])
		)
			return r.copy(r.content.append(J.from(Rv(n, t, o + 1))));
	}
}
function Iv(t, e) {
	if (e == 0) return t;
	let n = t.content.replaceChild(t.childCount - 1, Iv(t.lastChild, e - 1)),
		r = t.contentMatchAt(t.childCount).fillBefore(J.empty, !0);
	return t.copy(n.append(r));
}
function $d(t, e, n, r, o, i) {
	let s = e < 0 ? t.firstChild : t.lastChild,
		l = s.content;
	return (
		t.childCount > 1 && (i = 0),
		o < r - 1 && (l = $d(l, e, n, r, o + 1, i)),
		o >= n &&
			(l =
				e < 0
					? s
							.contentMatchAt(0)
							.fillBefore(l, i <= o)
							.append(l)
					: l.append(
							s
								.contentMatchAt(s.childCount)
								.fillBefore(J.empty, !0)
					  )),
		t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(l))
	);
}
function tg(t, e, n) {
	return (
		e < t.openStart &&
			(t = new se(
				$d(t.content, -1, e, t.openStart, 0, t.openEnd),
				e,
				t.openEnd
			)),
		n < t.openEnd &&
			(t = new se($d(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
		t
	);
}
const Nv = {
	thead: ["table"],
	tbody: ["table"],
	tfoot: ["table"],
	caption: ["table"],
	colgroup: ["table"],
	col: ["table", "colgroup"],
	tr: ["table", "tbody"],
	td: ["table", "tbody", "tr"],
	th: ["table", "tbody", "tr"],
};
let ng = null;
function Dv() {
	return ng || (ng = document.implementation.createHTMLDocument("title"));
}
function WM(t) {
	let e = /^(\s*<meta [^>]*>)*/.exec(t);
	e && (t = t.slice(e[0].length));
	let n = Dv().createElement("div"),
		r = /<([a-z][^>\s]+)/i.exec(t),
		o;
	if (
		((o = r && Nv[r[1].toLowerCase()]) &&
			(t =
				o.map((i) => "<" + i + ">").join("") +
				t +
				o
					.map((i) => "</" + i + ">")
					.reverse()
					.join("")),
		(n.innerHTML = t),
		o)
	)
		for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n;
	return n;
}
function UM(t) {
	let e = t.querySelectorAll(
		Wt ? "span:not([class]):not([style])" : "span.Apple-converted-space"
	);
	for (let n = 0; n < e.length; n++) {
		let r = e[n];
		r.childNodes.length == 1 &&
			r.textContent == "" &&
			r.parentNode &&
			r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
	}
}
function KM(t, e) {
	if (!t.size) return t;
	let n = t.content.firstChild.type.schema,
		r;
	try {
		r = JSON.parse(e);
	} catch (l) {
		return t;
	}
	let { content: o, openStart: i, openEnd: s } = t;
	for (let l = r.length - 2; l >= 0; l -= 2) {
		let a = n.nodes[r[l]];
		if (!a || a.hasRequiredAttrs()) break;
		(o = J.from(a.create(r[l + 1], o))), i++, s++;
	}
	return new se(o, i, s);
}
const nn = {},
	rn = {},
	qM = { touchstart: !0, touchmove: !0 };
class JM {
	constructor() {
		(this.shiftKey = !1),
			(this.mouseDown = null),
			(this.lastKeyCode = null),
			(this.lastKeyCodeTime = 0),
			(this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
			(this.lastSelectionOrigin = null),
			(this.lastSelectionTime = 0),
			(this.lastIOSEnter = 0),
			(this.lastIOSEnterFallbackTimeout = -1),
			(this.lastFocus = 0),
			(this.lastTouch = 0),
			(this.lastAndroidDelete = 0),
			(this.composing = !1),
			(this.composingTimeout = -1),
			(this.compositionNodes = []),
			(this.compositionEndedAt = -2e8),
			(this.compositionID = 1),
			(this.compositionPendingChanges = 0),
			(this.domChangeCount = 0),
			(this.eventHandlers = Object.create(null)),
			(this.hideSelectionGuard = null);
	}
}
function GM(t) {
	for (let e in nn) {
		let n = nn[e];
		t.dom.addEventListener(
			e,
			(t.input.eventHandlers[e] = (r) => {
				QM(t, r) &&
					!fh(t, r) &&
					(t.editable || !(r.type in rn)) &&
					n(t, r);
			}),
			qM[e] ? { passive: !0 } : void 0
		);
	}
	tn && t.dom.addEventListener("input", () => null), Bd(t);
}
function Yr(t, e) {
	(t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function YM(t) {
	t.domObserver.stop();
	for (let e in t.input.eventHandlers)
		t.dom.removeEventListener(e, t.input.eventHandlers[e]);
	clearTimeout(t.input.composingTimeout),
		clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Bd(t) {
	t.someProp("handleDOMEvents", (e) => {
		for (let n in e)
			t.input.eventHandlers[n] ||
				t.dom.addEventListener(
					n,
					(t.input.eventHandlers[n] = (r) => fh(t, r))
				);
	});
}
function fh(t, e) {
	return t.someProp("handleDOMEvents", (n) => {
		let r = n[e.type];
		return r ? r(t, e) || e.defaultPrevented : !1;
	});
}
function QM(t, e) {
	if (!e.bubbles) return !0;
	if (e.defaultPrevented) return !1;
	for (let n = e.target; n != t.dom; n = n.parentNode)
		if (
			!n ||
			n.nodeType == 11 ||
			(n.pmViewDesc && n.pmViewDesc.stopEvent(e))
		)
			return !1;
	return !0;
}
function XM(t, e) {
	!fh(t, e) &&
		nn[e.type] &&
		(t.editable || !(e.type in rn)) &&
		nn[e.type](t, e);
}
rn.keydown = (t, e) => {
	let n = e;
	if (
		((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
		!Lv(t, n) &&
			((t.input.lastKeyCode = n.keyCode),
			(t.input.lastKeyCodeTime = Date.now()),
			!(Dn && Wt && n.keyCode == 13)))
	)
		if (
			(n.keyCode != 229 && t.domObserver.forceFlush(),
			Ri && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
		) {
			let r = Date.now();
			(t.input.lastIOSEnter = r),
				(t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
					t.input.lastIOSEnter == r &&
						(t.someProp("handleKeyDown", (o) =>
							o(t, So(13, "Enter"))
						),
						(t.input.lastIOSEnter = 0));
				}, 200));
		} else
			t.someProp("handleKeyDown", (r) => r(t, n)) || HM(t, n)
				? n.preventDefault()
				: Yr(t, "key");
};
rn.keyup = (t, e) => {
	e.keyCode == 16 && (t.input.shiftKey = !1);
};
rn.keypress = (t, e) => {
	let n = e;
	if (
		Lv(t, n) ||
		!n.charCode ||
		(n.ctrlKey && !n.altKey) ||
		(Sn && n.metaKey)
	)
		return;
	if (t.someProp("handleKeyPress", (o) => o(t, n))) {
		n.preventDefault();
		return;
	}
	let r = t.state.selection;
	if (!(r instanceof ke) || !r.$from.sameParent(r.$to)) {
		let o = String.fromCharCode(n.charCode);
		!/[\r\n]/.test(o) &&
			!t.someProp("handleTextInput", (i) =>
				i(t, r.$from.pos, r.$to.pos, o)
			) &&
			t.dispatch(t.state.tr.insertText(o).scrollIntoView()),
			n.preventDefault();
	}
};
function $u(t) {
	return { left: t.clientX, top: t.clientY };
}
function ZM(t, e) {
	let n = e.x - t.clientX,
		r = e.y - t.clientY;
	return n * n + r * r < 100;
}
function hh(t, e, n, r, o) {
	if (r == -1) return !1;
	let i = t.state.doc.resolve(r);
	for (let s = i.depth + 1; s > 0; s--)
		if (
			t.someProp(e, (l) =>
				s > i.depth
					? l(t, n, i.nodeAfter, i.before(s), o, !0)
					: l(t, n, i.node(s), i.before(s), o, !1)
			)
		)
			return !0;
	return !1;
}
function gi(t, e, n) {
	t.focused || t.focus();
	let r = t.state.tr.setSelection(e);
	n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function eE(t, e) {
	if (e == -1) return !1;
	let n = t.state.doc.resolve(e),
		r = n.nodeAfter;
	return r && r.isAtom && ve.isSelectable(r)
		? (gi(t, new ve(n), "pointer"), !0)
		: !1;
}
function tE(t, e) {
	if (e == -1) return !1;
	let n = t.state.selection,
		r,
		o;
	n instanceof ve && (r = n.node);
	let i = t.state.doc.resolve(e);
	for (let s = i.depth + 1; s > 0; s--) {
		let l = s > i.depth ? i.nodeAfter : i.node(s);
		if (ve.isSelectable(l)) {
			r &&
			n.$from.depth > 0 &&
			s >= n.$from.depth &&
			i.before(n.$from.depth + 1) == n.$from.pos
				? (o = i.before(n.$from.depth))
				: (o = i.before(s));
			break;
		}
	}
	return o != null ? (gi(t, ve.create(t.state.doc, o), "pointer"), !0) : !1;
}
function nE(t, e, n, r, o) {
	return (
		hh(t, "handleClickOn", e, n, r) ||
		t.someProp("handleClick", (i) => i(t, e, r)) ||
		(o ? tE(t, n) : eE(t, n))
	);
}
function rE(t, e, n, r) {
	return (
		hh(t, "handleDoubleClickOn", e, n, r) ||
		t.someProp("handleDoubleClick", (o) => o(t, e, r))
	);
}
function oE(t, e, n, r) {
	return (
		hh(t, "handleTripleClickOn", e, n, r) ||
		t.someProp("handleTripleClick", (o) => o(t, e, r)) ||
		iE(t, n, r)
	);
}
function iE(t, e, n) {
	if (n.button != 0) return !1;
	let r = t.state.doc;
	if (e == -1)
		return r.inlineContent
			? (gi(t, ke.create(r, 0, r.content.size), "pointer"), !0)
			: !1;
	let o = r.resolve(e);
	for (let i = o.depth + 1; i > 0; i--) {
		let s = i > o.depth ? o.nodeAfter : o.node(i),
			l = o.before(i);
		if (s.inlineContent)
			gi(t, ke.create(r, l + 1, l + 1 + s.content.size), "pointer");
		else if (ve.isSelectable(s)) gi(t, ve.create(r, l), "pointer");
		else continue;
		return !0;
	}
}
function ph(t) {
	return _a(t);
}
const jv = Sn ? "metaKey" : "ctrlKey";
nn.mousedown = (t, e) => {
	let n = e;
	t.input.shiftKey = n.shiftKey;
	let r = ph(t),
		o = Date.now(),
		i = "singleClick";
	o - t.input.lastClick.time < 500 &&
		ZM(n, t.input.lastClick) &&
		!n[jv] &&
		(t.input.lastClick.type == "singleClick"
			? (i = "doubleClick")
			: t.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
		(t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i });
	let s = t.posAtCoords($u(n));
	s &&
		(i == "singleClick"
			? (t.input.mouseDown && t.input.mouseDown.done(),
			  (t.input.mouseDown = new sE(t, s, n, !!r)))
			: (i == "doubleClick" ? rE : oE)(t, s.pos, s.inside, n)
			? n.preventDefault()
			: Yr(t, "pointer"));
};
class sE {
	constructor(e, n, r, o) {
		(this.view = e),
			(this.pos = n),
			(this.event = r),
			(this.flushed = o),
			(this.delayedSelectionSync = !1),
			(this.mightDrag = null),
			(this.startDoc = e.state.doc),
			(this.selectNode = !!r[jv]),
			(this.allowDefault = r.shiftKey);
		let i, s;
		if (n.inside > -1) (i = e.state.doc.nodeAt(n.inside)), (s = n.inside);
		else {
			let c = e.state.doc.resolve(n.pos);
			(i = c.parent), (s = c.depth ? c.before() : 0);
		}
		const l = o ? null : r.target,
			a = l ? e.docView.nearestDesc(l, !0) : null;
		this.target = a ? a.dom : null;
		let { selection: u } = e.state;
		((r.button == 0 &&
			i.type.spec.draggable &&
			i.type.spec.selectable !== !1) ||
			(u instanceof ve && u.from <= s && u.to > s)) &&
			(this.mightDrag = {
				node: i,
				pos: s,
				addAttr: !!(this.target && !this.target.draggable),
				setUneditable: !!(
					this.target &&
					Wn &&
					!this.target.hasAttribute("contentEditable")
				),
			}),
			this.target &&
				this.mightDrag &&
				(this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr && (this.target.draggable = !0),
				this.mightDrag.setUneditable &&
					setTimeout(() => {
						this.view.input.mouseDown == this &&
							this.target.setAttribute(
								"contentEditable",
								"false"
							);
					}, 20),
				this.view.domObserver.start()),
			e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
			e.root.addEventListener(
				"mousemove",
				(this.move = this.move.bind(this))
			),
			Yr(e, "pointer");
	}
	done() {
		this.view.root.removeEventListener("mouseup", this.up),
			this.view.root.removeEventListener("mousemove", this.move),
			this.mightDrag &&
				this.target &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr &&
					this.target.removeAttribute("draggable"),
				this.mightDrag.setUneditable &&
					this.target.removeAttribute("contentEditable"),
				this.view.domObserver.start()),
			this.delayedSelectionSync && setTimeout(() => Sr(this.view)),
			(this.view.input.mouseDown = null);
	}
	up(e) {
		if ((this.done(), !this.view.dom.contains(e.target))) return;
		let n = this.pos;
		this.view.state.doc != this.startDoc &&
			(n = this.view.posAtCoords($u(e))),
			this.updateAllowDefault(e),
			this.allowDefault || !n
				? Yr(this.view, "pointer")
				: nE(this.view, n.pos, n.inside, e, this.selectNode)
				? e.preventDefault()
				: e.button == 0 &&
				  (this.flushed ||
						(tn && this.mightDrag && !this.mightDrag.node.isAtom) ||
						(Wt &&
							!this.view.state.selection.visible &&
							Math.min(
								Math.abs(
									n.pos - this.view.state.selection.from
								),
								Math.abs(n.pos - this.view.state.selection.to)
							) <= 2))
				? (gi(
						this.view,
						_e.near(this.view.state.doc.resolve(n.pos)),
						"pointer"
				  ),
				  e.preventDefault())
				: Yr(this.view, "pointer");
	}
	move(e) {
		this.updateAllowDefault(e),
			Yr(this.view, "pointer"),
			e.buttons == 0 && this.done();
	}
	updateAllowDefault(e) {
		!this.allowDefault &&
			(Math.abs(this.event.x - e.clientX) > 4 ||
				Math.abs(this.event.y - e.clientY) > 4) &&
			(this.allowDefault = !0);
	}
}
nn.touchstart = (t) => {
	(t.input.lastTouch = Date.now()), ph(t), Yr(t, "pointer");
};
nn.touchmove = (t) => {
	(t.input.lastTouch = Date.now()), Yr(t, "pointer");
};
nn.contextmenu = (t) => ph(t);
function Lv(t, e) {
	return t.composing
		? !0
		: tn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
		? ((t.input.compositionEndedAt = -2e8), !0)
		: !1;
}
const lE = Dn ? 5e3 : -1;
rn.compositionstart = rn.compositionupdate = (t) => {
	if (!t.composing) {
		t.domObserver.flush();
		let { state: e } = t,
			n = e.selection.$from;
		if (
			e.selection.empty &&
			(e.storedMarks ||
				(!n.textOffset &&
					n.parentOffset &&
					n.nodeBefore.marks.some(
						(r) => r.type.spec.inclusive === !1
					)))
		)
			(t.markCursor = t.state.storedMarks || n.marks()),
				_a(t, !0),
				(t.markCursor = null);
		else if (
			(_a(t),
			Wn &&
				e.selection.empty &&
				n.parentOffset &&
				!n.textOffset &&
				n.nodeBefore.marks.length)
		) {
			let r = t.domSelectionRange();
			for (
				let o = r.focusNode, i = r.focusOffset;
				o && o.nodeType == 1 && i != 0;

			) {
				let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
				if (!s) break;
				if (s.nodeType == 3) {
					t.domSelection().collapse(s, s.nodeValue.length);
					break;
				} else (o = s), (i = -1);
			}
		}
		t.input.composing = !0;
	}
	$v(t, lE);
};
rn.compositionend = (t, e) => {
	t.composing &&
		((t.input.composing = !1),
		(t.input.compositionEndedAt = e.timeStamp),
		(t.input.compositionPendingChanges = t.domObserver.pendingRecords()
			.length
			? t.input.compositionID
			: 0),
		t.input.compositionPendingChanges &&
			Promise.resolve().then(() => t.domObserver.flush()),
		t.input.compositionID++,
		$v(t, 20));
};
function $v(t, e) {
	clearTimeout(t.input.composingTimeout),
		e > -1 && (t.input.composingTimeout = setTimeout(() => _a(t), e));
}
function Bv(t) {
	for (
		t.composing &&
		((t.input.composing = !1), (t.input.compositionEndedAt = aE()));
		t.input.compositionNodes.length > 0;

	)
		t.input.compositionNodes.pop().markParentsDirty();
}
function aE() {
	let t = document.createEvent("Event");
	return t.initEvent("event", !0, !0), t.timeStamp;
}
function _a(t, e = !1) {
	if (!(Dn && t.domObserver.flushingSoon >= 0)) {
		if (
			(t.domObserver.forceFlush(),
			Bv(t),
			e || (t.docView && t.docView.dirty))
		) {
			let n = ch(t);
			return (
				n && !n.eq(t.state.selection)
					? t.dispatch(t.state.tr.setSelection(n))
					: t.updateState(t.state),
				!0
			);
		}
		return !1;
	}
}
function uE(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.dom.parentNode.appendChild(document.createElement("div"));
	n.appendChild(e),
		(n.style.cssText = "position: fixed; left: -10000px; top: 10px");
	let r = getSelection(),
		o = document.createRange();
	o.selectNodeContents(e),
		t.dom.blur(),
		r.removeAllRanges(),
		r.addRange(o),
		setTimeout(() => {
			n.parentNode && n.parentNode.removeChild(n), t.focus();
		}, 50);
}
const Ds = (un && to < 15) || (Ri && sM < 604);
nn.copy = rn.cut = (t, e) => {
	let n = e,
		r = t.state.selection,
		o = n.type == "cut";
	if (r.empty) return;
	let i = Ds ? null : n.clipboardData,
		s = r.content(),
		{ dom: l, text: a } = Av(t, s);
	i
		? (n.preventDefault(),
		  i.clearData(),
		  i.setData("text/html", l.innerHTML),
		  i.setData("text/plain", a))
		: uE(t, l),
		o &&
			t.dispatch(
				t.state.tr
					.deleteSelection()
					.scrollIntoView()
					.setMeta("uiEvent", "cut")
			);
};
function cE(t) {
	return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
		? t.content.firstChild
		: null;
}
function dE(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
		r = t.dom.parentNode.appendChild(
			document.createElement(n ? "textarea" : "div")
		);
	n || (r.contentEditable = "true"),
		(r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
		r.focus();
	let o = t.input.shiftKey && t.input.lastKeyCode != 45;
	setTimeout(() => {
		t.focus(),
			r.parentNode && r.parentNode.removeChild(r),
			n
				? js(t, r.value, null, o, e)
				: js(t, r.textContent, r.innerHTML, o, e);
	}, 50);
}
function js(t, e, n, r, o) {
	let i = Ov(t, e, n, r, t.state.selection.$from);
	if (t.someProp("handlePaste", (a) => a(t, o, i || se.empty))) return !0;
	if (!i) return !1;
	let s = cE(i),
		l = s
			? t.state.tr.replaceSelectionWith(s, r)
			: t.state.tr.replaceSelection(i);
	return (
		t.dispatch(
			l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
		),
		!0
	);
}
function zv(t) {
	let e = t.getData("text/plain") || t.getData("Text");
	if (e) return e;
	let n = t.getData("text/uri-list");
	return n ? n.replace(/\r?\n/g, " ") : "";
}
rn.paste = (t, e) => {
	let n = e;
	if (t.composing && !Dn) return;
	let r = Ds ? null : n.clipboardData,
		o = t.input.shiftKey && t.input.lastKeyCode != 45;
	r && js(t, zv(r), r.getData("text/html"), o, n)
		? n.preventDefault()
		: dE(t, n);
};
class Hv {
	constructor(e, n, r) {
		(this.slice = e), (this.move = n), (this.node = r);
	}
}
const Fv = Sn ? "altKey" : "ctrlKey";
nn.dragstart = (t, e) => {
	let n = e,
		r = t.input.mouseDown;
	if ((r && r.done(), !n.dataTransfer)) return;
	let o = t.state.selection,
		i = o.empty ? null : t.posAtCoords($u(n)),
		s;
	if (
		!(i && i.pos >= o.from && i.pos <= (o instanceof ve ? o.to - 1 : o.to))
	) {
		if (r && r.mightDrag) s = ve.create(t.state.doc, r.mightDrag.pos);
		else if (n.target && n.target.nodeType == 1) {
			let c = t.docView.nearestDesc(n.target, !0);
			c &&
				c.node.type.spec.draggable &&
				c != t.docView &&
				(s = ve.create(t.state.doc, c.posBefore));
		}
	}
	let l = (s || t.state.selection).content(),
		{ dom: a, text: u } = Av(t, l);
	n.dataTransfer.clearData(),
		n.dataTransfer.setData(Ds ? "Text" : "text/html", a.innerHTML),
		(n.dataTransfer.effectAllowed = "copyMove"),
		Ds || n.dataTransfer.setData("text/plain", u),
		(t.dragging = new Hv(l, !n[Fv], s));
};
nn.dragend = (t) => {
	let e = t.dragging;
	window.setTimeout(() => {
		t.dragging == e && (t.dragging = null);
	}, 50);
};
rn.dragover = rn.dragenter = (t, e) => e.preventDefault();
rn.drop = (t, e) => {
	let n = e,
		r = t.dragging;
	if (((t.dragging = null), !n.dataTransfer)) return;
	let o = t.posAtCoords($u(n));
	if (!o) return;
	let i = t.state.doc.resolve(o.pos),
		s = r && r.slice;
	s
		? t.someProp("transformPasted", (g) => {
				s = g(s, t);
		  })
		: (s = Ov(
				t,
				zv(n.dataTransfer),
				Ds ? null : n.dataTransfer.getData("text/html"),
				!1,
				i
		  ));
	let l = !!(r && !n[Fv]);
	if (t.someProp("handleDrop", (g) => g(t, n, s || se.empty, l))) {
		n.preventDefault();
		return;
	}
	if (!s) return;
	n.preventDefault();
	let a = s ? iv(t.state.doc, i.pos, s) : i.pos;
	a == null && (a = i.pos);
	let u = t.state.tr;
	if (l) {
		let { node: g } = r;
		g ? g.replace(u) : u.deleteSelection();
	}
	let c = u.mapping.map(a),
		d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
		h = u.doc;
	if (
		(d
			? u.replaceRangeWith(c, c, s.content.firstChild)
			: u.replaceRange(c, c, s),
		u.doc.eq(h))
	)
		return;
	let p = u.doc.resolve(c);
	if (
		d &&
		ve.isSelectable(s.content.firstChild) &&
		p.nodeAfter &&
		p.nodeAfter.sameMarkup(s.content.firstChild)
	)
		u.setSelection(new ve(p));
	else {
		let g = u.mapping.map(a);
		u.mapping.maps[u.mapping.maps.length - 1].forEach(
			(y, b, w, S) => (g = S)
		),
			u.setSelection(dh(t, p, u.doc.resolve(g)));
	}
	t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
nn.focus = (t) => {
	(t.input.lastFocus = Date.now()),
		t.focused ||
			(t.domObserver.stop(),
			t.dom.classList.add("ProseMirror-focused"),
			t.domObserver.start(),
			(t.focused = !0),
			setTimeout(() => {
				t.docView &&
					t.hasFocus() &&
					!t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
					Sr(t);
			}, 20));
};
nn.blur = (t, e) => {
	let n = e;
	t.focused &&
		(t.domObserver.stop(),
		t.dom.classList.remove("ProseMirror-focused"),
		t.domObserver.start(),
		n.relatedTarget &&
			t.dom.contains(n.relatedTarget) &&
			t.domObserver.currentSelection.clear(),
		(t.focused = !1));
};
nn.beforeinput = (t, e) => {
	if (Wt && Dn && e.inputType == "deleteContentBackward") {
		t.domObserver.flushSoon();
		let { domChangeCount: r } = t.input;
		setTimeout(() => {
			if (
				t.input.domChangeCount != r ||
				(t.dom.blur(),
				t.focus(),
				t.someProp("handleKeyDown", (i) => i(t, So(8, "Backspace"))))
			)
				return;
			let { $cursor: o } = t.state.selection;
			o &&
				o.pos > 0 &&
				t.dispatch(
					t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView()
				);
		}, 50);
	}
};
for (let t in rn) nn[t] = rn[t];
function Ls(t, e) {
	if (t == e) return !0;
	for (let n in t) if (t[n] !== e[n]) return !1;
	for (let n in e) if (!(n in t)) return !1;
	return !0;
}
class Ca {
	constructor(e, n) {
		(this.toDOM = e),
			(this.spec = n || Do),
			(this.side = this.spec.side || 0);
	}
	map(e, n, r, o) {
		let { pos: i, deleted: s } = e.mapResult(
			n.from + o,
			this.side < 0 ? -1 : 1
		);
		return s ? null : new Kt(i - r, i - r, this);
	}
	valid() {
		return !0;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof Ca &&
				((this.spec.key && this.spec.key == e.spec.key) ||
					(this.toDOM == e.toDOM && Ls(this.spec, e.spec))))
		);
	}
	destroy(e) {
		this.spec.destroy && this.spec.destroy(e);
	}
}
class ro {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || Do);
	}
	map(e, n, r, o) {
		let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
			s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
		return i >= s ? null : new Kt(i, s, this);
	}
	valid(e, n) {
		return n.from < n.to;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof ro &&
				Ls(this.attrs, e.attrs) &&
				Ls(this.spec, e.spec))
		);
	}
	static is(e) {
		return e.type instanceof ro;
	}
	destroy() {}
}
class mh {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || Do);
	}
	map(e, n, r, o) {
		let i = e.mapResult(n.from + o, 1);
		if (i.deleted) return null;
		let s = e.mapResult(n.to + o, -1);
		return s.deleted || s.pos <= i.pos
			? null
			: new Kt(i.pos - r, s.pos - r, this);
	}
	valid(e, n) {
		let { index: r, offset: o } = e.content.findIndex(n.from),
			i;
		return (
			o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to
		);
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof mh &&
				Ls(this.attrs, e.attrs) &&
				Ls(this.spec, e.spec))
		);
	}
	destroy() {}
}
class Kt {
	constructor(e, n, r) {
		(this.from = e), (this.to = n), (this.type = r);
	}
	copy(e, n) {
		return new Kt(e, n, this.type);
	}
	eq(e, n = 0) {
		return (
			this.type.eq(e.type) &&
			this.from + n == e.from &&
			this.to + n == e.to
		);
	}
	map(e, n, r) {
		return this.type.map(e, this, n, r);
	}
	static widget(e, n, r) {
		return new Kt(e, e, new Ca(n, r));
	}
	static inline(e, n, r, o) {
		return new Kt(e, n, new ro(r, o));
	}
	static node(e, n, r, o) {
		return new Kt(e, n, new mh(r, o));
	}
	get spec() {
		return this.type.spec;
	}
	get inline() {
		return this.type instanceof ro;
	}
	get widget() {
		return this.type instanceof Ca;
	}
}
const ni = [],
	Do = {};
class ft {
	constructor(e, n) {
		(this.local = e.length ? e : ni), (this.children = n.length ? n : ni);
	}
	static create(e, n) {
		return n.length ? Ma(n, e, 0, Do) : Ft;
	}
	find(e, n, r) {
		let o = [];
		return (
			this.findInner(e == null ? 0 : e, n == null ? 1e9 : n, o, 0, r), o
		);
	}
	findInner(e, n, r, o, i) {
		for (let s = 0; s < this.local.length; s++) {
			let l = this.local[s];
			l.from <= n &&
				l.to >= e &&
				(!i || i(l.spec)) &&
				r.push(l.copy(l.from + o, l.to + o));
		}
		for (let s = 0; s < this.children.length; s += 3)
			if (this.children[s] < n && this.children[s + 1] > e) {
				let l = this.children[s] + 1;
				this.children[s + 2].findInner(e - l, n - l, r, o + l, i);
			}
	}
	map(e, n, r) {
		return this == Ft || e.maps.length == 0
			? this
			: this.mapInner(e, n, 0, 0, r || Do);
	}
	mapInner(e, n, r, o, i) {
		let s;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l].map(e, r, o);
			a && a.type.valid(n, a)
				? (s || (s = [])).push(a)
				: i.onRemove && i.onRemove(this.local[l].spec);
		}
		return this.children.length
			? fE(this.children, s || [], e, n, r, o, i)
			: s
			? new ft(s.sort(jo), ni)
			: Ft;
	}
	add(e, n) {
		return n.length
			? this == Ft
				? ft.create(e, n)
				: this.addInner(e, n, 0)
			: this;
	}
	addInner(e, n, r) {
		let o,
			i = 0;
		e.forEach((l, a) => {
			let u = a + r,
				c;
			if ((c = Wv(n, l, u))) {
				for (
					o || (o = this.children.slice());
					i < o.length && o[i] < a;

				)
					i += 3;
				o[i] == a
					? (o[i + 2] = o[i + 2].addInner(l, c, u + 1))
					: o.splice(i, 0, a, a + l.nodeSize, Ma(c, l, u + 1, Do)),
					(i += 3);
			}
		});
		let s = Vv(i ? Uv(n) : n, -r);
		for (let l = 0; l < s.length; l++)
			s[l].type.valid(e, s[l]) || s.splice(l--, 1);
		return new ft(
			s.length ? this.local.concat(s).sort(jo) : this.local,
			o || this.children
		);
	}
	remove(e) {
		return e.length == 0 || this == Ft ? this : this.removeInner(e, 0);
	}
	removeInner(e, n) {
		let r = this.children,
			o = this.local;
		for (let i = 0; i < r.length; i += 3) {
			let s,
				l = r[i] + n,
				a = r[i + 1] + n;
			for (let c = 0, d; c < e.length; c++)
				(d = e[c]) &&
					d.from > l &&
					d.to < a &&
					((e[c] = null), (s || (s = [])).push(d));
			if (!s) continue;
			r == this.children && (r = this.children.slice());
			let u = r[i + 2].removeInner(s, l + 1);
			u != Ft ? (r[i + 2] = u) : (r.splice(i, 3), (i -= 3));
		}
		if (o.length) {
			for (let i = 0, s; i < e.length; i++)
				if ((s = e[i]))
					for (let l = 0; l < o.length; l++)
						o[l].eq(s, n) &&
							(o == this.local && (o = this.local.slice()),
							o.splice(l--, 1));
		}
		return r == this.children && o == this.local
			? this
			: o.length || r.length
			? new ft(o, r)
			: Ft;
	}
	forChild(e, n) {
		if (this == Ft) return this;
		if (n.isLeaf) return ft.empty;
		let r, o;
		for (let l = 0; l < this.children.length; l += 3)
			if (this.children[l] >= e) {
				this.children[l] == e && (r = this.children[l + 2]);
				break;
			}
		let i = e + 1,
			s = i + n.content.size;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l];
			if (a.from < s && a.to > i && a.type instanceof ro) {
				let u = Math.max(i, a.from) - i,
					c = Math.min(s, a.to) - i;
				u < c && (o || (o = [])).push(a.copy(u, c));
			}
		}
		if (o) {
			let l = new ft(o.sort(jo), ni);
			return r ? new Wr([l, r]) : l;
		}
		return r || Ft;
	}
	eq(e) {
		if (this == e) return !0;
		if (
			!(e instanceof ft) ||
			this.local.length != e.local.length ||
			this.children.length != e.children.length
		)
			return !1;
		for (let n = 0; n < this.local.length; n++)
			if (!this.local[n].eq(e.local[n])) return !1;
		for (let n = 0; n < this.children.length; n += 3)
			if (
				this.children[n] != e.children[n] ||
				this.children[n + 1] != e.children[n + 1] ||
				!this.children[n + 2].eq(e.children[n + 2])
			)
				return !1;
		return !0;
	}
	locals(e) {
		return gh(this.localsInner(e));
	}
	localsInner(e) {
		if (this == Ft) return ni;
		if (e.inlineContent || !this.local.some(ro.is)) return this.local;
		let n = [];
		for (let r = 0; r < this.local.length; r++)
			this.local[r].type instanceof ro || n.push(this.local[r]);
		return n;
	}
}
ft.empty = new ft([], []);
ft.removeOverlap = gh;
const Ft = ft.empty;
class Wr {
	constructor(e) {
		this.members = e;
	}
	map(e, n) {
		const r = this.members.map((o) => o.map(e, n, Do));
		return Wr.from(r);
	}
	forChild(e, n) {
		if (n.isLeaf) return ft.empty;
		let r = [];
		for (let o = 0; o < this.members.length; o++) {
			let i = this.members[o].forChild(e, n);
			i != Ft &&
				(i instanceof Wr ? (r = r.concat(i.members)) : r.push(i));
		}
		return Wr.from(r);
	}
	eq(e) {
		if (!(e instanceof Wr) || e.members.length != this.members.length)
			return !1;
		for (let n = 0; n < this.members.length; n++)
			if (!this.members[n].eq(e.members[n])) return !1;
		return !0;
	}
	locals(e) {
		let n,
			r = !0;
		for (let o = 0; o < this.members.length; o++) {
			let i = this.members[o].localsInner(e);
			if (i.length)
				if (!n) n = i;
				else {
					r && ((n = n.slice()), (r = !1));
					for (let s = 0; s < i.length; s++) n.push(i[s]);
				}
		}
		return n ? gh(r ? n : n.sort(jo)) : ni;
	}
	static from(e) {
		switch (e.length) {
			case 0:
				return Ft;
			case 1:
				return e[0];
			default:
				return new Wr(
					e.every((n) => n instanceof ft)
						? e
						: e.reduce(
								(n, r) =>
									n.concat(r instanceof ft ? r : r.members),
								[]
						  )
				);
		}
	}
}
function fE(t, e, n, r, o, i, s) {
	let l = t.slice();
	for (let u = 0, c = i; u < n.maps.length; u++) {
		let d = 0;
		n.maps[u].forEach((h, p, g, y) => {
			let b = y - g - (p - h);
			for (let w = 0; w < l.length; w += 3) {
				let S = l[w + 1];
				if (S < 0 || h > S + c - d) continue;
				let E = l[w] + c - d;
				p >= E
					? (l[w + 1] = h <= E ? -2 : -1)
					: h >= c && b && ((l[w] += b), (l[w + 1] += b));
			}
			d += b;
		}),
			(c = n.maps[u].map(c, -1));
	}
	let a = !1;
	for (let u = 0; u < l.length; u += 3)
		if (l[u + 1] < 0) {
			if (l[u + 1] == -2) {
				(a = !0), (l[u + 1] = -1);
				continue;
			}
			let c = n.map(t[u] + i),
				d = c - o;
			if (d < 0 || d >= r.content.size) {
				a = !0;
				continue;
			}
			let h = n.map(t[u + 1] + i, -1),
				p = h - o,
				{ index: g, offset: y } = r.content.findIndex(d),
				b = r.maybeChild(g);
			if (b && y == d && y + b.nodeSize == p) {
				let w = l[u + 2].mapInner(n, b, c + 1, t[u] + i + 1, s);
				w != Ft
					? ((l[u] = d), (l[u + 1] = p), (l[u + 2] = w))
					: ((l[u + 1] = -2), (a = !0));
			} else a = !0;
		}
	if (a) {
		let u = hE(l, t, e, n, o, i, s),
			c = Ma(u, r, 0, s);
		e = c.local;
		for (let d = 0; d < l.length; d += 3)
			l[d + 1] < 0 && (l.splice(d, 3), (d -= 3));
		for (let d = 0, h = 0; d < c.children.length; d += 3) {
			let p = c.children[d];
			for (; h < l.length && l[h] < p; ) h += 3;
			l.splice(h, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
		}
	}
	return new ft(e.sort(jo), l);
}
function Vv(t, e) {
	if (!e || !t.length) return t;
	let n = [];
	for (let r = 0; r < t.length; r++) {
		let o = t[r];
		n.push(new Kt(o.from + e, o.to + e, o.type));
	}
	return n;
}
function hE(t, e, n, r, o, i, s) {
	function l(a, u) {
		for (let c = 0; c < a.local.length; c++) {
			let d = a.local[c].map(r, o, u);
			d ? n.push(d) : s.onRemove && s.onRemove(a.local[c].spec);
		}
		for (let c = 0; c < a.children.length; c += 3)
			l(a.children[c + 2], a.children[c] + u + 1);
	}
	for (let a = 0; a < t.length; a += 3)
		t[a + 1] == -1 && l(t[a + 2], e[a] + i + 1);
	return n;
}
function Wv(t, e, n) {
	if (e.isLeaf) return null;
	let r = n + e.nodeSize,
		o = null;
	for (let i = 0, s; i < t.length; i++)
		(s = t[i]) &&
			s.from > n &&
			s.to < r &&
			((o || (o = [])).push(s), (t[i] = null));
	return o;
}
function Uv(t) {
	let e = [];
	for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
	return e;
}
function Ma(t, e, n, r) {
	let o = [],
		i = !1;
	e.forEach((l, a) => {
		let u = Wv(t, l, a + n);
		if (u) {
			i = !0;
			let c = Ma(u, l, n + a + 1, r);
			c != Ft && o.push(a, a + l.nodeSize, c);
		}
	});
	let s = Vv(i ? Uv(t) : t, -n).sort(jo);
	for (let l = 0; l < s.length; l++)
		s[l].type.valid(e, s[l]) ||
			(r.onRemove && r.onRemove(s[l].spec), s.splice(l--, 1));
	return s.length || o.length ? new ft(s, o) : Ft;
}
function jo(t, e) {
	return t.from - e.from || t.to - e.to;
}
function gh(t) {
	let e = t;
	for (let n = 0; n < e.length - 1; n++) {
		let r = e[n];
		if (r.from != r.to)
			for (let o = n + 1; o < e.length; o++) {
				let i = e[o];
				if (i.from == r.from) {
					i.to != r.to &&
						(e == t && (e = t.slice()),
						(e[o] = i.copy(i.from, r.to)),
						rg(e, o + 1, i.copy(r.to, i.to)));
					continue;
				} else {
					i.from < r.to &&
						(e == t && (e = t.slice()),
						(e[n] = r.copy(r.from, i.from)),
						rg(e, o, r.copy(i.from, r.to)));
					break;
				}
			}
	}
	return e;
}
function rg(t, e, n) {
	for (; e < t.length && jo(n, t[e]) > 0; ) e++;
	t.splice(e, 0, n);
}
function Tc(t) {
	let e = [];
	return (
		t.someProp("decorations", (n) => {
			let r = n(t.state);
			r && r != Ft && e.push(r);
		}),
		t.cursorWrapper &&
			e.push(ft.create(t.state.doc, [t.cursorWrapper.deco])),
		Wr.from(e)
	);
}
const pE = {
		childList: !0,
		characterData: !0,
		characterDataOldValue: !0,
		attributes: !0,
		attributeOldValue: !0,
		subtree: !0,
	},
	mE = un && to <= 11;
class gE {
	constructor() {
		(this.anchorNode = null),
			(this.anchorOffset = 0),
			(this.focusNode = null),
			(this.focusOffset = 0);
	}
	set(e) {
		(this.anchorNode = e.anchorNode),
			(this.anchorOffset = e.anchorOffset),
			(this.focusNode = e.focusNode),
			(this.focusOffset = e.focusOffset);
	}
	clear() {
		this.anchorNode = this.focusNode = null;
	}
	eq(e) {
		return (
			e.anchorNode == this.anchorNode &&
			e.anchorOffset == this.anchorOffset &&
			e.focusNode == this.focusNode &&
			e.focusOffset == this.focusOffset
		);
	}
}
class yE {
	constructor(e, n) {
		(this.view = e),
			(this.handleDOMChange = n),
			(this.queue = []),
			(this.flushingSoon = -1),
			(this.observer = null),
			(this.currentSelection = new gE()),
			(this.onCharData = null),
			(this.suppressingSelectionUpdates = !1),
			(this.observer =
				window.MutationObserver &&
				new window.MutationObserver((r) => {
					for (let o = 0; o < r.length; o++) this.queue.push(r[o]);
					un &&
					to <= 11 &&
					r.some(
						(o) =>
							(o.type == "childList" && o.removedNodes.length) ||
							(o.type == "characterData" &&
								o.oldValue.length > o.target.nodeValue.length)
					)
						? this.flushSoon()
						: this.flush();
				})),
			mE &&
				(this.onCharData = (r) => {
					this.queue.push({
						target: r.target,
						type: "characterData",
						oldValue: r.prevValue,
					}),
						this.flushSoon();
				}),
			(this.onSelectionChange = this.onSelectionChange.bind(this));
	}
	flushSoon() {
		this.flushingSoon < 0 &&
			(this.flushingSoon = window.setTimeout(() => {
				(this.flushingSoon = -1), this.flush();
			}, 20));
	}
	forceFlush() {
		this.flushingSoon > -1 &&
			(window.clearTimeout(this.flushingSoon),
			(this.flushingSoon = -1),
			this.flush());
	}
	start() {
		this.observer &&
			(this.observer.takeRecords(),
			this.observer.observe(this.view.dom, pE)),
			this.onCharData &&
				this.view.dom.addEventListener(
					"DOMCharacterDataModified",
					this.onCharData
				),
			this.connectSelection();
	}
	stop() {
		if (this.observer) {
			let e = this.observer.takeRecords();
			if (e.length) {
				for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
				window.setTimeout(() => this.flush(), 20);
			}
			this.observer.disconnect();
		}
		this.onCharData &&
			this.view.dom.removeEventListener(
				"DOMCharacterDataModified",
				this.onCharData
			),
			this.disconnectSelection();
	}
	connectSelection() {
		this.view.dom.ownerDocument.addEventListener(
			"selectionchange",
			this.onSelectionChange
		);
	}
	disconnectSelection() {
		this.view.dom.ownerDocument.removeEventListener(
			"selectionchange",
			this.onSelectionChange
		);
	}
	suppressSelectionUpdates() {
		(this.suppressingSelectionUpdates = !0),
			setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
	}
	onSelectionChange() {
		if (Gm(this.view)) {
			if (this.suppressingSelectionUpdates) return Sr(this.view);
			if (un && to <= 11 && !this.view.state.selection.empty) {
				let e = this.view.domSelectionRange();
				if (
					e.focusNode &&
					zo(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
				)
					return this.flushSoon();
			}
			this.flush();
		}
	}
	setCurSelection() {
		this.currentSelection.set(this.view.domSelectionRange());
	}
	ignoreSelectionChange(e) {
		if (!e.focusNode) return !0;
		let n = new Set(),
			r;
		for (let i = e.focusNode; i; i = Ns(i)) n.add(i);
		for (let i = e.anchorNode; i; i = Ns(i))
			if (n.has(i)) {
				r = i;
				break;
			}
		let o = r && this.view.docView.nearestDesc(r);
		if (
			o &&
			o.ignoreMutation({
				type: "selection",
				target: r.nodeType == 3 ? r.parentNode : r,
			})
		)
			return this.setCurSelection(), !0;
	}
	pendingRecords() {
		if (this.observer)
			for (let e of this.observer.takeRecords()) this.queue.push(e);
		return this.queue;
	}
	flush() {
		let { view: e } = this;
		if (!e.docView || this.flushingSoon > -1) return;
		let n = this.pendingRecords();
		n.length && (this.queue = []);
		let r = e.domSelectionRange(),
			o =
				!this.suppressingSelectionUpdates &&
				!this.currentSelection.eq(r) &&
				Gm(e) &&
				!this.ignoreSelectionChange(r),
			i = -1,
			s = -1,
			l = !1,
			a = [];
		if (e.editable)
			for (let c = 0; c < n.length; c++) {
				let d = this.registerMutation(n[c], a);
				d &&
					((i = i < 0 ? d.from : Math.min(d.from, i)),
					(s = s < 0 ? d.to : Math.max(d.to, s)),
					d.typeOver && (l = !0));
			}
		if (Wn && a.length > 1) {
			let c = a.filter((d) => d.nodeName == "BR");
			if (c.length == 2) {
				let d = c[0],
					h = c[1];
				d.parentNode && d.parentNode.parentNode == h.parentNode
					? h.remove()
					: d.remove();
			}
		}
		let u = null;
		i < 0 &&
		o &&
		e.input.lastFocus > Date.now() - 200 &&
		Math.max(e.input.lastTouch, e.input.lastClick.time) <
			Date.now() - 300 &&
		ju(r) &&
		(u = ch(e)) &&
		u.eq(_e.near(e.state.doc.resolve(0), 1))
			? ((e.input.lastFocus = 0),
			  Sr(e),
			  this.currentSelection.set(r),
			  e.scrollToSelection())
			: (i > -1 || o) &&
			  (i > -1 && (e.docView.markDirty(i, s), vE(e)),
			  this.handleDOMChange(i, s, l, a),
			  e.docView && e.docView.dirty
					? e.updateState(e.state)
					: this.currentSelection.eq(r) || Sr(e),
			  this.currentSelection.set(r));
	}
	registerMutation(e, n) {
		if (n.indexOf(e.target) > -1) return null;
		let r = this.view.docView.nearestDesc(e.target);
		if (
			(e.type == "attributes" &&
				(r == this.view.docView ||
					e.attributeName == "contenteditable" ||
					(e.attributeName == "style" &&
						!e.oldValue &&
						!e.target.getAttribute("style")))) ||
			!r ||
			r.ignoreMutation(e)
		)
			return null;
		if (e.type == "childList") {
			for (let c = 0; c < e.addedNodes.length; c++)
				n.push(e.addedNodes[c]);
			if (
				r.contentDOM &&
				r.contentDOM != r.dom &&
				!r.contentDOM.contains(e.target)
			)
				return { from: r.posBefore, to: r.posAfter };
			let o = e.previousSibling,
				i = e.nextSibling;
			if (un && to <= 11 && e.addedNodes.length)
				for (let c = 0; c < e.addedNodes.length; c++) {
					let { previousSibling: d, nextSibling: h } =
						e.addedNodes[c];
					(!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) &&
						(o = d),
						(!h ||
							Array.prototype.indexOf.call(e.addedNodes, h) <
								0) &&
							(i = h);
				}
			let s = o && o.parentNode == e.target ? Zt(o) + 1 : 0,
				l = r.localPosFromDOM(e.target, s, -1),
				a =
					i && i.parentNode == e.target
						? Zt(i)
						: e.target.childNodes.length,
				u = r.localPosFromDOM(e.target, a, 1);
			return { from: l, to: u };
		} else
			return e.type == "attributes"
				? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
				: {
						from: r.posAtStart,
						to: r.posAtEnd,
						typeOver: e.target.nodeValue == e.oldValue,
				  };
	}
}
let og = new WeakMap(),
	ig = !1;
function vE(t) {
	if (
		!og.has(t) &&
		(og.set(t, null),
		["normal", "nowrap", "pre-line"].indexOf(
			getComputedStyle(t.dom).whiteSpace
		) !== -1)
	) {
		if (((t.requiresGeckoHackNode = Wn), ig)) return;
		console.warn(
			"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
		),
			(ig = !0);
	}
}
function bE(t) {
	let e;
	function n(a) {
		a.preventDefault(),
			a.stopImmediatePropagation(),
			(e = a.getTargetRanges()[0]);
	}
	t.dom.addEventListener("beforeinput", n, !0),
		document.execCommand("indent"),
		t.dom.removeEventListener("beforeinput", n, !0);
	let r = e.startContainer,
		o = e.startOffset,
		i = e.endContainer,
		s = e.endOffset,
		l = t.domAtPos(t.state.selection.anchor);
	return (
		zo(l.node, l.offset, i, s) && ([r, o, i, s] = [i, s, r, o]),
		{ anchorNode: r, anchorOffset: o, focusNode: i, focusOffset: s }
	);
}
function wE(t, e, n) {
	let {
			node: r,
			fromOffset: o,
			toOffset: i,
			from: s,
			to: l,
		} = t.docView.parseRange(e, n),
		a = t.domSelectionRange(),
		u,
		c = a.anchorNode;
	if (
		(c &&
			t.dom.contains(c.nodeType == 1 ? c : c.parentNode) &&
			((u = [{ node: c, offset: a.anchorOffset }]),
			ju(a) || u.push({ node: a.focusNode, offset: a.focusOffset })),
		Wt && t.input.lastKeyCode === 8)
	)
		for (let b = i; b > o; b--) {
			let w = r.childNodes[b - 1],
				S = w.pmViewDesc;
			if (w.nodeName == "BR" && !S) {
				i = b;
				break;
			}
			if (!S || S.size) break;
		}
	let d = t.state.doc,
		h = t.someProp("domParser") || Iu.fromSchema(t.state.schema),
		p = d.resolve(s),
		g = null,
		y = h.parse(r, {
			topNode: p.parent,
			topMatch: p.parent.contentMatchAt(p.index()),
			topOpen: !0,
			from: o,
			to: i,
			preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
			findPositions: u,
			ruleFromNode: xE,
			context: p,
		});
	if (u && u[0].pos != null) {
		let b = u[0].pos,
			w = u[1] && u[1].pos;
		w == null && (w = b), (g = { anchor: b + s, head: w + s });
	}
	return { doc: y, sel: g, from: s, to: l };
}
function xE(t) {
	let e = t.pmViewDesc;
	if (e) return e.parseRule();
	if (t.nodeName == "BR" && t.parentNode) {
		if (tn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
			let n = document.createElement("div");
			return n.appendChild(document.createElement("li")), { skip: n };
		} else if (
			t.parentNode.lastChild == t ||
			(tn && /^(tr|table)$/i.test(t.parentNode.nodeName))
		)
			return { ignore: !0 };
	} else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
		return { ignore: !0 };
	return null;
}
const kE =
	/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function SE(t, e, n, r, o) {
	let i =
		t.input.compositionPendingChanges ||
		(t.composing ? t.input.compositionID : 0);
	if (((t.input.compositionPendingChanges = 0), e < 0)) {
		let C =
				t.input.lastSelectionTime > Date.now() - 50
					? t.input.lastSelectionOrigin
					: null,
			_ = ch(t, C);
		if (_ && !t.state.selection.eq(_)) {
			if (
				Wt &&
				Dn &&
				t.input.lastKeyCode === 13 &&
				Date.now() - 100 < t.input.lastKeyCodeTime &&
				t.someProp("handleKeyDown", (R) => R(t, So(13, "Enter")))
			)
				return;
			let T = t.state.tr.setSelection(_);
			C == "pointer"
				? T.setMeta("pointer", !0)
				: C == "key" && T.scrollIntoView(),
				i && T.setMeta("composition", i),
				t.dispatch(T);
		}
		return;
	}
	let s = t.state.doc.resolve(e),
		l = s.sharedDepth(n);
	(e = s.before(l + 1)), (n = t.state.doc.resolve(n).after(l + 1));
	let a = t.state.selection,
		u = wE(t, e, n),
		c = t.state.doc,
		d = c.slice(u.from, u.to),
		h,
		p;
	t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
		? ((h = t.state.selection.to), (p = "end"))
		: ((h = t.state.selection.from), (p = "start")),
		(t.input.lastKeyCode = null);
	let g = ME(d.content, u.doc.content, u.from, h, p);
	if (
		((Ri && t.input.lastIOSEnter > Date.now() - 225) || Dn) &&
		o.some((C) => C.nodeType == 1 && !kE.test(C.nodeName)) &&
		(!g || g.endA >= g.endB) &&
		t.someProp("handleKeyDown", (C) => C(t, So(13, "Enter")))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (!g)
		if (
			r &&
			a instanceof ke &&
			!a.empty &&
			a.$head.sameParent(a.$anchor) &&
			!t.composing &&
			!(u.sel && u.sel.anchor != u.sel.head)
		)
			g = { start: a.from, endA: a.to, endB: a.to };
		else {
			if (u.sel) {
				let C = sg(t, t.state.doc, u.sel);
				if (C && !C.eq(t.state.selection)) {
					let _ = t.state.tr.setSelection(C);
					i && _.setMeta("composition", i), t.dispatch(_);
				}
			}
			return;
		}
	if (
		Wt &&
		t.cursorWrapper &&
		u.sel &&
		u.sel.anchor == t.cursorWrapper.deco.from &&
		u.sel.head == u.sel.anchor
	) {
		let C = g.endB - g.start;
		u.sel = { anchor: u.sel.anchor + C, head: u.sel.anchor + C };
	}
	t.input.domChangeCount++,
		t.state.selection.from < t.state.selection.to &&
			g.start == g.endB &&
			t.state.selection instanceof ke &&
			(g.start > t.state.selection.from &&
			g.start <= t.state.selection.from + 2 &&
			t.state.selection.from >= u.from
				? (g.start = t.state.selection.from)
				: g.endA < t.state.selection.to &&
				  g.endA >= t.state.selection.to - 2 &&
				  t.state.selection.to <= u.to &&
				  ((g.endB += t.state.selection.to - g.endA),
				  (g.endA = t.state.selection.to))),
		un &&
			to <= 11 &&
			g.endB == g.start + 1 &&
			g.endA == g.start &&
			g.start > u.from &&
			u.doc.textBetween(g.start - u.from - 1, g.start - u.from + 1) ==
				" " &&
			(g.start--, g.endA--, g.endB--);
	let y = u.doc.resolveNoCache(g.start - u.from),
		b = u.doc.resolveNoCache(g.endB - u.from),
		w = c.resolve(g.start),
		S = y.sameParent(b) && y.parent.inlineContent && w.end() >= g.endA,
		E;
	if (
		((Ri &&
			t.input.lastIOSEnter > Date.now() - 225 &&
			(!S || o.some((C) => C.nodeName == "DIV" || C.nodeName == "P"))) ||
			(!S &&
				y.pos < u.doc.content.size &&
				!y.sameParent(b) &&
				(E = _e.findFrom(u.doc.resolve(y.pos + 1), 1, !0)) &&
				E.head == b.pos)) &&
		t.someProp("handleKeyDown", (C) => C(t, So(13, "Enter")))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (
		t.state.selection.anchor > g.start &&
		CE(c, g.start, g.endA, y, b) &&
		t.someProp("handleKeyDown", (C) => C(t, So(8, "Backspace")))
	) {
		Dn && Wt && t.domObserver.suppressSelectionUpdates();
		return;
	}
	Wt && Dn && g.endB == g.start && (t.input.lastAndroidDelete = Date.now()),
		Dn &&
			!S &&
			y.start() != b.start() &&
			b.parentOffset == 0 &&
			y.depth == b.depth &&
			u.sel &&
			u.sel.anchor == u.sel.head &&
			u.sel.head == g.endA &&
			((g.endB -= 2),
			(b = u.doc.resolveNoCache(g.endB - u.from)),
			setTimeout(() => {
				t.someProp("handleKeyDown", function (C) {
					return C(t, So(13, "Enter"));
				});
			}, 20));
	let f = g.start,
		v = g.endA,
		m,
		x,
		k;
	if (S) {
		if (y.pos == b.pos)
			un &&
				to <= 11 &&
				y.parentOffset == 0 &&
				(t.domObserver.suppressSelectionUpdates(),
				setTimeout(() => Sr(t), 20)),
				(m = t.state.tr.delete(f, v)),
				(x = c.resolve(g.start).marksAcross(c.resolve(g.endA)));
		else if (
			g.endA == g.endB &&
			(k = _E(
				y.parent.content.cut(y.parentOffset, b.parentOffset),
				w.parent.content.cut(w.parentOffset, g.endA - w.start())
			))
		)
			(m = t.state.tr),
				k.type == "add"
					? m.addMark(f, v, k.mark)
					: m.removeMark(f, v, k.mark);
		else if (
			y.parent.child(y.index()).isText &&
			y.index() == b.index() - (b.textOffset ? 0 : 1)
		) {
			let C = y.parent.textBetween(y.parentOffset, b.parentOffset);
			if (t.someProp("handleTextInput", (_) => _(t, f, v, C))) return;
			m = t.state.tr.insertText(C, f, v);
		}
	}
	if (
		(m ||
			(m = t.state.tr.replace(
				f,
				v,
				u.doc.slice(g.start - u.from, g.endB - u.from)
			)),
		u.sel)
	) {
		let C = sg(t, m.doc, u.sel);
		C &&
			!(
				(Wt &&
					Dn &&
					t.composing &&
					C.empty &&
					(g.start != g.endB ||
						t.input.lastAndroidDelete < Date.now() - 100) &&
					(C.head == f || C.head == m.mapping.map(v) - 1)) ||
				(un && C.empty && C.head == f)
			) &&
			m.setSelection(C);
	}
	x && m.ensureMarks(x),
		i && m.setMeta("composition", i),
		t.dispatch(m.scrollIntoView());
}
function sg(t, e, n) {
	return Math.max(n.anchor, n.head) > e.content.size
		? null
		: dh(t, e.resolve(n.anchor), e.resolve(n.head));
}
function _E(t, e) {
	let n = t.firstChild.marks,
		r = e.firstChild.marks,
		o = n,
		i = r,
		s,
		l,
		a;
	for (let c = 0; c < r.length; c++) o = r[c].removeFromSet(o);
	for (let c = 0; c < n.length; c++) i = n[c].removeFromSet(i);
	if (o.length == 1 && i.length == 0)
		(l = o[0]), (s = "add"), (a = (c) => c.mark(l.addToSet(c.marks)));
	else if (o.length == 0 && i.length == 1)
		(l = i[0]),
			(s = "remove"),
			(a = (c) => c.mark(l.removeFromSet(c.marks)));
	else return null;
	let u = [];
	for (let c = 0; c < e.childCount; c++) u.push(a(e.child(c)));
	if (J.from(u).eq(t)) return { mark: l, type: s };
}
function CE(t, e, n, r, o) {
	if (
		!r.parent.isTextblock ||
		n - e <= o.pos - r.pos ||
		Ac(r, !0, !1) < o.pos
	)
		return !1;
	let i = t.resolve(e);
	if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
		return !1;
	let s = t.resolve(Ac(i, !0, !0));
	return !s.parent.isTextblock || s.pos > n || Ac(s, !0, !1) < n
		? !1
		: r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Ac(t, e, n) {
	let r = t.depth,
		o = e ? t.end() : t.pos;
	for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
		r--, o++, (e = !1);
	if (n) {
		let i = t.node(r).maybeChild(t.indexAfter(r));
		for (; i && !i.isLeaf; ) (i = i.firstChild), o++;
	}
	return o;
}
function ME(t, e, n, r, o) {
	let i = t.findDiffStart(e, n);
	if (i == null) return null;
	let { a: s, b: l } = t.findDiffEnd(e, n + t.size, n + e.size);
	if (o == "end") {
		let a = Math.max(0, i - Math.min(s, l));
		r -= s + a - i;
	}
	if (s < i && t.size < e.size) {
		let a = r <= i && r >= s ? i - r : 0;
		(i -= a),
			i &&
				i < e.size &&
				lg(e.textBetween(i - 1, i + 1)) &&
				(i += a ? 1 : -1),
			(l = i + (l - s)),
			(s = i);
	} else if (l < i) {
		let a = r <= i && r >= l ? i - r : 0;
		(i -= a),
			i &&
				i < t.size &&
				lg(t.textBetween(i - 1, i + 1)) &&
				(i += a ? 1 : -1),
			(s = i + (s - l)),
			(l = i);
	}
	return { start: i, endA: s, endB: l };
}
function lg(t) {
	if (t.length != 2) return !1;
	let e = t.charCodeAt(0),
		n = t.charCodeAt(1);
	return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class EE {
	constructor(e, n) {
		(this._root = null),
			(this.focused = !1),
			(this.trackWrites = null),
			(this.mounted = !1),
			(this.markCursor = null),
			(this.cursorWrapper = null),
			(this.lastSelectedViewDesc = void 0),
			(this.input = new JM()),
			(this.prevDirectPlugins = []),
			(this.pluginViews = []),
			(this.requiresGeckoHackNode = !1),
			(this.dragging = null),
			(this._props = n),
			(this.state = n.state),
			(this.directPlugins = n.plugins || []),
			this.directPlugins.forEach(fg),
			(this.dispatch = this.dispatch.bind(this)),
			(this.dom = (e && e.mount) || document.createElement("div")),
			e &&
				(e.appendChild
					? e.appendChild(this.dom)
					: typeof e == "function"
					? e(this.dom)
					: e.mount && (this.mounted = !0)),
			(this.editable = cg(this)),
			ug(this),
			(this.nodeViews = dg(this)),
			(this.docView = Vm(
				this.state.doc,
				ag(this),
				Tc(this),
				this.dom,
				this
			)),
			(this.domObserver = new yE(this, (r, o, i, s) =>
				SE(this, r, o, i, s)
			)),
			this.domObserver.start(),
			GM(this),
			this.updatePluginViews();
	}
	get composing() {
		return this.input.composing;
	}
	get props() {
		if (this._props.state != this.state) {
			let e = this._props;
			this._props = {};
			for (let n in e) this._props[n] = e[n];
			this._props.state = this.state;
		}
		return this._props;
	}
	update(e) {
		e.handleDOMEvents != this._props.handleDOMEvents && Bd(this);
		let n = this._props;
		(this._props = e),
			e.plugins &&
				(e.plugins.forEach(fg), (this.directPlugins = e.plugins)),
			this.updateStateInner(e.state, n);
	}
	setProps(e) {
		let n = {};
		for (let r in this._props) n[r] = this._props[r];
		n.state = this.state;
		for (let r in e) n[r] = e[r];
		this.update(n);
	}
	updateState(e) {
		this.updateStateInner(e, this._props);
	}
	updateStateInner(e, n) {
		var r;
		let o = this.state,
			i = !1,
			s = !1;
		e.storedMarks && this.composing && (Bv(this), (s = !0)),
			(this.state = e);
		let l = o.plugins != e.plugins || this._props.plugins != n.plugins;
		if (
			l ||
			this._props.plugins != n.plugins ||
			this._props.nodeViews != n.nodeViews
		) {
			let p = dg(this);
			AE(p, this.nodeViews) && ((this.nodeViews = p), (i = !0));
		}
		(l || n.handleDOMEvents != this._props.handleDOMEvents) && Bd(this),
			(this.editable = cg(this)),
			ug(this);
		let a = Tc(this),
			u = ag(this),
			c =
				o.plugins != e.plugins && !o.doc.eq(e.doc)
					? "reset"
					: e.scrollToSelection > o.scrollToSelection
					? "to selection"
					: "preserve",
			d = i || !this.docView.matchesNode(e.doc, u, a);
		(d || !e.selection.eq(o.selection)) && (s = !0);
		let h =
			c == "preserve" &&
			s &&
			this.dom.style.overflowAnchor == null &&
			uM(this);
		if (s) {
			this.domObserver.stop();
			let p =
				d &&
				(un || Wt) &&
				!this.composing &&
				!o.selection.empty &&
				!e.selection.empty &&
				TE(o.selection, e.selection);
			if (d) {
				let g = Wt
					? (this.trackWrites = this.domSelectionRange().focusNode)
					: null;
				(i || !this.docView.update(e.doc, u, a, this)) &&
					(this.docView.updateOuterDeco([]),
					this.docView.destroy(),
					(this.docView = Vm(e.doc, u, a, this.dom, this))),
					g && !this.trackWrites && (p = !0);
			}
			p ||
			!(
				this.input.mouseDown &&
				this.domObserver.currentSelection.eq(
					this.domSelectionRange()
				) &&
				NM(this)
			)
				? Sr(this, p)
				: (Mv(this, e.selection), this.domObserver.setCurSelection()),
				this.domObserver.start();
		}
		this.updatePluginViews(o),
			!((r = this.dragging) === null || r === void 0) &&
				r.node &&
				!o.doc.eq(e.doc) &&
				this.updateDraggedNode(this.dragging, o),
			c == "reset"
				? (this.dom.scrollTop = 0)
				: c == "to selection"
				? this.scrollToSelection()
				: h && cM(h);
	}
	scrollToSelection() {
		let e = this.domSelectionRange().focusNode;
		if (!this.someProp("handleScrollToSelection", (n) => n(this)))
			if (this.state.selection instanceof ve) {
				let n = this.docView.domAfterPos(this.state.selection.from);
				n.nodeType == 1 && Lm(this, n.getBoundingClientRect(), e);
			} else Lm(this, this.coordsAtPos(this.state.selection.head, 1), e);
	}
	destroyPluginViews() {
		let e;
		for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
	}
	updatePluginViews(e) {
		if (
			!e ||
			e.plugins != this.state.plugins ||
			this.directPlugins != this.prevDirectPlugins
		) {
			(this.prevDirectPlugins = this.directPlugins),
				this.destroyPluginViews();
			for (let n = 0; n < this.directPlugins.length; n++) {
				let r = this.directPlugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
			for (let n = 0; n < this.state.plugins.length; n++) {
				let r = this.state.plugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
		} else
			for (let n = 0; n < this.pluginViews.length; n++) {
				let r = this.pluginViews[n];
				r.update && r.update(this, e);
			}
	}
	updateDraggedNode(e, n) {
		let r = e.node,
			o = -1;
		if (this.state.doc.nodeAt(r.from) == r.node) o = r.from;
		else {
			let i = r.from + (this.state.doc.content.size - n.doc.content.size);
			(i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
		}
		this.dragging = new Hv(
			e.slice,
			e.move,
			o < 0 ? void 0 : ve.create(this.state.doc, o)
		);
	}
	someProp(e, n) {
		let r = this._props && this._props[e],
			o;
		if (r != null && (o = n ? n(r) : r)) return o;
		for (let s = 0; s < this.directPlugins.length; s++) {
			let l = this.directPlugins[s].props[e];
			if (l != null && (o = n ? n(l) : l)) return o;
		}
		let i = this.state.plugins;
		if (i)
			for (let s = 0; s < i.length; s++) {
				let l = i[s].props[e];
				if (l != null && (o = n ? n(l) : l)) return o;
			}
	}
	hasFocus() {
		if (un) {
			let e = this.root.activeElement;
			if (e == this.dom) return !0;
			if (!e || !this.dom.contains(e)) return !1;
			for (; e && this.dom != e && this.dom.contains(e); ) {
				if (e.contentEditable == "false") return !1;
				e = e.parentElement;
			}
			return !0;
		}
		return this.root.activeElement == this.dom;
	}
	focus() {
		this.domObserver.stop(),
			this.editable && dM(this.dom),
			Sr(this),
			this.domObserver.start();
	}
	get root() {
		let e = this._root;
		if (e == null) {
			for (let n = this.dom.parentNode; n; n = n.parentNode)
				if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
					return (
						n.getSelection ||
							(Object.getPrototypeOf(n).getSelection = () =>
								n.ownerDocument.getSelection()),
						(this._root = n)
					);
		}
		return e || document;
	}
	updateRoot() {
		this._root = null;
	}
	posAtCoords(e) {
		return gM(this, e);
	}
	coordsAtPos(e, n = 1) {
		return vv(this, e, n);
	}
	domAtPos(e, n = 0) {
		return this.docView.domFromPos(e, n);
	}
	nodeDOM(e) {
		let n = this.docView.descAt(e);
		return n ? n.nodeDOM : null;
	}
	posAtDOM(e, n, r = -1) {
		let o = this.docView.posFromDOM(e, n, r);
		if (o == null)
			throw new RangeError("DOM position not inside the editor");
		return o;
	}
	endOfTextblock(e, n) {
		return xM(this, n || this.state, e);
	}
	pasteHTML(e, n) {
		return js(this, "", e, !1, n || new ClipboardEvent("paste"));
	}
	pasteText(e, n) {
		return js(this, e, null, !0, n || new ClipboardEvent("paste"));
	}
	destroy() {
		this.docView &&
			(YM(this),
			this.destroyPluginViews(),
			this.mounted
				? (this.docView.update(this.state.doc, [], Tc(this), this),
				  (this.dom.textContent = ""))
				: this.dom.parentNode &&
				  this.dom.parentNode.removeChild(this.dom),
			this.docView.destroy(),
			(this.docView = null));
	}
	get isDestroyed() {
		return this.docView == null;
	}
	dispatchEvent(e) {
		return XM(this, e);
	}
	dispatch(e) {
		let n = this._props.dispatchTransaction;
		n ? n.call(this, e) : this.updateState(this.state.apply(e));
	}
	domSelectionRange() {
		return tn &&
			this.root.nodeType === 11 &&
			nM(this.dom.ownerDocument) == this.dom
			? bE(this)
			: this.domSelection();
	}
	domSelection() {
		return this.root.getSelection();
	}
}
function ag(t) {
	let e = Object.create(null);
	return (
		(e.class = "ProseMirror"),
		(e.contenteditable = String(t.editable)),
		t.someProp("attributes", (n) => {
			if ((typeof n == "function" && (n = n(t.state)), n))
				for (let r in n)
					r == "class"
						? (e.class += " " + n[r])
						: r == "style"
						? (e.style = (e.style ? e.style + ";" : "") + n[r])
						: !e[r] &&
						  r != "contenteditable" &&
						  r != "nodeName" &&
						  (e[r] = String(n[r]));
		}),
		e.translate || (e.translate = "no"),
		[Kt.node(0, t.state.doc.content.size, e)]
	);
}
function ug(t) {
	if (t.markCursor) {
		let e = document.createElement("img");
		(e.className = "ProseMirror-separator"),
			e.setAttribute("mark-placeholder", "true"),
			e.setAttribute("alt", ""),
			(t.cursorWrapper = {
				dom: e,
				deco: Kt.widget(t.state.selection.head, e, {
					raw: !0,
					marks: t.markCursor,
				}),
			});
	} else t.cursorWrapper = null;
}
function cg(t) {
	return !t.someProp("editable", (e) => e(t.state) === !1);
}
function TE(t, e) {
	let n = Math.min(
		t.$anchor.sharedDepth(t.head),
		e.$anchor.sharedDepth(e.head)
	);
	return t.$anchor.start(n) != e.$anchor.start(n);
}
function dg(t) {
	let e = Object.create(null);
	function n(r) {
		for (let o in r)
			Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
	}
	return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function AE(t, e) {
	let n = 0,
		r = 0;
	for (let o in t) {
		if (t[o] != e[o]) return !0;
		n++;
	}
	for (let o in e) r++;
	return n != r;
}
function fg(t) {
	if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
		throw new RangeError(
			"Plugins passed directly to the view must not have a state component"
		);
}
var io = {
		8: "Backspace",
		9: "Tab",
		10: "Enter",
		12: "NumLock",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		44: "PrintScreen",
		45: "Insert",
		46: "Delete",
		59: ";",
		61: "=",
		91: "Meta",
		92: "Meta",
		106: "*",
		107: "+",
		108: ",",
		109: "-",
		110: ".",
		111: "/",
		144: "NumLock",
		145: "ScrollLock",
		160: "Shift",
		161: "Shift",
		162: "Control",
		163: "Control",
		164: "Alt",
		165: "Alt",
		173: "-",
		186: ";",
		187: "=",
		188: ",",
		189: "-",
		190: ".",
		191: "/",
		192: "`",
		219: "[",
		220: "\\",
		221: "]",
		222: "'",
	},
	Ea = {
		48: ")",
		49: "!",
		50: "@",
		51: "#",
		52: "$",
		53: "%",
		54: "^",
		55: "&",
		56: "*",
		57: "(",
		59: ":",
		61: "+",
		173: "_",
		186: ":",
		187: "+",
		188: "<",
		189: "_",
		190: ">",
		191: "?",
		192: "~",
		219: "{",
		220: "|",
		221: "}",
		222: '"',
	},
	OE = typeof navigator != "undefined" && /Mac/.test(navigator.platform),
	RE =
		typeof navigator != "undefined" &&
		/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
			navigator.userAgent
		);
for (var Bt = 0; Bt < 10; Bt++) io[48 + Bt] = io[96 + Bt] = String(Bt);
for (var Bt = 1; Bt <= 24; Bt++) io[Bt + 111] = "F" + Bt;
for (var Bt = 65; Bt <= 90; Bt++)
	(io[Bt] = String.fromCharCode(Bt + 32)), (Ea[Bt] = String.fromCharCode(Bt));
for (var Oc in io) Ea.hasOwnProperty(Oc) || (Ea[Oc] = io[Oc]);
function PE(t) {
	var e =
			(OE && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
			(RE && t.shiftKey && t.key && t.key.length == 1) ||
			t.key == "Unidentified",
		n =
			(!e && t.key) ||
			(t.shiftKey ? Ea : io)[t.keyCode] ||
			t.key ||
			"Unidentified";
	return (
		n == "Esc" && (n = "Escape"),
		n == "Del" && (n = "Delete"),
		n == "Left" && (n = "ArrowLeft"),
		n == "Up" && (n = "ArrowUp"),
		n == "Right" && (n = "ArrowRight"),
		n == "Down" && (n = "ArrowDown"),
		n
	);
}
const IE =
	typeof navigator != "undefined"
		? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
		: !1;
function NE(t) {
	let e = t.split(/-(?!$)/),
		n = e[e.length - 1];
	n == "Space" && (n = " ");
	let r, o, i, s;
	for (let l = 0; l < e.length - 1; l++) {
		let a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) s = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) o = !0;
		else if (/^s(hift)?$/i.test(a)) i = !0;
		else if (/^mod$/i.test(a)) IE ? (s = !0) : (o = !0);
		else throw new Error("Unrecognized modifier name: " + a);
	}
	return (
		r && (n = "Alt-" + n),
		o && (n = "Ctrl-" + n),
		s && (n = "Meta-" + n),
		i && (n = "Shift-" + n),
		n
	);
}
function DE(t) {
	let e = Object.create(null);
	for (let n in t) e[NE(n)] = t[n];
	return e;
}
function Rc(t, e, n = !0) {
	return (
		e.altKey && (t = "Alt-" + t),
		e.ctrlKey && (t = "Ctrl-" + t),
		e.metaKey && (t = "Meta-" + t),
		n && e.shiftKey && (t = "Shift-" + t),
		t
	);
}
function jE(t) {
	return new wt({ props: { handleKeyDown: yh(t) } });
}
function yh(t) {
	let e = DE(t);
	return function (n, r) {
		let o = PE(r),
			i,
			s = e[Rc(o, r)];
		if (s && s(n.state, n.dispatch, n)) return !0;
		if (o.length == 1 && o != " ") {
			if (r.shiftKey) {
				let l = e[Rc(o, r, !1)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
			if (
				(r.shiftKey ||
					r.altKey ||
					r.metaKey ||
					o.charCodeAt(0) > 127) &&
				(i = io[r.keyCode]) &&
				i != o
			) {
				let l = e[Rc(i, r)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
		}
		return !1;
	};
}
const LE = (t, e) =>
	t.selection.empty
		? !1
		: (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function $E(t, e) {
	let { $cursor: n } = t.selection;
	return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
		? null
		: n;
}
const BE = (t, e, n) => {
	let r = $E(t, n);
	if (!r) return !1;
	let o = Kv(r);
	if (!o) {
		let s = r.blockRange(),
			l = s && Li(s);
		return l == null ? !1 : (e && e(t.tr.lift(s, l).scrollIntoView()), !0);
	}
	let i = o.nodeBefore;
	if (!i.type.spec.isolating && Gv(t, o, e)) return !0;
	if (r.parent.content.size == 0 && (Pi(i, "end") || ve.isSelectable(i))) {
		let s = ih(t.doc, r.before(), r.after(), se.empty);
		if (s && s.slice.size < s.to - s.from) {
			if (e) {
				let l = t.tr.step(s);
				l.setSelection(
					Pi(i, "end")
						? _e.findFrom(
								l.doc.resolve(l.mapping.map(o.pos, -1)),
								-1
						  )
						: ve.create(l.doc, o.pos - i.nodeSize)
				),
					e(l.scrollIntoView());
			}
			return !0;
		}
	}
	return i.isAtom && o.depth == r.depth - 1
		? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0)
		: !1;
};
function Pi(t, e, n = !1) {
	for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
		if (r.isTextblock) return !0;
		if (n && r.childCount != 1) return !1;
	}
	return !1;
}
const zE = (t, e, n) => {
	let { $head: r, empty: o } = t.selection,
		i = r;
	if (!o) return !1;
	if (r.parent.isTextblock) {
		if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
			return !1;
		i = Kv(r);
	}
	let s = i && i.nodeBefore;
	return !s || !ve.isSelectable(s)
		? !1
		: (e &&
				e(
					t.tr
						.setSelection(ve.create(t.doc, i.pos - s.nodeSize))
						.scrollIntoView()
				),
		  !0);
};
function Kv(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
			if (t.node(e).type.spec.isolating) break;
		}
	return null;
}
function HE(t, e) {
	let { $cursor: n } = t.selection;
	return !n ||
		(e
			? !e.endOfTextblock("forward", t)
			: n.parentOffset < n.parent.content.size)
		? null
		: n;
}
const FE = (t, e, n) => {
		let r = HE(t, n);
		if (!r) return !1;
		let o = qv(r);
		if (!o) return !1;
		let i = o.nodeAfter;
		if (Gv(t, o, e)) return !0;
		if (
			r.parent.content.size == 0 &&
			(Pi(i, "start") || ve.isSelectable(i))
		) {
			let s = ih(t.doc, r.before(), r.after(), se.empty);
			if (s && s.slice.size < s.to - s.from) {
				if (e) {
					let l = t.tr.step(s);
					l.setSelection(
						Pi(i, "start")
							? _e.findFrom(
									l.doc.resolve(l.mapping.map(o.pos)),
									1
							  )
							: ve.create(l.doc, l.mapping.map(o.pos))
					),
						e(l.scrollIntoView());
				}
				return !0;
			}
		}
		return i.isAtom && o.depth == r.depth - 1
			? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()),
			  !0)
			: !1;
	},
	VE = (t, e, n) => {
		let { $head: r, empty: o } = t.selection,
			i = r;
		if (!o) return !1;
		if (r.parent.isTextblock) {
			if (
				n
					? !n.endOfTextblock("forward", t)
					: r.parentOffset < r.parent.content.size
			)
				return !1;
			i = qv(r);
		}
		let s = i && i.nodeAfter;
		return !s || !ve.isSelectable(s)
			? !1
			: (e &&
					e(
						t.tr
							.setSelection(ve.create(t.doc, i.pos))
							.scrollIntoView()
					),
			  !0);
	};
function qv(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			let n = t.node(e);
			if (t.index(e) + 1 < n.childCount)
				return t.doc.resolve(t.after(e + 1));
			if (n.type.spec.isolating) break;
		}
	return null;
}
const WE = (t, e) => {
		let n = t.selection,
			r = n instanceof ve,
			o;
		if (r) {
			if (n.node.isTextblock || !fo(t.doc, n.from)) return !1;
			o = n.from;
		} else if (((o = Nu(t.doc, n.from, -1)), o == null)) return !1;
		if (e) {
			let i = t.tr.join(o);
			r &&
				i.setSelection(
					ve.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)
				),
				e(i.scrollIntoView());
		}
		return !0;
	},
	UE = (t, e) => {
		let n = t.selection,
			r;
		if (n instanceof ve) {
			if (n.node.isTextblock || !fo(t.doc, n.to)) return !1;
			r = n.to;
		} else if (((r = Nu(t.doc, n.to, 1)), r == null)) return !1;
		return e && e(t.tr.join(r).scrollIntoView()), !0;
	},
	KE = (t, e) => {
		let { $from: n, $to: r } = t.selection,
			o = n.blockRange(r),
			i = o && Li(o);
		return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
	},
	qE = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		return !n.parent.type.spec.code || !n.sameParent(r)
			? !1
			: (e &&
					e(
						t.tr
							.insertText(
								`
`
							)
							.scrollIntoView()
					),
			  !0);
	};
function Jv(t) {
	for (let e = 0; e < t.edgeCount; e++) {
		let { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
const JE = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
		let o = n.node(-1),
			i = n.indexAfter(-1),
			s = Jv(o.contentMatchAt(i));
		if (!s || !o.canReplaceWith(i, i, s)) return !1;
		if (e) {
			let l = n.after(),
				a = t.tr.replaceWith(l, l, s.createAndFill());
			a.setSelection(_e.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
		}
		return !0;
	},
	GE = (t, e) => {
		let n = t.selection,
			{ $from: r, $to: o } = n;
		if (n instanceof Hn || r.parent.inlineContent || o.parent.inlineContent)
			return !1;
		let i = Jv(o.parent.contentMatchAt(o.indexAfter()));
		if (!i || !i.isTextblock) return !1;
		if (e) {
			let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o)
					.pos,
				l = t.tr.insert(s, i.createAndFill());
			l.setSelection(ke.create(l.doc, s + 1)), e(l.scrollIntoView());
		}
		return !0;
	},
	YE = (t, e) => {
		let { $cursor: n } = t.selection;
		if (!n || n.parent.content.size) return !1;
		if (n.depth > 1 && n.after() != n.end(-1)) {
			let i = n.before();
			if (pi(t.doc, i)) return e && e(t.tr.split(i).scrollIntoView()), !0;
		}
		let r = n.blockRange(),
			o = r && Li(r);
		return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
	},
	QE = (t, e) => {
		let { $from: n, to: r } = t.selection,
			o,
			i = n.sharedDepth(r);
		return i == 0
			? !1
			: ((o = n.before(i)),
			  e && e(t.tr.setSelection(ve.create(t.doc, o))),
			  !0);
	};
function XE(t, e, n) {
	let r = e.nodeBefore,
		o = e.nodeAfter,
		i = e.index();
	return !r || !o || !r.type.compatibleContent(o.type)
		? !1
		: !r.content.size && e.parent.canReplace(i - 1, i)
		? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
		: !e.parent.canReplace(i, i + 1) || !(o.isTextblock || fo(t.doc, e.pos))
		? !1
		: (n &&
				n(
					t.tr
						.clearIncompatible(
							e.pos,
							r.type,
							r.contentMatchAt(r.childCount)
						)
						.join(e.pos)
						.scrollIntoView()
				),
		  !0);
}
function Gv(t, e, n) {
	let r = e.nodeBefore,
		o = e.nodeAfter,
		i,
		s;
	if (r.type.spec.isolating || o.type.spec.isolating) return !1;
	if (XE(t, e, n)) return !0;
	let l = e.parent.canReplace(e.index(), e.index() + 1);
	if (
		l &&
		(i = (s = r.contentMatchAt(r.childCount)).findWrapping(o.type)) &&
		s.matchType(i[0] || o.type).validEnd
	) {
		if (n) {
			let d = e.pos + o.nodeSize,
				h = J.empty;
			for (let y = i.length - 1; y >= 0; y--)
				h = J.from(i[y].create(null, h));
			h = J.from(r.copy(h));
			let p = t.tr.step(
					new It(
						e.pos - 1,
						d,
						e.pos,
						d,
						new se(h, 1, 0),
						i.length,
						!0
					)
				),
				g = d + 2 * i.length;
			fo(p.doc, g) && p.join(g), n(p.scrollIntoView());
		}
		return !0;
	}
	let a = _e.findFrom(e, 1),
		u = a && a.$from.blockRange(a.$to),
		c = u && Li(u);
	if (c != null && c >= e.depth)
		return n && n(t.tr.lift(u, c).scrollIntoView()), !0;
	if (l && Pi(o, "start", !0) && Pi(r, "end")) {
		let d = r,
			h = [];
		for (; h.push(d), !d.isTextblock; ) d = d.lastChild;
		let p = o,
			g = 1;
		for (; !p.isTextblock; p = p.firstChild) g++;
		if (d.canReplace(d.childCount, d.childCount, p.content)) {
			if (n) {
				let y = J.empty;
				for (let w = h.length - 1; w >= 0; w--)
					y = J.from(h[w].copy(y));
				let b = t.tr.step(
					new It(
						e.pos - h.length,
						e.pos + o.nodeSize,
						e.pos + g,
						e.pos + o.nodeSize - g,
						new se(y, h.length, 0),
						0,
						!0
					)
				);
				n(b.scrollIntoView());
			}
			return !0;
		}
	}
	return !1;
}
function Yv(t) {
	return function (e, n) {
		let r = e.selection,
			o = t < 0 ? r.$from : r.$to,
			i = o.depth;
		for (; o.node(i).isInline; ) {
			if (!i) return !1;
			i--;
		}
		return o.node(i).isTextblock
			? (n &&
					n(
						e.tr.setSelection(
							ke.create(e.doc, t < 0 ? o.start(i) : o.end(i))
						)
					),
			  !0)
			: !1;
	};
}
const ZE = Yv(-1),
	eT = Yv(1);
function tT(t, e = null) {
	return function (n, r) {
		let { $from: o, $to: i } = n.selection,
			s = o.blockRange(i),
			l = s && oh(s, t, e);
		return l ? (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) : !1;
	};
}
function hg(t, e = null) {
	return function (n, r) {
		let o = !1;
		for (let i = 0; i < n.selection.ranges.length && !o; i++) {
			let {
				$from: { pos: s },
				$to: { pos: l },
			} = n.selection.ranges[i];
			n.doc.nodesBetween(s, l, (a, u) => {
				if (o) return !1;
				if (!(!a.isTextblock || a.hasMarkup(t, e)))
					if (a.type == t) o = !0;
					else {
						let c = n.doc.resolve(u),
							d = c.index();
						o = c.parent.canReplaceWith(d, d + 1, t);
					}
			});
		}
		if (!o) return !1;
		if (r) {
			let i = n.tr;
			for (let s = 0; s < n.selection.ranges.length; s++) {
				let {
					$from: { pos: l },
					$to: { pos: a },
				} = n.selection.ranges[s];
				i.setBlockType(l, a, t, e);
			}
			r(i.scrollIntoView());
		}
		return !0;
	};
}
typeof navigator != "undefined"
	? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
	: typeof os != "undefined" && os.platform && os.platform() == "darwin";
function nT(t, e = null) {
	return function (n, r) {
		let { $from: o, $to: i } = n.selection,
			s = o.blockRange(i),
			l = !1,
			a = s;
		if (!s) return !1;
		if (
			s.depth >= 2 &&
			o.node(s.depth - 1).type.compatibleContent(t) &&
			s.startIndex == 0
		) {
			if (o.index(s.depth - 1) == 0) return !1;
			let c = n.doc.resolve(s.start - 2);
			(a = new ba(c, c, s.depth)),
				s.endIndex < s.parent.childCount &&
					(s = new ba(o, n.doc.resolve(i.end(s.depth)), s.depth)),
				(l = !0);
		}
		let u = oh(a, t, e, s);
		return u ? (r && r(rT(n.tr, s, u, l, t).scrollIntoView()), !0) : !1;
	};
}
function rT(t, e, n, r, o) {
	let i = J.empty;
	for (let c = n.length - 1; c >= 0; c--)
		i = J.from(n[c].type.create(n[c].attrs, i));
	t.step(
		new It(
			e.start - (r ? 2 : 0),
			e.end,
			e.start,
			e.end,
			new se(i, 0, 0),
			n.length,
			!0
		)
	);
	let s = 0;
	for (let c = 0; c < n.length; c++) n[c].type == o && (s = c + 1);
	let l = n.length - s,
		a = e.start + n.length - (r ? 2 : 0),
		u = e.parent;
	for (let c = e.startIndex, d = e.endIndex, h = !0; c < d; c++, h = !1)
		!h && pi(t.doc, a, l) && (t.split(a, l), (a += 2 * l)),
			(a += u.child(c).nodeSize);
	return t;
}
function oT(t) {
	return function (e, n) {
		let { $from: r, $to: o } = e.selection,
			i = r.blockRange(
				o,
				(s) => s.childCount > 0 && s.firstChild.type == t
			);
		return i
			? n
				? r.node(i.depth - 1).type == t
					? iT(e, n, t, i)
					: sT(e, n, i)
				: !0
			: !1;
	};
}
function iT(t, e, n, r) {
	let o = t.tr,
		i = r.end,
		s = r.$to.end(r.depth);
	i < s &&
		(o.step(
			new It(
				i - 1,
				s,
				i,
				s,
				new se(J.from(n.create(null, r.parent.copy())), 1, 0),
				1,
				!0
			)
		),
		(r = new ba(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth)));
	const l = Li(r);
	if (l == null) return !1;
	o.lift(r, l);
	let a = o.mapping.map(i, -1) - 1;
	return fo(o.doc, a) && o.join(a), e(o.scrollIntoView()), !0;
}
function sT(t, e, n) {
	let r = t.tr,
		o = n.parent;
	for (let p = n.end, g = n.endIndex - 1, y = n.startIndex; g > y; g--)
		(p -= o.child(g).nodeSize), r.delete(p - 1, p + 1);
	let i = r.doc.resolve(n.start),
		s = i.nodeAfter;
	if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1;
	let l = n.startIndex == 0,
		a = n.endIndex == o.childCount,
		u = i.node(-1),
		c = i.index(-1);
	if (
		!u.canReplace(
			c + (l ? 0 : 1),
			c + 1,
			s.content.append(a ? J.empty : J.from(o))
		)
	)
		return !1;
	let d = i.pos,
		h = d + s.nodeSize;
	return (
		r.step(
			new It(
				d - (l ? 1 : 0),
				h + (a ? 1 : 0),
				d + 1,
				h - 1,
				new se(
					(l ? J.empty : J.from(o.copy(J.empty))).append(
						a ? J.empty : J.from(o.copy(J.empty))
					),
					l ? 0 : 1,
					a ? 0 : 1
				),
				l ? 0 : 1
			)
		),
		e(r.scrollIntoView()),
		!0
	);
}
function lT(t) {
	return function (e, n) {
		let { $from: r, $to: o } = e.selection,
			i = r.blockRange(
				o,
				(u) => u.childCount > 0 && u.firstChild.type == t
			);
		if (!i) return !1;
		let s = i.startIndex;
		if (s == 0) return !1;
		let l = i.parent,
			a = l.child(s - 1);
		if (a.type != t) return !1;
		if (n) {
			let u = a.lastChild && a.lastChild.type == l.type,
				c = J.from(u ? t.create() : null),
				d = new se(
					J.from(t.create(null, J.from(l.type.create(null, c)))),
					u ? 3 : 1,
					0
				),
				h = i.start,
				p = i.end;
			n(
				e.tr
					.step(new It(h - (u ? 3 : 1), p, h, p, d, 1, !0))
					.scrollIntoView()
			);
		}
		return !0;
	};
}
function Bu(t) {
	const { state: e, transaction: n } = t;
	let { selection: r } = n,
		{ doc: o } = n,
		{ storedMarks: i } = n;
	return ye(z({}, e), {
		apply: e.apply.bind(e),
		applyTransaction: e.applyTransaction.bind(e),
		filterTransaction: e.filterTransaction,
		plugins: e.plugins,
		schema: e.schema,
		reconfigure: e.reconfigure.bind(e),
		toJSON: e.toJSON.bind(e),
		get storedMarks() {
			return i;
		},
		get selection() {
			return r;
		},
		get doc() {
			return o;
		},
		get tr() {
			return (r = n.selection), (o = n.doc), (i = n.storedMarks), n;
		},
	});
}
class zu {
	constructor(e) {
		(this.editor = e.editor),
			(this.rawCommands = this.editor.extensionManager.commands),
			(this.customState = e.state);
	}
	get hasCustomState() {
		return !!this.customState;
	}
	get state() {
		return this.customState || this.editor.state;
	}
	get commands() {
		const { rawCommands: e, editor: n, state: r } = this,
			{ view: o } = n,
			{ tr: i } = r,
			s = this.buildProps(i);
		return Object.fromEntries(
			Object.entries(e).map(([l, a]) => [
				l,
				(...c) => {
					const d = a(...c)(s);
					return (
						!i.getMeta("preventDispatch") &&
							!this.hasCustomState &&
							o.dispatch(i),
						d
					);
				},
			])
		);
	}
	get chain() {
		return () => this.createChain();
	}
	get can() {
		return () => this.createCan();
	}
	createChain(e, n = !0) {
		const { rawCommands: r, editor: o, state: i } = this,
			{ view: s } = o,
			l = [],
			a = !!e,
			u = e || i.tr,
			c = () => (
				!a &&
					n &&
					!u.getMeta("preventDispatch") &&
					!this.hasCustomState &&
					s.dispatch(u),
				l.every((h) => h === !0)
			),
			d = ye(
				z(
					{},
					Object.fromEntries(
						Object.entries(r).map(([h, p]) => [
							h,
							(...y) => {
								const b = this.buildProps(u, n),
									w = p(...y)(b);
								return l.push(w), d;
							},
						])
					)
				),
				{ run: c }
			);
		return d;
	}
	createCan(e) {
		const { rawCommands: n, state: r } = this,
			o = !1,
			i = e || r.tr,
			s = this.buildProps(i, o),
			l = Object.fromEntries(
				Object.entries(n).map(([a, u]) => [
					a,
					(...c) => u(...c)(ye(z({}, s), { dispatch: void 0 })),
				])
			);
		return ye(z({}, l), { chain: () => this.createChain(i, o) });
	}
	buildProps(e, n = !0) {
		const { rawCommands: r, editor: o, state: i } = this,
			{ view: s } = o,
			l = {
				tr: e,
				editor: o,
				view: s,
				state: Bu({ state: i, transaction: e }),
				dispatch: n ? () => {} : void 0,
				chain: () => this.createChain(e, n),
				can: () => this.createCan(e),
				get commands() {
					return Object.fromEntries(
						Object.entries(r).map(([a, u]) => [
							a,
							(...c) => u(...c)(l),
						])
					);
				},
			};
		return l;
	}
}
class aT {
	constructor() {
		this.callbacks = {};
	}
	on(e, n) {
		return (
			this.callbacks[e] || (this.callbacks[e] = []),
			this.callbacks[e].push(n),
			this
		);
	}
	emit(e, ...n) {
		const r = this.callbacks[e];
		return r && r.forEach((o) => o.apply(this, n)), this;
	}
	off(e, n) {
		const r = this.callbacks[e];
		return (
			r &&
				(n
					? (this.callbacks[e] = r.filter((o) => o !== n))
					: delete this.callbacks[e]),
			this
		);
	}
	removeAllListeners() {
		this.callbacks = {};
	}
}
function de(t, e, n) {
	return t.config[e] === void 0 && t.parent
		? de(t.parent, e, n)
		: typeof t.config[e] == "function"
		? t.config[e].bind(
				ye(z({}, n), { parent: t.parent ? de(t.parent, e, n) : null })
		  )
		: t.config[e];
}
function Hu(t) {
	const e = t.filter((o) => o.type === "extension"),
		n = t.filter((o) => o.type === "node"),
		r = t.filter((o) => o.type === "mark");
	return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
}
function Qv(t) {
	const e = [],
		{ nodeExtensions: n, markExtensions: r } = Hu(t),
		o = [...n, ...r],
		i = {
			default: null,
			rendered: !0,
			renderHTML: null,
			parseHTML: null,
			keepOnSplit: !0,
			isRequired: !1,
		};
	return (
		t.forEach((s) => {
			const l = { name: s.name, options: s.options, storage: s.storage },
				a = de(s, "addGlobalAttributes", l);
			if (!a) return;
			a().forEach((c) => {
				c.types.forEach((d) => {
					Object.entries(c.attributes).forEach(([h, p]) => {
						e.push({ type: d, name: h, attribute: z(z({}, i), p) });
					});
				});
			});
		}),
		o.forEach((s) => {
			const l = { name: s.name, options: s.options, storage: s.storage },
				a = de(s, "addAttributes", l);
			if (!a) return;
			const u = a();
			Object.entries(u).forEach(([c, d]) => {
				const h = z(z({}, i), d);
				typeof (h == null ? void 0 : h.default) == "function" &&
					(h.default = h.default()),
					h != null &&
						h.isRequired &&
						(h == null ? void 0 : h.default) === void 0 &&
						delete h.default,
					e.push({ type: s.name, name: c, attribute: h });
			});
		}),
		e
	);
}
function jt(t, e) {
	if (typeof t == "string") {
		if (!e.nodes[t])
			throw Error(
				`There is no node type named '${t}'. Maybe you forgot to add the extension?`
			);
		return e.nodes[t];
	}
	return t;
}
function Ze(...t) {
	return t
		.filter((e) => !!e)
		.reduce((e, n) => {
			const r = z({}, e);
			return (
				Object.entries(n).forEach(([o, i]) => {
					if (!r[o]) {
						r[o] = i;
						return;
					}
					if (o === "class") {
						const l = i ? i.split(" ") : [],
							a = r[o] ? r[o].split(" ") : [],
							u = l.filter((c) => !a.includes(c));
						r[o] = [...a, ...u].join(" ");
					} else
						o === "style"
							? (r[o] = [r[o], i].join("; "))
							: (r[o] = i);
				}),
				r
			);
		}, {});
}
function zd(t, e) {
	return e
		.filter((n) => n.attribute.rendered)
		.map((n) =>
			n.attribute.renderHTML
				? n.attribute.renderHTML(t.attrs) || {}
				: { [n.name]: t.attrs[n.name] }
		)
		.reduce((n, r) => Ze(n, r), {});
}
function Xv(t) {
	return typeof t == "function";
}
function Ie(t, e = void 0, ...n) {
	return Xv(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function uT(t = {}) {
	return Object.keys(t).length === 0 && t.constructor === Object;
}
function cT(t) {
	return typeof t != "string"
		? t
		: t.match(/^[+-]?(?:\d*\.)?\d+$/)
		? Number(t)
		: t === "true"
		? !0
		: t === "false"
		? !1
		: t;
}
function pg(t, e) {
	return t.style
		? t
		: ye(z({}, t), {
				getAttrs: (n) => {
					const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
					if (r === !1) return !1;
					const o = e.reduce((i, s) => {
						const l = s.attribute.parseHTML
							? s.attribute.parseHTML(n)
							: cT(n.getAttribute(s.name));
						return l == null ? i : ye(z({}, i), { [s.name]: l });
					}, {});
					return z(z({}, r), o);
				},
		  });
}
function mg(t) {
	return Object.fromEntries(
		Object.entries(t).filter(([e, n]) =>
			e === "attrs" && uT(n) ? !1 : n != null
		)
	);
}
function dT(t, e) {
	var n;
	const r = Qv(t),
		{ nodeExtensions: o, markExtensions: i } = Hu(t),
		s =
			(n = o.find((u) => de(u, "topNode"))) === null || n === void 0
				? void 0
				: n.name,
		l = Object.fromEntries(
			o.map((u) => {
				const c = r.filter((w) => w.type === u.name),
					d = {
						name: u.name,
						options: u.options,
						storage: u.storage,
						editor: e,
					},
					h = t.reduce((w, S) => {
						const E = de(S, "extendNodeSchema", d);
						return z(z({}, w), E ? E(u) : {});
					}, {}),
					p = mg(
						ye(z({}, h), {
							content: Ie(de(u, "content", d)),
							marks: Ie(de(u, "marks", d)),
							group: Ie(de(u, "group", d)),
							inline: Ie(de(u, "inline", d)),
							atom: Ie(de(u, "atom", d)),
							selectable: Ie(de(u, "selectable", d)),
							draggable: Ie(de(u, "draggable", d)),
							code: Ie(de(u, "code", d)),
							defining: Ie(de(u, "defining", d)),
							isolating: Ie(de(u, "isolating", d)),
							attrs: Object.fromEntries(
								c.map((w) => {
									var S;
									return [
										w.name,
										{
											default:
												(S =
													w == null
														? void 0
														: w.attribute) ===
													null || S === void 0
													? void 0
													: S.default,
										},
									];
								})
							),
						})
					),
					g = Ie(de(u, "parseHTML", d));
				g && (p.parseDOM = g.map((w) => pg(w, c)));
				const y = de(u, "renderHTML", d);
				y &&
					(p.toDOM = (w) => y({ node: w, HTMLAttributes: zd(w, c) }));
				const b = de(u, "renderText", d);
				return b && (p.toText = b), [u.name, p];
			})
		),
		a = Object.fromEntries(
			i.map((u) => {
				const c = r.filter((b) => b.type === u.name),
					d = {
						name: u.name,
						options: u.options,
						storage: u.storage,
						editor: e,
					},
					h = t.reduce((b, w) => {
						const S = de(w, "extendMarkSchema", d);
						return z(z({}, b), S ? S(u) : {});
					}, {}),
					p = mg(
						ye(z({}, h), {
							inclusive: Ie(de(u, "inclusive", d)),
							excludes: Ie(de(u, "excludes", d)),
							group: Ie(de(u, "group", d)),
							spanning: Ie(de(u, "spanning", d)),
							code: Ie(de(u, "code", d)),
							attrs: Object.fromEntries(
								c.map((b) => {
									var w;
									return [
										b.name,
										{
											default:
												(w =
													b == null
														? void 0
														: b.attribute) ===
													null || w === void 0
													? void 0
													: w.default,
										},
									];
								})
							),
						})
					),
					g = Ie(de(u, "parseHTML", d));
				g && (p.parseDOM = g.map((b) => pg(b, c)));
				const y = de(u, "renderHTML", d);
				return (
					y &&
						(p.toDOM = (b) =>
							y({ mark: b, HTMLAttributes: zd(b, c) })),
					[u.name, p]
				);
			})
		);
	return new kC({ topNode: s, nodes: l, marks: a });
}
function Pc(t, e) {
	return e.nodes[t] || e.marks[t] || null;
}
function gg(t, e) {
	return Array.isArray(e)
		? e.some((n) => (typeof n == "string" ? n : n.name) === t.name)
		: e;
}
const fT = (t, e = 500) => {
	let n = "";
	const r = t.parentOffset;
	return (
		t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, l) => {
			var a, u;
			const c =
				((u = (a = o.type.spec).toText) === null || u === void 0
					? void 0
					: u.call(a, { node: o, pos: i, parent: s, index: l })) ||
				o.textContent ||
				"%leaf%";
			n += c.slice(0, Math.max(0, r - i));
		}),
		n
	);
};
function vh(t) {
	return Object.prototype.toString.call(t) === "[object RegExp]";
}
class tl {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const hT = (t, e) => {
	if (vh(e)) return e.exec(t);
	const n = e(t);
	if (!n) return null;
	const r = [n.text];
	return (
		(r.index = n.index),
		(r.input = t),
		(r.data = n.data),
		n.replaceWith &&
			(n.text.includes(n.replaceWith) ||
				console.warn(
					'[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
				),
			r.push(n.replaceWith)),
		r
	);
};
function Ic(t) {
	var e;
	const { editor: n, from: r, to: o, text: i, rules: s, plugin: l } = t,
		{ view: a } = n;
	if (a.composing) return !1;
	const u = a.state.doc.resolve(r);
	if (
		u.parent.type.spec.code ||
		(!((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) &&
			e.marks.find((h) => h.type.spec.code))
	)
		return !1;
	let c = !1;
	const d = fT(u) + i;
	return (
		s.forEach((h) => {
			if (c) return;
			const p = hT(d, h.find);
			if (!p) return;
			const g = a.state.tr,
				y = Bu({ state: a.state, transaction: g }),
				b = { from: r - (p[0].length - i.length), to: o },
				{
					commands: w,
					chain: S,
					can: E,
				} = new zu({ editor: n, state: y });
			h.handler({
				state: y,
				range: b,
				match: p,
				commands: w,
				chain: S,
				can: E,
			}) === null ||
				!g.steps.length ||
				(g.setMeta(l, { transform: g, from: r, to: o, text: i }),
				a.dispatch(g),
				(c = !0));
		}),
		c
	);
}
function pT(t) {
	const { editor: e, rules: n } = t,
		r = new wt({
			state: {
				init() {
					return null;
				},
				apply(o, i) {
					const s = o.getMeta(r);
					return s || (o.selectionSet || o.docChanged ? null : i);
				},
			},
			props: {
				handleTextInput(o, i, s, l) {
					return Ic({
						editor: e,
						from: i,
						to: s,
						text: l,
						rules: n,
						plugin: r,
					});
				},
				handleDOMEvents: {
					compositionend: (o) => (
						setTimeout(() => {
							const { $cursor: i } = o.state.selection;
							i &&
								Ic({
									editor: e,
									from: i.pos,
									to: i.pos,
									text: "",
									rules: n,
									plugin: r,
								});
						}),
						!1
					),
				},
				handleKeyDown(o, i) {
					if (i.key !== "Enter") return !1;
					const { $cursor: s } = o.state.selection;
					return s
						? Ic({
								editor: e,
								from: s.pos,
								to: s.pos,
								text: `
`,
								rules: n,
								plugin: r,
						  })
						: !1;
				},
			},
			isInputRules: !0,
		});
	return r;
}
function mT(t) {
	return typeof t == "number";
}
class gT {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const yT = (t, e, n) => {
	if (vh(e)) return [...t.matchAll(e)];
	const r = e(t, n);
	return r
		? r.map((o) => {
				const i = [o.text];
				return (
					(i.index = o.index),
					(i.input = t),
					(i.data = o.data),
					o.replaceWith &&
						(o.text.includes(o.replaceWith) ||
							console.warn(
								'[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
							),
						i.push(o.replaceWith)),
					i
				);
		  })
		: [];
};
function vT(t) {
	const {
			editor: e,
			state: n,
			from: r,
			to: o,
			rule: i,
			pasteEvent: s,
			dropEvent: l,
		} = t,
		{ commands: a, chain: u, can: c } = new zu({ editor: e, state: n }),
		d = [];
	return (
		n.doc.nodesBetween(r, o, (p, g) => {
			if (!p.isTextblock || p.type.spec.code) return;
			const y = Math.max(r, g),
				b = Math.min(o, g + p.content.size),
				w = p.textBetween(y - g, b - g, void 0, "");
			yT(w, i.find, s).forEach((E) => {
				if (E.index === void 0) return;
				const f = y + E.index + 1,
					v = f + E[0].length,
					m = { from: n.tr.mapping.map(f), to: n.tr.mapping.map(v) },
					x = i.handler({
						state: n,
						range: m,
						match: E,
						commands: a,
						chain: u,
						can: c,
						pasteEvent: s,
						dropEvent: l,
					});
				d.push(x);
			});
		}),
		d.every((p) => p !== null)
	);
}
function bT(t) {
	const { editor: e, rules: n } = t;
	let r = null,
		o = !1,
		i = !1,
		s = new ClipboardEvent("paste"),
		l = new DragEvent("drop");
	return n.map(
		(u) =>
			new wt({
				view(c) {
					const d = (h) => {
						var p;
						r =
							!(
								(p = c.dom.parentElement) === null ||
								p === void 0
							) && p.contains(h.target)
								? c.dom.parentElement
								: null;
					};
					return (
						window.addEventListener("dragstart", d),
						{
							destroy() {
								window.removeEventListener("dragstart", d);
							},
						}
					);
				},
				props: {
					handleDOMEvents: {
						drop: (c, d) => (
							(i = r === c.dom.parentElement), (l = d), !1
						),
						paste: (c, d) => {
							var h;
							const p =
								(h = d.clipboardData) === null || h === void 0
									? void 0
									: h.getData("text/html");
							return (
								(s = d),
								(o = !!(
									p != null && p.includes("data-pm-slice")
								)),
								!1
							);
						},
					},
				},
				appendTransaction: (c, d, h) => {
					const p = c[0],
						g = p.getMeta("uiEvent") === "paste" && !o,
						y = p.getMeta("uiEvent") === "drop" && !i;
					if (!g && !y) return;
					const b = d.doc.content.findDiffStart(h.doc.content),
						w = d.doc.content.findDiffEnd(h.doc.content);
					if (!mT(b) || !w || b === w.b) return;
					const S = h.tr,
						E = Bu({ state: h, transaction: S });
					if (
						!(
							!vT({
								editor: e,
								state: E,
								from: Math.max(b - 1, 0),
								to: w.b - 1,
								rule: u,
								pasteEvent: s,
								dropEvent: l,
							}) || !S.steps.length
						)
					)
						return (
							(l = new DragEvent("drop")),
							(s = new ClipboardEvent("paste")),
							S
						);
				},
			})
	);
}
function wT(t) {
	const e = t.filter((n, r) => t.indexOf(n) !== r);
	return [...new Set(e)];
}
class ai {
	constructor(e, n) {
		(this.splittableMarks = []),
			(this.editor = n),
			(this.extensions = ai.resolve(e)),
			(this.schema = dT(this.extensions, n)),
			this.extensions.forEach((r) => {
				var o;
				this.editor.extensionStorage[r.name] = r.storage;
				const i = {
					name: r.name,
					options: r.options,
					storage: r.storage,
					editor: this.editor,
					type: Pc(r.name, this.schema),
				};
				r.type === "mark" &&
					(!(
						(o = Ie(de(r, "keepOnSplit", i))) !== null &&
						o !== void 0
					) ||
						o) &&
					this.splittableMarks.push(r.name);
				const s = de(r, "onBeforeCreate", i);
				s && this.editor.on("beforeCreate", s);
				const l = de(r, "onCreate", i);
				l && this.editor.on("create", l);
				const a = de(r, "onUpdate", i);
				a && this.editor.on("update", a);
				const u = de(r, "onSelectionUpdate", i);
				u && this.editor.on("selectionUpdate", u);
				const c = de(r, "onTransaction", i);
				c && this.editor.on("transaction", c);
				const d = de(r, "onFocus", i);
				d && this.editor.on("focus", d);
				const h = de(r, "onBlur", i);
				h && this.editor.on("blur", h);
				const p = de(r, "onDestroy", i);
				p && this.editor.on("destroy", p);
			});
	}
	static resolve(e) {
		const n = ai.sort(ai.flatten(e)),
			r = wT(n.map((o) => o.name));
		return (
			r.length &&
				console.warn(
					`[tiptap warn]: Duplicate extension names found: [${r
						.map((o) => `'${o}'`)
						.join(", ")}]. This can lead to issues.`
				),
			n
		);
	}
	static flatten(e) {
		return e
			.map((n) => {
				const r = {
						name: n.name,
						options: n.options,
						storage: n.storage,
					},
					o = de(n, "addExtensions", r);
				return o ? [n, ...this.flatten(o())] : n;
			})
			.flat(10);
	}
	static sort(e) {
		return e.sort((r, o) => {
			const i = de(r, "priority") || 100,
				s = de(o, "priority") || 100;
			return i > s ? -1 : i < s ? 1 : 0;
		});
	}
	get commands() {
		return this.extensions.reduce((e, n) => {
			const r = {
					name: n.name,
					options: n.options,
					storage: n.storage,
					editor: this.editor,
					type: Pc(n.name, this.schema),
				},
				o = de(n, "addCommands", r);
			return o ? z(z({}, e), o()) : e;
		}, {});
	}
	get plugins() {
		const { editor: e } = this,
			n = ai.sort([...this.extensions].reverse()),
			r = [],
			o = [],
			i = n
				.map((s) => {
					const l = {
							name: s.name,
							options: s.options,
							storage: s.storage,
							editor: e,
							type: Pc(s.name, this.schema),
						},
						a = [],
						u = de(s, "addKeyboardShortcuts", l);
					let c = {};
					if (
						(s.type === "mark" &&
							s.config.exitable &&
							(c.ArrowRight = () =>
								vn.handleExit({ editor: e, mark: s })),
						u)
					) {
						const y = Object.fromEntries(
							Object.entries(u()).map(([b, w]) => [
								b,
								() => w({ editor: e }),
							])
						);
						c = z(z({}, c), y);
					}
					const d = jE(c);
					a.push(d);
					const h = de(s, "addInputRules", l);
					gg(s, e.options.enableInputRules) && h && r.push(...h());
					const p = de(s, "addPasteRules", l);
					gg(s, e.options.enablePasteRules) && p && o.push(...p());
					const g = de(s, "addProseMirrorPlugins", l);
					if (g) {
						const y = g();
						a.push(...y);
					}
					return a;
				})
				.flat();
		return [
			pT({ editor: e, rules: r }),
			...bT({ editor: e, rules: o }),
			...i,
		];
	}
	get attributes() {
		return Qv(this.extensions);
	}
	get nodeViews() {
		const { editor: e } = this,
			{ nodeExtensions: n } = Hu(this.extensions);
		return Object.fromEntries(
			n
				.filter((r) => !!de(r, "addNodeView"))
				.map((r) => {
					const o = this.attributes.filter((a) => a.type === r.name),
						i = {
							name: r.name,
							options: r.options,
							storage: r.storage,
							editor: e,
							type: jt(r.name, this.schema),
						},
						s = de(r, "addNodeView", i);
					if (!s) return [];
					const l = (a, u, c, d) => {
						const h = zd(a, o);
						return s()({
							editor: e,
							node: a,
							getPos: c,
							decorations: d,
							HTMLAttributes: h,
							extension: r,
						});
					};
					return [r.name, l];
				})
		);
	}
}
function xT(t) {
	return Object.prototype.toString.call(t).slice(8, -1);
}
function Nc(t) {
	return xT(t) !== "Object"
		? !1
		: t.constructor === Object &&
				Object.getPrototypeOf(t) === Object.prototype;
}
function Fu(t, e) {
	const n = z({}, t);
	return (
		Nc(t) &&
			Nc(e) &&
			Object.keys(e).forEach((r) => {
				Nc(e[r])
					? r in t
						? (n[r] = Fu(t[r], e[r]))
						: Object.assign(n, { [r]: e[r] })
					: Object.assign(n, { [r]: e[r] });
			}),
		n
	);
}
class Ot {
	constructor(e = {}) {
		(this.type = "extension"),
			(this.name = "extension"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = z(z({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Ie(
					de(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Ie(
					de(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new Ot(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Fu(this.options, e)),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new Ot(e);
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Ie(de(n, "addOptions", { name: n.name }))),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
}
function Zv(t, e, n) {
	const { from: r, to: o } = e,
		{
			blockSeparator: i = `

`,
			textSerializers: s = {},
		} = n || {};
	let l = "",
		a = !0;
	return (
		t.nodesBetween(r, o, (u, c, d, h) => {
			var p;
			const g = s == null ? void 0 : s[u.type.name];
			g
				? (u.isBlock && !a && ((l += i), (a = !0)),
				  d &&
						(l += g({
							node: u,
							pos: c,
							parent: d,
							index: h,
							range: e,
						})))
				: u.isText
				? ((l +=
						(p = u == null ? void 0 : u.text) === null ||
						p === void 0
							? void 0
							: p.slice(Math.max(r, c) - c, o - c)),
				  (a = !1))
				: u.isBlock && !a && ((l += i), (a = !0));
		}),
		l
	);
}
function e2(t) {
	return Object.fromEntries(
		Object.entries(t.nodes)
			.filter(([, e]) => e.spec.toText)
			.map(([e, n]) => [e, n.spec.toText])
	);
}
const kT = Ot.create({
		name: "clipboardTextSerializer",
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("clipboardTextSerializer"),
					props: {
						clipboardTextSerializer: () => {
							const { editor: t } = this,
								{ state: e, schema: n } = t,
								{ doc: r, selection: o } = e,
								{ ranges: i } = o,
								s = Math.min(...i.map((c) => c.$from.pos)),
								l = Math.max(...i.map((c) => c.$to.pos)),
								a = e2(n);
							return Zv(
								r,
								{ from: s, to: l },
								{ textSerializers: a }
							);
						},
					},
				}),
			];
		},
	}),
	ST =
		() =>
		({ editor: t, view: e }) => (
			requestAnimationFrame(() => {
				var n;
				t.isDestroyed ||
					(e.dom.blur(),
					(n = window == null ? void 0 : window.getSelection()) ===
						null ||
						n === void 0 ||
						n.removeAllRanges());
			}),
			!0
		),
	_T =
		(t = !1) =>
		({ commands: e }) =>
			e.setContent("", t),
	CT =
		() =>
		({ state: t, tr: e, dispatch: n }) => {
			const { selection: r } = e,
				{ ranges: o } = r;
			return (
				n &&
					o.forEach(({ $from: i, $to: s }) => {
						t.doc.nodesBetween(i.pos, s.pos, (l, a) => {
							if (l.type.isText) return;
							const { doc: u, mapping: c } = e,
								d = u.resolve(c.map(a)),
								h = u.resolve(c.map(a + l.nodeSize)),
								p = d.blockRange(h);
							if (!p) return;
							const g = Li(p);
							if (l.type.isTextblock) {
								const { defaultType: y } =
									d.parent.contentMatchAt(d.index());
								e.setNodeMarkup(p.start, y);
							}
							(g || g === 0) && e.lift(p, g);
						});
					}),
				!0
			);
		},
	MT = (t) => (e) => t(e),
	ET =
		() =>
		({ state: t, dispatch: e }) =>
			GE(t, e),
	TT =
		(t, e) =>
		({ editor: n, tr: r }) => {
			const { state: o } = n,
				i = o.doc.slice(t.from, t.to);
			r.deleteRange(t.from, t.to);
			const s = r.mapping.map(e);
			return (
				r.insert(s, i.content),
				r.setSelection(new ke(r.doc.resolve(s - 1))),
				!0
			);
		},
	AT =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				r = n.$anchor.node();
			if (r.content.size > 0) return !1;
			const o = t.selection.$anchor;
			for (let i = o.depth; i > 0; i -= 1)
				if (o.node(i).type === r.type) {
					if (e) {
						const l = o.before(i),
							a = o.after(i);
						t.delete(l, a).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	OT =
		(t) =>
		({ tr: e, state: n, dispatch: r }) => {
			const o = jt(t, n.schema),
				i = e.selection.$anchor;
			for (let s = i.depth; s > 0; s -= 1)
				if (i.node(s).type === o) {
					if (r) {
						const a = i.before(s),
							u = i.after(s);
						e.delete(a, u).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	RT =
		(t) =>
		({ tr: e, dispatch: n }) => {
			const { from: r, to: o } = t;
			return n && e.delete(r, o), !0;
		},
	PT =
		() =>
		({ state: t, dispatch: e }) =>
			LE(t, e),
	IT =
		() =>
		({ commands: t }) =>
			t.keyboardShortcut("Enter"),
	NT =
		() =>
		({ state: t, dispatch: e }) =>
			JE(t, e);
function Ta(t, e, n = { strict: !0 }) {
	const r = Object.keys(e);
	return r.length
		? r.every((o) =>
				n.strict
					? e[o] === t[o]
					: vh(e[o])
					? e[o].test(t[o])
					: e[o] === t[o]
		  )
		: !0;
}
function Hd(t, e, n = {}) {
	return t.find((r) => r.type === e && Ta(r.attrs, n));
}
function DT(t, e, n = {}) {
	return !!Hd(t, e, n);
}
function bh(t, e, n = {}) {
	if (!t || !e) return;
	let r = t.parent.childAfter(t.parentOffset);
	if (
		(t.parentOffset === r.offset &&
			r.offset !== 0 &&
			(r = t.parent.childBefore(t.parentOffset)),
		!r.node)
	)
		return;
	const o = Hd([...r.node.marks], e, n);
	if (!o) return;
	let i = r.index,
		s = t.start() + r.offset,
		l = i + 1,
		a = s + r.node.nodeSize;
	for (
		Hd([...r.node.marks], e, n);
		i > 0 && o.isInSet(t.parent.child(i - 1).marks);

	)
		(i -= 1), (s -= t.parent.child(i).nodeSize);
	for (; l < t.parent.childCount && DT([...t.parent.child(l).marks], e, n); )
		(a += t.parent.child(l).nodeSize), (l += 1);
	return { from: s, to: a };
}
function po(t, e) {
	if (typeof t == "string") {
		if (!e.marks[t])
			throw Error(
				`There is no mark type named '${t}'. Maybe you forgot to add the extension?`
			);
		return e.marks[t];
	}
	return t;
}
const jT =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			const i = po(t, r.schema),
				{ doc: s, selection: l } = n,
				{ $from: a, from: u, to: c } = l;
			if (o) {
				const d = bh(a, i, e);
				if (d && d.from <= u && d.to >= c) {
					const h = ke.create(s, d.from, d.to);
					n.setSelection(h);
				}
			}
			return !0;
		},
	LT = (t) => (e) => {
		const n = typeof t == "function" ? t(e) : t;
		for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
		return !1;
	};
function wh(t) {
	return t instanceof ke;
}
function xr(t = 0, e = 0, n = 0) {
	return Math.min(Math.max(t, e), n);
}
function t2(t, e = null) {
	if (!e) return null;
	const n = _e.atStart(t),
		r = _e.atEnd(t);
	if (e === "start" || e === !0) return n;
	if (e === "end") return r;
	const o = n.from,
		i = r.to;
	return e === "all"
		? ke.create(t, xr(0, o, i), xr(t.content.size, o, i))
		: ke.create(t, xr(e, o, i), xr(e, o, i));
}
function xh() {
	return (
		[
			"iPad Simulator",
			"iPhone Simulator",
			"iPod Simulator",
			"iPad",
			"iPhone",
			"iPod",
		].includes(navigator.platform) ||
		(navigator.userAgent.includes("Mac") && "ontouchend" in document)
	);
}
const $T =
		(t = null, e = {}) =>
		({ editor: n, view: r, tr: o, dispatch: i }) => {
			e = z({ scrollIntoView: !0 }, e);
			const s = () => {
				xh() && r.dom.focus(),
					requestAnimationFrame(() => {
						n.isDestroyed ||
							(r.focus(),
							e != null &&
								e.scrollIntoView &&
								n.commands.scrollIntoView());
					});
			};
			if ((r.hasFocus() && t === null) || t === !1) return !0;
			if (i && t === null && !wh(n.state.selection)) return s(), !0;
			const l = t2(o.doc, t) || n.state.selection,
				a = n.state.selection.eq(l);
			return (
				i &&
					(a || o.setSelection(l),
					a && o.storedMarks && o.setStoredMarks(o.storedMarks),
					s()),
				!0
			);
		},
	BT = (t, e) => (n) => t.every((r, o) => e(r, ye(z({}, n), { index: o }))),
	zT =
		(t, e) =>
		({ tr: n, commands: r }) =>
			r.insertContentAt(
				{ from: n.selection.from, to: n.selection.to },
				t,
				e
			),
	Fd = (t) => {
		const e = t.childNodes;
		for (let n = e.length - 1; n >= 0; n -= 1) {
			const r = e[n];
			r.nodeType === 3 && r.nodeValue && !/\S/.test(r.nodeValue)
				? t.removeChild(r)
				: r.nodeType === 1 && Fd(r);
		}
		return t;
	};
function yg(t) {
	const e = `<body>${t}</body>`,
		n = new window.DOMParser().parseFromString(e, "text/html").body;
	return Fd(n), Fd(n);
}
function Aa(t, e, n) {
	if (
		((n = z({ slice: !0, parseOptions: {} }, n)),
		typeof t == "object" && t !== null)
	)
		try {
			return Array.isArray(t) && t.length > 0
				? J.fromArray(t.map((r) => e.nodeFromJSON(r)))
				: e.nodeFromJSON(t);
		} catch (r) {
			return (
				console.warn(
					"[tiptap warn]: Invalid content.",
					"Passed value:",
					t,
					"Error:",
					r
				),
				Aa("", e, n)
			);
		}
	if (typeof t == "string") {
		const r = Iu.fromSchema(e);
		return n.slice
			? r.parseSlice(yg(t), n.parseOptions).content
			: r.parse(yg(t), n.parseOptions);
	}
	return Aa("", e, n);
}
function HT(t, e, n) {
	const r = t.steps.length - 1;
	if (r < e) return;
	const o = t.steps[r];
	if (!(o instanceof $t || o instanceof It)) return;
	const i = t.mapping.maps[r];
	let s = 0;
	i.forEach((l, a, u, c) => {
		s === 0 && (s = c);
	}),
		t.setSelection(_e.near(t.doc.resolve(s), n));
}
const FT = (t) => t.toString().startsWith("<"),
	VT =
		(t, e, n) =>
		({ tr: r, dispatch: o, editor: i }) => {
			if (o) {
				n = z({ parseOptions: {}, updateSelection: !0 }, n);
				const s = Aa(e, i.schema, {
					parseOptions: z(
						{ preserveWhitespace: "full" },
						n.parseOptions
					),
				});
				if (s.toString() === "<>") return !0;
				let { from: l, to: a } =
						typeof t == "number"
							? { from: t, to: t }
							: { from: t.from, to: t.to },
					u = !0,
					c = !0;
				if (
					((FT(s) ? s : [s]).forEach((h) => {
						h.check(),
							(u = u ? h.isText && h.marks.length === 0 : !1),
							(c = c ? h.isBlock : !1);
					}),
					l === a && c)
				) {
					const { parent: h } = r.doc.resolve(l);
					h.isTextblock &&
						!h.type.spec.code &&
						!h.childCount &&
						((l -= 1), (a += 1));
				}
				u
					? Array.isArray(e)
						? r.insertText(
								e.map((h) => h.text || "").join(""),
								l,
								a
						  )
						: typeof e == "object" && e && e.text
						? r.insertText(e.text, l, a)
						: r.insertText(e, l, a)
					: r.replaceWith(l, a, s),
					n.updateSelection && HT(r, r.steps.length - 1, -1);
			}
			return !0;
		},
	WT =
		() =>
		({ state: t, dispatch: e }) =>
			WE(t, e),
	UT =
		() =>
		({ state: t, dispatch: e }) =>
			UE(t, e),
	KT =
		() =>
		({ state: t, dispatch: e }) =>
			BE(t, e),
	qT =
		() =>
		({ state: t, dispatch: e }) =>
			FE(t, e),
	JT =
		() =>
		({ tr: t, state: e, dispatch: n }) => {
			try {
				const r = Nu(e.doc, e.selection.$from.pos, -1);
				return r == null ? !1 : (t.join(r, 2), n && n(t), !0);
			} catch (r) {
				return !1;
			}
		},
	GT =
		() =>
		({ state: t, dispatch: e, tr: n }) => {
			try {
				const r = Nu(t.doc, t.selection.$from.pos, 1);
				return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
			} catch (r) {
				return !1;
			}
		};
function kh() {
	return typeof navigator != "undefined"
		? /Mac/.test(navigator.platform)
		: !1;
}
function YT(t) {
	const e = t.split(/-(?!$)/);
	let n = e[e.length - 1];
	n === "Space" && (n = " ");
	let r, o, i, s;
	for (let l = 0; l < e.length - 1; l += 1) {
		const a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) s = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) o = !0;
		else if (/^s(hift)?$/i.test(a)) i = !0;
		else if (/^mod$/i.test(a)) xh() || kh() ? (s = !0) : (o = !0);
		else throw new Error(`Unrecognized modifier name: ${a}`);
	}
	return (
		r && (n = `Alt-${n}`),
		o && (n = `Ctrl-${n}`),
		s && (n = `Meta-${n}`),
		i && (n = `Shift-${n}`),
		n
	);
}
const QT =
	(t) =>
	({ editor: e, view: n, tr: r, dispatch: o }) => {
		const i = YT(t).split(/-(?!$)/),
			s = i.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)),
			l = new KeyboardEvent("keydown", {
				key: s === "Space" ? " " : s,
				altKey: i.includes("Alt"),
				ctrlKey: i.includes("Ctrl"),
				metaKey: i.includes("Meta"),
				shiftKey: i.includes("Shift"),
				bubbles: !0,
				cancelable: !0,
			}),
			a = e.captureTransaction(() => {
				n.someProp("handleKeyDown", (u) => u(n, l));
			});
		return (
			a == null ||
				a.steps.forEach((u) => {
					const c = u.map(r.mapping);
					c && o && r.maybeStep(c);
				}),
			!0
		);
	};
function $s(t, e, n = {}) {
	const { from: r, to: o, empty: i } = t.selection,
		s = e ? jt(e, t.schema) : null,
		l = [];
	t.doc.nodesBetween(r, o, (d, h) => {
		if (d.isText) return;
		const p = Math.max(r, h),
			g = Math.min(o, h + d.nodeSize);
		l.push({ node: d, from: p, to: g });
	});
	const a = o - r,
		u = l
			.filter((d) => (s ? s.name === d.node.type.name : !0))
			.filter((d) => Ta(d.node.attrs, n, { strict: !1 }));
	return i ? !!u.length : u.reduce((d, h) => d + h.to - h.from, 0) >= a;
}
const XT =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = jt(t, n.schema);
			return $s(n, o, e) ? KE(n, r) : !1;
		},
	ZT =
		() =>
		({ state: t, dispatch: e }) =>
			YE(t, e),
	eA =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = jt(t, e.schema);
			return oT(r)(e, n);
		},
	tA =
		() =>
		({ state: t, dispatch: e }) =>
			qE(t, e);
function Vu(t, e) {
	return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function vg(t, e) {
	const n = typeof e == "string" ? [e] : e;
	return Object.keys(t).reduce(
		(r, o) => (n.includes(o) || (r[o] = t[o]), r),
		{}
	);
}
const nA =
		(t, e) =>
		({ tr: n, state: r, dispatch: o }) => {
			let i = null,
				s = null;
			const l = Vu(typeof t == "string" ? t : t.name, r.schema);
			return l
				? (l === "node" && (i = jt(t, r.schema)),
				  l === "mark" && (s = po(t, r.schema)),
				  o &&
						n.selection.ranges.forEach((a) => {
							r.doc.nodesBetween(
								a.$from.pos,
								a.$to.pos,
								(u, c) => {
									i &&
										i === u.type &&
										n.setNodeMarkup(
											c,
											void 0,
											vg(u.attrs, e)
										),
										s &&
											u.marks.length &&
											u.marks.forEach((d) => {
												s === d.type &&
													n.addMark(
														c,
														c + u.nodeSize,
														s.create(vg(d.attrs, e))
													);
											});
								}
							);
						}),
				  !0)
				: !1;
		},
	rA =
		() =>
		({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
	oA =
		() =>
		({ tr: t, commands: e }) =>
			e.setTextSelection({ from: 0, to: t.doc.content.size }),
	iA =
		() =>
		({ state: t, dispatch: e }) =>
			zE(t, e),
	sA =
		() =>
		({ state: t, dispatch: e }) =>
			VE(t, e),
	lA =
		() =>
		({ state: t, dispatch: e }) =>
			QE(t, e),
	aA =
		() =>
		({ state: t, dispatch: e }) =>
			eT(t, e),
	uA =
		() =>
		({ state: t, dispatch: e }) =>
			ZE(t, e);
function n2(t, e, n = {}) {
	return Aa(t, e, { slice: !1, parseOptions: n });
}
const cA =
	(t, e = !1, n = {}) =>
	({ tr: r, editor: o, dispatch: i }) => {
		const { doc: s } = r,
			l = n2(t, o.schema, n);
		return (
			i &&
				r
					.replaceWith(0, s.content.size, l)
					.setMeta("preventUpdate", !e),
			!0
		);
	};
function nl(t, e) {
	const n = po(e, t.schema),
		{ from: r, to: o, empty: i } = t.selection,
		s = [];
	i
		? (t.storedMarks && s.push(...t.storedMarks),
		  s.push(...t.selection.$head.marks()))
		: t.doc.nodesBetween(r, o, (a) => {
				s.push(...a.marks);
		  });
	const l = s.find((a) => a.type.name === n.name);
	return l ? z({}, l.attrs) : {};
}
function dA(t, e) {
	const n = new sh(t);
	return (
		e.forEach((r) => {
			r.steps.forEach((o) => {
				n.step(o);
			});
		}),
		n
	);
}
function fA(t) {
	for (let e = 0; e < t.edgeCount; e += 1) {
		const { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
function hA(t, e, n) {
	const r = [];
	return (
		t.nodesBetween(e.from, e.to, (o, i) => {
			n(o) && r.push({ node: o, pos: i });
		}),
		r
	);
}
function r2(t, e) {
	for (let n = t.depth; n > 0; n -= 1) {
		const r = t.node(n);
		if (e(r))
			return {
				pos: n > 0 ? t.before(n) : 0,
				start: t.start(n),
				depth: n,
				node: r,
			};
	}
}
function Sh(t) {
	return (e) => r2(e.$from, t);
}
function pA(t, e) {
	const n = tr.fromSchema(e).serializeFragment(t),
		o = document.implementation.createHTMLDocument().createElement("div");
	return o.appendChild(n), o.innerHTML;
}
function mA(t, e) {
	const n = { from: 0, to: t.content.size };
	return Zv(t, n, e);
}
function gA(t, e) {
	const n = jt(e, t.schema),
		{ from: r, to: o } = t.selection,
		i = [];
	t.doc.nodesBetween(r, o, (l) => {
		i.push(l);
	});
	const s = i.reverse().find((l) => l.type.name === n.name);
	return s ? z({}, s.attrs) : {};
}
function o2(t, e) {
	const n = Vu(typeof e == "string" ? e : e.name, t.schema);
	return n === "node" ? gA(t, e) : n === "mark" ? nl(t, e) : {};
}
function yA(t, e = JSON.stringify) {
	const n = {};
	return t.filter((r) => {
		const o = e(r);
		return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0);
	});
}
function vA(t) {
	const e = yA(t);
	return e.length === 1
		? e
		: e.filter(
				(n, r) =>
					!e
						.filter((i, s) => s !== r)
						.some(
							(i) =>
								n.oldRange.from >= i.oldRange.from &&
								n.oldRange.to <= i.oldRange.to &&
								n.newRange.from >= i.newRange.from &&
								n.newRange.to <= i.newRange.to
						)
		  );
}
function bA(t) {
	const { mapping: e, steps: n } = t,
		r = [];
	return (
		e.maps.forEach((o, i) => {
			const s = [];
			if (o.ranges.length)
				o.forEach((l, a) => {
					s.push({ from: l, to: a });
				});
			else {
				const { from: l, to: a } = n[i];
				if (l === void 0 || a === void 0) return;
				s.push({ from: l, to: a });
			}
			s.forEach(({ from: l, to: a }) => {
				const u = e.slice(i).map(l, -1),
					c = e.slice(i).map(a),
					d = e.invert().map(u, -1),
					h = e.invert().map(c);
				r.push({
					oldRange: { from: d, to: h },
					newRange: { from: u, to: c },
				});
			});
		}),
		vA(r)
	);
}
function _h(t, e, n) {
	const r = [];
	return (
		t === e
			? n
					.resolve(t)
					.marks()
					.forEach((o) => {
						const i = n.resolve(t - 1),
							s = bh(i, o.type);
						s && r.push(z({ mark: o }, s));
					})
			: n.nodesBetween(t, e, (o, i) => {
					!o ||
						o.nodeSize === void 0 ||
						r.push(
							...o.marks.map((s) => ({
								from: i,
								to: i + o.nodeSize,
								mark: s,
							}))
						);
			  }),
		r
	);
}
function Ul(t, e, n) {
	return Object.fromEntries(
		Object.entries(n).filter(([r]) => {
			const o = t.find((i) => i.type === e && i.name === r);
			return o ? o.attribute.keepOnSplit : !1;
		})
	);
}
function Vd(t, e, n = {}) {
	const { empty: r, ranges: o } = t.selection,
		i = e ? po(e, t.schema) : null;
	if (r)
		return !!(t.storedMarks || t.selection.$from.marks())
			.filter((d) => (i ? i.name === d.type.name : !0))
			.find((d) => Ta(d.attrs, n, { strict: !1 }));
	let s = 0;
	const l = [];
	if (
		(o.forEach(({ $from: d, $to: h }) => {
			const p = d.pos,
				g = h.pos;
			t.doc.nodesBetween(p, g, (y, b) => {
				if (!y.isText && !y.marks.length) return;
				const w = Math.max(p, b),
					S = Math.min(g, b + y.nodeSize),
					E = S - w;
				(s += E),
					l.push(
						...y.marks.map((f) => ({ mark: f, from: w, to: S }))
					);
			});
		}),
		s === 0)
	)
		return !1;
	const a = l
			.filter((d) => (i ? i.name === d.mark.type.name : !0))
			.filter((d) => Ta(d.mark.attrs, n, { strict: !1 }))
			.reduce((d, h) => d + h.to - h.from, 0),
		u = l
			.filter((d) =>
				i ? d.mark.type !== i && d.mark.type.excludes(i) : !0
			)
			.reduce((d, h) => d + h.to - h.from, 0);
	return (a > 0 ? a + u : a) >= s;
}
function wA(t, e, n = {}) {
	if (!e) return $s(t, null, n) || Vd(t, null, n);
	const r = Vu(e, t.schema);
	return r === "node" ? $s(t, e, n) : r === "mark" ? Vd(t, e, n) : !1;
}
function bg(t, e) {
	const { nodeExtensions: n } = Hu(e),
		r = n.find((s) => s.name === t);
	if (!r) return !1;
	const o = { name: r.name, options: r.options, storage: r.storage },
		i = Ie(de(r, "group", o));
	return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function xA(t) {
	var e;
	const n =
			(e = t.type.createAndFill()) === null || e === void 0
				? void 0
				: e.toJSON(),
		r = t.toJSON();
	return JSON.stringify(n) === JSON.stringify(r);
}
function kA(t) {
	return t instanceof ve;
}
function i2(t, e, n) {
	const o = t.state.doc.content.size,
		i = xr(e, 0, o),
		s = xr(n, 0, o),
		l = t.coordsAtPos(i),
		a = t.coordsAtPos(s, -1),
		u = Math.min(l.top, a.top),
		c = Math.max(l.bottom, a.bottom),
		d = Math.min(l.left, a.left),
		h = Math.max(l.right, a.right),
		p = h - d,
		g = c - u,
		w = {
			top: u,
			bottom: c,
			left: d,
			right: h,
			width: p,
			height: g,
			x: d,
			y: u,
		};
	return ye(z({}, w), { toJSON: () => w });
}
function SA(t, e, n) {
	var r;
	const { selection: o } = e;
	let i = null;
	if ((wh(o) && (i = o.$cursor), i)) {
		const l = (r = t.storedMarks) !== null && r !== void 0 ? r : i.marks();
		return !!n.isInSet(l) || !l.some((a) => a.type.excludes(n));
	}
	const { ranges: s } = o;
	return s.some(({ $from: l, $to: a }) => {
		let u =
			l.depth === 0
				? t.doc.inlineContent && t.doc.type.allowsMarkType(n)
				: !1;
		return (
			t.doc.nodesBetween(l.pos, a.pos, (c, d, h) => {
				if (u) return !1;
				if (c.isInline) {
					const p = !h || h.type.allowsMarkType(n),
						g =
							!!n.isInSet(c.marks) ||
							!c.marks.some((y) => y.type.excludes(n));
					u = p && g;
				}
				return !u;
			}),
			u
		);
	});
}
const _A =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			const { selection: i } = n,
				{ empty: s, ranges: l } = i,
				a = po(t, r.schema);
			if (o)
				if (s) {
					const u = nl(r, a);
					n.addStoredMark(a.create(z(z({}, u), e)));
				} else
					l.forEach((u) => {
						const c = u.$from.pos,
							d = u.$to.pos;
						r.doc.nodesBetween(c, d, (h, p) => {
							const g = Math.max(p, c),
								y = Math.min(p + h.nodeSize, d);
							h.marks.find((w) => w.type === a)
								? h.marks.forEach((w) => {
										a === w.type &&
											n.addMark(
												g,
												y,
												a.create(z(z({}, w.attrs), e))
											);
								  })
								: n.addMark(g, y, a.create(e));
						});
					});
			return SA(r, n, a);
		},
	CA =
		(t, e) =>
		({ tr: n }) => (n.setMeta(t, e), !0),
	MA =
		(t, e = {}) =>
		({ state: n, dispatch: r, chain: o }) => {
			const i = jt(t, n.schema);
			return i.isTextblock
				? o()
						.command(({ commands: s }) =>
							hg(i, e)(n) ? !0 : s.clearNodes()
						)
						.command(({ state: s }) => hg(i, e)(s, r))
						.run()
				: (console.warn(
						'[tiptap warn]: Currently "setNode()" only supports text block nodes.'
				  ),
				  !1);
		},
	EA =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					o = xr(t, 0, r.content.size),
					i = ve.create(r, o);
				e.setSelection(i);
			}
			return !0;
		},
	TA =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					{ from: o, to: i } =
						typeof t == "number" ? { from: t, to: t } : t,
					s = ke.atStart(r).from,
					l = ke.atEnd(r).to,
					a = xr(o, s, l),
					u = xr(i, s, l),
					c = ke.create(r, a, u);
				e.setSelection(c);
			}
			return !0;
		},
	AA =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = jt(t, e.schema);
			return lT(r)(e, n);
		};
function wg(t, e) {
	const n =
		t.storedMarks ||
		(t.selection.$to.parentOffset && t.selection.$from.marks());
	if (n) {
		const r = n.filter((o) =>
			e == null ? void 0 : e.includes(o.type.name)
		);
		t.tr.ensureMarks(r);
	}
}
const OA =
		({ keepMarks: t = !0 } = {}) =>
		({ tr: e, state: n, dispatch: r, editor: o }) => {
			const { selection: i, doc: s } = e,
				{ $from: l, $to: a } = i,
				u = o.extensionManager.attributes,
				c = Ul(u, l.node().type.name, l.node().attrs);
			if (i instanceof ve && i.node.isBlock)
				return !l.parentOffset || !pi(s, l.pos)
					? !1
					: (r &&
							(t && wg(n, o.extensionManager.splittableMarks),
							e.split(l.pos).scrollIntoView()),
					  !0);
			if (!l.parent.isBlock) return !1;
			if (r) {
				const d = a.parentOffset === a.parent.content.size;
				i instanceof ke && e.deleteSelection();
				const h =
					l.depth === 0
						? void 0
						: fA(l.node(-1).contentMatchAt(l.indexAfter(-1)));
				let p = d && h ? [{ type: h, attrs: c }] : void 0,
					g = pi(e.doc, e.mapping.map(l.pos), 1, p);
				if (
					(!p &&
						!g &&
						pi(
							e.doc,
							e.mapping.map(l.pos),
							1,
							h ? [{ type: h }] : void 0
						) &&
						((g = !0), (p = h ? [{ type: h, attrs: c }] : void 0)),
					g &&
						(e.split(e.mapping.map(l.pos), 1, p),
						h && !d && !l.parentOffset && l.parent.type !== h))
				) {
					const y = e.mapping.map(l.before()),
						b = e.doc.resolve(y);
					l.node(-1).canReplaceWith(b.index(), b.index() + 1, h) &&
						e.setNodeMarkup(e.mapping.map(l.before()), h);
				}
				t && wg(n, o.extensionManager.splittableMarks),
					e.scrollIntoView();
			}
			return !0;
		},
	RA =
		(t) =>
		({ tr: e, state: n, dispatch: r, editor: o }) => {
			var i;
			const s = jt(t, n.schema),
				{ $from: l, $to: a } = n.selection,
				u = n.selection.node;
			if ((u && u.isBlock) || l.depth < 2 || !l.sameParent(a)) return !1;
			const c = l.node(-1);
			if (c.type !== s) return !1;
			const d = o.extensionManager.attributes;
			if (
				l.parent.content.size === 0 &&
				l.node(-1).childCount === l.indexAfter(-1)
			) {
				if (
					l.depth === 2 ||
					l.node(-3).type !== s ||
					l.index(-2) !== l.node(-2).childCount - 1
				)
					return !1;
				if (r) {
					let b = J.empty;
					const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
					for (let x = l.depth - w; x >= l.depth - 3; x -= 1)
						b = J.from(l.node(x).copy(b));
					const S =
							l.indexAfter(-1) < l.node(-2).childCount
								? 1
								: l.indexAfter(-2) < l.node(-3).childCount
								? 2
								: 3,
						E = Ul(d, l.node().type.name, l.node().attrs),
						f =
							((i = s.contentMatch.defaultType) === null ||
							i === void 0
								? void 0
								: i.createAndFill(E)) || void 0;
					b = b.append(J.from(s.createAndFill(null, f) || void 0));
					const v = l.before(l.depth - (w - 1));
					e.replace(v, l.after(-S), new se(b, 4 - w, 0));
					let m = -1;
					e.doc.nodesBetween(v, e.doc.content.size, (x, k) => {
						if (m > -1) return !1;
						x.isTextblock && x.content.size === 0 && (m = k + 1);
					}),
						m > -1 && e.setSelection(ke.near(e.doc.resolve(m))),
						e.scrollIntoView();
				}
				return !0;
			}
			const h =
					a.pos === l.end() ? c.contentMatchAt(0).defaultType : null,
				p = Ul(d, c.type.name, c.attrs),
				g = Ul(d, l.node().type.name, l.node().attrs);
			e.delete(l.pos, a.pos);
			const y = h
				? [
						{ type: s, attrs: p },
						{ type: h, attrs: g },
				  ]
				: [{ type: s, attrs: p }];
			if (!pi(e.doc, l.pos, 2)) return !1;
			if (r) {
				const { selection: b, storedMarks: w } = n,
					{ splittableMarks: S } = o.extensionManager,
					E = w || (b.$to.parentOffset && b.$from.marks());
				if ((e.split(l.pos, 2, y).scrollIntoView(), !E || !r))
					return !0;
				const f = E.filter((v) => S.includes(v.type.name));
				e.ensureMarks(f);
			}
			return !0;
		},
	Dc = (t, e) => {
		const n = Sh((s) => s.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
		if (r === void 0) return !0;
		const o = t.doc.nodeAt(r);
		return (
			n.node.type === (o == null ? void 0 : o.type) &&
				fo(t.doc, n.pos) &&
				t.join(n.pos),
			!0
		);
	},
	jc = (t, e) => {
		const n = Sh((s) => s.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(n.start).after(n.depth);
		if (r === void 0) return !0;
		const o = t.doc.nodeAt(r);
		return (
			n.node.type === (o == null ? void 0 : o.type) &&
				fo(t.doc, r) &&
				t.join(r),
			!0
		);
	},
	PA =
		(t, e, n, r = {}) =>
		({
			editor: o,
			tr: i,
			state: s,
			dispatch: l,
			chain: a,
			commands: u,
			can: c,
		}) => {
			const { extensions: d, splittableMarks: h } = o.extensionManager,
				p = jt(t, s.schema),
				g = jt(e, s.schema),
				{ selection: y, storedMarks: b } = s,
				{ $from: w, $to: S } = y,
				E = w.blockRange(S),
				f = b || (y.$to.parentOffset && y.$from.marks());
			if (!E) return !1;
			const v = Sh((m) => bg(m.type.name, d))(y);
			if (E.depth >= 1 && v && E.depth - v.depth <= 1) {
				if (v.node.type === p) return u.liftListItem(g);
				if (
					bg(v.node.type.name, d) &&
					p.validContent(v.node.content) &&
					l
				)
					return a()
						.command(() => (i.setNodeMarkup(v.pos, p), !0))
						.command(() => Dc(i, p))
						.command(() => jc(i, p))
						.run();
			}
			return !n || !f || !l
				? a()
						.command(() =>
							c().wrapInList(p, r) ? !0 : u.clearNodes()
						)
						.wrapInList(p, r)
						.command(() => Dc(i, p))
						.command(() => jc(i, p))
						.run()
				: a()
						.command(() => {
							const m = c().wrapInList(p, r),
								x = f.filter((k) => h.includes(k.type.name));
							return i.ensureMarks(x), m ? !0 : u.clearNodes();
						})
						.wrapInList(p, r)
						.command(() => Dc(i, p))
						.command(() => jc(i, p))
						.run();
		},
	IA =
		(t, e = {}, n = {}) =>
		({ state: r, commands: o }) => {
			const { extendEmptyMarkRange: i = !1 } = n,
				s = po(t, r.schema);
			return Vd(r, s, e)
				? o.unsetMark(s, { extendEmptyMarkRange: i })
				: o.setMark(s, e);
		},
	NA =
		(t, e, n = {}) =>
		({ state: r, commands: o }) => {
			const i = jt(t, r.schema),
				s = jt(e, r.schema);
			return $s(r, i, n) ? o.setNode(s) : o.setNode(i, n);
		},
	DA =
		(t, e = {}) =>
		({ state: n, commands: r }) => {
			const o = jt(t, n.schema);
			return $s(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
		},
	jA =
		() =>
		({ state: t, dispatch: e }) => {
			const n = t.plugins;
			for (let r = 0; r < n.length; r += 1) {
				const o = n[r];
				let i;
				if (o.spec.isInputRules && (i = o.getState(t))) {
					if (e) {
						const s = t.tr,
							l = i.transform;
						for (let a = l.steps.length - 1; a >= 0; a -= 1)
							s.step(l.steps[a].invert(l.docs[a]));
						if (i.text) {
							const a = s.doc.resolve(i.from).marks();
							s.replaceWith(
								i.from,
								i.to,
								t.schema.text(i.text, a)
							);
						} else s.delete(i.from, i.to);
					}
					return !0;
				}
			}
			return !1;
		},
	LA =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				{ empty: r, ranges: o } = n;
			return (
				r ||
					(e &&
						o.forEach((i) => {
							t.removeMark(i.$from.pos, i.$to.pos);
						})),
				!0
			);
		},
	$A =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			var i;
			const { extendEmptyMarkRange: s = !1 } = e,
				{ selection: l } = n,
				a = po(t, r.schema),
				{ $from: u, empty: c, ranges: d } = l;
			if (!o) return !0;
			if (c && s) {
				let { from: h, to: p } = l;
				const g =
						(i = u.marks().find((b) => b.type === a)) === null ||
						i === void 0
							? void 0
							: i.attrs,
					y = bh(u, a, g);
				y && ((h = y.from), (p = y.to)), n.removeMark(h, p, a);
			} else
				d.forEach((h) => {
					n.removeMark(h.$from.pos, h.$to.pos, a);
				});
			return n.removeStoredMark(a), !0;
		},
	BA =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			let i = null,
				s = null;
			const l = Vu(typeof t == "string" ? t : t.name, r.schema);
			return l
				? (l === "node" && (i = jt(t, r.schema)),
				  l === "mark" && (s = po(t, r.schema)),
				  o &&
						n.selection.ranges.forEach((a) => {
							const u = a.$from.pos,
								c = a.$to.pos;
							r.doc.nodesBetween(u, c, (d, h) => {
								i &&
									i === d.type &&
									n.setNodeMarkup(
										h,
										void 0,
										z(z({}, d.attrs), e)
									),
									s &&
										d.marks.length &&
										d.marks.forEach((p) => {
											if (s === p.type) {
												const g = Math.max(h, u),
													y = Math.min(
														h + d.nodeSize,
														c
													);
												n.addMark(
													g,
													y,
													s.create(
														z(z({}, p.attrs), e)
													)
												);
											}
										});
							});
						}),
				  !0)
				: !1;
		},
	zA =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = jt(t, n.schema);
			return tT(o, e)(n, r);
		},
	HA =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = jt(t, n.schema);
			return nT(o, e)(n, r);
		};
var FA = Object.freeze({
	__proto__: null,
	blur: ST,
	clearContent: _T,
	clearNodes: CT,
	command: MT,
	createParagraphNear: ET,
	cut: TT,
	deleteCurrentNode: AT,
	deleteNode: OT,
	deleteRange: RT,
	deleteSelection: PT,
	enter: IT,
	exitCode: NT,
	extendMarkRange: jT,
	first: LT,
	focus: $T,
	forEach: BT,
	insertContent: zT,
	insertContentAt: VT,
	joinUp: WT,
	joinDown: UT,
	joinBackward: KT,
	joinForward: qT,
	joinItemBackward: JT,
	joinItemForward: GT,
	keyboardShortcut: QT,
	lift: XT,
	liftEmptyBlock: ZT,
	liftListItem: eA,
	newlineInCode: tA,
	resetAttributes: nA,
	scrollIntoView: rA,
	selectAll: oA,
	selectNodeBackward: iA,
	selectNodeForward: sA,
	selectParentNode: lA,
	selectTextblockEnd: aA,
	selectTextblockStart: uA,
	setContent: cA,
	setMark: _A,
	setMeta: CA,
	setNode: MA,
	setNodeSelection: EA,
	setTextSelection: TA,
	sinkListItem: AA,
	splitBlock: OA,
	splitListItem: RA,
	toggleList: PA,
	toggleMark: IA,
	toggleNode: NA,
	toggleWrap: DA,
	undoInputRule: jA,
	unsetAllMarks: LA,
	unsetMark: $A,
	updateAttributes: BA,
	wrapIn: zA,
	wrapInList: HA,
});
const VA = Ot.create({
		name: "commands",
		addCommands() {
			return z({}, FA);
		},
	}),
	WA = Ot.create({
		name: "editable",
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("editable"),
					props: { editable: () => this.editor.options.editable },
				}),
			];
		},
	}),
	UA = Ot.create({
		name: "focusEvents",
		addProseMirrorPlugins() {
			const { editor: t } = this;
			return [
				new wt({
					key: new Rt("focusEvents"),
					props: {
						handleDOMEvents: {
							focus: (e, n) => {
								t.isFocused = !0;
								const r = t.state.tr
									.setMeta("focus", { event: n })
									.setMeta("addToHistory", !1);
								return e.dispatch(r), !1;
							},
							blur: (e, n) => {
								t.isFocused = !1;
								const r = t.state.tr
									.setMeta("blur", { event: n })
									.setMeta("addToHistory", !1);
								return e.dispatch(r), !1;
							},
						},
					},
				}),
			];
		},
	}),
	KA = Ot.create({
		name: "keymap",
		addKeyboardShortcuts() {
			const t = () =>
					this.editor.commands.first(({ commands: s }) => [
						() => s.undoInputRule(),
						() =>
							s.command(({ tr: l }) => {
								const { selection: a, doc: u } = l,
									{ empty: c, $anchor: d } = a,
									{ pos: h, parent: p } = d,
									g = d.parent.isTextblock
										? l.doc.resolve(h - 1)
										: d,
									y = g.parent.type.spec.isolating,
									b = d.pos - d.parentOffset,
									w =
										y && g.parent.childCount === 1
											? b === d.pos
											: _e.atStart(u).from === h;
								return !c ||
									!w ||
									!p.type.isTextblock ||
									p.textContent.length
									? !1
									: s.clearNodes();
							}),
						() => s.deleteSelection(),
						() => s.joinBackward(),
						() => s.selectNodeBackward(),
					]),
				e = () =>
					this.editor.commands.first(({ commands: s }) => [
						() => s.deleteSelection(),
						() => s.deleteCurrentNode(),
						() => s.joinForward(),
						() => s.selectNodeForward(),
					]),
				r = {
					Enter: () =>
						this.editor.commands.first(({ commands: s }) => [
							() => s.newlineInCode(),
							() => s.createParagraphNear(),
							() => s.liftEmptyBlock(),
							() => s.splitBlock(),
						]),
					"Mod-Enter": () => this.editor.commands.exitCode(),
					Backspace: t,
					"Mod-Backspace": t,
					"Shift-Backspace": t,
					Delete: e,
					"Mod-Delete": e,
					"Mod-a": () => this.editor.commands.selectAll(),
				},
				o = z({}, r),
				i = ye(z({}, r), {
					"Ctrl-h": t,
					"Alt-Backspace": t,
					"Ctrl-d": e,
					"Ctrl-Alt-Backspace": e,
					"Alt-Delete": e,
					"Alt-d": e,
					"Ctrl-a": () => this.editor.commands.selectTextblockStart(),
					"Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
				});
			return xh() || kh() ? i : o;
		},
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("clearDocument"),
					appendTransaction: (t, e, n) => {
						if (!(t.some((g) => g.docChanged) && !e.doc.eq(n.doc)))
							return;
						const { empty: o, from: i, to: s } = e.selection,
							l = _e.atStart(e.doc).from,
							a = _e.atEnd(e.doc).to;
						if (
							o ||
							!(i === l && s === a) ||
							!(
								n.doc.textBetween(
									0,
									n.doc.content.size,
									" ",
									" "
								).length === 0
							)
						)
							return;
						const d = n.tr,
							h = Bu({ state: n, transaction: d }),
							{ commands: p } = new zu({
								editor: this.editor,
								state: h,
							});
						if ((p.clearNodes(), !!d.steps.length)) return d;
					},
				}),
			];
		},
	}),
	qA = Ot.create({
		name: "tabindex",
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("tabindex"),
					props: {
						attributes: this.editor.isEditable
							? { tabindex: "0" }
							: {},
					},
				}),
			];
		},
	});
var JA = Object.freeze({
	__proto__: null,
	ClipboardTextSerializer: kT,
	Commands: VA,
	Editable: WA,
	FocusEvents: UA,
	Keymap: KA,
	Tabindex: qA,
});
const GA = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function YA(t, e, n) {
	const r = document.querySelector(
		`style[data-tiptap-style${n ? `-${n}` : ""}]`
	);
	if (r !== null) return r;
	const o = document.createElement("style");
	return (
		e && o.setAttribute("nonce", e),
		o.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
		(o.innerHTML = t),
		document.getElementsByTagName("head")[0].appendChild(o),
		o
	);
}
let QA = class extends aT {
	constructor(e = {}) {
		super(),
			(this.isFocused = !1),
			(this.extensionStorage = {}),
			(this.options = {
				element: document.createElement("div"),
				content: "",
				injectCSS: !0,
				injectNonce: void 0,
				extensions: [],
				autofocus: !1,
				editable: !0,
				editorProps: {},
				parseOptions: {},
				enableInputRules: !0,
				enablePasteRules: !0,
				enableCoreExtensions: !0,
				onBeforeCreate: () => null,
				onCreate: () => null,
				onUpdate: () => null,
				onSelectionUpdate: () => null,
				onTransaction: () => null,
				onFocus: () => null,
				onBlur: () => null,
				onDestroy: () => null,
			}),
			(this.isCapturingTransaction = !1),
			(this.capturedTransaction = null),
			this.setOptions(e),
			this.createExtensionManager(),
			this.createCommandManager(),
			this.createSchema(),
			this.on("beforeCreate", this.options.onBeforeCreate),
			this.emit("beforeCreate", { editor: this }),
			this.createView(),
			this.injectCSS(),
			this.on("create", this.options.onCreate),
			this.on("update", this.options.onUpdate),
			this.on("selectionUpdate", this.options.onSelectionUpdate),
			this.on("transaction", this.options.onTransaction),
			this.on("focus", this.options.onFocus),
			this.on("blur", this.options.onBlur),
			this.on("destroy", this.options.onDestroy),
			window.setTimeout(() => {
				this.isDestroyed ||
					(this.commands.focus(this.options.autofocus),
					this.emit("create", { editor: this }));
			}, 0);
	}
	get storage() {
		return this.extensionStorage;
	}
	get commands() {
		return this.commandManager.commands;
	}
	chain() {
		return this.commandManager.chain();
	}
	can() {
		return this.commandManager.can();
	}
	injectCSS() {
		this.options.injectCSS &&
			document &&
			(this.css = YA(GA, this.options.injectNonce));
	}
	setOptions(e = {}) {
		(this.options = z(z({}, this.options), e)),
			!(!this.view || !this.state || this.isDestroyed) &&
				(this.options.editorProps &&
					this.view.setProps(this.options.editorProps),
				this.view.updateState(this.state));
	}
	setEditable(e, n = !0) {
		this.setOptions({ editable: e }),
			n &&
				this.emit("update", {
					editor: this,
					transaction: this.state.tr,
				});
	}
	get isEditable() {
		return this.options.editable && this.view && this.view.editable;
	}
	get state() {
		return this.view.state;
	}
	registerPlugin(e, n) {
		const r = Xv(n)
				? n(e, [...this.state.plugins])
				: [...this.state.plugins, e],
			o = this.state.reconfigure({ plugins: r });
		this.view.updateState(o);
	}
	unregisterPlugin(e) {
		if (this.isDestroyed) return;
		const n = typeof e == "string" ? `${e}$` : e.key,
			r = this.state.reconfigure({
				plugins: this.state.plugins.filter((o) => !o.key.startsWith(n)),
			});
		this.view.updateState(r);
	}
	createExtensionManager() {
		const n = [
			...(this.options.enableCoreExtensions ? Object.values(JA) : []),
			...this.options.extensions,
		].filter((r) =>
			["extension", "node", "mark"].includes(r == null ? void 0 : r.type)
		);
		this.extensionManager = new ai(n, this);
	}
	createCommandManager() {
		this.commandManager = new zu({ editor: this });
	}
	createSchema() {
		this.schema = this.extensionManager.schema;
	}
	createView() {
		const e = n2(
				this.options.content,
				this.schema,
				this.options.parseOptions
			),
			n = t2(e, this.options.autofocus);
		this.view = new EE(
			this.options.element,
			ye(z({}, this.options.editorProps), {
				dispatchTransaction: this.dispatchTransaction.bind(this),
				state: li.create({ doc: e, selection: n || void 0 }),
			})
		);
		const r = this.state.reconfigure({
			plugins: this.extensionManager.plugins,
		});
		this.view.updateState(r), this.createNodeViews(), this.prependClass();
		const o = this.view.dom;
		o.editor = this;
	}
	createNodeViews() {
		this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
	}
	prependClass() {
		this.view.dom.className = `tiptap ${this.view.dom.className}`;
	}
	captureTransaction(e) {
		(this.isCapturingTransaction = !0),
			e(),
			(this.isCapturingTransaction = !1);
		const n = this.capturedTransaction;
		return (this.capturedTransaction = null), n;
	}
	dispatchTransaction(e) {
		if (this.view.isDestroyed) return;
		if (this.isCapturingTransaction) {
			if (!this.capturedTransaction) {
				this.capturedTransaction = e;
				return;
			}
			e.steps.forEach((s) => {
				var l;
				return (l = this.capturedTransaction) === null || l === void 0
					? void 0
					: l.step(s);
			});
			return;
		}
		const n = this.state.apply(e),
			r = !this.state.selection.eq(n.selection);
		this.view.updateState(n),
			this.emit("transaction", { editor: this, transaction: e }),
			r && this.emit("selectionUpdate", { editor: this, transaction: e });
		const o = e.getMeta("focus"),
			i = e.getMeta("blur");
		o &&
			this.emit("focus", {
				editor: this,
				event: o.event,
				transaction: e,
			}),
			i &&
				this.emit("blur", {
					editor: this,
					event: i.event,
					transaction: e,
				}),
			!(!e.docChanged || e.getMeta("preventUpdate")) &&
				this.emit("update", { editor: this, transaction: e });
	}
	getAttributes(e) {
		return o2(this.state, e);
	}
	isActive(e, n) {
		const r = typeof e == "string" ? e : null,
			o = typeof e == "string" ? n : e;
		return wA(this.state, r, o);
	}
	getJSON() {
		return this.state.doc.toJSON();
	}
	getHTML() {
		return pA(this.state.doc.content, this.schema);
	}
	getText(e) {
		const {
			blockSeparator: n = `

`,
			textSerializers: r = {},
		} = e || {};
		return mA(this.state.doc, {
			blockSeparator: n,
			textSerializers: z(z({}, e2(this.schema)), r),
		});
	}
	get isEmpty() {
		return xA(this.state.doc);
	}
	getCharacterCount() {
		return (
			console.warn(
				'[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
			),
			this.state.doc.content.size - 2
		);
	}
	destroy() {
		this.emit("destroy"),
			this.view && this.view.destroy(),
			this.removeAllListeners();
	}
	get isDestroyed() {
		var e;
		return !(!((e = this.view) === null || e === void 0) && e.docView);
	}
};
function Fo(t) {
	return new tl({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = Ie(t.getAttributes, void 0, r);
			if (o === !1 || o === null) return null;
			const { tr: i } = e,
				s = r[r.length - 1],
				l = r[0];
			if (s) {
				const a = l.search(/\S/),
					u = n.from + l.indexOf(s),
					c = u + s.length;
				if (
					_h(n.from, n.to, e.doc)
						.filter((p) =>
							p.mark.type.excluded.find(
								(y) => y === t.type && y !== p.mark.type
							)
						)
						.filter((p) => p.to > u).length
				)
					return null;
				c < n.to && i.delete(c, n.to),
					u > n.from && i.delete(n.from + a, u);
				const h = n.from + a + s.length;
				i.addMark(n.from + a, h, t.type.create(o || {})),
					i.removeStoredMark(t.type);
			}
		},
	});
}
function s2(t) {
	return new tl({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = Ie(t.getAttributes, void 0, r) || {},
				{ tr: i } = e,
				s = n.from;
			let l = n.to;
			const a = t.type.create(o);
			if (r[1]) {
				const u = r[0].lastIndexOf(r[1]);
				let c = s + u;
				c > l ? (c = l) : (l = c + r[1].length);
				const d = r[0][r[0].length - 1];
				i.insertText(d, s + r[0].length - 1), i.replaceWith(c, l, a);
			} else
				r[0] &&
					i
						.insert(s - 1, t.type.create(o))
						.delete(i.mapping.map(s), i.mapping.map(l));
			i.scrollIntoView();
		},
	});
}
function Wd(t) {
	return new tl({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = e.doc.resolve(n.from),
				i = Ie(t.getAttributes, void 0, r) || {};
			if (
				!o
					.node(-1)
					.canReplaceWith(o.index(-1), o.indexAfter(-1), t.type)
			)
				return null;
			e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
		},
	});
}
function xt(t) {
	return new tl({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			let o = t.replace,
				i = n.from;
			const s = n.to;
			if (r[1]) {
				const l = r[0].lastIndexOf(r[1]);
				(o += r[0].slice(l + r[1].length)), (i += l);
				const a = i - s;
				a > 0 && ((o = r[0].slice(l - a, l) + o), (i = s));
			}
			e.tr.insertText(o, i, s);
		},
	});
}
function Bs(t) {
	return new tl({
		find: t.find,
		handler: ({ state: e, range: n, match: r, chain: o }) => {
			const i = Ie(t.getAttributes, void 0, r) || {},
				s = e.tr.delete(n.from, n.to),
				a = s.doc.resolve(n.from).blockRange(),
				u = a && oh(a, t.type, i);
			if (!u) return null;
			if ((s.wrap(a, u), t.keepMarks && t.editor)) {
				const { selection: d, storedMarks: h } = e,
					{ splittableMarks: p } = t.editor.extensionManager,
					g = h || (d.$to.parentOffset && d.$from.marks());
				if (g) {
					const y = g.filter((b) => p.includes(b.type.name));
					s.ensureMarks(y);
				}
			}
			if (t.keepAttributes) {
				const d =
					t.type.name === "bulletList" ||
					t.type.name === "orderedList"
						? "listItem"
						: "taskList";
				o().updateAttributes(d, i).run();
			}
			const c = s.doc.resolve(n.from - 1).nodeBefore;
			c &&
				c.type === t.type &&
				fo(s.doc, n.from - 1) &&
				(!t.joinPredicate || t.joinPredicate(r, c)) &&
				s.join(n.from - 1);
		},
	});
}
class vn {
	constructor(e = {}) {
		(this.type = "mark"),
			(this.name = "mark"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = z(z({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Ie(
					de(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Ie(
					de(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new vn(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Fu(this.options, e)),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new vn(e);
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Ie(de(n, "addOptions", { name: n.name }))),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	static handleExit({ editor: e, mark: n }) {
		const { tr: r } = e.state,
			o = e.state.selection.$from;
		if (o.pos === o.end()) {
			const s = o.marks();
			if (!!!s.find((u) => (u == null ? void 0 : u.type.name) === n.name))
				return !1;
			const a = s.find(
				(u) => (u == null ? void 0 : u.type.name) === n.name
			);
			return (
				a && r.removeStoredMark(a),
				r.insertText(" ", o.pos),
				e.view.dispatch(r),
				!0
			);
		}
		return !1;
	}
}
let Tt = class Ud {
	constructor(e = {}) {
		(this.type = "node"),
			(this.name = "node"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = z(z({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Ie(
					de(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Ie(
					de(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new Ud(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Fu(this.options, e)),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new Ud(e);
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Ie(de(n, "addOptions", { name: n.name }))),
			(n.storage = Ie(
				de(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
};
function so(t) {
	return new gT({
		find: t.find,
		handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
			const i = Ie(t.getAttributes, void 0, r, o);
			if (i === !1 || i === null) return null;
			const { tr: s } = e,
				l = r[r.length - 1],
				a = r[0];
			let u = n.to;
			if (l) {
				const c = a.search(/\S/),
					d = n.from + a.indexOf(l),
					h = d + l.length;
				if (
					_h(n.from, n.to, e.doc)
						.filter((g) =>
							g.mark.type.excluded.find(
								(b) => b === t.type && b !== g.mark.type
							)
						)
						.filter((g) => g.to > d).length
				)
					return null;
				h < n.to && s.delete(h, n.to),
					d > n.from && s.delete(n.from + c, d),
					(u = n.from + c + l.length),
					s.addMark(n.from + c, u, t.type.create(i || {})),
					s.removeStoredMark(t.type);
			}
		},
	});
}
function XA(t) {
	return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var ZA = "tippy-box",
	l2 = "tippy-content",
	e4 = "tippy-backdrop",
	a2 = "tippy-arrow",
	u2 = "tippy-svg-arrow",
	wo = { passive: !0, capture: !0 },
	c2 = function () {
		return document.body;
	};
function Lc(t, e, n) {
	if (Array.isArray(t)) {
		var r = t[e];
		return r == null ? (Array.isArray(n) ? n[e] : n) : r;
	}
	return t;
}
function Ch(t, e) {
	var n = {}.toString.call(t);
	return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function d2(t, e) {
	return typeof t == "function" ? t.apply(void 0, e) : t;
}
function xg(t, e) {
	if (e === 0) return t;
	var n;
	return function (r) {
		clearTimeout(n),
			(n = setTimeout(function () {
				t(r);
			}, e));
	};
}
function t4(t) {
	return t.split(/\s+/).filter(Boolean);
}
function ri(t) {
	return [].concat(t);
}
function kg(t, e) {
	t.indexOf(e) === -1 && t.push(e);
}
function n4(t) {
	return t.filter(function (e, n) {
		return t.indexOf(e) === n;
	});
}
function r4(t) {
	return t.split("-")[0];
}
function Oa(t) {
	return [].slice.call(t);
}
function Sg(t) {
	return Object.keys(t).reduce(function (e, n) {
		return t[n] !== void 0 && (e[n] = t[n]), e;
	}, {});
}
function ps() {
	return document.createElement("div");
}
function Wu(t) {
	return ["Element", "Fragment"].some(function (e) {
		return Ch(t, e);
	});
}
function o4(t) {
	return Ch(t, "NodeList");
}
function i4(t) {
	return Ch(t, "MouseEvent");
}
function s4(t) {
	return !!(t && t._tippy && t._tippy.reference === t);
}
function l4(t) {
	return Wu(t)
		? [t]
		: o4(t)
		? Oa(t)
		: Array.isArray(t)
		? t
		: Oa(document.querySelectorAll(t));
}
function $c(t, e) {
	t.forEach(function (n) {
		n && (n.style.transitionDuration = e + "ms");
	});
}
function _g(t, e) {
	t.forEach(function (n) {
		n && n.setAttribute("data-state", e);
	});
}
function a4(t) {
	var e,
		n = ri(t),
		r = n[0];
	return r != null && (e = r.ownerDocument) != null && e.body
		? r.ownerDocument
		: document;
}
function u4(t, e) {
	var n = e.clientX,
		r = e.clientY;
	return t.every(function (o) {
		var i = o.popperRect,
			s = o.popperState,
			l = o.props,
			a = l.interactiveBorder,
			u = r4(s.placement),
			c = s.modifiersData.offset;
		if (!c) return !0;
		var d = u === "bottom" ? c.top.y : 0,
			h = u === "top" ? c.bottom.y : 0,
			p = u === "right" ? c.left.x : 0,
			g = u === "left" ? c.right.x : 0,
			y = i.top - r + d > a,
			b = r - i.bottom - h > a,
			w = i.left - n + p > a,
			S = n - i.right - g > a;
		return y || b || w || S;
	});
}
function Bc(t, e, n) {
	var r = e + "EventListener";
	["transitionend", "webkitTransitionEnd"].forEach(function (o) {
		t[r](o, n);
	});
}
function Cg(t, e) {
	for (var n = e; n; ) {
		var r;
		if (t.contains(n)) return !0;
		n =
			n.getRootNode == null || (r = n.getRootNode()) == null
				? void 0
				: r.host;
	}
	return !1;
}
var Xn = { isTouch: !1 },
	Mg = 0;
function c4() {
	Xn.isTouch ||
		((Xn.isTouch = !0),
		window.performance && document.addEventListener("mousemove", f2));
}
function f2() {
	var t = performance.now();
	t - Mg < 20 &&
		((Xn.isTouch = !1), document.removeEventListener("mousemove", f2)),
		(Mg = t);
}
function d4() {
	var t = document.activeElement;
	if (s4(t)) {
		var e = t._tippy;
		t.blur && !e.state.isVisible && t.blur();
	}
}
function f4() {
	document.addEventListener("touchstart", c4, wo),
		window.addEventListener("blur", d4);
}
var h4 = typeof window != "undefined" && typeof document != "undefined",
	p4 = h4 ? !!window.msCrypto : !1,
	m4 = {
		animateFill: !1,
		followCursor: !1,
		inlinePositioning: !1,
		sticky: !1,
	},
	g4 = {
		allowHTML: !1,
		animation: "fade",
		arrow: !0,
		content: "",
		inertia: !1,
		maxWidth: 350,
		role: "tooltip",
		theme: "",
		zIndex: 9999,
	},
	Bn = Object.assign(
		{
			appendTo: c2,
			aria: { content: "auto", expanded: "auto" },
			delay: 0,
			duration: [300, 250],
			getReferenceClientRect: null,
			hideOnClick: !0,
			ignoreAttributes: !1,
			interactive: !1,
			interactiveBorder: 2,
			interactiveDebounce: 0,
			moveTransition: "",
			offset: [0, 10],
			onAfterUpdate: function () {},
			onBeforeUpdate: function () {},
			onCreate: function () {},
			onDestroy: function () {},
			onHidden: function () {},
			onHide: function () {},
			onMount: function () {},
			onShow: function () {},
			onShown: function () {},
			onTrigger: function () {},
			onUntrigger: function () {},
			onClickOutside: function () {},
			placement: "top",
			plugins: [],
			popperOptions: {},
			render: null,
			showOnCreate: !1,
			touch: !0,
			trigger: "mouseenter focus",
			triggerTarget: null,
		},
		m4,
		g4
	),
	y4 = Object.keys(Bn),
	v4 = function (e) {
		var n = Object.keys(e);
		n.forEach(function (r) {
			Bn[r] = e[r];
		});
	};
function h2(t) {
	var e = t.plugins || [],
		n = e.reduce(function (r, o) {
			var i = o.name,
				s = o.defaultValue;
			if (i) {
				var l;
				r[i] = t[i] !== void 0 ? t[i] : (l = Bn[i]) != null ? l : s;
			}
			return r;
		}, {});
	return Object.assign({}, t, n);
}
function b4(t, e) {
	var n = e ? Object.keys(h2(Object.assign({}, Bn, { plugins: e }))) : y4,
		r = n.reduce(function (o, i) {
			var s = (t.getAttribute("data-tippy-" + i) || "").trim();
			if (!s) return o;
			if (i === "content") o[i] = s;
			else
				try {
					o[i] = JSON.parse(s);
				} catch (l) {
					o[i] = s;
				}
			return o;
		}, {});
	return r;
}
function Eg(t, e) {
	var n = Object.assign(
		{},
		e,
		{ content: d2(e.content, [t]) },
		e.ignoreAttributes ? {} : b4(t, e.plugins)
	);
	return (
		(n.aria = Object.assign({}, Bn.aria, n.aria)),
		(n.aria = {
			expanded:
				n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
			content:
				n.aria.content === "auto"
					? e.interactive
						? null
						: "describedby"
					: n.aria.content,
		}),
		n
	);
}
var w4 = function () {
	return "innerHTML";
};
function Kd(t, e) {
	t[w4()] = e;
}
function Tg(t) {
	var e = ps();
	return (
		t === !0
			? (e.className = a2)
			: ((e.className = u2), Wu(t) ? e.appendChild(t) : Kd(e, t)),
		e
	);
}
function Ag(t, e) {
	Wu(e.content)
		? (Kd(t, ""), t.appendChild(e.content))
		: typeof e.content != "function" &&
		  (e.allowHTML ? Kd(t, e.content) : (t.textContent = e.content));
}
function qd(t) {
	var e = t.firstElementChild,
		n = Oa(e.children);
	return {
		box: e,
		content: n.find(function (r) {
			return r.classList.contains(l2);
		}),
		arrow: n.find(function (r) {
			return r.classList.contains(a2) || r.classList.contains(u2);
		}),
		backdrop: n.find(function (r) {
			return r.classList.contains(e4);
		}),
	};
}
function p2(t) {
	var e = ps(),
		n = ps();
	(n.className = ZA),
		n.setAttribute("data-state", "hidden"),
		n.setAttribute("tabindex", "-1");
	var r = ps();
	(r.className = l2),
		r.setAttribute("data-state", "hidden"),
		Ag(r, t.props),
		e.appendChild(n),
		n.appendChild(r),
		o(t.props, t.props);
	function o(i, s) {
		var l = qd(e),
			a = l.box,
			u = l.content,
			c = l.arrow;
		s.theme
			? a.setAttribute("data-theme", s.theme)
			: a.removeAttribute("data-theme"),
			typeof s.animation == "string"
				? a.setAttribute("data-animation", s.animation)
				: a.removeAttribute("data-animation"),
			s.inertia
				? a.setAttribute("data-inertia", "")
				: a.removeAttribute("data-inertia"),
			(a.style.maxWidth =
				typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth),
			s.role ? a.setAttribute("role", s.role) : a.removeAttribute("role"),
			(i.content !== s.content || i.allowHTML !== s.allowHTML) &&
				Ag(u, t.props),
			s.arrow
				? c
					? i.arrow !== s.arrow &&
					  (a.removeChild(c), a.appendChild(Tg(s.arrow)))
					: a.appendChild(Tg(s.arrow))
				: c && a.removeChild(c);
	}
	return { popper: e, onUpdate: o };
}
p2.$$tippy = !0;
var x4 = 1,
	Ml = [],
	zc = [];
function k4(t, e) {
	var n = Eg(t, Object.assign({}, Bn, h2(Sg(e)))),
		r,
		o,
		i,
		s = !1,
		l = !1,
		a = !1,
		u = !1,
		c,
		d,
		h,
		p = [],
		g = xg(O, n.interactiveDebounce),
		y,
		b = x4++,
		w = null,
		S = n4(n.plugins),
		E = {
			isEnabled: !0,
			isVisible: !1,
			isDestroyed: !1,
			isMounted: !1,
			isShown: !1,
		},
		f = {
			id: b,
			reference: t,
			popper: ps(),
			popperInstance: w,
			props: n,
			state: E,
			plugins: S,
			clearDelayTimeouts: Se,
			setProps: Pe,
			setContent: Ge,
			show: st,
			hide: St,
			hideWithInteractivity: hn,
			enable: ge,
			disable: me,
			unmount: Tr,
			destroy: rl,
		};
	if (!n.render) return f;
	var v = n.render(f),
		m = v.popper,
		x = v.onUpdate;
	m.setAttribute("data-tippy-root", ""),
		(m.id = "tippy-" + f.id),
		(f.popper = m),
		(t._tippy = f),
		(m._tippy = f);
	var k = S.map(function (F) {
			return F.fn(f);
		}),
		C = t.hasAttribute("aria-expanded");
	return (
		$e(),
		ie(),
		I(),
		$("onCreate", [f]),
		n.showOnCreate && G(),
		m.addEventListener("mouseenter", function () {
			f.props.interactive && f.state.isVisible && f.clearDelayTimeouts();
		}),
		m.addEventListener("mouseleave", function () {
			f.props.interactive &&
				f.props.trigger.indexOf("mouseenter") >= 0 &&
				N().addEventListener("mousemove", g);
		}),
		f
	);
	function _() {
		var F = f.props.touch;
		return Array.isArray(F) ? F : [F, 0];
	}
	function T() {
		return _()[0] === "hold";
	}
	function R() {
		var F;
		return !!((F = f.props.render) != null && F.$$tippy);
	}
	function P() {
		return y || t;
	}
	function N() {
		var F = P().parentNode;
		return F ? a4(F) : document;
	}
	function D() {
		return qd(m);
	}
	function M(F) {
		return (f.state.isMounted && !f.state.isVisible) ||
			Xn.isTouch ||
			(c && c.type === "focus")
			? 0
			: Lc(f.props.delay, F ? 0 : 1, Bn.delay);
	}
	function I(F) {
		F === void 0 && (F = !1),
			(m.style.pointerEvents = f.props.interactive && !F ? "" : "none"),
			(m.style.zIndex = "" + f.props.zIndex);
	}
	function $(F, fe, pe) {
		if (
			(pe === void 0 && (pe = !0),
			k.forEach(function (We) {
				We[F] && We[F].apply(We, fe);
			}),
			pe)
		) {
			var Be;
			(Be = f.props)[F].apply(Be, fe);
		}
	}
	function V() {
		var F = f.props.aria;
		if (F.content) {
			var fe = "aria-" + F.content,
				pe = m.id,
				Be = ri(f.props.triggerTarget || t);
			Be.forEach(function (We) {
				var Qt = We.getAttribute(fe);
				if (f.state.isVisible)
					We.setAttribute(fe, Qt ? Qt + " " + pe : pe);
				else {
					var bn = Qt && Qt.replace(pe, "").trim();
					bn ? We.setAttribute(fe, bn) : We.removeAttribute(fe);
				}
			});
		}
	}
	function ie() {
		if (!(C || !f.props.aria.expanded)) {
			var F = ri(f.props.triggerTarget || t);
			F.forEach(function (fe) {
				f.props.interactive
					? fe.setAttribute(
							"aria-expanded",
							f.state.isVisible && fe === P() ? "true" : "false"
					  )
					: fe.removeAttribute("aria-expanded");
			});
		}
	}
	function Y() {
		N().removeEventListener("mousemove", g),
			(Ml = Ml.filter(function (F) {
				return F !== g;
			}));
	}
	function he(F) {
		if (!(Xn.isTouch && (a || F.type === "mousedown"))) {
			var fe = (F.composedPath && F.composedPath()[0]) || F.target;
			if (!(f.props.interactive && Cg(m, fe))) {
				if (
					ri(f.props.triggerTarget || t).some(function (pe) {
						return Cg(pe, fe);
					})
				) {
					if (
						Xn.isTouch ||
						(f.state.isVisible &&
							f.props.trigger.indexOf("click") >= 0)
					)
						return;
				} else $("onClickOutside", [f, F]);
				f.props.hideOnClick === !0 &&
					(f.clearDelayTimeouts(),
					f.hide(),
					(l = !0),
					setTimeout(function () {
						l = !1;
					}),
					f.state.isMounted || Te());
			}
		}
	}
	function Le() {
		a = !0;
	}
	function Ce() {
		a = !1;
	}
	function Me() {
		var F = N();
		F.addEventListener("mousedown", he, !0),
			F.addEventListener("touchend", he, wo),
			F.addEventListener("touchstart", Ce, wo),
			F.addEventListener("touchmove", Le, wo);
	}
	function Te() {
		var F = N();
		F.removeEventListener("mousedown", he, !0),
			F.removeEventListener("touchend", he, wo),
			F.removeEventListener("touchstart", Ce, wo),
			F.removeEventListener("touchmove", Le, wo);
	}
	function B(F, fe) {
		ne(F, function () {
			!f.state.isVisible &&
				m.parentNode &&
				m.parentNode.contains(m) &&
				fe();
		});
	}
	function Z(F, fe) {
		ne(F, fe);
	}
	function ne(F, fe) {
		var pe = D().box;
		function Be(We) {
			We.target === pe && (Bc(pe, "remove", Be), fe());
		}
		if (F === 0) return fe();
		Bc(pe, "remove", d), Bc(pe, "add", Be), (d = Be);
	}
	function ce(F, fe, pe) {
		pe === void 0 && (pe = !1);
		var Be = ri(f.props.triggerTarget || t);
		Be.forEach(function (We) {
			We.addEventListener(F, fe, pe),
				p.push({ node: We, eventType: F, handler: fe, options: pe });
		});
	}
	function $e() {
		T() &&
			(ce("touchstart", A, { passive: !0 }),
			ce("touchend", L, { passive: !0 })),
			t4(f.props.trigger).forEach(function (F) {
				if (F !== "manual")
					switch ((ce(F, A), F)) {
						case "mouseenter":
							ce("mouseleave", L);
							break;
						case "focus":
							ce(p4 ? "focusout" : "blur", K);
							break;
						case "focusin":
							ce("focusout", K);
							break;
					}
			});
	}
	function Je() {
		p.forEach(function (F) {
			var fe = F.node,
				pe = F.eventType,
				Be = F.handler,
				We = F.options;
			fe.removeEventListener(pe, Be, We);
		}),
			(p = []);
	}
	function A(F) {
		var fe,
			pe = !1;
		if (!(!f.state.isEnabled || W(F) || l)) {
			var Be = ((fe = c) == null ? void 0 : fe.type) === "focus";
			(c = F),
				(y = F.currentTarget),
				ie(),
				!f.state.isVisible &&
					i4(F) &&
					Ml.forEach(function (We) {
						return We(F);
					}),
				F.type === "click" &&
				(f.props.trigger.indexOf("mouseenter") < 0 || s) &&
				f.props.hideOnClick !== !1 &&
				f.state.isVisible
					? (pe = !0)
					: G(F),
				F.type === "click" && (s = !pe),
				pe && !Be && ae(F);
		}
	}
	function O(F) {
		var fe = F.target,
			pe = P().contains(fe) || m.contains(fe);
		if (!(F.type === "mousemove" && pe)) {
			var Be = te()
				.concat(m)
				.map(function (We) {
					var Qt,
						bn = We._tippy,
						qo =
							(Qt = bn.popperInstance) == null
								? void 0
								: Qt.state;
					return qo
						? {
								popperRect: We.getBoundingClientRect(),
								popperState: qo,
								props: n,
						  }
						: null;
				})
				.filter(Boolean);
			u4(Be, F) && (Y(), ae(F));
		}
	}
	function L(F) {
		var fe = W(F) || (f.props.trigger.indexOf("click") >= 0 && s);
		if (!fe) {
			if (f.props.interactive) {
				f.hideWithInteractivity(F);
				return;
			}
			ae(F);
		}
	}
	function K(F) {
		(f.props.trigger.indexOf("focusin") < 0 && F.target !== P()) ||
			(f.props.interactive &&
				F.relatedTarget &&
				m.contains(F.relatedTarget)) ||
			ae(F);
	}
	function W(F) {
		return Xn.isTouch ? T() !== F.type.indexOf("touch") >= 0 : !1;
	}
	function ee() {
		le();
		var F = f.props,
			fe = F.popperOptions,
			pe = F.placement,
			Be = F.offset,
			We = F.getReferenceClientRect,
			Qt = F.moveTransition,
			bn = R() ? qd(m).arrow : null,
			qo = We
				? {
						getBoundingClientRect: We,
						contextElement: We.contextElement || P(),
				  }
				: t,
			Kh = {
				name: "$$tippy",
				enabled: !0,
				phase: "beforeWrite",
				requires: ["computeStyles"],
				fn: function (ol) {
					var Jo = ol.state;
					if (R()) {
						var tb = D(),
							Qu = tb.box;
						["placement", "reference-hidden", "escaped"].forEach(
							function (il) {
								il === "placement"
									? Qu.setAttribute(
											"data-placement",
											Jo.placement
									  )
									: Jo.attributes.popper["data-popper-" + il]
									? Qu.setAttribute("data-" + il, "")
									: Qu.removeAttribute("data-" + il);
							}
						),
							(Jo.attributes.popper = {});
					}
				},
			},
			mo = [
				{ name: "offset", options: { offset: Be } },
				{
					name: "preventOverflow",
					options: {
						padding: { top: 2, bottom: 2, left: 5, right: 5 },
					},
				},
				{ name: "flip", options: { padding: 5 } },
				{ name: "computeStyles", options: { adaptive: !Qt } },
				Kh,
			];
		R() &&
			bn &&
			mo.push({ name: "arrow", options: { element: bn, padding: 3 } }),
			mo.push.apply(mo, (fe == null ? void 0 : fe.modifiers) || []),
			(f.popperInstance = Oy(
				qo,
				m,
				Object.assign({}, fe, {
					placement: pe,
					onFirstUpdate: h,
					modifiers: mo,
				})
			));
	}
	function le() {
		f.popperInstance &&
			(f.popperInstance.destroy(), (f.popperInstance = null));
	}
	function Q() {
		var F = f.props.appendTo,
			fe,
			pe = P();
		(f.props.interactive && F === c2) || F === "parent"
			? (fe = pe.parentNode)
			: (fe = d2(F, [pe])),
			fe.contains(m) || fe.appendChild(m),
			(f.state.isMounted = !0),
			ee();
	}
	function te() {
		return Oa(m.querySelectorAll("[data-tippy-root]"));
	}
	function G(F) {
		f.clearDelayTimeouts(), F && $("onTrigger", [f, F]), Me();
		var fe = M(!0),
			pe = _(),
			Be = pe[0],
			We = pe[1];
		Xn.isTouch && Be === "hold" && We && (fe = We),
			fe
				? (r = setTimeout(function () {
						f.show();
				  }, fe))
				: f.show();
	}
	function ae(F) {
		if (
			(f.clearDelayTimeouts(),
			$("onUntrigger", [f, F]),
			!f.state.isVisible)
		) {
			Te();
			return;
		}
		if (
			!(
				f.props.trigger.indexOf("mouseenter") >= 0 &&
				f.props.trigger.indexOf("click") >= 0 &&
				["mouseleave", "mousemove"].indexOf(F.type) >= 0 &&
				s
			)
		) {
			var fe = M(!1);
			fe
				? (o = setTimeout(function () {
						f.state.isVisible && f.hide();
				  }, fe))
				: (i = requestAnimationFrame(function () {
						f.hide();
				  }));
		}
	}
	function ge() {
		f.state.isEnabled = !0;
	}
	function me() {
		f.hide(), (f.state.isEnabled = !1);
	}
	function Se() {
		clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
	}
	function Pe(F) {
		if (!f.state.isDestroyed) {
			$("onBeforeUpdate", [f, F]), Je();
			var fe = f.props,
				pe = Eg(
					t,
					Object.assign({}, fe, Sg(F), { ignoreAttributes: !0 })
				);
			(f.props = pe),
				$e(),
				fe.interactiveDebounce !== pe.interactiveDebounce &&
					(Y(), (g = xg(O, pe.interactiveDebounce))),
				fe.triggerTarget && !pe.triggerTarget
					? ri(fe.triggerTarget).forEach(function (Be) {
							Be.removeAttribute("aria-expanded");
					  })
					: pe.triggerTarget && t.removeAttribute("aria-expanded"),
				ie(),
				I(),
				x && x(fe, pe),
				f.popperInstance &&
					(ee(),
					te().forEach(function (Be) {
						requestAnimationFrame(
							Be._tippy.popperInstance.forceUpdate
						);
					})),
				$("onAfterUpdate", [f, F]);
		}
	}
	function Ge(F) {
		f.setProps({ content: F });
	}
	function st() {
		var F = f.state.isVisible,
			fe = f.state.isDestroyed,
			pe = !f.state.isEnabled,
			Be = Xn.isTouch && !f.props.touch,
			We = Lc(f.props.duration, 0, Bn.duration);
		if (
			!(F || fe || pe || Be) &&
			!P().hasAttribute("disabled") &&
			($("onShow", [f], !1), f.props.onShow(f) !== !1)
		) {
			if (
				((f.state.isVisible = !0),
				R() && (m.style.visibility = "visible"),
				I(),
				Me(),
				f.state.isMounted || (m.style.transition = "none"),
				R())
			) {
				var Qt = D(),
					bn = Qt.box,
					qo = Qt.content;
				$c([bn, qo], 0);
			}
			(h = function () {
				var mo;
				if (!(!f.state.isVisible || u)) {
					if (
						((u = !0),
						m.offsetHeight,
						(m.style.transition = f.props.moveTransition),
						R() && f.props.animation)
					) {
						var Yu = D(),
							ol = Yu.box,
							Jo = Yu.content;
						$c([ol, Jo], We), _g([ol, Jo], "visible");
					}
					V(),
						ie(),
						kg(zc, f),
						(mo = f.popperInstance) == null || mo.forceUpdate(),
						$("onMount", [f]),
						f.props.animation &&
							R() &&
							Z(We, function () {
								(f.state.isShown = !0), $("onShown", [f]);
							});
				}
			}),
				Q();
		}
	}
	function St() {
		var F = !f.state.isVisible,
			fe = f.state.isDestroyed,
			pe = !f.state.isEnabled,
			Be = Lc(f.props.duration, 1, Bn.duration);
		if (
			!(F || fe || pe) &&
			($("onHide", [f], !1), f.props.onHide(f) !== !1)
		) {
			if (
				((f.state.isVisible = !1),
				(f.state.isShown = !1),
				(u = !1),
				(s = !1),
				R() && (m.style.visibility = "hidden"),
				Y(),
				Te(),
				I(!0),
				R())
			) {
				var We = D(),
					Qt = We.box,
					bn = We.content;
				f.props.animation && ($c([Qt, bn], Be), _g([Qt, bn], "hidden"));
			}
			V(),
				ie(),
				f.props.animation ? R() && B(Be, f.unmount) : f.unmount();
		}
	}
	function hn(F) {
		N().addEventListener("mousemove", g), kg(Ml, g), g(F);
	}
	function Tr() {
		f.state.isVisible && f.hide(),
			f.state.isMounted &&
				(le(),
				te().forEach(function (F) {
					F._tippy.unmount();
				}),
				m.parentNode && m.parentNode.removeChild(m),
				(zc = zc.filter(function (F) {
					return F !== f;
				})),
				(f.state.isMounted = !1),
				$("onHidden", [f]));
	}
	function rl() {
		f.state.isDestroyed ||
			(f.clearDelayTimeouts(),
			f.unmount(),
			Je(),
			delete t._tippy,
			(f.state.isDestroyed = !0),
			$("onDestroy", [f]));
	}
}
function Ko(t, e) {
	e === void 0 && (e = {});
	var n = Bn.plugins.concat(e.plugins || []);
	f4();
	var r = Object.assign({}, e, { plugins: n }),
		o = l4(t),
		i = o.reduce(function (s, l) {
			var a = l && k4(l, r);
			return a && s.push(a), s;
		}, []);
	return Wu(t) ? i[0] : i;
}
Ko.defaultProps = Bn;
Ko.setDefaultProps = v4;
Ko.currentInput = Xn;
Object.assign({}, ky, {
	effect: function (e) {
		var n = e.state,
			r = {
				popper: {
					position: n.options.strategy,
					left: "0",
					top: "0",
					margin: "0",
				},
				arrow: { position: "absolute" },
				reference: {},
			};
		Object.assign(n.elements.popper.style, r.popper),
			(n.styles = r),
			n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
	},
});
Ko.setDefaultProps({ render: p2 });
class S4 {
	constructor({
		editor: e,
		element: n,
		view: r,
		tippyOptions: o = {},
		updateDelay: i = 250,
		shouldShow: s,
	}) {
		(this.preventHide = !1),
			(this.shouldShow = ({ view: l, state: a, from: u, to: c }) => {
				const { doc: d, selection: h } = a,
					{ empty: p } = h,
					g = !d.textBetween(u, c).length && wh(a.selection),
					y = this.element.contains(document.activeElement);
				return !(
					!(l.hasFocus() || y) ||
					p ||
					g ||
					!this.editor.isEditable
				);
			}),
			(this.mousedownHandler = () => {
				this.preventHide = !0;
			}),
			(this.dragstartHandler = () => {
				this.hide();
			}),
			(this.focusHandler = () => {
				setTimeout(() => this.update(this.editor.view));
			}),
			(this.blurHandler = ({ event: l }) => {
				var a;
				if (this.preventHide) {
					this.preventHide = !1;
					return;
				}
				(l != null &&
					l.relatedTarget &&
					!((a = this.element.parentNode) === null || a === void 0) &&
					a.contains(l.relatedTarget)) ||
					this.hide();
			}),
			(this.tippyBlurHandler = (l) => {
				this.blurHandler({ event: l });
			}),
			(this.handleDebouncedUpdate = (l, a) => {
				const u = !(a != null && a.selection.eq(l.state.selection)),
					c = !(a != null && a.doc.eq(l.state.doc));
				(!u && !c) ||
					(this.updateDebounceTimer &&
						clearTimeout(this.updateDebounceTimer),
					(this.updateDebounceTimer = window.setTimeout(() => {
						this.updateHandler(l, u, c, a);
					}, this.updateDelay)));
			}),
			(this.updateHandler = (l, a, u, c) => {
				var d, h, p;
				const { state: g, composing: y } = l,
					{ selection: b } = g;
				if (y || (!a && !u)) return;
				this.createTooltip();
				const { ranges: S } = b,
					E = Math.min(...S.map((m) => m.$from.pos)),
					f = Math.max(...S.map((m) => m.$to.pos));
				if (
					!((d = this.shouldShow) === null || d === void 0
						? void 0
						: d.call(this, {
								editor: this.editor,
								view: l,
								state: g,
								oldState: c,
								from: E,
								to: f,
						  }))
				) {
					this.hide();
					return;
				}
				(h = this.tippy) === null ||
					h === void 0 ||
					h.setProps({
						getReferenceClientRect:
							((p = this.tippyOptions) === null || p === void 0
								? void 0
								: p.getReferenceClientRect) ||
							(() => {
								if (kA(g.selection)) {
									let m = l.nodeDOM(E);
									const x = m.dataset.nodeViewWrapper
										? m
										: m.querySelector(
												"[data-node-view-wrapper]"
										  );
									if ((x && (m = x.firstChild), m))
										return m.getBoundingClientRect();
								}
								return i2(l, E, f);
							}),
					}),
					this.show();
			}),
			(this.editor = e),
			(this.element = n),
			(this.view = r),
			(this.updateDelay = i),
			s && (this.shouldShow = s),
			this.element.addEventListener("mousedown", this.mousedownHandler, {
				capture: !0,
			}),
			this.view.dom.addEventListener("dragstart", this.dragstartHandler),
			this.editor.on("focus", this.focusHandler),
			this.editor.on("blur", this.blurHandler),
			(this.tippyOptions = o),
			this.element.remove(),
			(this.element.style.visibility = "visible");
	}
	createTooltip() {
		const { element: e } = this.editor.options,
			n = !!e.parentElement;
		this.tippy ||
			!n ||
			((this.tippy = Ko(
				e,
				z(
					{
						duration: 0,
						getReferenceClientRect: null,
						content: this.element,
						interactive: !0,
						trigger: "manual",
						placement: "top",
						hideOnClick: "toggle",
					},
					this.tippyOptions
				)
			)),
			this.tippy.popper.firstChild &&
				this.tippy.popper.firstChild.addEventListener(
					"blur",
					this.tippyBlurHandler
				));
	}
	update(e, n) {
		const { state: r } = e,
			o = r.selection.$from.pos !== r.selection.$to.pos;
		if (this.updateDelay > 0 && o) {
			this.handleDebouncedUpdate(e, n);
			return;
		}
		const i = !(n != null && n.selection.eq(e.state.selection)),
			s = !(n != null && n.doc.eq(e.state.doc));
		this.updateHandler(e, i, s, n);
	}
	show() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.show();
	}
	hide() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.hide();
	}
	destroy() {
		var e, n;
		!((e = this.tippy) === null || e === void 0) &&
			e.popper.firstChild &&
			this.tippy.popper.firstChild.removeEventListener(
				"blur",
				this.tippyBlurHandler
			),
			(n = this.tippy) === null || n === void 0 || n.destroy(),
			this.element.removeEventListener(
				"mousedown",
				this.mousedownHandler,
				{ capture: !0 }
			),
			this.view.dom.removeEventListener(
				"dragstart",
				this.dragstartHandler
			),
			this.editor.off("focus", this.focusHandler),
			this.editor.off("blur", this.blurHandler);
	}
}
const m2 = (t) =>
	new wt({
		key: typeof t.pluginKey == "string" ? new Rt(t.pluginKey) : t.pluginKey,
		view: (e) => new S4(z({ view: e }, t)),
	});
Ot.create({
	name: "bubbleMenu",
	addOptions() {
		return {
			element: null,
			tippyOptions: {},
			pluginKey: "bubbleMenu",
			updateDelay: void 0,
			shouldShow: null,
		};
	},
	addProseMirrorPlugins() {
		return this.options.element
			? [
					m2({
						pluginKey: this.options.pluginKey,
						editor: this.editor,
						element: this.options.element,
						tippyOptions: this.options.tippyOptions,
						updateDelay: this.options.updateDelay,
						shouldShow: this.options.shouldShow,
					}),
			  ]
			: [];
	},
});
class _4 {
	constructor({
		editor: e,
		element: n,
		view: r,
		tippyOptions: o = {},
		shouldShow: i,
	}) {
		(this.preventHide = !1),
			(this.shouldShow = ({ view: s, state: l }) => {
				const { selection: a } = l,
					{ $anchor: u, empty: c } = a,
					d = u.depth === 1,
					h =
						u.parent.isTextblock &&
						!u.parent.type.spec.code &&
						!u.parent.textContent;
				return !(
					!s.hasFocus() ||
					!c ||
					!d ||
					!h ||
					!this.editor.isEditable
				);
			}),
			(this.mousedownHandler = () => {
				this.preventHide = !0;
			}),
			(this.focusHandler = () => {
				setTimeout(() => this.update(this.editor.view));
			}),
			(this.blurHandler = ({ event: s }) => {
				var l;
				if (this.preventHide) {
					this.preventHide = !1;
					return;
				}
				(s != null &&
					s.relatedTarget &&
					!((l = this.element.parentNode) === null || l === void 0) &&
					l.contains(s.relatedTarget)) ||
					this.hide();
			}),
			(this.tippyBlurHandler = (s) => {
				this.blurHandler({ event: s });
			}),
			(this.editor = e),
			(this.element = n),
			(this.view = r),
			i && (this.shouldShow = i),
			this.element.addEventListener("mousedown", this.mousedownHandler, {
				capture: !0,
			}),
			this.editor.on("focus", this.focusHandler),
			this.editor.on("blur", this.blurHandler),
			(this.tippyOptions = o),
			this.element.remove(),
			(this.element.style.visibility = "visible");
	}
	createTooltip() {
		const { element: e } = this.editor.options,
			n = !!e.parentElement;
		this.tippy ||
			!n ||
			((this.tippy = Ko(
				e,
				z(
					{
						duration: 0,
						getReferenceClientRect: null,
						content: this.element,
						interactive: !0,
						trigger: "manual",
						placement: "right",
						hideOnClick: "toggle",
					},
					this.tippyOptions
				)
			)),
			this.tippy.popper.firstChild &&
				this.tippy.popper.firstChild.addEventListener(
					"blur",
					this.tippyBlurHandler
				));
	}
	update(e, n) {
		var r, o, i;
		const { state: s } = e,
			{ doc: l, selection: a } = s,
			{ from: u, to: c } = a;
		if (n && n.doc.eq(l) && n.selection.eq(a)) return;
		if (
			(this.createTooltip(),
			!((r = this.shouldShow) === null || r === void 0
				? void 0
				: r.call(this, {
						editor: this.editor,
						view: e,
						state: s,
						oldState: n,
				  })))
		) {
			this.hide();
			return;
		}
		(o = this.tippy) === null ||
			o === void 0 ||
			o.setProps({
				getReferenceClientRect:
					((i = this.tippyOptions) === null || i === void 0
						? void 0
						: i.getReferenceClientRect) || (() => i2(e, u, c)),
			}),
			this.show();
	}
	show() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.show();
	}
	hide() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.hide();
	}
	destroy() {
		var e, n;
		!((e = this.tippy) === null || e === void 0) &&
			e.popper.firstChild &&
			this.tippy.popper.firstChild.removeEventListener(
				"blur",
				this.tippyBlurHandler
			),
			(n = this.tippy) === null || n === void 0 || n.destroy(),
			this.element.removeEventListener(
				"mousedown",
				this.mousedownHandler,
				{ capture: !0 }
			),
			this.editor.off("focus", this.focusHandler),
			this.editor.off("blur", this.blurHandler);
	}
}
const g2 = (t) =>
	new wt({
		key: typeof t.pluginKey == "string" ? new Rt(t.pluginKey) : t.pluginKey,
		view: (e) => new _4(z({ view: e }, t)),
	});
Ot.create({
	name: "floatingMenu",
	addOptions() {
		return {
			element: null,
			tippyOptions: {},
			pluginKey: "floatingMenu",
			shouldShow: null,
		};
	},
	addProseMirrorPlugins() {
		return this.options.element
			? [
					g2({
						pluginKey: this.options.pluginKey,
						editor: this.editor,
						element: this.options.element,
						tippyOptions: this.options.tippyOptions,
						shouldShow: this.options.shouldShow,
					}),
			  ]
			: [];
	},
});
const C4 = Re({
	name: "BubbleMenu",
	props: {
		pluginKey: { type: [String, Object], default: "bubbleMenu" },
		editor: { type: Object, required: !0 },
		updateDelay: { type: Number, default: void 0 },
		tippyOptions: { type: Object, default: () => ({}) },
		shouldShow: { type: Function, default: null },
	},
	setup(t, { slots: e }) {
		const n = X(null);
		return (
			Xe(() => {
				const {
					updateDelay: r,
					editor: o,
					pluginKey: i,
					shouldShow: s,
					tippyOptions: l,
				} = t;
				o.registerPlugin(
					m2({
						updateDelay: r,
						editor: o,
						element: n.value,
						pluginKey: i,
						shouldShow: s,
						tippyOptions: l,
					})
				);
			}),
			Us(() => {
				const { pluginKey: r, editor: o } = t;
				o.unregisterPlugin(r);
			}),
			() => {
				var r;
				return Ue(
					"div",
					{ ref: n },
					(r = e.default) === null || r === void 0
						? void 0
						: r.call(e)
				);
			}
		);
	},
});
function Og(t) {
	return W1((e, n) => ({
		get() {
			return e(), t;
		},
		set(r) {
			(t = r),
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						n();
					});
				});
		},
	}));
}
class M4 extends QA {
	constructor(e = {}) {
		return (
			super(e),
			(this.vueRenderers = Gt(new Map())),
			(this.contentComponent = null),
			(this.reactiveState = Og(this.view.state)),
			(this.reactiveExtensionStorage = Og(this.extensionStorage)),
			this.on("transaction", () => {
				(this.reactiveState.value = this.view.state),
					(this.reactiveExtensionStorage.value =
						this.extensionStorage);
			}),
			hu(this)
		);
	}
	get state() {
		return this.reactiveState ? this.reactiveState.value : this.view.state;
	}
	get storage() {
		return this.reactiveExtensionStorage
			? this.reactiveExtensionStorage.value
			: super.storage;
	}
	registerPlugin(e, n) {
		super.registerPlugin(e, n),
			(this.reactiveState.value = this.view.state);
	}
	unregisterPlugin(e) {
		super.unregisterPlugin(e), (this.reactiveState.value = this.view.state);
	}
}
const E4 = Re({
		name: "EditorContent",
		props: { editor: { default: null, type: Object } },
		setup(t) {
			const e = X(),
				n = uo();
			return (
				bt(() => {
					const r = t.editor;
					r &&
						r.options.element &&
						e.value &&
						zt(() => {
							if (!e.value || !r.options.element.firstChild)
								return;
							const o = ue(e.value);
							e.value.append(...r.options.element.childNodes),
								(r.contentComponent = n.ctx._),
								r.setOptions({ element: o }),
								r.createNodeViews();
						});
				}),
				Us(() => {
					const r = t.editor;
					if (
						!r ||
						(r.isDestroyed || r.view.setProps({ nodeViews: {} }),
						(r.contentComponent = null),
						!r.options.element.firstChild)
					)
						return;
					const o = document.createElement("div");
					o.append(...r.options.element.childNodes),
						r.setOptions({ element: o });
				}),
				{ rootEl: e }
			);
		},
		render() {
			const t = [];
			return (
				this.editor &&
					this.editor.vueRenderers.forEach((e) => {
						const n = Ue(
							bu,
							{ to: e.teleportElement, key: e.id },
							Ue(e.component, z({ ref: e.id }, e.props))
						);
						t.push(n);
					}),
				Ue(
					"div",
					{
						ref: (e) => {
							this.rootEl = e;
						},
					},
					...t
				)
			);
		},
	}),
	T4 = Re({
		name: "FloatingMenu",
		props: {
			pluginKey: { type: null, default: "floatingMenu" },
			editor: { type: Object, required: !0 },
			tippyOptions: { type: Object, default: () => ({}) },
			shouldShow: { type: Function, default: null },
		},
		setup(t, { slots: e }) {
			const n = X(null);
			return (
				Xe(() => {
					const {
						pluginKey: r,
						editor: o,
						tippyOptions: i,
						shouldShow: s,
					} = t;
					o.registerPlugin(
						g2({
							pluginKey: r,
							editor: o,
							element: n.value,
							tippyOptions: i,
							shouldShow: s,
						})
					);
				}),
				Us(() => {
					const { pluginKey: r, editor: o } = t;
					o.unregisterPlugin(r);
				}),
				() => {
					var r;
					return Ue(
						"div",
						{ ref: n },
						(r = e.default) === null || r === void 0
							? void 0
							: r.call(e)
					);
				}
			);
		},
	});
class A4 {
	constructor(e, { props: n = {}, editor: r }) {
		if (
			((this.id = Math.floor(Math.random() * 4294967295).toString()),
			(this.editor = r),
			(this.component = hu(e)),
			(this.teleportElement = document.createElement("div")),
			(this.element = this.teleportElement),
			(this.props = Gt(n)),
			this.editor.vueRenderers.set(this.id, this),
			this.editor.contentComponent)
		) {
			if (
				(this.editor.contentComponent.update(),
				this.teleportElement.children.length !== 1)
			)
				throw Error(
					"VueRenderer doesnt support multiple child elements."
				);
			this.element = this.teleportElement.firstElementChild;
		}
	}
	get ref() {
		var e;
		return (e = this.editor.contentComponent) === null || e === void 0
			? void 0
			: e.refs[this.id];
	}
	updateProps(e = {}) {
		Object.entries(e).forEach(([n, r]) => {
			this.props[n] = r;
		});
	}
	destroy() {
		this.editor.vueRenderers.delete(this.id);
	}
}
const O4 = /^\s*>\s$/,
	R4 = Tt.create({
		name: "blockquote",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		group: "block",
		defining: !0,
		parseHTML() {
			return [{ tag: "blockquote" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["blockquote", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBlockquote:
					() =>
					({ commands: t }) =>
						t.wrapIn(this.name),
				toggleBlockquote:
					() =>
					({ commands: t }) =>
						t.toggleWrap(this.name),
				unsetBlockquote:
					() =>
					({ commands: t }) =>
						t.lift(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-b": () => this.editor.commands.toggleBlockquote(),
			};
		},
		addInputRules() {
			return [Bs({ find: O4, type: this.type })];
		},
	}),
	P4 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,
	I4 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,
	N4 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,
	D4 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g,
	j4 = vn.create({
		name: "bold",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "strong" },
				{
					tag: "b",
					getAttrs: (t) => t.style.fontWeight !== "normal" && null,
				},
				{
					style: "font-weight",
					getAttrs: (t) =>
						/^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["strong", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBold:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleBold:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetBold:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-b": () => this.editor.commands.toggleBold(),
				"Mod-B": () => this.editor.commands.toggleBold(),
			};
		},
		addInputRules() {
			return [
				Fo({ find: P4, type: this.type }),
				Fo({ find: N4, type: this.type }),
			];
		},
		addPasteRules() {
			return [
				so({ find: I4, type: this.type }),
				so({ find: D4, type: this.type }),
			];
		},
	}),
	L4 = Tt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", Ze(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	Rg = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = nl(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	Pg = /^\s*([-+*])\s$/,
	$4 = Tt.create({
		name: "bulletList",
		addOptions() {
			return {
				itemTypeName: "listItem",
				HTMLAttributes: {},
				keepMarks: !1,
				keepAttributes: !1,
			};
		},
		group: "block list",
		content() {
			return `${this.options.itemTypeName}+`;
		},
		parseHTML() {
			return [{ tag: "ul" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["ul", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleBulletList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(
										this.name,
										this.options.itemTypeName,
										this.options.keepMarks
									)
									.updateAttributes(
										L4.name,
										this.editor.getAttributes(Rg.name)
									)
									.run()
							: t.toggleList(
									this.name,
									this.options.itemTypeName,
									this.options.keepMarks
							  ),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-8": () => this.editor.commands.toggleBulletList(),
			};
		},
		addInputRules() {
			let t = Bs({ find: Pg, type: this.type });
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Bs({
						find: Pg,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: () => this.editor.getAttributes(Rg.name),
						editor: this.editor,
					})),
				[t]
			);
		},
	}),
	B4 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/,
	z4 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g,
	H4 = vn.create({
		name: "code",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		excludes: "_",
		code: !0,
		exitable: !0,
		parseHTML() {
			return [{ tag: "code" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["code", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setCode:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleCode:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetCode:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return { "Mod-e": () => this.editor.commands.toggleCode() };
		},
		addInputRules() {
			return [Fo({ find: B4, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: z4, type: this.type })];
		},
	}),
	F4 = /^```([a-z]+)?[\s\n]$/,
	V4 = /^~~~([a-z]+)?[\s\n]$/,
	W4 = Tt.create({
		name: "codeBlock",
		addOptions() {
			return {
				languageClassPrefix: "language-",
				exitOnTripleEnter: !0,
				exitOnArrowDown: !0,
				HTMLAttributes: {},
			};
		},
		content: "text*",
		marks: "",
		group: "block",
		code: !0,
		defining: !0,
		addAttributes() {
			return {
				language: {
					default: null,
					parseHTML: (t) => {
						var e;
						const { languageClassPrefix: n } = this.options,
							i = [
								...(((e = t.firstElementChild) === null ||
								e === void 0
									? void 0
									: e.classList) || []),
							]
								.filter((s) => s.startsWith(n))
								.map((s) => s.replace(n, ""))[0];
						return i || null;
					},
					rendered: !1,
				},
			};
		},
		parseHTML() {
			return [{ tag: "pre", preserveWhitespace: "full" }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				"pre",
				Ze(this.options.HTMLAttributes, e),
				[
					"code",
					{
						class: t.attrs.language
							? this.options.languageClassPrefix +
							  t.attrs.language
							: null,
					},
					0,
				],
			];
		},
		addCommands() {
			return {
				setCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.setNode(this.name, t),
				toggleCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.toggleNode(this.name, "paragraph", t),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
				Backspace: () => {
					const { empty: t, $anchor: e } =
							this.editor.state.selection,
						n = e.pos === 1;
					return !t || e.parent.type.name !== this.name
						? !1
						: n || !e.parent.textContent.length
						? this.editor.commands.clearNodes()
						: !1;
				},
				Enter: ({ editor: t }) => {
					if (!this.options.exitOnTripleEnter) return !1;
					const { state: e } = t,
						{ selection: n } = e,
						{ $from: r, empty: o } = n;
					if (!o || r.parent.type !== this.type) return !1;
					const i = r.parentOffset === r.parent.nodeSize - 2,
						s = r.parent.textContent.endsWith(`

`);
					return !i || !s
						? !1
						: t
								.chain()
								.command(
									({ tr: l }) => (
										l.delete(r.pos - 2, r.pos), !0
									)
								)
								.exitCode()
								.run();
				},
				ArrowDown: ({ editor: t }) => {
					if (!this.options.exitOnArrowDown) return !1;
					const { state: e } = t,
						{ selection: n, doc: r } = e,
						{ $from: o, empty: i } = n;
					if (
						!i ||
						o.parent.type !== this.type ||
						!(o.parentOffset === o.parent.nodeSize - 2)
					)
						return !1;
					const l = o.after();
					return l === void 0 || r.nodeAt(l)
						? !1
						: t.commands.exitCode();
				},
			};
		},
		addInputRules() {
			return [
				Wd({
					find: F4,
					type: this.type,
					getAttributes: (t) => ({ language: t[1] }),
				}),
				Wd({
					find: V4,
					type: this.type,
					getAttributes: (t) => ({ language: t[1] }),
				}),
			];
		},
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("codeBlockVSCodeHandler"),
					props: {
						handlePaste: (t, e) => {
							if (
								!e.clipboardData ||
								this.editor.isActive(this.type.name)
							)
								return !1;
							const n = e.clipboardData.getData("text/plain"),
								r =
									e.clipboardData.getData(
										"vscode-editor-data"
									),
								o = r ? JSON.parse(r) : void 0,
								i = o == null ? void 0 : o.mode;
							if (!n || !i) return !1;
							const { tr: s } = t.state;
							return (
								s.replaceSelectionWith(
									this.type.create({ language: i })
								),
								s.setSelection(
									ke.near(
										s.doc.resolve(
											Math.max(0, s.selection.from - 2)
										)
									)
								),
								s.insertText(
									n.replace(
										/\r\n?/g,
										`
`
									)
								),
								s.setMeta("paste", !0),
								t.dispatch(s),
								!0
							);
						},
					},
				}),
			];
		},
	}),
	U4 = Tt.create({ name: "doc", topNode: !0, content: "block+" });
function K4(t = {}) {
	return new wt({
		view(e) {
			return new q4(e, t);
		},
	});
}
class q4 {
	constructor(e, n) {
		var r;
		(this.editorView = e),
			(this.cursorPos = null),
			(this.element = null),
			(this.timeout = -1),
			(this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
			(this.color = n.color === !1 ? void 0 : n.color || "black"),
			(this.class = n.class),
			(this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(
				(o) => {
					let i = (s) => {
						this[o](s);
					};
					return (
						e.dom.addEventListener(o, i), { name: o, handler: i }
					);
				}
			));
	}
	destroy() {
		this.handlers.forEach(({ name: e, handler: n }) =>
			this.editorView.dom.removeEventListener(e, n)
		);
	}
	update(e, n) {
		this.cursorPos != null &&
			n.doc != e.state.doc &&
			(this.cursorPos > e.state.doc.content.size
				? this.setCursor(null)
				: this.updateOverlay());
	}
	setCursor(e) {
		e != this.cursorPos &&
			((this.cursorPos = e),
			e == null
				? (this.element.parentNode.removeChild(this.element),
				  (this.element = null))
				: this.updateOverlay());
	}
	updateOverlay() {
		let e = this.editorView.state.doc.resolve(this.cursorPos),
			n = !e.parent.inlineContent,
			r;
		if (n) {
			let l = e.nodeBefore,
				a = e.nodeAfter;
			if (l || a) {
				let u = this.editorView.nodeDOM(
					this.cursorPos - (l ? l.nodeSize : 0)
				);
				if (u) {
					let c = u.getBoundingClientRect(),
						d = l ? c.bottom : c.top;
					l &&
						a &&
						(d =
							(d +
								this.editorView
									.nodeDOM(this.cursorPos)
									.getBoundingClientRect().top) /
							2),
						(r = {
							left: c.left,
							right: c.right,
							top: d - this.width / 2,
							bottom: d + this.width / 2,
						});
				}
			}
		}
		if (!r) {
			let l = this.editorView.coordsAtPos(this.cursorPos);
			r = {
				left: l.left - this.width / 2,
				right: l.left + this.width / 2,
				top: l.top,
				bottom: l.bottom,
			};
		}
		let o = this.editorView.dom.offsetParent;
		this.element ||
			((this.element = o.appendChild(document.createElement("div"))),
			this.class && (this.element.className = this.class),
			(this.element.style.cssText =
				"position: absolute; z-index: 50; pointer-events: none;"),
			this.color && (this.element.style.backgroundColor = this.color)),
			this.element.classList.toggle("prosemirror-dropcursor-block", n),
			this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
		let i, s;
		if (
			!o ||
			(o == document.body && getComputedStyle(o).position == "static")
		)
			(i = -pageXOffset), (s = -pageYOffset);
		else {
			let l = o.getBoundingClientRect();
			(i = l.left - o.scrollLeft), (s = l.top - o.scrollTop);
		}
		(this.element.style.left = r.left - i + "px"),
			(this.element.style.top = r.top - s + "px"),
			(this.element.style.width = r.right - r.left + "px"),
			(this.element.style.height = r.bottom - r.top + "px");
	}
	scheduleRemoval(e) {
		clearTimeout(this.timeout),
			(this.timeout = setTimeout(() => this.setCursor(null), e));
	}
	dragover(e) {
		if (!this.editorView.editable) return;
		let n = this.editorView.posAtCoords({
				left: e.clientX,
				top: e.clientY,
			}),
			r =
				n &&
				n.inside >= 0 &&
				this.editorView.state.doc.nodeAt(n.inside),
			o = r && r.type.spec.disableDropCursor,
			i = typeof o == "function" ? o(this.editorView, n, e) : o;
		if (n && !i) {
			let s = n.pos;
			if (this.editorView.dragging && this.editorView.dragging.slice) {
				let l = iv(
					this.editorView.state.doc,
					s,
					this.editorView.dragging.slice
				);
				l != null && (s = l);
			}
			this.setCursor(s), this.scheduleRemoval(5e3);
		}
	}
	dragend() {
		this.scheduleRemoval(20);
	}
	drop() {
		this.scheduleRemoval(20);
	}
	dragleave(e) {
		(e.target == this.editorView.dom ||
			!this.editorView.dom.contains(e.relatedTarget)) &&
			this.setCursor(null);
	}
}
const J4 = Ot.create({
	name: "dropCursor",
	addOptions() {
		return { color: "currentColor", width: 1, class: void 0 };
	},
	addProseMirrorPlugins() {
		return [K4(this.options)];
	},
});
class gt extends _e {
	constructor(e) {
		super(e, e);
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		return gt.valid(r) ? new gt(r) : _e.near(r);
	}
	content() {
		return se.empty;
	}
	eq(e) {
		return e instanceof gt && e.head == this.head;
	}
	toJSON() {
		return { type: "gapcursor", pos: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for GapCursor.fromJSON");
		return new gt(e.resolve(n.pos));
	}
	getBookmark() {
		return new Mh(this.anchor);
	}
	static valid(e) {
		let n = e.parent;
		if (n.isTextblock || !G4(e) || !Y4(e)) return !1;
		let r = n.type.spec.allowGapCursor;
		if (r != null) return r;
		let o = n.contentMatchAt(e.index()).defaultType;
		return o && o.isTextblock;
	}
	static findGapCursorFrom(e, n, r = !1) {
		e: for (;;) {
			if (!r && gt.valid(e)) return e;
			let o = e.pos,
				i = null;
			for (let s = e.depth; ; s--) {
				let l = e.node(s);
				if (n > 0 ? e.indexAfter(s) < l.childCount : e.index(s) > 0) {
					i = l.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
					break;
				} else if (s == 0) return null;
				o += n;
				let a = e.doc.resolve(o);
				if (gt.valid(a)) return a;
			}
			for (;;) {
				let s = n > 0 ? i.firstChild : i.lastChild;
				if (!s) {
					if (i.isAtom && !i.isText && !ve.isSelectable(i)) {
						(e = e.doc.resolve(o + i.nodeSize * n)), (r = !1);
						continue e;
					}
					break;
				}
				(i = s), (o += n);
				let l = e.doc.resolve(o);
				if (gt.valid(l)) return l;
			}
			return null;
		}
	}
}
gt.prototype.visible = !1;
gt.findFrom = gt.findGapCursorFrom;
_e.jsonID("gapcursor", gt);
class Mh {
	constructor(e) {
		this.pos = e;
	}
	map(e) {
		return new Mh(e.map(this.pos));
	}
	resolve(e) {
		let n = e.resolve(this.pos);
		return gt.valid(n) ? new gt(n) : _e.near(n);
	}
}
function G4(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.index(e),
			r = t.node(e);
		if (n == 0) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let o = r.child(n - 1); ; o = o.lastChild) {
			if (
				(o.childCount == 0 && !o.inlineContent) ||
				o.isAtom ||
				o.type.spec.isolating
			)
				return !0;
			if (o.inlineContent) return !1;
		}
	}
	return !0;
}
function Y4(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.indexAfter(e),
			r = t.node(e);
		if (n == r.childCount) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let o = r.child(n); ; o = o.firstChild) {
			if (
				(o.childCount == 0 && !o.inlineContent) ||
				o.isAtom ||
				o.type.spec.isolating
			)
				return !0;
			if (o.inlineContent) return !1;
		}
	}
	return !0;
}
function Q4() {
	return new wt({
		props: {
			decorations: tO,
			createSelectionBetween(t, e, n) {
				return e.pos == n.pos && gt.valid(n) ? new gt(n) : null;
			},
			handleClick: Z4,
			handleKeyDown: X4,
			handleDOMEvents: { beforeinput: eO },
		},
	});
}
const X4 = yh({
	ArrowLeft: El("horiz", -1),
	ArrowRight: El("horiz", 1),
	ArrowUp: El("vert", -1),
	ArrowDown: El("vert", 1),
});
function El(t, e) {
	const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
	return function (r, o, i) {
		let s = r.selection,
			l = e > 0 ? s.$to : s.$from,
			a = s.empty;
		if (s instanceof ke) {
			if (!i.endOfTextblock(n) || l.depth == 0) return !1;
			(a = !1), (l = r.doc.resolve(e > 0 ? l.after() : l.before()));
		}
		let u = gt.findGapCursorFrom(l, e, a);
		return u ? (o && o(r.tr.setSelection(new gt(u))), !0) : !1;
	};
}
function Z4(t, e, n) {
	if (!t || !t.editable) return !1;
	let r = t.state.doc.resolve(e);
	if (!gt.valid(r)) return !1;
	let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
	return o && o.inside > -1 && ve.isSelectable(t.state.doc.nodeAt(o.inside))
		? !1
		: (t.dispatch(t.state.tr.setSelection(new gt(r))), !0);
}
function eO(t, e) {
	if (
		e.inputType != "insertCompositionText" ||
		!(t.state.selection instanceof gt)
	)
		return !1;
	let { $from: n } = t.state.selection,
		r = n.parent
			.contentMatchAt(n.index())
			.findWrapping(t.state.schema.nodes.text);
	if (!r) return !1;
	let o = J.empty;
	for (let s = r.length - 1; s >= 0; s--)
		o = J.from(r[s].createAndFill(null, o));
	let i = t.state.tr.replace(n.pos, n.pos, new se(o, 0, 0));
	return i.setSelection(ke.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function tO(t) {
	if (!(t.selection instanceof gt)) return null;
	let e = document.createElement("div");
	return (
		(e.className = "ProseMirror-gapcursor"),
		ft.create(t.doc, [Kt.widget(t.selection.head, e, { key: "gapcursor" })])
	);
}
const nO = Ot.create({
		name: "gapCursor",
		addProseMirrorPlugins() {
			return [Q4()];
		},
		extendNodeSchema(t) {
			var e;
			const n = { name: t.name, options: t.options, storage: t.storage };
			return {
				allowGapCursor:
					(e = Ie(de(t, "allowGapCursor", n))) !== null &&
					e !== void 0
						? e
						: null,
			};
		},
	}),
	rO = Tt.create({
		name: "hardBreak",
		addOptions() {
			return { keepMarks: !0, HTMLAttributes: {} };
		},
		inline: !0,
		group: "inline",
		selectable: !1,
		parseHTML() {
			return [{ tag: "br" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["br", Ze(this.options.HTMLAttributes, t)];
		},
		renderText() {
			return `
`;
		},
		addCommands() {
			return {
				setHardBreak:
					() =>
					({ commands: t, chain: e, state: n, editor: r }) =>
						t.first([
							() => t.exitCode(),
							() =>
								t.command(() => {
									const { selection: o, storedMarks: i } = n;
									if (o.$from.parent.type.spec.isolating)
										return !1;
									const { keepMarks: s } = this.options,
										{ splittableMarks: l } =
											r.extensionManager,
										a =
											i ||
											(o.$to.parentOffset &&
												o.$from.marks());
									return e()
										.insertContent({ type: this.name })
										.command(({ tr: u, dispatch: c }) => {
											if (c && a && s) {
												const d = a.filter((h) =>
													l.includes(h.type.name)
												);
												u.ensureMarks(d);
											}
											return !0;
										})
										.run();
								}),
						]),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Enter": () => this.editor.commands.setHardBreak(),
				"Shift-Enter": () => this.editor.commands.setHardBreak(),
			};
		},
	}),
	oO = Tt.create({
		name: "heading",
		addOptions() {
			return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
		},
		content: "inline*",
		group: "block",
		defining: !0,
		addAttributes() {
			return { level: { default: 1, rendered: !1 } };
		},
		parseHTML() {
			return this.options.levels.map((t) => ({
				tag: `h${t}`,
				attrs: { level: t },
			}));
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				`h${
					this.options.levels.includes(t.attrs.level)
						? t.attrs.level
						: this.options.levels[0]
				}`,
				Ze(this.options.HTMLAttributes, e),
				0,
			];
		},
		addCommands() {
			return {
				setHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level)
							? e.setNode(this.name, t)
							: !1,
				toggleHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level)
							? e.toggleNode(this.name, "paragraph", t)
							: !1,
			};
		},
		addKeyboardShortcuts() {
			return this.options.levels.reduce(
				(t, e) =>
					ye(z({}, t), {
						[`Mod-Alt-${e}`]: () =>
							this.editor.commands.toggleHeading({ level: e }),
					}),
				{}
			);
		},
		addInputRules() {
			return this.options.levels.map((t) =>
				Wd({
					find: new RegExp(`^(#{1,${t}})\\s$`),
					type: this.type,
					getAttributes: { level: t },
				})
			);
		},
	});
var Ra = 200,
	Nt = function () {};
Nt.prototype.append = function (e) {
	return e.length
		? ((e = Nt.from(e)),
		  (!this.length && e) ||
				(e.length < Ra && this.leafAppend(e)) ||
				(this.length < Ra && e.leafPrepend(this)) ||
				this.appendInner(e))
		: this;
};
Nt.prototype.prepend = function (e) {
	return e.length ? Nt.from(e).append(this) : this;
};
Nt.prototype.appendInner = function (e) {
	return new iO(this, e);
};
Nt.prototype.slice = function (e, n) {
	return (
		e === void 0 && (e = 0),
		n === void 0 && (n = this.length),
		e >= n
			? Nt.empty
			: this.sliceInner(Math.max(0, e), Math.min(this.length, n))
	);
};
Nt.prototype.get = function (e) {
	if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
Nt.prototype.forEach = function (e, n, r) {
	n === void 0 && (n = 0),
		r === void 0 && (r = this.length),
		n <= r
			? this.forEachInner(e, n, r, 0)
			: this.forEachInvertedInner(e, n, r, 0);
};
Nt.prototype.map = function (e, n, r) {
	n === void 0 && (n = 0), r === void 0 && (r = this.length);
	var o = [];
	return (
		this.forEach(
			function (i, s) {
				return o.push(e(i, s));
			},
			n,
			r
		),
		o
	);
};
Nt.from = function (e) {
	return e instanceof Nt ? e : e && e.length ? new y2(e) : Nt.empty;
};
var y2 = (function (t) {
	function e(r) {
		t.call(this), (this.values = r);
	}
	t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e);
	var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
	return (
		(e.prototype.flatten = function () {
			return this.values;
		}),
		(e.prototype.sliceInner = function (o, i) {
			return o == 0 && i == this.length
				? this
				: new e(this.values.slice(o, i));
		}),
		(e.prototype.getInner = function (o) {
			return this.values[o];
		}),
		(e.prototype.forEachInner = function (o, i, s, l) {
			for (var a = i; a < s; a++)
				if (o(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.forEachInvertedInner = function (o, i, s, l) {
			for (var a = i - 1; a >= s; a--)
				if (o(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.leafAppend = function (o) {
			if (this.length + o.length <= Ra)
				return new e(this.values.concat(o.flatten()));
		}),
		(e.prototype.leafPrepend = function (o) {
			if (this.length + o.length <= Ra)
				return new e(o.flatten().concat(this.values));
		}),
		(n.length.get = function () {
			return this.values.length;
		}),
		(n.depth.get = function () {
			return 0;
		}),
		Object.defineProperties(e.prototype, n),
		e
	);
})(Nt);
Nt.empty = new y2([]);
var iO = (function (t) {
	function e(n, r) {
		t.call(this),
			(this.left = n),
			(this.right = r),
			(this.length = n.length + r.length),
			(this.depth = Math.max(n.depth, r.depth) + 1);
	}
	return (
		t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e),
		(e.prototype.flatten = function () {
			return this.left.flatten().concat(this.right.flatten());
		}),
		(e.prototype.getInner = function (r) {
			return r < this.left.length
				? this.left.get(r)
				: this.right.get(r - this.left.length);
		}),
		(e.prototype.forEachInner = function (r, o, i, s) {
			var l = this.left.length;
			if (
				(o < l &&
					this.left.forEachInner(r, o, Math.min(i, l), s) === !1) ||
				(i > l &&
					this.right.forEachInner(
						r,
						Math.max(o - l, 0),
						Math.min(this.length, i) - l,
						s + l
					) === !1)
			)
				return !1;
		}),
		(e.prototype.forEachInvertedInner = function (r, o, i, s) {
			var l = this.left.length;
			if (
				(o > l &&
					this.right.forEachInvertedInner(
						r,
						o - l,
						Math.max(i, l) - l,
						s + l
					) === !1) ||
				(i < l &&
					this.left.forEachInvertedInner(r, Math.min(o, l), i, s) ===
						!1)
			)
				return !1;
		}),
		(e.prototype.sliceInner = function (r, o) {
			if (r == 0 && o == this.length) return this;
			var i = this.left.length;
			return o <= i
				? this.left.slice(r, o)
				: r >= i
				? this.right.slice(r - i, o - i)
				: this.left.slice(r, i).append(this.right.slice(0, o - i));
		}),
		(e.prototype.leafAppend = function (r) {
			var o = this.right.leafAppend(r);
			if (o) return new e(this.left, o);
		}),
		(e.prototype.leafPrepend = function (r) {
			var o = this.left.leafPrepend(r);
			if (o) return new e(o, this.right);
		}),
		(e.prototype.appendInner = function (r) {
			return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
				? new e(this.left, new e(this.right, r))
				: new e(this, r);
		}),
		e
	);
})(Nt);
const sO = 500;
class jn {
	constructor(e, n) {
		(this.items = e), (this.eventCount = n);
	}
	popEvent(e, n) {
		if (this.eventCount == 0) return null;
		let r = this.items.length;
		for (; ; r--)
			if (this.items.get(r - 1).selection) {
				--r;
				break;
			}
		let o, i;
		n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length));
		let s = e.tr,
			l,
			a,
			u = [],
			c = [];
		return (
			this.items.forEach(
				(d, h) => {
					if (!d.step) {
						o ||
							((o = this.remapping(r, h + 1)),
							(i = o.maps.length)),
							i--,
							c.push(d);
						return;
					}
					if (o) {
						c.push(new qn(d.map));
						let p = d.step.map(o.slice(i)),
							g;
						p &&
							s.maybeStep(p).doc &&
							((g = s.mapping.maps[s.mapping.maps.length - 1]),
							u.push(
								new qn(g, void 0, void 0, u.length + c.length)
							)),
							i--,
							g && o.appendMap(g, i);
					} else s.maybeStep(d.step);
					if (d.selection)
						return (
							(l = o ? d.selection.map(o.slice(i)) : d.selection),
							(a = new jn(
								this.items
									.slice(0, r)
									.append(c.reverse().concat(u)),
								this.eventCount - 1
							)),
							!1
						);
				},
				this.items.length,
				0
			),
			{ remaining: a, transform: s, selection: l }
		);
	}
	addTransform(e, n, r, o) {
		let i = [],
			s = this.eventCount,
			l = this.items,
			a = !o && l.length ? l.get(l.length - 1) : null;
		for (let c = 0; c < e.steps.length; c++) {
			let d = e.steps[c].invert(e.docs[c]),
				h = new qn(e.mapping.maps[c], d, n),
				p;
			(p = a && a.merge(h)) &&
				((h = p), c ? i.pop() : (l = l.slice(0, l.length - 1))),
				i.push(h),
				n && (s++, (n = void 0)),
				o || (a = h);
		}
		let u = s - r.depth;
		return u > aO && ((l = lO(l, u)), (s -= u)), new jn(l.append(i), s);
	}
	remapping(e, n) {
		let r = new hi();
		return (
			this.items.forEach(
				(o, i) => {
					let s =
						o.mirrorOffset != null && i - o.mirrorOffset >= e
							? r.maps.length - o.mirrorOffset
							: void 0;
					r.appendMap(o.map, s);
				},
				e,
				n
			),
			r
		);
	}
	addMaps(e) {
		return this.eventCount == 0
			? this
			: new jn(
					this.items.append(e.map((n) => new qn(n))),
					this.eventCount
			  );
	}
	rebased(e, n) {
		if (!this.eventCount) return this;
		let r = [],
			o = Math.max(0, this.items.length - n),
			i = e.mapping,
			s = e.steps.length,
			l = this.eventCount;
		this.items.forEach((h) => {
			h.selection && l--;
		}, o);
		let a = n;
		this.items.forEach((h) => {
			let p = i.getMirror(--a);
			if (p == null) return;
			s = Math.min(s, p);
			let g = i.maps[p];
			if (h.step) {
				let y = e.steps[p].invert(e.docs[p]),
					b = h.selection && h.selection.map(i.slice(a + 1, p));
				b && l++, r.push(new qn(g, y, b));
			} else r.push(new qn(g));
		}, o);
		let u = [];
		for (let h = n; h < s; h++) u.push(new qn(i.maps[h]));
		let c = this.items.slice(0, o).append(u).append(r),
			d = new jn(c, l);
		return (
			d.emptyItemCount() > sO &&
				(d = d.compress(this.items.length - r.length)),
			d
		);
	}
	emptyItemCount() {
		let e = 0;
		return (
			this.items.forEach((n) => {
				n.step || e++;
			}),
			e
		);
	}
	compress(e = this.items.length) {
		let n = this.remapping(0, e),
			r = n.maps.length,
			o = [],
			i = 0;
		return (
			this.items.forEach(
				(s, l) => {
					if (l >= e) o.push(s), s.selection && i++;
					else if (s.step) {
						let a = s.step.map(n.slice(r)),
							u = a && a.getMap();
						if ((r--, u && n.appendMap(u, r), a)) {
							let c = s.selection && s.selection.map(n.slice(r));
							c && i++;
							let d = new qn(u.invert(), a, c),
								h,
								p = o.length - 1;
							(h = o.length && o[p].merge(d))
								? (o[p] = h)
								: o.push(d);
						}
					} else s.map && r--;
				},
				this.items.length,
				0
			),
			new jn(Nt.from(o.reverse()), i)
		);
	}
}
jn.empty = new jn(Nt.empty, 0);
function lO(t, e) {
	let n;
	return (
		t.forEach((r, o) => {
			if (r.selection && e-- == 0) return (n = o), !1;
		}),
		t.slice(n)
	);
}
class qn {
	constructor(e, n, r, o) {
		(this.map = e),
			(this.step = n),
			(this.selection = r),
			(this.mirrorOffset = o);
	}
	merge(e) {
		if (this.step && e.step && !e.selection) {
			let n = e.step.merge(this.step);
			if (n) return new qn(n.getMap().invert(), n, this.selection);
		}
	}
}
class Hr {
	constructor(e, n, r, o, i) {
		(this.done = e),
			(this.undone = n),
			(this.prevRanges = r),
			(this.prevTime = o),
			(this.prevComposition = i);
	}
}
const aO = 20;
function uO(t, e, n, r) {
	let o = n.getMeta(oo),
		i;
	if (o) return o.historyState;
	n.getMeta(dO) && (t = new Hr(t.done, t.undone, null, 0, -1));
	let s = n.getMeta("appendedTransaction");
	if (n.steps.length == 0) return t;
	if (s && s.getMeta(oo))
		return s.getMeta(oo).redo
			? new Hr(
					t.done.addTransform(n, void 0, r, Kl(e)),
					t.undone,
					Ig(n.mapping.maps[n.steps.length - 1]),
					t.prevTime,
					t.prevComposition
			  )
			: new Hr(
					t.done,
					t.undone.addTransform(n, void 0, r, Kl(e)),
					null,
					t.prevTime,
					t.prevComposition
			  );
	if (
		n.getMeta("addToHistory") !== !1 &&
		!(s && s.getMeta("addToHistory") === !1)
	) {
		let l = n.getMeta("composition"),
			a =
				t.prevTime == 0 ||
				(!s &&
					t.prevComposition != l &&
					(t.prevTime < (n.time || 0) - r.newGroupDelay ||
						!cO(n, t.prevRanges))),
			u = s
				? Hc(t.prevRanges, n.mapping)
				: Ig(n.mapping.maps[n.steps.length - 1]);
		return new Hr(
			t.done.addTransform(
				n,
				a ? e.selection.getBookmark() : void 0,
				r,
				Kl(e)
			),
			jn.empty,
			u,
			n.time,
			l == null ? t.prevComposition : l
		);
	} else
		return (i = n.getMeta("rebased"))
			? new Hr(
					t.done.rebased(n, i),
					t.undone.rebased(n, i),
					Hc(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
			  )
			: new Hr(
					t.done.addMaps(n.mapping.maps),
					t.undone.addMaps(n.mapping.maps),
					Hc(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
			  );
}
function cO(t, e) {
	if (!e) return !1;
	if (!t.docChanged) return !0;
	let n = !1;
	return (
		t.mapping.maps[0].forEach((r, o) => {
			for (let i = 0; i < e.length; i += 2)
				r <= e[i + 1] && o >= e[i] && (n = !0);
		}),
		n
	);
}
function Ig(t) {
	let e = [];
	return t.forEach((n, r, o, i) => e.push(o, i)), e;
}
function Hc(t, e) {
	if (!t) return null;
	let n = [];
	for (let r = 0; r < t.length; r += 2) {
		let o = e.map(t[r], 1),
			i = e.map(t[r + 1], -1);
		o <= i && n.push(o, i);
	}
	return n;
}
function v2(t, e, n, r) {
	let o = Kl(e),
		i = oo.get(e).spec.config,
		s = (r ? t.undone : t.done).popEvent(e, o);
	if (!s) return;
	let l = s.selection.resolve(s.transform.doc),
		a = (r ? t.done : t.undone).addTransform(
			s.transform,
			e.selection.getBookmark(),
			i,
			o
		),
		u = new Hr(r ? a : s.remaining, r ? s.remaining : a, null, 0, -1);
	n(
		s.transform
			.setSelection(l)
			.setMeta(oo, { redo: r, historyState: u })
			.scrollIntoView()
	);
}
let Fc = !1,
	Ng = null;
function Kl(t) {
	let e = t.plugins;
	if (Ng != e) {
		(Fc = !1), (Ng = e);
		for (let n = 0; n < e.length; n++)
			if (e[n].spec.historyPreserveItems) {
				Fc = !0;
				break;
			}
	}
	return Fc;
}
const oo = new Rt("history"),
	dO = new Rt("closeHistory");
function fO(t = {}) {
	return (
		(t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
		new wt({
			key: oo,
			state: {
				init() {
					return new Hr(jn.empty, jn.empty, null, 0, -1);
				},
				apply(e, n, r) {
					return uO(n, r, e, t);
				},
			},
			config: t,
			props: {
				handleDOMEvents: {
					beforeinput(e, n) {
						let r = n.inputType,
							o =
								r == "historyUndo"
									? b2
									: r == "historyRedo"
									? w2
									: null;
						return o
							? (n.preventDefault(), o(e.state, e.dispatch))
							: !1;
					},
				},
			},
		})
	);
}
const b2 = (t, e) => {
		let n = oo.getState(t);
		return !n || n.done.eventCount == 0 ? !1 : (e && v2(n, t, e, !1), !0);
	},
	w2 = (t, e) => {
		let n = oo.getState(t);
		return !n || n.undone.eventCount == 0 ? !1 : (e && v2(n, t, e, !0), !0);
	},
	hO = Ot.create({
		name: "history",
		addOptions() {
			return { depth: 100, newGroupDelay: 500 };
		},
		addCommands() {
			return {
				undo:
					() =>
					({ state: t, dispatch: e }) =>
						b2(t, e),
				redo:
					() =>
					({ state: t, dispatch: e }) =>
						w2(t, e),
			};
		},
		addProseMirrorPlugins() {
			return [fO(this.options)];
		},
		addKeyboardShortcuts() {
			return {
				"Mod-z": () => this.editor.commands.undo(),
				"Mod-Z": () => this.editor.commands.undo(),
				"Mod-y": () => this.editor.commands.redo(),
				"Mod-Y": () => this.editor.commands.redo(),
				"Shift-Mod-z": () => this.editor.commands.redo(),
				"Shift-Mod-Z": () => this.editor.commands.redo(),
				"Mod-": () => this.editor.commands.undo(),
				"Shift-Mod-": () => this.editor.commands.redo(),
			};
		},
	}),
	pO = Tt.create({
		name: "horizontalRule",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: "block",
		parseHTML() {
			return [{ tag: "hr" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["hr", Ze(this.options.HTMLAttributes, t)];
		},
		addCommands() {
			return {
				setHorizontalRule:
					() =>
					({ chain: t, state: e }) => {
						const { $to: n } = e.selection,
							r = t();
						return (
							n.parentOffset === 0
								? r.insertContentAt(Math.max(n.pos - 2, 0), {
										type: this.name,
								  })
								: r.insertContent({ type: this.name }),
							r
								.command(({ tr: o, dispatch: i }) => {
									var s;
									if (i) {
										const { $to: l } = o.selection,
											a = l.end();
										if (l.nodeAfter)
											l.nodeAfter.isTextblock
												? o.setSelection(
														ke.create(
															o.doc,
															l.pos + 1
														)
												  )
												: l.nodeAfter.isBlock
												? o.setSelection(
														ve.create(o.doc, l.pos)
												  )
												: o.setSelection(
														ke.create(o.doc, l.pos)
												  );
										else {
											const u =
												(s =
													l.parent.type.contentMatch
														.defaultType) ===
													null || s === void 0
													? void 0
													: s.create();
											u &&
												(o.insert(a, u),
												o.setSelection(
													ke.create(o.doc, a + 1)
												));
										}
										o.scrollIntoView();
									}
									return !0;
								})
								.run()
						);
					},
			};
		},
		addInputRules() {
			return [
				s2({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type }),
			];
		},
	}),
	mO = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,
	gO = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,
	yO = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,
	vO = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g,
	bO = vn.create({
		name: "italic",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "em" },
				{
					tag: "i",
					getAttrs: (t) => t.style.fontStyle !== "normal" && null,
				},
				{ style: "font-style=italic" },
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["em", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setItalic:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleItalic:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetItalic:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-i": () => this.editor.commands.toggleItalic(),
				"Mod-I": () => this.editor.commands.toggleItalic(),
			};
		},
		addInputRules() {
			return [
				Fo({ find: mO, type: this.type }),
				Fo({ find: yO, type: this.type }),
			];
		},
		addPasteRules() {
			return [
				so({ find: gO, type: this.type }),
				so({ find: vO, type: this.type }),
			];
		},
	}),
	wO = Tt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", Ze(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	xO = Tt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", Ze(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	Dg = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = nl(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	jg = /^(\d+)\.\s$/,
	kO = Tt.create({
		name: "orderedList",
		addOptions() {
			return {
				itemTypeName: "listItem",
				HTMLAttributes: {},
				keepMarks: !1,
				keepAttributes: !1,
			};
		},
		group: "block list",
		content() {
			return `${this.options.itemTypeName}+`;
		},
		addAttributes() {
			return {
				start: {
					default: 1,
					parseHTML: (t) =>
						t.hasAttribute("start")
							? parseInt(t.getAttribute("start") || "", 10)
							: 1,
				},
			};
		},
		parseHTML() {
			return [{ tag: "ol" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			const r = t,
				{ start: e } = r,
				n = et(r, ["start"]);
			return e === 1
				? ["ol", Ze(this.options.HTMLAttributes, n), 0]
				: ["ol", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleOrderedList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(
										this.name,
										this.options.itemTypeName,
										this.options.keepMarks
									)
									.updateAttributes(
										xO.name,
										this.editor.getAttributes(Dg.name)
									)
									.run()
							: t.toggleList(
									this.name,
									this.options.itemTypeName,
									this.options.keepMarks
							  ),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
			};
		},
		addInputRules() {
			let t = Bs({
				find: jg,
				type: this.type,
				getAttributes: (e) => ({ start: +e[1] }),
				joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
			});
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Bs({
						find: jg,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: (e) =>
							z(
								{ start: +e[1] },
								this.editor.getAttributes(Dg.name)
							),
						joinPredicate: (e, n) =>
							n.childCount + n.attrs.start === +e[1],
						editor: this.editor,
					})),
				[t]
			);
		},
	}),
	SO = Tt.create({
		name: "paragraph",
		priority: 1e3,
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: "block",
		content: "inline*",
		parseHTML() {
			return [{ tag: "p" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["p", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setParagraph:
					() =>
					({ commands: t }) =>
						t.setNode(this.name),
			};
		},
		addKeyboardShortcuts() {
			return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
		},
	}),
	_O = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,
	CO = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g,
	MO = vn.create({
		name: "strike",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "s" },
				{ tag: "del" },
				{ tag: "strike" },
				{
					style: "text-decoration",
					consuming: !1,
					getAttrs: (t) => (t.includes("line-through") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["s", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setStrike:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleStrike:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetStrike:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			const t = {};
			return (
				kh()
					? (t["Mod-Shift-s"] = () =>
							this.editor.commands.toggleStrike())
					: (t["Ctrl-Shift-s"] = () =>
							this.editor.commands.toggleStrike()),
				t
			);
		},
		addInputRules() {
			return [Fo({ find: _O, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: CO, type: this.type })];
		},
	}),
	EO = Tt.create({ name: "text", group: "inline" }),
	TO = Ot.create({
		name: "starterKit",
		addExtensions() {
			var t, e, n, r, o, i, s, l, a, u, c, d, h, p, g, y, b, w;
			const S = [];
			return (
				this.options.blockquote !== !1 &&
					S.push(
						R4.configure(
							(t = this.options) === null || t === void 0
								? void 0
								: t.blockquote
						)
					),
				this.options.bold !== !1 &&
					S.push(
						j4.configure(
							(e = this.options) === null || e === void 0
								? void 0
								: e.bold
						)
					),
				this.options.bulletList !== !1 &&
					S.push(
						$4.configure(
							(n = this.options) === null || n === void 0
								? void 0
								: n.bulletList
						)
					),
				this.options.code !== !1 &&
					S.push(
						H4.configure(
							(r = this.options) === null || r === void 0
								? void 0
								: r.code
						)
					),
				this.options.codeBlock !== !1 &&
					S.push(
						W4.configure(
							(o = this.options) === null || o === void 0
								? void 0
								: o.codeBlock
						)
					),
				this.options.document !== !1 &&
					S.push(
						U4.configure(
							(i = this.options) === null || i === void 0
								? void 0
								: i.document
						)
					),
				this.options.dropcursor !== !1 &&
					S.push(
						J4.configure(
							(s = this.options) === null || s === void 0
								? void 0
								: s.dropcursor
						)
					),
				this.options.gapcursor !== !1 &&
					S.push(
						nO.configure(
							(l = this.options) === null || l === void 0
								? void 0
								: l.gapcursor
						)
					),
				this.options.hardBreak !== !1 &&
					S.push(
						rO.configure(
							(a = this.options) === null || a === void 0
								? void 0
								: a.hardBreak
						)
					),
				this.options.heading !== !1 &&
					S.push(
						oO.configure(
							(u = this.options) === null || u === void 0
								? void 0
								: u.heading
						)
					),
				this.options.history !== !1 &&
					S.push(
						hO.configure(
							(c = this.options) === null || c === void 0
								? void 0
								: c.history
						)
					),
				this.options.horizontalRule !== !1 &&
					S.push(
						pO.configure(
							(d = this.options) === null || d === void 0
								? void 0
								: d.horizontalRule
						)
					),
				this.options.italic !== !1 &&
					S.push(
						bO.configure(
							(h = this.options) === null || h === void 0
								? void 0
								: h.italic
						)
					),
				this.options.listItem !== !1 &&
					S.push(
						wO.configure(
							(p = this.options) === null || p === void 0
								? void 0
								: p.listItem
						)
					),
				this.options.orderedList !== !1 &&
					S.push(
						kO.configure(
							(g = this.options) === null || g === void 0
								? void 0
								: g.orderedList
						)
					),
				this.options.paragraph !== !1 &&
					S.push(
						SO.configure(
							(y = this.options) === null || y === void 0
								? void 0
								: y.paragraph
						)
					),
				this.options.strike !== !1 &&
					S.push(
						MO.configure(
							(b = this.options) === null || b === void 0
								? void 0
								: b.strike
						)
					),
				this.options.text !== !1 &&
					S.push(
						EO.configure(
							(w = this.options) === null || w === void 0
								? void 0
								: w.text
						)
					),
				S
			);
		},
	}),
	AO = Ot.create({
		name: "placeholder",
		addOptions() {
			return {
				emptyEditorClass: "is-editor-empty",
				emptyNodeClass: "is-empty",
				placeholder: "Write something ",
				showOnlyWhenEditable: !0,
				showOnlyCurrent: !0,
				includeChildren: !1,
			};
		},
		addProseMirrorPlugins() {
			return [
				new wt({
					key: new Rt("placeholder"),
					props: {
						decorations: ({ doc: t, selection: e }) => {
							const n =
									this.editor.isEditable ||
									!this.options.showOnlyWhenEditable,
								{ anchor: r } = e,
								o = [];
							if (!n) return null;
							const i = t.type.createAndFill(),
								s =
									(i == null ? void 0 : i.sameMarkup(t)) &&
									i.content.findDiffStart(t.content) === null;
							return (
								t.descendants((l, a) => {
									const u = r >= a && r <= a + l.nodeSize,
										c = !l.isLeaf && !l.childCount;
									if (
										(u || !this.options.showOnlyCurrent) &&
										c
									) {
										const d = [this.options.emptyNodeClass];
										s &&
											d.push(
												this.options.emptyEditorClass
											);
										const h = Kt.node(a, a + l.nodeSize, {
											class: d.join(" "),
											"data-placeholder":
												typeof this.options
													.placeholder == "function"
													? this.options.placeholder({
															editor: this.editor,
															node: l,
															pos: a,
															hasAnchor: u,
													  })
													: this.options.placeholder,
										});
										o.push(h);
									}
									return this.options.includeChildren;
								}),
								ft.create(t, o)
							);
						},
					},
				}),
			];
		},
	}),
	OO = Ot.create({
		name: "textAlign",
		addOptions() {
			return {
				types: [],
				alignments: ["left", "center", "right", "justify"],
				defaultAlignment: "left",
			};
		},
		addGlobalAttributes() {
			return [
				{
					types: this.options.types,
					attributes: {
						textAlign: {
							default: this.options.defaultAlignment,
							parseHTML: (t) =>
								t.style.textAlign ||
								this.options.defaultAlignment,
							renderHTML: (t) =>
								t.textAlign === this.options.defaultAlignment
									? {}
									: { style: `text-align: ${t.textAlign}` },
						},
					},
				},
			];
		},
		addCommands() {
			return {
				setTextAlign:
					(t) =>
					({ commands: e }) =>
						this.options.alignments.includes(t)
							? this.options.types.every((n) =>
									e.updateAttributes(n, { textAlign: t })
							  )
							: !1,
				unsetTextAlign:
					() =>
					({ commands: t }) =>
						this.options.types.every((e) =>
							t.resetAttributes(e, "textAlign")
						),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
				"Mod-Shift-e": () =>
					this.editor.commands.setTextAlign("center"),
				"Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
				"Mod-Shift-j": () =>
					this.editor.commands.setTextAlign("justify"),
			};
		},
	});
var Jd, Gd;
if (typeof WeakMap != "undefined") {
	let t = new WeakMap();
	(Jd = (e) => t.get(e)), (Gd = (e, n) => (t.set(e, n), n));
} else {
	const t = [];
	let n = 0;
	(Jd = (r) => {
		for (let o = 0; o < t.length; o += 2) if (t[o] == r) return t[o + 1];
	}),
		(Gd = (r, o) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = o)));
}
var yt = class {
	constructor(t, e, n, r) {
		(this.width = t),
			(this.height = e),
			(this.map = n),
			(this.problems = r);
	}
	findCell(t) {
		for (let e = 0; e < this.map.length; e++) {
			const n = this.map[e];
			if (n != t) continue;
			const r = e % this.width,
				o = (e / this.width) | 0;
			let i = r + 1,
				s = o + 1;
			for (let l = 1; i < this.width && this.map[e + l] == n; l++) i++;
			for (
				let l = 1;
				s < this.height && this.map[e + this.width * l] == n;
				l++
			)
				s++;
			return { left: r, top: o, right: i, bottom: s };
		}
		throw new RangeError(`No cell with offset ${t} found`);
	}
	colCount(t) {
		for (let e = 0; e < this.map.length; e++)
			if (this.map[e] == t) return e % this.width;
		throw new RangeError(`No cell with offset ${t} found`);
	}
	nextCell(t, e, n) {
		const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
		return e == "horiz"
			? (n < 0 ? r == 0 : o == this.width)
				? null
				: this.map[i * this.width + (n < 0 ? r - 1 : o)]
			: (n < 0 ? i == 0 : s == this.height)
			? null
			: this.map[r + this.width * (n < 0 ? i - 1 : s)];
	}
	rectBetween(t, e) {
		const { left: n, right: r, top: o, bottom: i } = this.findCell(t),
			{ left: s, right: l, top: a, bottom: u } = this.findCell(e);
		return {
			left: Math.min(n, s),
			top: Math.min(o, a),
			right: Math.max(r, l),
			bottom: Math.max(i, u),
		};
	}
	cellsInRect(t) {
		const e = [],
			n = {};
		for (let r = t.top; r < t.bottom; r++)
			for (let o = t.left; o < t.right; o++) {
				const i = r * this.width + o,
					s = this.map[i];
				n[s] ||
					((n[s] = !0),
					!(
						(o == t.left && o && this.map[i - 1] == s) ||
						(r == t.top && r && this.map[i - this.width] == s)
					) && e.push(s));
			}
		return e;
	}
	positionAt(t, e, n) {
		for (let r = 0, o = 0; ; r++) {
			const i = o + n.child(r).nodeSize;
			if (r == t) {
				let s = e + t * this.width;
				const l = (t + 1) * this.width;
				for (; s < l && this.map[s] < o; ) s++;
				return s == l ? i - 1 : this.map[s];
			}
			o = i;
		}
	}
	static get(t) {
		return Jd(t) || Gd(t, RO(t));
	}
};
function RO(t) {
	if (t.type.spec.tableRole != "table")
		throw new RangeError("Not a table node: " + t.type.name);
	const e = PO(t),
		n = t.childCount,
		r = [];
	let o = 0,
		i = null;
	const s = [];
	for (let u = 0, c = e * n; u < c; u++) r[u] = 0;
	for (let u = 0, c = 0; u < n; u++) {
		const d = t.child(u);
		c++;
		for (let g = 0; ; g++) {
			for (; o < r.length && r[o] != 0; ) o++;
			if (g == d.childCount) break;
			const y = d.child(g),
				{ colspan: b, rowspan: w, colwidth: S } = y.attrs;
			for (let E = 0; E < w; E++) {
				if (E + u >= n) {
					(i || (i = [])).push({
						type: "overlong_rowspan",
						pos: c,
						n: w - E,
					});
					break;
				}
				const f = o + E * e;
				for (let v = 0; v < b; v++) {
					r[f + v] == 0
						? (r[f + v] = c)
						: (i || (i = [])).push({
								type: "collision",
								row: u,
								pos: c,
								n: b - v,
						  });
					const m = S && S[v];
					if (m) {
						const x = ((f + v) % e) * 2,
							k = s[x];
						k == null || (k != m && s[x + 1] == 1)
							? ((s[x] = m), (s[x + 1] = 1))
							: k == m && s[x + 1]++;
					}
				}
			}
			(o += b), (c += y.nodeSize);
		}
		const h = (u + 1) * e;
		let p = 0;
		for (; o < h; ) r[o++] == 0 && p++;
		p && (i || (i = [])).push({ type: "missing", row: u, n: p }), c++;
	}
	const l = new yt(e, n, r, i);
	let a = !1;
	for (let u = 0; !a && u < s.length; u += 2)
		s[u] != null && s[u + 1] < n && (a = !0);
	return a && IO(l, s, t), l;
}
function PO(t) {
	let e = -1,
		n = !1;
	for (let r = 0; r < t.childCount; r++) {
		const o = t.child(r);
		let i = 0;
		if (n)
			for (let s = 0; s < r; s++) {
				const l = t.child(s);
				for (let a = 0; a < l.childCount; a++) {
					const u = l.child(a);
					s + u.attrs.rowspan > r && (i += u.attrs.colspan);
				}
			}
		for (let s = 0; s < o.childCount; s++) {
			const l = o.child(s);
			(i += l.attrs.colspan), l.attrs.rowspan > 1 && (n = !0);
		}
		e == -1 ? (e = i) : e != i && (e = Math.max(e, i));
	}
	return e;
}
function IO(t, e, n) {
	t.problems || (t.problems = []);
	const r = {};
	for (let o = 0; o < t.map.length; o++) {
		const i = t.map[o];
		if (r[i]) continue;
		r[i] = !0;
		const s = n.nodeAt(i);
		if (!s) throw new RangeError(`No cell with offset ${i} found`);
		let l = null;
		const a = s.attrs;
		for (let u = 0; u < a.colspan; u++) {
			const c = (o + u) % t.width,
				d = e[c * 2];
			d != null &&
				(!a.colwidth || a.colwidth[u] != d) &&
				((l || (l = NO(a)))[u] = d);
		}
		l &&
			t.problems.unshift({
				type: "colwidth mismatch",
				pos: i,
				colwidth: l,
			});
	}
}
function NO(t) {
	if (t.colwidth) return t.colwidth.slice();
	const e = [];
	for (let n = 0; n < t.colspan; n++) e.push(0);
	return e;
}
function Jt(t) {
	let e = t.cached.tableNodeTypes;
	if (!e) {
		e = t.cached.tableNodeTypes = {};
		for (const n in t.nodes) {
			const r = t.nodes[n],
				o = r.spec.tableRole;
			o && (e[o] = r);
		}
	}
	return e;
}
var Ur = new Rt("selectingCells");
function $i(t) {
	for (let e = t.depth - 1; e > 0; e--)
		if (t.node(e).type.spec.tableRole == "row")
			return t.node(0).resolve(t.before(e + 1));
	return null;
}
function DO(t) {
	for (let e = t.depth; e > 0; e--) {
		const n = t.node(e).type.spec.tableRole;
		if (n === "cell" || n === "header_cell") return t.node(e);
	}
	return null;
}
function Un(t) {
	const e = t.selection.$head;
	for (let n = e.depth; n > 0; n--)
		if (e.node(n).type.spec.tableRole == "row") return !0;
	return !1;
}
function Uu(t) {
	const e = t.selection;
	if ("$anchorCell" in e && e.$anchorCell)
		return e.$anchorCell.pos > e.$headCell.pos
			? e.$anchorCell
			: e.$headCell;
	if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
		return e.$anchor;
	const n = $i(e.$head) || jO(e.$head);
	if (n) return n;
	throw new RangeError(`No cell found around position ${e.head}`);
}
function jO(t) {
	for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
	}
	for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell")
			return t.doc.resolve(n - e.nodeSize);
	}
}
function Yd(t) {
	return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function LO(t) {
	return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Eh(t, e) {
	return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function x2(t, e, n) {
	const r = t.node(-1),
		o = yt.get(r),
		i = t.start(-1),
		s = o.nextCell(t.pos - i, e, n);
	return s == null ? null : t.node(0).resolve(i + s);
}
function Vo(t, e, n = 1) {
	const r = ye(z({}, t), { colspan: t.colspan - n });
	return (
		r.colwidth &&
			((r.colwidth = r.colwidth.slice()),
			r.colwidth.splice(e, n),
			r.colwidth.some((o) => o > 0) || (r.colwidth = null)),
		r
	);
}
function k2(t, e, n = 1) {
	const r = ye(z({}, t), { colspan: t.colspan + n });
	if (r.colwidth) {
		r.colwidth = r.colwidth.slice();
		for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
	}
	return r;
}
function $O(t, e, n) {
	const r = Jt(e.type.schema).header_cell;
	for (let o = 0; o < t.height; o++)
		if (e.nodeAt(t.map[n + o * t.width]).type != r) return !1;
	return !0;
}
var at = class yr extends _e {
	constructor(e, n = e) {
		const r = e.node(-1),
			o = yt.get(r),
			i = e.start(-1),
			s = o.rectBetween(e.pos - i, n.pos - i),
			l = e.node(0),
			a = o.cellsInRect(s).filter((c) => c != n.pos - i);
		a.unshift(n.pos - i);
		const u = a.map((c) => {
			const d = r.nodeAt(c);
			if (!d) throw RangeError(`No cell with offset ${c} found`);
			const h = i + c + 1;
			return new cv(l.resolve(h), l.resolve(h + d.content.size));
		});
		super(u[0].$from, u[0].$to, u),
			(this.$anchorCell = e),
			(this.$headCell = n);
	}
	map(e, n) {
		const r = e.resolve(n.map(this.$anchorCell.pos)),
			o = e.resolve(n.map(this.$headCell.pos));
		if (Yd(r) && Yd(o) && Eh(r, o)) {
			const i = this.$anchorCell.node(-1) != r.node(-1);
			return i && this.isRowSelection()
				? yr.rowSelection(r, o)
				: i && this.isColSelection()
				? yr.colSelection(r, o)
				: new yr(r, o);
		}
		return ke.between(r, o);
	}
	content() {
		const e = this.$anchorCell.node(-1),
			n = yt.get(e),
			r = this.$anchorCell.start(-1),
			o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
			i = {},
			s = [];
		for (let a = o.top; a < o.bottom; a++) {
			const u = [];
			for (
				let c = a * n.width + o.left, d = o.left;
				d < o.right;
				d++, c++
			) {
				const h = n.map[c];
				if (i[h]) continue;
				i[h] = !0;
				const p = n.findCell(h);
				let g = e.nodeAt(h);
				if (!g) throw RangeError(`No cell with offset ${h} found`);
				const y = o.left - p.left,
					b = p.right - o.right;
				if (y > 0 || b > 0) {
					let w = g.attrs;
					if (
						(y > 0 && (w = Vo(w, 0, y)),
						b > 0 && (w = Vo(w, w.colspan - b, b)),
						p.left < o.left)
					) {
						if (((g = g.type.createAndFill(w)), !g))
							throw RangeError(
								`Could not create cell with attrs ${JSON.stringify(
									w
								)}`
							);
					} else g = g.type.create(w, g.content);
				}
				if (p.top < o.top || p.bottom > o.bottom) {
					const w = ye(z({}, g.attrs), {
						rowspan:
							Math.min(p.bottom, o.bottom) -
							Math.max(p.top, o.top),
					});
					p.top < o.top
						? (g = g.type.createAndFill(w))
						: (g = g.type.create(w, g.content));
				}
				u.push(g);
			}
			s.push(e.child(a).copy(J.from(u)));
		}
		const l = this.isColSelection() && this.isRowSelection() ? e : s;
		return new se(J.from(l), 1, 1);
	}
	replace(e, n = se.empty) {
		const r = e.steps.length,
			o = this.ranges;
		for (let s = 0; s < o.length; s++) {
			const { $from: l, $to: a } = o[s],
				u = e.mapping.slice(r);
			e.replace(u.map(l.pos), u.map(a.pos), s ? se.empty : n);
		}
		const i = _e.findFrom(
			e.doc.resolve(e.mapping.slice(r).map(this.to)),
			-1
		);
		i && e.setSelection(i);
	}
	replaceWith(e, n) {
		this.replace(e, new se(J.from(n), 0, 0));
	}
	forEachCell(e) {
		const n = this.$anchorCell.node(-1),
			r = yt.get(n),
			o = this.$anchorCell.start(-1),
			i = r.cellsInRect(
				r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o)
			);
		for (let s = 0; s < i.length; s++) e(n.nodeAt(i[s]), o + i[s]);
	}
	isColSelection() {
		const e = this.$anchorCell.index(-1),
			n = this.$headCell.index(-1);
		if (Math.min(e, n) > 0) return !1;
		const r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
			o = n + this.$headCell.nodeAfter.attrs.rowspan;
		return Math.max(r, o) == this.$headCell.node(-1).childCount;
	}
	static colSelection(e, n = e) {
		const r = e.node(-1),
			o = yt.get(r),
			i = e.start(-1),
			s = o.findCell(e.pos - i),
			l = o.findCell(n.pos - i),
			a = e.node(0);
		return (
			s.top <= l.top
				? (s.top > 0 && (e = a.resolve(i + o.map[s.left])),
				  l.bottom < o.height &&
						(n = a.resolve(
							i + o.map[o.width * (o.height - 1) + l.right - 1]
						)))
				: (l.top > 0 && (n = a.resolve(i + o.map[l.left])),
				  s.bottom < o.height &&
						(e = a.resolve(
							i + o.map[o.width * (o.height - 1) + s.right - 1]
						))),
			new yr(e, n)
		);
	}
	isRowSelection() {
		const e = this.$anchorCell.node(-1),
			n = yt.get(e),
			r = this.$anchorCell.start(-1),
			o = n.colCount(this.$anchorCell.pos - r),
			i = n.colCount(this.$headCell.pos - r);
		if (Math.min(o, i) > 0) return !1;
		const s = o + this.$anchorCell.nodeAfter.attrs.colspan,
			l = i + this.$headCell.nodeAfter.attrs.colspan;
		return Math.max(s, l) == n.width;
	}
	eq(e) {
		return (
			e instanceof yr &&
			e.$anchorCell.pos == this.$anchorCell.pos &&
			e.$headCell.pos == this.$headCell.pos
		);
	}
	static rowSelection(e, n = e) {
		const r = e.node(-1),
			o = yt.get(r),
			i = e.start(-1),
			s = o.findCell(e.pos - i),
			l = o.findCell(n.pos - i),
			a = e.node(0);
		return (
			s.left <= l.left
				? (s.left > 0 && (e = a.resolve(i + o.map[s.top * o.width])),
				  l.right < o.width &&
						(n = a.resolve(i + o.map[o.width * (l.top + 1) - 1])))
				: (l.left > 0 && (n = a.resolve(i + o.map[l.top * o.width])),
				  s.right < o.width &&
						(e = a.resolve(i + o.map[o.width * (s.top + 1) - 1]))),
			new yr(e, n)
		);
	}
	toJSON() {
		return {
			type: "cell",
			anchor: this.$anchorCell.pos,
			head: this.$headCell.pos,
		};
	}
	static fromJSON(e, n) {
		return new yr(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		return new yr(e.resolve(n), e.resolve(r));
	}
	getBookmark() {
		return new BO(this.$anchorCell.pos, this.$headCell.pos);
	}
};
at.prototype.visible = !1;
_e.jsonID("cell", at);
var BO = class S2 {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new S2(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		const n = e.resolve(this.anchor),
			r = e.resolve(this.head);
		return n.parent.type.spec.tableRole == "row" &&
			r.parent.type.spec.tableRole == "row" &&
			n.index() < n.parent.childCount &&
			r.index() < r.parent.childCount &&
			Eh(n, r)
			? new at(n, r)
			: _e.near(r, 1);
	}
};
function zO(t) {
	if (!(t.selection instanceof at)) return null;
	const e = [];
	return (
		t.selection.forEachCell((n, r) => {
			e.push(Kt.node(r, r + n.nodeSize, { class: "selectedCell" }));
		}),
		ft.create(t.doc, e)
	);
}
function HO({ $from: t, $to: e }) {
	if (t.pos == e.pos || t.pos < t.pos - 6) return !1;
	let n = t.pos,
		r = e.pos,
		o = t.depth;
	for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++);
	for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--);
	return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
}
function FO({ $from: t, $to: e }) {
	let n, r;
	for (let o = t.depth; o > 0; o--) {
		const i = t.node(o);
		if (
			i.type.spec.tableRole === "cell" ||
			i.type.spec.tableRole === "header_cell"
		) {
			n = i;
			break;
		}
	}
	for (let o = e.depth; o > 0; o--) {
		const i = e.node(o);
		if (
			i.type.spec.tableRole === "cell" ||
			i.type.spec.tableRole === "header_cell"
		) {
			r = i;
			break;
		}
	}
	return n !== r && e.parentOffset === 0;
}
function VO(t, e, n) {
	const r = (e || t).selection,
		o = (e || t).doc;
	let i, s;
	if (r instanceof ve && (s = r.node.type.spec.tableRole)) {
		if (s == "cell" || s == "header_cell") i = at.create(o, r.from);
		else if (s == "row") {
			const l = o.resolve(r.from + 1);
			i = at.rowSelection(l, l);
		} else if (!n) {
			const l = yt.get(r.node),
				a = r.from + 1,
				u = a + l.map[l.width * l.height - 1];
			i = at.create(o, a + 1, u);
		}
	} else
		r instanceof ke && HO(r)
			? (i = ke.create(o, r.from))
			: r instanceof ke &&
			  FO(r) &&
			  (i = ke.create(o, r.$from.start(), r.$from.end()));
	return i && (e || (e = t.tr)).setSelection(i), e;
}
var WO = new Rt("fix-tables");
function _2(t, e, n, r) {
	const o = t.childCount,
		i = e.childCount;
	e: for (let s = 0, l = 0; s < i; s++) {
		const a = e.child(s);
		for (let u = l, c = Math.min(o, s + 3); u < c; u++)
			if (t.child(u) == a) {
				(l = u + 1), (n += a.nodeSize);
				continue e;
			}
		r(a, n),
			l < o && t.child(l).sameMarkup(a)
				? _2(t.child(l), a, n + 1, r)
				: a.nodesBetween(0, a.content.size, r, n + 1),
			(n += a.nodeSize);
	}
}
function C2(t, e) {
	let n;
	const r = (o, i) => {
		o.type.spec.tableRole == "table" && (n = UO(t, o, i, n));
	};
	return (
		e ? e.doc != t.doc && _2(e.doc, t.doc, 0, r) : t.doc.descendants(r), n
	);
}
function UO(t, e, n, r) {
	const o = yt.get(e);
	if (!o.problems) return r;
	r || (r = t.tr);
	const i = [];
	for (let a = 0; a < o.height; a++) i.push(0);
	for (let a = 0; a < o.problems.length; a++) {
		const u = o.problems[a];
		if (u.type == "collision") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			const d = c.attrs;
			for (let h = 0; h < d.rowspan; h++) i[u.row + h] += u.n;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				Vo(d, d.colspan - u.n, u.n)
			);
		} else if (u.type == "missing") i[u.row] += u.n;
		else if (u.type == "overlong_rowspan") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				ye(z({}, c.attrs), { rowspan: c.attrs.rowspan - u.n })
			);
		} else if (u.type == "colwidth mismatch") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				ye(z({}, c.attrs), { colwidth: u.colwidth })
			);
		}
	}
	let s, l;
	for (let a = 0; a < i.length; a++) i[a] && (s == null && (s = a), (l = a));
	for (let a = 0, u = n + 1; a < o.height; a++) {
		const c = e.child(a),
			d = u + c.nodeSize,
			h = i[a];
		if (h > 0) {
			let p = "cell";
			c.firstChild && (p = c.firstChild.type.spec.tableRole);
			const g = [];
			for (let b = 0; b < h; b++) {
				const w = Jt(t.schema)[p].createAndFill();
				w && g.push(w);
			}
			const y = (a == 0 || s == a - 1) && l == a ? u + 1 : d - 1;
			r.insert(r.mapping.map(y), g);
		}
		u = d;
	}
	return r.setMeta(WO, { fixTables: !0 });
}
function KO(t) {
	if (!t.size) return null;
	let { content: e, openStart: n, openEnd: r } = t;
	for (
		;
		e.childCount == 1 &&
		((n > 0 && r > 0) || e.child(0).type.spec.tableRole == "table");

	)
		n--, r--, (e = e.child(0).content);
	const o = e.child(0),
		i = o.type.spec.tableRole,
		s = o.type.schema,
		l = [];
	if (i == "row")
		for (let a = 0; a < e.childCount; a++) {
			let u = e.child(a).content;
			const c = a ? 0 : Math.max(0, n - 1),
				d = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
			(c || d) && (u = Qd(Jt(s).row, new se(u, c, d)).content), l.push(u);
		}
	else if (i == "cell" || i == "header_cell")
		l.push(n || r ? Qd(Jt(s).row, new se(e, n, r)).content : e);
	else return null;
	return qO(s, l);
}
function qO(t, e) {
	const n = [];
	for (let o = 0; o < e.length; o++) {
		const i = e[o];
		for (let s = i.childCount - 1; s >= 0; s--) {
			const { rowspan: l, colspan: a } = i.child(s).attrs;
			for (let u = o; u < o + l; u++) n[u] = (n[u] || 0) + a;
		}
	}
	let r = 0;
	for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
	for (let o = 0; o < n.length; o++)
		if ((o >= e.length && e.push(J.empty), n[o] < r)) {
			const i = Jt(t).cell.createAndFill(),
				s = [];
			for (let l = n[o]; l < r; l++) s.push(i);
			e[o] = e[o].append(J.from(s));
		}
	return { height: e.length, width: r, rows: e };
}
function Qd(t, e) {
	const n = t.createAndFill();
	return new sh(n).replace(0, n.content.size, e).doc;
}
function JO({ width: t, height: e, rows: n }, r, o) {
	if (t != r) {
		const i = [],
			s = [];
		for (let l = 0; l < n.length; l++) {
			const a = n[l],
				u = [];
			for (let c = i[l] || 0, d = 0; c < r; d++) {
				let h = a.child(d % a.childCount);
				c + h.attrs.colspan > r &&
					(h = h.type.createChecked(
						Vo(h.attrs, h.attrs.colspan, c + h.attrs.colspan - r),
						h.content
					)),
					u.push(h),
					(c += h.attrs.colspan);
				for (let p = 1; p < h.attrs.rowspan; p++)
					i[l + p] = (i[l + p] || 0) + h.attrs.colspan;
			}
			s.push(J.from(u));
		}
		(n = s), (t = r);
	}
	if (e != o) {
		const i = [];
		for (let s = 0, l = 0; s < o; s++, l++) {
			const a = [],
				u = n[l % e];
			for (let c = 0; c < u.childCount; c++) {
				let d = u.child(c);
				s + d.attrs.rowspan > o &&
					(d = d.type.create(
						ye(z({}, d.attrs), {
							rowspan: Math.max(1, o - d.attrs.rowspan),
						}),
						d.content
					)),
					a.push(d);
			}
			i.push(J.from(a));
		}
		(n = i), (e = o);
	}
	return { width: t, height: e, rows: n };
}
function GO(t, e, n, r, o, i, s) {
	const l = t.doc.type.schema,
		a = Jt(l);
	let u, c;
	if (o > e.width)
		for (let d = 0, h = 0; d < e.height; d++) {
			const p = n.child(d);
			h += p.nodeSize;
			const g = [];
			let y;
			p.lastChild == null || p.lastChild.type == a.cell
				? (y = u || (u = a.cell.createAndFill()))
				: (y = c || (c = a.header_cell.createAndFill()));
			for (let b = e.width; b < o; b++) g.push(y);
			t.insert(t.mapping.slice(s).map(h - 1 + r), g);
		}
	if (i > e.height) {
		const d = [];
		for (
			let g = 0, y = (e.height - 1) * e.width;
			g < Math.max(e.width, o);
			g++
		) {
			const b =
				g >= e.width
					? !1
					: n.nodeAt(e.map[y + g]).type == a.header_cell;
			d.push(
				b
					? c || (c = a.header_cell.createAndFill())
					: u || (u = a.cell.createAndFill())
			);
		}
		const h = a.row.create(null, J.from(d)),
			p = [];
		for (let g = e.height; g < i; g++) p.push(h);
		t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), p);
	}
	return !!(u || c);
}
function Lg(t, e, n, r, o, i, s, l) {
	if (s == 0 || s == e.height) return !1;
	let a = !1;
	for (let u = o; u < i; u++) {
		const c = s * e.width + u,
			d = e.map[c];
		if (e.map[c - e.width] == d) {
			a = !0;
			const h = n.nodeAt(d),
				{ top: p, left: g } = e.findCell(d);
			t.setNodeMarkup(
				t.mapping.slice(l).map(d + r),
				null,
				ye(z({}, h.attrs), { rowspan: s - p })
			),
				t.insert(
					t.mapping.slice(l).map(e.positionAt(s, g, n)),
					h.type.createAndFill(
						ye(z({}, h.attrs), { rowspan: p + h.attrs.rowspan - s })
					)
				),
				(u += h.attrs.colspan - 1);
		}
	}
	return a;
}
function $g(t, e, n, r, o, i, s, l) {
	if (s == 0 || s == e.width) return !1;
	let a = !1;
	for (let u = o; u < i; u++) {
		const c = u * e.width + s,
			d = e.map[c];
		if (e.map[c - 1] == d) {
			a = !0;
			const h = n.nodeAt(d),
				p = e.colCount(d),
				g = t.mapping.slice(l).map(d + r);
			t.setNodeMarkup(
				g,
				null,
				Vo(h.attrs, s - p, h.attrs.colspan - (s - p))
			),
				t.insert(
					g + h.nodeSize,
					h.type.createAndFill(Vo(h.attrs, 0, s - p))
				),
				(u += h.attrs.rowspan - 1);
		}
	}
	return a;
}
function Bg(t, e, n, r, o) {
	let i = n ? t.doc.nodeAt(n - 1) : t.doc;
	if (!i) throw new Error("No table found");
	let s = yt.get(i);
	const { top: l, left: a } = r,
		u = a + o.width,
		c = l + o.height,
		d = t.tr;
	let h = 0;
	function p() {
		if (((i = n ? d.doc.nodeAt(n - 1) : d.doc), !i))
			throw new Error("No table found");
		(s = yt.get(i)), (h = d.mapping.maps.length);
	}
	GO(d, s, i, n, u, c, h) && p(),
		Lg(d, s, i, n, a, u, l, h) && p(),
		Lg(d, s, i, n, a, u, c, h) && p(),
		$g(d, s, i, n, l, c, a, h) && p(),
		$g(d, s, i, n, l, c, u, h) && p();
	for (let g = l; g < c; g++) {
		const y = s.positionAt(g, a, i),
			b = s.positionAt(g, u, i);
		d.replace(
			d.mapping.slice(h).map(y + n),
			d.mapping.slice(h).map(b + n),
			new se(o.rows[g - l], 0, 0)
		);
	}
	p(),
		d.setSelection(
			new at(
				d.doc.resolve(n + s.positionAt(l, a, i)),
				d.doc.resolve(n + s.positionAt(c - 1, u - 1, i))
			)
		),
		e(d);
}
var YO = yh({
	ArrowLeft: Tl("horiz", -1),
	ArrowRight: Tl("horiz", 1),
	ArrowUp: Tl("vert", -1),
	ArrowDown: Tl("vert", 1),
	"Shift-ArrowLeft": Al("horiz", -1),
	"Shift-ArrowRight": Al("horiz", 1),
	"Shift-ArrowUp": Al("vert", -1),
	"Shift-ArrowDown": Al("vert", 1),
	Backspace: Ol,
	"Mod-Backspace": Ol,
	Delete: Ol,
	"Mod-Delete": Ol,
});
function ql(t, e, n) {
	return n.eq(t.selection)
		? !1
		: (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Tl(t, e) {
	return (n, r, o) => {
		if (!o) return !1;
		const i = n.selection;
		if (i instanceof at) return ql(n, r, _e.near(i.$headCell, e));
		if (t != "horiz" && !i.empty) return !1;
		const s = M2(o, t, e);
		if (s == null) return !1;
		if (t == "horiz")
			return ql(n, r, _e.near(n.doc.resolve(i.head + e), e));
		{
			const l = n.doc.resolve(s),
				a = x2(l, t, e);
			let u;
			return (
				a
					? (u = _e.near(a, 1))
					: e < 0
					? (u = _e.near(n.doc.resolve(l.before(-1)), -1))
					: (u = _e.near(n.doc.resolve(l.after(-1)), 1)),
				ql(n, r, u)
			);
		}
	};
}
function Al(t, e) {
	return (n, r, o) => {
		if (!o) return !1;
		const i = n.selection;
		let s;
		if (i instanceof at) s = i;
		else {
			const a = M2(o, t, e);
			if (a == null) return !1;
			s = new at(n.doc.resolve(a));
		}
		const l = x2(s.$headCell, t, e);
		return l ? ql(n, r, new at(s.$anchorCell, l)) : !1;
	};
}
function Ol(t, e) {
	const n = t.selection;
	if (!(n instanceof at)) return !1;
	if (e) {
		const r = t.tr,
			o = Jt(t.schema).cell.createAndFill().content;
		n.forEachCell((i, s) => {
			i.content.eq(o) ||
				r.replace(
					r.mapping.map(s + 1),
					r.mapping.map(s + i.nodeSize - 1),
					new se(o, 0, 0)
				);
		}),
			r.docChanged && e(r);
	}
	return !0;
}
function QO(t, e) {
	const n = t.state.doc,
		r = $i(n.resolve(e));
	return r ? (t.dispatch(t.state.tr.setSelection(new at(r))), !0) : !1;
}
function XO(t, e, n) {
	if (!Un(t.state)) return !1;
	let r = KO(n);
	const o = t.state.selection;
	if (o instanceof at) {
		r ||
			(r = {
				width: 1,
				height: 1,
				rows: [J.from(Qd(Jt(t.state.schema).cell, n))],
			});
		const i = o.$anchorCell.node(-1),
			s = o.$anchorCell.start(-1),
			l = yt
				.get(i)
				.rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
		return (
			(r = JO(r, l.right - l.left, l.bottom - l.top)),
			Bg(t.state, t.dispatch, s, l, r),
			!0
		);
	} else if (r) {
		const i = Uu(t.state),
			s = i.start(-1);
		return (
			Bg(
				t.state,
				t.dispatch,
				s,
				yt.get(i.node(-1)).findCell(i.pos - s),
				r
			),
			!0
		);
	} else return !1;
}
function ZO(t, e) {
	var n;
	if (e.ctrlKey || e.metaKey) return;
	const r = zg(t, e.target);
	let o;
	if (e.shiftKey && t.state.selection instanceof at)
		i(t.state.selection.$anchorCell, e), e.preventDefault();
	else if (
		e.shiftKey &&
		r &&
		(o = $i(t.state.selection.$anchor)) != null &&
		((n = Vc(t, e)) == null ? void 0 : n.pos) != o.pos
	)
		i(o, e), e.preventDefault();
	else if (!r) return;
	function i(a, u) {
		let c = Vc(t, u);
		const d = Ur.getState(t.state) == null;
		if (!c || !Eh(a, c))
			if (d) c = a;
			else return;
		const h = new at(a, c);
		if (d || !t.state.selection.eq(h)) {
			const p = t.state.tr.setSelection(h);
			d && p.setMeta(Ur, a.pos), t.dispatch(p);
		}
	}
	function s() {
		t.root.removeEventListener("mouseup", s),
			t.root.removeEventListener("dragstart", s),
			t.root.removeEventListener("mousemove", l),
			Ur.getState(t.state) != null &&
				t.dispatch(t.state.tr.setMeta(Ur, -1));
	}
	function l(a) {
		const u = a,
			c = Ur.getState(t.state);
		let d;
		if (c != null) d = t.state.doc.resolve(c);
		else if (zg(t, u.target) != r && ((d = Vc(t, e)), !d)) return s();
		d && i(d, u);
	}
	t.root.addEventListener("mouseup", s),
		t.root.addEventListener("dragstart", s),
		t.root.addEventListener("mousemove", l);
}
function M2(t, e, n) {
	if (!(t.state.selection instanceof ke)) return null;
	const { $head: r } = t.state.selection;
	for (let o = r.depth - 1; o >= 0; o--) {
		const i = r.node(o);
		if (
			(n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)
		)
			return null;
		if (
			i.type.spec.tableRole == "cell" ||
			i.type.spec.tableRole == "header_cell"
		) {
			const l = r.before(o),
				a =
					e == "vert"
						? n > 0
							? "down"
							: "up"
						: n > 0
						? "right"
						: "left";
			return t.endOfTextblock(a) ? l : null;
		}
	}
	return null;
}
function zg(t, e) {
	for (; e && e != t.dom; e = e.parentNode)
		if (e.nodeName == "TD" || e.nodeName == "TH") return e;
	return null;
}
function Vc(t, e) {
	const n = t.posAtCoords({ left: e.clientX, top: e.clientY });
	return n && n ? $i(t.state.doc.resolve(n.pos)) : null;
}
var e5 = class {
	constructor(e, n) {
		(this.node = e),
			(this.cellMinWidth = n),
			(this.dom = document.createElement("div")),
			(this.dom.className = "tableWrapper"),
			(this.table = this.dom.appendChild(
				document.createElement("table")
			)),
			(this.colgroup = this.table.appendChild(
				document.createElement("colgroup")
			)),
			Xd(e, this.colgroup, this.table, n),
			(this.contentDOM = this.table.appendChild(
				document.createElement("tbody")
			));
	}
	update(e) {
		return e.type != this.node.type
			? !1
			: ((this.node = e),
			  Xd(e, this.colgroup, this.table, this.cellMinWidth),
			  !0);
	}
	ignoreMutation(e) {
		return (
			e.type == "attributes" &&
			(e.target == this.table || this.colgroup.contains(e.target))
		);
	}
};
function Xd(t, e, n, r, o, i) {
	var s;
	let l = 0,
		a = !0,
		u = e.firstChild;
	const c = t.firstChild;
	if (c) {
		for (let d = 0, h = 0; d < c.childCount; d++) {
			const { colspan: p, colwidth: g } = c.child(d).attrs;
			for (let y = 0; y < p; y++, h++) {
				const b = o == h ? i : g && g[y],
					w = b ? b + "px" : "";
				(l += b || r),
					b || (a = !1),
					u
						? (u.style.width != w && (u.style.width = w),
						  (u = u.nextSibling))
						: (e.appendChild(
								document.createElement("col")
						  ).style.width = w);
			}
		}
		for (; u; ) {
			const d = u.nextSibling;
			(s = u.parentNode) == null || s.removeChild(u), (u = d);
		}
		a
			? ((n.style.width = l + "px"), (n.style.minWidth = ""))
			: ((n.style.width = ""), (n.style.minWidth = l + "px"));
	}
}
var Cn = new Rt("tableColumnResizing");
function t5({
	handleWidth: t = 5,
	cellMinWidth: e = 25,
	View: n = e5,
	lastColumnResizable: r = !0,
} = {}) {
	const o = new wt({
		key: Cn,
		state: {
			init(i, s) {
				return (
					(o.spec.props.nodeViews[Jt(s.schema).table.name] = (l, a) =>
						new n(l, e, a)),
					new n5(-1, !1)
				);
			},
			apply(i, s) {
				return s.apply(i);
			},
		},
		props: {
			attributes: (i) => {
				const s = Cn.getState(i);
				return s && s.activeHandle > -1
					? { class: "resize-cursor" }
					: {};
			},
			handleDOMEvents: {
				mousemove: (i, s) => {
					r5(i, s, t, e, r);
				},
				mouseleave: (i) => {
					o5(i);
				},
				mousedown: (i, s) => {
					i5(i, s, e);
				},
			},
			decorations: (i) => {
				const s = Cn.getState(i);
				if (s && s.activeHandle > -1) return d5(i, s.activeHandle);
			},
			nodeViews: {},
		},
	});
	return o;
}
var n5 = class Jl {
	constructor(e, n) {
		(this.activeHandle = e), (this.dragging = n);
	}
	apply(e) {
		const n = this,
			r = e.getMeta(Cn);
		if (r && r.setHandle != null) return new Jl(r.setHandle, !1);
		if (r && r.setDragging !== void 0)
			return new Jl(n.activeHandle, r.setDragging);
		if (n.activeHandle > -1 && e.docChanged) {
			let o = e.mapping.map(n.activeHandle, -1);
			return Yd(e.doc.resolve(o)) || (o = -1), new Jl(o, n.dragging);
		}
		return n;
	}
};
function r5(t, e, n, r, o) {
	const i = Cn.getState(t.state);
	if (i && !i.dragging) {
		const s = l5(e.target);
		let l = -1;
		if (s) {
			const { left: a, right: u } = s.getBoundingClientRect();
			e.clientX - a <= n
				? (l = Hg(t, e, "left", n))
				: u - e.clientX <= n && (l = Hg(t, e, "right", n));
		}
		if (l != i.activeHandle) {
			if (!o && l !== -1) {
				const a = t.state.doc.resolve(l),
					u = a.node(-1),
					c = yt.get(u),
					d = a.start(-1);
				if (
					c.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 ==
					c.width - 1
				)
					return;
			}
			E2(t, l);
		}
	}
}
function o5(t) {
	const e = Cn.getState(t.state);
	e && e.activeHandle > -1 && !e.dragging && E2(t, -1);
}
function i5(t, e, n) {
	const r = Cn.getState(t.state);
	if (!r || r.activeHandle == -1 || r.dragging) return !1;
	const o = t.state.doc.nodeAt(r.activeHandle),
		i = s5(t, r.activeHandle, o.attrs);
	t.dispatch(
		t.state.tr.setMeta(Cn, {
			setDragging: { startX: e.clientX, startWidth: i },
		})
	);
	function s(a) {
		window.removeEventListener("mouseup", s),
			window.removeEventListener("mousemove", l);
		const u = Cn.getState(t.state);
		u != null &&
			u.dragging &&
			(a5(t, u.activeHandle, Fg(u.dragging, a, n)),
			t.dispatch(t.state.tr.setMeta(Cn, { setDragging: null })));
	}
	function l(a) {
		if (!a.which) return s(a);
		const u = Cn.getState(t.state);
		if (u && u.dragging) {
			const c = Fg(u.dragging, a, n);
			u5(t, u.activeHandle, c, n);
		}
	}
	return (
		window.addEventListener("mouseup", s),
		window.addEventListener("mousemove", l),
		e.preventDefault(),
		!0
	);
}
function s5(t, e, { colspan: n, colwidth: r }) {
	const o = r && r[r.length - 1];
	if (o) return o;
	const i = t.domAtPos(e);
	let l = i.node.childNodes[i.offset].offsetWidth,
		a = n;
	if (r) for (let u = 0; u < n; u++) r[u] && ((l -= r[u]), a--);
	return l / a;
}
function l5(t) {
	for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
		t =
			t.classList && t.classList.contains("ProseMirror")
				? null
				: t.parentNode;
	return t;
}
function Hg(t, e, n, r) {
	const o = n == "right" ? -r : r,
		i = t.posAtCoords({ left: e.clientX + o, top: e.clientY });
	if (!i) return -1;
	const { pos: s } = i,
		l = $i(t.state.doc.resolve(s));
	if (!l) return -1;
	if (n == "right") return l.pos;
	const a = yt.get(l.node(-1)),
		u = l.start(-1),
		c = a.map.indexOf(l.pos - u);
	return c % a.width == 0 ? -1 : u + a.map[c - 1];
}
function Fg(t, e, n) {
	const r = e.clientX - t.startX;
	return Math.max(n, t.startWidth + r);
}
function E2(t, e) {
	t.dispatch(t.state.tr.setMeta(Cn, { setHandle: e }));
}
function a5(t, e, n) {
	const r = t.state.doc.resolve(e),
		o = r.node(-1),
		i = yt.get(o),
		s = r.start(-1),
		l = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1,
		a = t.state.tr;
	for (let u = 0; u < i.height; u++) {
		const c = u * i.width + l;
		if (u && i.map[c] == i.map[c - i.width]) continue;
		const d = i.map[c],
			h = o.nodeAt(d).attrs,
			p = h.colspan == 1 ? 0 : l - i.colCount(d);
		if (h.colwidth && h.colwidth[p] == n) continue;
		const g = h.colwidth ? h.colwidth.slice() : c5(h.colspan);
		(g[p] = n), a.setNodeMarkup(s + d, null, ye(z({}, h), { colwidth: g }));
	}
	a.docChanged && t.dispatch(a);
}
function u5(t, e, n, r) {
	const o = t.state.doc.resolve(e),
		i = o.node(-1),
		s = o.start(-1),
		l = yt.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
	let a = t.domAtPos(o.start(-1)).node;
	for (; a && a.nodeName != "TABLE"; ) a = a.parentNode;
	a && Xd(i, a.firstChild, a, r, l, n);
}
function c5(t) {
	return Array(t).fill(0);
}
function d5(t, e) {
	const n = [],
		r = t.doc.resolve(e),
		o = r.node(-1);
	if (!o) return ft.empty;
	const i = yt.get(o),
		s = r.start(-1),
		l = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan;
	for (let a = 0; a < i.height; a++) {
		const u = l + a * i.width - 1;
		if (
			(l == i.width || i.map[u] != i.map[u + 1]) &&
			(a == 0 || i.map[u] != i.map[u - i.width])
		) {
			const c = i.map[u],
				d = s + c + o.nodeAt(c).nodeSize - 1,
				h = document.createElement("div");
			(h.className = "column-resize-handle"), n.push(Kt.widget(d, h));
		}
	}
	return ft.create(t.doc, n);
}
function fr(t) {
	const e = t.selection,
		n = Uu(t),
		r = n.node(-1),
		o = n.start(-1),
		i = yt.get(r),
		s =
			e instanceof at
				? i.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o)
				: i.findCell(n.pos - o);
	return ye(z({}, s), { tableStart: o, map: i, table: r });
}
function T2(t, { map: e, tableStart: n, table: r }, o) {
	let i = o > 0 ? -1 : 0;
	$O(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
	for (let s = 0; s < e.height; s++) {
		const l = s * e.width + o;
		if (o > 0 && o < e.width && e.map[l - 1] == e.map[l]) {
			const a = e.map[l],
				u = r.nodeAt(a);
			t.setNodeMarkup(
				t.mapping.map(n + a),
				null,
				k2(u.attrs, o - e.colCount(a))
			),
				(s += u.attrs.rowspan - 1);
		} else {
			const a =
					i == null
						? Jt(r.type.schema).cell
						: r.nodeAt(e.map[l + i]).type,
				u = e.positionAt(s, o, r);
			t.insert(t.mapping.map(n + u), a.createAndFill());
		}
	}
	return t;
}
function f5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t);
		e(T2(t.tr, n, n.left));
	}
	return !0;
}
function h5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t);
		e(T2(t.tr, n, n.right));
	}
	return !0;
}
function p5(t, { map: e, table: n, tableStart: r }, o) {
	const i = t.mapping.maps.length;
	for (let s = 0; s < e.height; ) {
		const l = s * e.width + o,
			a = e.map[l],
			u = n.nodeAt(a),
			c = u.attrs;
		if (
			(o > 0 && e.map[l - 1] == a) ||
			(o < e.width - 1 && e.map[l + 1] == a)
		)
			t.setNodeMarkup(
				t.mapping.slice(i).map(r + a),
				null,
				Vo(c, o - e.colCount(a))
			);
		else {
			const d = t.mapping.slice(i).map(r + a);
			t.delete(d, d + u.nodeSize);
		}
		s += c.rowspan;
	}
}
function m5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t),
			r = t.tr;
		if (n.left == 0 && n.right == n.map.width) return !1;
		for (let o = n.right - 1; p5(r, n, o), o != n.left; o--) {
			const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!i) throw RangeError("No table found");
			(n.table = i), (n.map = yt.get(i));
		}
		e(r);
	}
	return !0;
}
function g5(t, e, n) {
	var r;
	const o = Jt(e.type.schema).header_cell;
	for (let i = 0; i < t.width; i++)
		if (
			((r = e.nodeAt(t.map[i + n * t.width])) == null
				? void 0
				: r.type) != o
		)
			return !1;
	return !0;
}
function A2(t, { map: e, tableStart: n, table: r }, o) {
	var i;
	let s = n;
	for (let u = 0; u < o; u++) s += r.child(u).nodeSize;
	const l = [];
	let a = o > 0 ? -1 : 0;
	g5(e, r, o + a) && (a = o == 0 || o == e.height ? null : 0);
	for (let u = 0, c = e.width * o; u < e.width; u++, c++)
		if (o > 0 && o < e.height && e.map[c] == e.map[c - e.width]) {
			const d = e.map[c],
				h = r.nodeAt(d).attrs;
			t.setNodeMarkup(
				n + d,
				null,
				ye(z({}, h), { rowspan: h.rowspan + 1 })
			),
				(u += h.colspan - 1);
		} else {
			const d =
					a == null
						? Jt(r.type.schema).cell
						: (i = r.nodeAt(e.map[c + a * e.width])) == null
						? void 0
						: i.type,
				h = d == null ? void 0 : d.createAndFill();
			h && l.push(h);
		}
	return t.insert(s, Jt(r.type.schema).row.create(null, l)), t;
}
function y5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t);
		e(A2(t.tr, n, n.top));
	}
	return !0;
}
function v5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t);
		e(A2(t.tr, n, n.bottom));
	}
	return !0;
}
function b5(t, { map: e, table: n, tableStart: r }, o) {
	let i = 0;
	for (let u = 0; u < o; u++) i += n.child(u).nodeSize;
	const s = i + n.child(o).nodeSize,
		l = t.mapping.maps.length;
	t.delete(i + r, s + r);
	const a = new Set();
	for (let u = 0, c = o * e.width; u < e.width; u++, c++) {
		const d = e.map[c];
		if (!a.has(d)) {
			if ((a.add(d), o > 0 && d == e.map[c - e.width])) {
				const h = n.nodeAt(d).attrs;
				t.setNodeMarkup(
					t.mapping.slice(l).map(d + r),
					null,
					ye(z({}, h), { rowspan: h.rowspan - 1 })
				),
					(u += h.colspan - 1);
			} else if (o < e.height && d == e.map[c + e.width]) {
				const h = n.nodeAt(d),
					p = h.attrs,
					g = h.type.create(
						ye(z({}, p), { rowspan: h.attrs.rowspan - 1 }),
						h.content
					),
					y = e.positionAt(o + 1, u, n);
				t.insert(t.mapping.slice(l).map(r + y), g),
					(u += p.colspan - 1);
			}
		}
	}
}
function w5(t, e) {
	if (!Un(t)) return !1;
	if (e) {
		const n = fr(t),
			r = t.tr;
		if (n.top == 0 && n.bottom == n.map.height) return !1;
		for (let o = n.bottom - 1; b5(r, n, o), o != n.top; o--) {
			const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!i) throw RangeError("No table found");
			(n.table = i), (n.map = yt.get(n.table));
		}
		e(r);
	}
	return !0;
}
function Vg(t) {
	const e = t.content;
	return (
		e.childCount == 1 &&
		e.child(0).isTextblock &&
		e.child(0).childCount == 0
	);
}
function x5({ width: t, height: e, map: n }, r) {
	let o = r.top * t + r.left,
		i = o,
		s = (r.bottom - 1) * t + r.left,
		l = o + (r.right - r.left - 1);
	for (let a = r.top; a < r.bottom; a++) {
		if (
			(r.left > 0 && n[i] == n[i - 1]) ||
			(r.right < t && n[l] == n[l + 1])
		)
			return !0;
		(i += t), (l += t);
	}
	for (let a = r.left; a < r.right; a++) {
		if (
			(r.top > 0 && n[o] == n[o - t]) ||
			(r.bottom < e && n[s] == n[s + t])
		)
			return !0;
		o++, s++;
	}
	return !1;
}
function Wg(t, e) {
	const n = t.selection;
	if (!(n instanceof at) || n.$anchorCell.pos == n.$headCell.pos) return !1;
	const r = fr(t),
		{ map: o } = r;
	if (x5(o, r)) return !1;
	if (e) {
		const i = t.tr,
			s = {};
		let l = J.empty,
			a,
			u;
		for (let c = r.top; c < r.bottom; c++)
			for (let d = r.left; d < r.right; d++) {
				const h = o.map[c * o.width + d],
					p = r.table.nodeAt(h);
				if (!(s[h] || !p))
					if (((s[h] = !0), a == null)) (a = h), (u = p);
					else {
						Vg(p) || (l = l.append(p.content));
						const g = i.mapping.map(h + r.tableStart);
						i.delete(g, g + p.nodeSize);
					}
			}
		if (a == null || u == null) return !0;
		if (
			(i.setNodeMarkup(
				a + r.tableStart,
				null,
				ye(
					z(
						{},
						k2(
							u.attrs,
							u.attrs.colspan,
							r.right - r.left - u.attrs.colspan
						)
					),
					{ rowspan: r.bottom - r.top }
				)
			),
			l.size)
		) {
			const c = a + 1 + u.content.size,
				d = Vg(u) ? a + 1 : c;
			i.replaceWith(d + r.tableStart, c + r.tableStart, l);
		}
		i.setSelection(new at(i.doc.resolve(a + r.tableStart))), e(i);
	}
	return !0;
}
function Ug(t, e) {
	const n = Jt(t.schema);
	return k5(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function k5(t) {
	return (e, n) => {
		var r;
		const o = e.selection;
		let i, s;
		if (o instanceof at) {
			if (o.$anchorCell.pos != o.$headCell.pos) return !1;
			(i = o.$anchorCell.nodeAfter), (s = o.$anchorCell.pos);
		} else {
			if (((i = DO(o.$from)), !i)) return !1;
			s = (r = $i(o.$from)) == null ? void 0 : r.pos;
		}
		if (
			i == null ||
			s == null ||
			(i.attrs.colspan == 1 && i.attrs.rowspan == 1)
		)
			return !1;
		if (n) {
			let l = i.attrs;
			const a = [],
				u = l.colwidth;
			l.rowspan > 1 && (l = ye(z({}, l), { rowspan: 1 })),
				l.colspan > 1 && (l = ye(z({}, l), { colspan: 1 }));
			const c = fr(e),
				d = e.tr;
			for (let p = 0; p < c.right - c.left; p++)
				a.push(
					u
						? ye(z({}, l), { colwidth: u && u[p] ? [u[p]] : null })
						: l
				);
			let h;
			for (let p = c.top; p < c.bottom; p++) {
				let g = c.map.positionAt(p, c.left, c.table);
				p == c.top && (g += i.nodeSize);
				for (let y = c.left, b = 0; y < c.right; y++, b++)
					(y == c.left && p == c.top) ||
						d.insert(
							(h = d.mapping.map(g + c.tableStart, 1)),
							t({ node: i, row: p, col: y }).createAndFill(a[b])
						);
			}
			d.setNodeMarkup(s, t({ node: i, row: c.top, col: c.left }), a[0]),
				o instanceof at &&
					d.setSelection(
						new at(
							d.doc.resolve(o.$anchorCell.pos),
							h ? d.doc.resolve(h) : void 0
						)
					),
				n(d);
		}
		return !0;
	};
}
function S5(t, e) {
	return function (n, r) {
		if (!Un(n)) return !1;
		const o = Uu(n);
		if (o.nodeAfter.attrs[t] === e) return !1;
		if (r) {
			const i = n.tr;
			n.selection instanceof at
				? n.selection.forEachCell((s, l) => {
						s.attrs[t] !== e &&
							i.setNodeMarkup(
								l,
								null,
								ye(z({}, s.attrs), { [t]: e })
							);
				  })
				: i.setNodeMarkup(
						o.pos,
						null,
						ye(z({}, o.nodeAfter.attrs), { [t]: e })
				  ),
				r(i);
		}
		return !0;
	};
}
function _5(t) {
	return function (e, n) {
		if (!Un(e)) return !1;
		if (n) {
			const r = Jt(e.schema),
				o = fr(e),
				i = e.tr,
				s = o.map.cellsInRect(
					t == "column"
						? {
								left: o.left,
								top: 0,
								right: o.right,
								bottom: o.map.height,
						  }
						: t == "row"
						? {
								left: 0,
								top: o.top,
								right: o.map.width,
								bottom: o.bottom,
						  }
						: o
				),
				l = s.map((a) => o.table.nodeAt(a));
			for (let a = 0; a < s.length; a++)
				l[a].type == r.header_cell &&
					i.setNodeMarkup(o.tableStart + s[a], r.cell, l[a].attrs);
			if (i.steps.length == 0)
				for (let a = 0; a < s.length; a++)
					i.setNodeMarkup(
						o.tableStart + s[a],
						r.header_cell,
						l[a].attrs
					);
			n(i);
		}
		return !0;
	};
}
function Kg(t, e, n) {
	const r = e.map.cellsInRect({
		left: 0,
		top: 0,
		right: t == "row" ? e.map.width : 1,
		bottom: t == "column" ? e.map.height : 1,
	});
	for (let o = 0; o < r.length; o++) {
		const i = e.table.nodeAt(r[o]);
		if (i && i.type !== n.header_cell) return !1;
	}
	return !0;
}
function zs(t, e) {
	return (
		(e = e || { useDeprecatedLogic: !1 }),
		e.useDeprecatedLogic
			? _5(t)
			: function (n, r) {
					if (!Un(n)) return !1;
					if (r) {
						const o = Jt(n.schema),
							i = fr(n),
							s = n.tr,
							l = Kg("row", i, o),
							a = Kg("column", i, o),
							c = (t === "column" ? l : t === "row" ? a : !1)
								? 1
								: 0,
							d =
								t == "column"
									? {
											left: 0,
											top: c,
											right: 1,
											bottom: i.map.height,
									  }
									: t == "row"
									? {
											left: c,
											top: 0,
											right: i.map.width,
											bottom: 1,
									  }
									: i,
							h =
								t == "column"
									? a
										? o.cell
										: o.header_cell
									: t == "row"
									? l
										? o.cell
										: o.header_cell
									: o.cell;
						i.map.cellsInRect(d).forEach((p) => {
							const g = p + i.tableStart,
								y = s.doc.nodeAt(g);
							y && s.setNodeMarkup(g, h, y.attrs);
						}),
							r(s);
					}
					return !0;
			  }
	);
}
zs("row", { useDeprecatedLogic: !0 });
zs("column", { useDeprecatedLogic: !0 });
var C5 = zs("cell", { useDeprecatedLogic: !0 });
function M5(t, e) {
	if (e < 0) {
		const n = t.nodeBefore;
		if (n) return t.pos - n.nodeSize;
		for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
			const i = t.node(-1).child(r),
				s = i.lastChild;
			if (s) return o - 1 - s.nodeSize;
			o -= i.nodeSize;
		}
	} else {
		if (t.index() < t.parent.childCount - 1)
			return t.pos + t.nodeAfter.nodeSize;
		const n = t.node(-1);
		for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
			const i = n.child(r);
			if (i.childCount) return o + 1;
			o += i.nodeSize;
		}
	}
	return null;
}
function qg(t) {
	return function (e, n) {
		if (!Un(e)) return !1;
		const r = M5(Uu(e), t);
		if (r == null) return !1;
		if (n) {
			const o = e.doc.resolve(r);
			n(e.tr.setSelection(ke.between(o, LO(o))).scrollIntoView());
		}
		return !0;
	};
}
function E5(t, e) {
	const n = t.selection.$anchor;
	for (let r = n.depth; r > 0; r--)
		if (n.node(r).type.spec.tableRole == "table")
			return (
				e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()),
				!0
			);
	return !1;
}
function T5({ allowTableNodeSelection: t = !1 } = {}) {
	return new wt({
		key: Ur,
		state: {
			init() {
				return null;
			},
			apply(e, n) {
				const r = e.getMeta(Ur);
				if (r != null) return r == -1 ? null : r;
				if (n == null || !e.docChanged) return n;
				const { deleted: o, pos: i } = e.mapping.mapResult(n);
				return o ? null : i;
			},
		},
		props: {
			decorations: zO,
			handleDOMEvents: { mousedown: ZO },
			createSelectionBetween(e) {
				return Ur.getState(e.state) != null ? e.state.selection : null;
			},
			handleTripleClick: QO,
			handleKeyDown: YO,
			handlePaste: XO,
		},
		appendTransaction(e, n, r) {
			return VO(r, C2(r, n), t);
		},
	});
}
function Jg(t, e, n, r, o, i) {
	let s = 0,
		l = !0,
		a = e.firstChild;
	const u = t.firstChild;
	for (let c = 0, d = 0; c < u.childCount; c += 1) {
		const { colspan: h, colwidth: p } = u.child(c).attrs;
		for (let g = 0; g < h; g += 1, d += 1) {
			const y = o === d ? i : p && p[g],
				b = y ? `${y}px` : "";
			(s += y || r),
				y || (l = !1),
				a
					? (a.style.width !== b && (a.style.width = b),
					  (a = a.nextSibling))
					: (e.appendChild(
							document.createElement("col")
					  ).style.width = b);
		}
	}
	for (; a; ) {
		const c = a.nextSibling;
		a.parentNode.removeChild(a), (a = c);
	}
	l
		? ((n.style.width = `${s}px`), (n.style.minWidth = ""))
		: ((n.style.width = ""), (n.style.minWidth = `${s}px`));
}
class A5 {
	constructor(e, n) {
		(this.node = e),
			(this.cellMinWidth = n),
			(this.dom = document.createElement("div")),
			(this.dom.className = "tableWrapper"),
			(this.table = this.dom.appendChild(
				document.createElement("table")
			)),
			(this.colgroup = this.table.appendChild(
				document.createElement("colgroup")
			)),
			Jg(e, this.colgroup, this.table, n),
			(this.contentDOM = this.table.appendChild(
				document.createElement("tbody")
			));
	}
	update(e) {
		return e.type !== this.node.type
			? !1
			: ((this.node = e),
			  Jg(e, this.colgroup, this.table, this.cellMinWidth),
			  !0);
	}
	ignoreMutation(e) {
		return (
			e.type === "attributes" &&
			(e.target === this.table || this.colgroup.contains(e.target))
		);
	}
}
function Gg(t, e) {
	return e ? t.createChecked(null, e) : t.createAndFill();
}
function O5(t) {
	if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
	const e = {};
	return (
		Object.keys(t.nodes).forEach((n) => {
			const r = t.nodes[n];
			r.spec.tableRole && (e[r.spec.tableRole] = r);
		}),
		(t.cached.tableNodeTypes = e),
		e
	);
}
function R5(t, e, n, r, o) {
	const i = O5(t),
		s = [],
		l = [];
	for (let u = 0; u < n; u += 1) {
		const c = Gg(i.cell, o);
		if ((c && l.push(c), r)) {
			const d = Gg(i.header_cell, o);
			d && s.push(d);
		}
	}
	const a = [];
	for (let u = 0; u < e; u += 1)
		a.push(i.row.createChecked(null, r && u === 0 ? s : l));
	return i.table.createChecked(null, a);
}
function P5(t) {
	return t instanceof at;
}
const Rl = ({ editor: t }) => {
		const { selection: e } = t.state;
		if (!P5(e)) return !1;
		let n = 0;
		const r = r2(e.ranges[0].$from, (i) => i.type.name === "table");
		return (
			r == null ||
				r.node.descendants((i) => {
					if (i.type.name === "table") return !1;
					["tableCell", "tableHeader"].includes(i.type.name) &&
						(n += 1);
				}),
			n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
		);
	},
	I5 = Tt.create({
		name: "table",
		addOptions() {
			return {
				HTMLAttributes: {},
				resizable: !1,
				handleWidth: 5,
				cellMinWidth: 25,
				View: A5,
				lastColumnResizable: !0,
				allowTableNodeSelection: !1,
			};
		},
		content: "tableRow+",
		tableRole: "table",
		isolating: !0,
		group: "block",
		parseHTML() {
			return [{ tag: "table" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["table", Ze(this.options.HTMLAttributes, t), ["tbody", 0]];
		},
		addCommands() {
			return {
				insertTable:
					({
						rows: t = 3,
						cols: e = 3,
						withHeaderRow: n = !0,
					} = {}) =>
					({ tr: r, dispatch: o, editor: i }) => {
						const s = R5(i.schema, t, e, n);
						if (o) {
							const l = r.selection.anchor + 1;
							r.replaceSelectionWith(s)
								.scrollIntoView()
								.setSelection(ke.near(r.doc.resolve(l)));
						}
						return !0;
					},
				addColumnBefore:
					() =>
					({ state: t, dispatch: e }) =>
						f5(t, e),
				addColumnAfter:
					() =>
					({ state: t, dispatch: e }) =>
						h5(t, e),
				deleteColumn:
					() =>
					({ state: t, dispatch: e }) =>
						m5(t, e),
				addRowBefore:
					() =>
					({ state: t, dispatch: e }) =>
						y5(t, e),
				addRowAfter:
					() =>
					({ state: t, dispatch: e }) =>
						v5(t, e),
				deleteRow:
					() =>
					({ state: t, dispatch: e }) =>
						w5(t, e),
				deleteTable:
					() =>
					({ state: t, dispatch: e }) =>
						E5(t, e),
				mergeCells:
					() =>
					({ state: t, dispatch: e }) =>
						Wg(t, e),
				splitCell:
					() =>
					({ state: t, dispatch: e }) =>
						Ug(t, e),
				toggleHeaderColumn:
					() =>
					({ state: t, dispatch: e }) =>
						zs("column")(t, e),
				toggleHeaderRow:
					() =>
					({ state: t, dispatch: e }) =>
						zs("row")(t, e),
				toggleHeaderCell:
					() =>
					({ state: t, dispatch: e }) =>
						C5(t, e),
				mergeOrSplit:
					() =>
					({ state: t, dispatch: e }) =>
						Wg(t, e) ? !0 : Ug(t, e),
				setCellAttribute:
					(t, e) =>
					({ state: n, dispatch: r }) =>
						S5(t, e)(n, r),
				goToNextCell:
					() =>
					({ state: t, dispatch: e }) =>
						qg(1)(t, e),
				goToPreviousCell:
					() =>
					({ state: t, dispatch: e }) =>
						qg(-1)(t, e),
				fixTables:
					() =>
					({ state: t, dispatch: e }) => (e && C2(t), !0),
				setCellSelection:
					(t) =>
					({ tr: e, dispatch: n }) => {
						if (n) {
							const r = at.create(
								e.doc,
								t.anchorCell,
								t.headCell
							);
							e.setSelection(r);
						}
						return !0;
					},
			};
		},
		addKeyboardShortcuts() {
			return {
				Tab: () =>
					this.editor.commands.goToNextCell()
						? !0
						: this.editor.can().addRowAfter()
						? this.editor.chain().addRowAfter().goToNextCell().run()
						: !1,
				"Shift-Tab": () => this.editor.commands.goToPreviousCell(),
				Backspace: Rl,
				"Mod-Backspace": Rl,
				Delete: Rl,
				"Mod-Delete": Rl,
			};
		},
		addProseMirrorPlugins() {
			return [
				...(this.options.resizable && this.editor.isEditable
					? [
							t5({
								handleWidth: this.options.handleWidth,
								cellMinWidth: this.options.cellMinWidth,
								View: this.options.View,
								lastColumnResizable:
									this.options.lastColumnResizable,
							}),
					  ]
					: []),
				T5({
					allowTableNodeSelection:
						this.options.allowTableNodeSelection,
				}),
			];
		},
		extendNodeSchema(t) {
			const e = { name: t.name, options: t.options, storage: t.storage };
			return { tableRole: Ie(de(t, "tableRole", e)) };
		},
	}),
	N5 = Tt.create({
		name: "tableCell",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		addAttributes() {
			return {
				colspan: { default: 1 },
				rowspan: { default: 1 },
				colwidth: {
					default: null,
					parseHTML: (t) => {
						const e = t.getAttribute("colwidth");
						return e ? [parseInt(e, 10)] : null;
					},
				},
			};
		},
		tableRole: "cell",
		isolating: !0,
		parseHTML() {
			return [{ tag: "td" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["td", Ze(this.options.HTMLAttributes, t), 0];
		},
	}),
	D5 = Tt.create({
		name: "tableHeader",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		addAttributes() {
			return {
				colspan: { default: 1 },
				rowspan: { default: 1 },
				colwidth: {
					default: null,
					parseHTML: (t) => {
						const e = t.getAttribute("colwidth");
						return e ? [parseInt(e, 10)] : null;
					},
				},
			};
		},
		tableRole: "header_cell",
		isolating: !0,
		parseHTML() {
			return [{ tag: "th" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["th", Ze(this.options.HTMLAttributes, t), 0];
		},
	}),
	j5 = Tt.create({
		name: "tableRow",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "(tableCell | tableHeader)*",
		tableRole: "row",
		parseHTML() {
			return [{ tag: "tr" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["tr", Ze(this.options.HTMLAttributes, t), 0];
		},
	}),
	Yg = (t) =>
		new Promise((e) => {
			let n = new FileReader();
			(n.onloadend = () => {
				e(n.result);
			}),
				n.readAsDataURL(t);
		}),
	L5 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
	$5 = Tt.create({
		name: "image",
		addOptions() {
			return { inline: !1, HTMLAttributes: {} };
		},
		inline() {
			return this.options.inline;
		},
		group() {
			return this.options.inline ? "inline" : "block";
		},
		draggable: !0,
		addAttributes() {
			return {
				src: { default: null },
				alt: { default: null },
				title: { default: null },
			};
		},
		parseHTML() {
			return [{ tag: "img[src]" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["img", Ze(this.options.HTMLAttributes, t)];
		},
		addCommands() {
			return {
				setImage:
					(t) =>
					({ commands: e }) =>
						e.insertContent({ type: this.name, attrs: t }),
			};
		},
		addInputRules() {
			return [
				s2({
					find: L5,
					type: this.type,
					getAttributes: (t) => {
						const [, , e, n, r] = t;
						return { src: n, alt: e, title: r };
					},
				}),
			];
		},
		addProseMirrorPlugins() {
			return [B5()];
		},
	}),
	B5 = () =>
		new wt({
			props: {
				handlePaste(t, e, n) {
					var i;
					const r = Array.from(
							((i = e.clipboardData) == null
								? void 0
								: i.items) || []
						),
						{ schema: o } = t.state;
					return (
						r.forEach((s) => {
							const l = s.getAsFile();
							l &&
								s.type.indexOf("image") === 0 &&
								(e.preventDefault(),
								Yg(l).then((a) => {
									const u = o.nodes.image.create({ src: a }),
										c = t.state.tr.replaceSelectionWith(u);
									t.dispatch(c);
								}));
						}),
						!1
					);
				},
				handleDOMEvents: {
					drop: (t, e) => {
						var s, l;
						if (
							!(
								e.dataTransfer &&
								e.dataTransfer.files &&
								e.dataTransfer.files.length
							)
						)
							return !1;
						const r = Array.from(
							(l =
								(s = e.dataTransfer) == null
									? void 0
									: s.files) != null
								? l
								: []
						).filter((a) => /image/i.test(a.type));
						if (r.length === 0) return !1;
						e.preventDefault();
						const { schema: o } = t.state,
							i = t.posAtCoords({
								left: e.clientX,
								top: e.clientY,
							});
						return i
							? (r.forEach((a) =>
									hr(void 0, null, function* () {
										Yg(a).then((u) => {
											const c = o.nodes.image.create({
													src: u,
												}),
												d = t.state.tr.insert(i.pos, c);
											t.dispatch(d);
										});
									})
							  ),
							  !0)
							: !1;
					},
				},
			},
		}),
	z5 = Tt.create({
		name: "video",
		group: "block",
		selectable: !0,
		draggable: !0,
		atom: !0,
		addAttributes() {
			return { src: { default: null } };
		},
		parseHTML() {
			return [{ tag: "video" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["video", Ze(t)];
		},
		addNodeView() {
			return ({ editor: t, node: e }) => {
				const n = document.createElement("div");
				n.className =
					"relative aspect-w-16 aspect-h-9" +
					(t.isEditable ? " cursor-pointer" : "");
				const r = document.createElement("video");
				if (
					(t.isEditable && (r.className = "pointer-events-none"),
					(r.src = e.attrs.src),
					!t.isEditable)
				)
					r.setAttribute("controls", "");
				else {
					let o = document.createElement("div");
					(o.className =
						"absolute top-0 right-0 text-xs m-2 bg-gray-800 text-white px-2 py-1 rounded-md"),
						(o.innerHTML = "Video"),
						n.append(o);
				}
				return n.append(r), { dom: n };
			};
		},
	}),
	H5 =
		"aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
	F5 =
		"121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
	Ii = (t, e) => {
		for (const n in e) t[n] = e[n];
		return t;
	},
	Zd = "numeric",
	ef = "ascii",
	tf = "alpha",
	Gl = "asciinumeric",
	Pl = "alphanumeric",
	nf = "domain",
	O2 = "emoji",
	V5 = "scheme",
	W5 = "slashscheme",
	Qg = "whitespace";
function U5(t, e) {
	return t in e || (e[t] = []), e[t];
}
function To(t, e, n) {
	e[Zd] && ((e[Gl] = !0), (e[Pl] = !0)),
		e[ef] && ((e[Gl] = !0), (e[tf] = !0)),
		e[Gl] && (e[Pl] = !0),
		e[tf] && (e[Pl] = !0),
		e[Pl] && (e[nf] = !0),
		e[O2] && (e[nf] = !0);
	for (const r in e) {
		const o = U5(r, n);
		o.indexOf(t) < 0 && o.push(t);
	}
}
function K5(t, e) {
	const n = {};
	for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
	return n;
}
function sn(t) {
	t === void 0 && (t = null),
		(this.j = {}),
		(this.jr = []),
		(this.jd = null),
		(this.t = t);
}
sn.groups = {};
sn.prototype = {
	accepts() {
		return !!this.t;
	},
	go(t) {
		const e = this,
			n = e.j[t];
		if (n) return n;
		for (let r = 0; r < e.jr.length; r++) {
			const o = e.jr[r][0],
				i = e.jr[r][1];
			if (i && o.test(t)) return i;
		}
		return e.jd;
	},
	has(t, e) {
		return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
	},
	ta(t, e, n, r) {
		for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
	},
	tr(t, e, n, r) {
		r = r || sn.groups;
		let o;
		return (
			e && e.j ? (o = e) : ((o = new sn(e)), n && r && To(e, n, r)),
			this.jr.push([t, o]),
			o
		);
	},
	ts(t, e, n, r) {
		let o = this;
		const i = t.length;
		if (!i) return o;
		for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
		return o.tt(t[i - 1], e, n, r);
	},
	tt(t, e, n, r) {
		r = r || sn.groups;
		const o = this;
		if (e && e.j) return (o.j[t] = e), e;
		const i = e;
		let s,
			l = o.go(t);
		if (
			(l
				? ((s = new sn()),
				  Ii(s.j, l.j),
				  s.jr.push.apply(s.jr, l.jr),
				  (s.jd = l.jd),
				  (s.t = l.t))
				: (s = new sn()),
			i)
		) {
			if (r)
				if (s.t && typeof s.t == "string") {
					const a = Ii(K5(s.t, r), n);
					To(i, a, r);
				} else n && To(i, n, r);
			s.t = i;
		}
		return (o.j[t] = s), s;
	},
};
const ze = (t, e, n, r, o) => t.ta(e, n, r, o),
	xn = (t, e, n, r, o) => t.tr(e, n, r, o),
	Xg = (t, e, n, r, o) => t.ts(e, n, r, o),
	oe = (t, e, n, r, o) => t.tt(e, n, r, o),
	vr = "WORD",
	rf = "UWORD",
	Hs = "LOCALHOST",
	of = "TLD",
	sf = "UTLD",
	Yl = "SCHEME",
	oi = "SLASH_SCHEME",
	Th = "NUM",
	R2 = "WS",
	Ah = "NL",
	ms = "OPENBRACE",
	gs = "CLOSEBRACE",
	Pa = "OPENBRACKET",
	Ia = "CLOSEBRACKET",
	Na = "OPENPAREN",
	Da = "CLOSEPAREN",
	ja = "OPENANGLEBRACKET",
	La = "CLOSEANGLEBRACKET",
	$a = "FULLWIDTHLEFTPAREN",
	Ba = "FULLWIDTHRIGHTPAREN",
	za = "LEFTCORNERBRACKET",
	Ha = "RIGHTCORNERBRACKET",
	Fa = "LEFTWHITECORNERBRACKET",
	Va = "RIGHTWHITECORNERBRACKET",
	Wa = "FULLWIDTHLESSTHAN",
	Ua = "FULLWIDTHGREATERTHAN",
	Ka = "AMPERSAND",
	qa = "APOSTROPHE",
	Ja = "ASTERISK",
	Fr = "AT",
	Ga = "BACKSLASH",
	Ya = "BACKTICK",
	Qa = "CARET",
	Kr = "COLON",
	Oh = "COMMA",
	Xa = "DOLLAR",
	Jn = "DOT",
	Za = "EQUALS",
	Rh = "EXCLAMATION",
	Gn = "HYPHEN",
	eu = "PERCENT",
	tu = "PIPE",
	nu = "PLUS",
	ru = "POUND",
	ou = "QUERY",
	Ph = "QUOTE",
	Ih = "SEMI",
	Yn = "SLASH",
	ys = "TILDE",
	iu = "UNDERSCORE",
	P2 = "EMOJI",
	su = "SYM";
var I2 = Object.freeze({
	__proto__: null,
	WORD: vr,
	UWORD: rf,
	LOCALHOST: Hs,
	TLD: of,
	UTLD: sf,
	SCHEME: Yl,
	SLASH_SCHEME: oi,
	NUM: Th,
	WS: R2,
	NL: Ah,
	OPENBRACE: ms,
	CLOSEBRACE: gs,
	OPENBRACKET: Pa,
	CLOSEBRACKET: Ia,
	OPENPAREN: Na,
	CLOSEPAREN: Da,
	OPENANGLEBRACKET: ja,
	CLOSEANGLEBRACKET: La,
	FULLWIDTHLEFTPAREN: $a,
	FULLWIDTHRIGHTPAREN: Ba,
	LEFTCORNERBRACKET: za,
	RIGHTCORNERBRACKET: Ha,
	LEFTWHITECORNERBRACKET: Fa,
	RIGHTWHITECORNERBRACKET: Va,
	FULLWIDTHLESSTHAN: Wa,
	FULLWIDTHGREATERTHAN: Ua,
	AMPERSAND: Ka,
	APOSTROPHE: qa,
	ASTERISK: Ja,
	AT: Fr,
	BACKSLASH: Ga,
	BACKTICK: Ya,
	CARET: Qa,
	COLON: Kr,
	COMMA: Oh,
	DOLLAR: Xa,
	DOT: Jn,
	EQUALS: Za,
	EXCLAMATION: Rh,
	HYPHEN: Gn,
	PERCENT: eu,
	PIPE: tu,
	PLUS: nu,
	POUND: ru,
	QUERY: ou,
	QUOTE: Ph,
	SEMI: Ih,
	SLASH: Yn,
	TILDE: ys,
	UNDERSCORE: iu,
	EMOJI: P2,
	SYM: su,
});
const Xo = /[a-z]/,
	Wc = new RegExp("\\p{L}", "u"),
	Uc = new RegExp("\\p{Emoji}", "u"),
	Kc = /\d/,
	Zg = /\s/,
	e1 = `
`,
	q5 = "",
	J5 = "";
let Il = null,
	Nl = null;
function G5(t) {
	t === void 0 && (t = []);
	const e = {};
	sn.groups = e;
	const n = new sn();
	Il == null && (Il = t1(H5)),
		Nl == null && (Nl = t1(F5)),
		oe(n, "'", qa),
		oe(n, "{", ms),
		oe(n, "}", gs),
		oe(n, "[", Pa),
		oe(n, "]", Ia),
		oe(n, "(", Na),
		oe(n, ")", Da),
		oe(n, "<", ja),
		oe(n, ">", La),
		oe(n, "", $a),
		oe(n, "", Ba),
		oe(n, "", za),
		oe(n, "", Ha),
		oe(n, "", Fa),
		oe(n, "", Va),
		oe(n, "", Wa),
		oe(n, "", Ua),
		oe(n, "&", Ka),
		oe(n, "*", Ja),
		oe(n, "@", Fr),
		oe(n, "`", Ya),
		oe(n, "^", Qa),
		oe(n, ":", Kr),
		oe(n, ",", Oh),
		oe(n, "$", Xa),
		oe(n, ".", Jn),
		oe(n, "=", Za),
		oe(n, "!", Rh),
		oe(n, "-", Gn),
		oe(n, "%", eu),
		oe(n, "|", tu),
		oe(n, "+", nu),
		oe(n, "#", ru),
		oe(n, "?", ou),
		oe(n, '"', Ph),
		oe(n, "/", Yn),
		oe(n, ";", Ih),
		oe(n, "~", ys),
		oe(n, "_", iu),
		oe(n, "\\", Ga);
	const r = xn(n, Kc, Th, { [Zd]: !0 });
	xn(r, Kc, r);
	const o = xn(n, Xo, vr, { [ef]: !0 });
	xn(o, Xo, o);
	const i = xn(n, Wc, rf, { [tf]: !0 });
	xn(i, Xo), xn(i, Wc, i);
	const s = xn(n, Zg, R2, { [Qg]: !0 });
	oe(n, e1, Ah, { [Qg]: !0 }), oe(s, e1), xn(s, Zg, s);
	const l = xn(n, Uc, P2, { [O2]: !0 });
	xn(l, Uc, l), oe(l, q5, l);
	const a = oe(l, J5);
	xn(a, Uc, l);
	const u = [[Xo, o]],
		c = [
			[Xo, null],
			[Wc, i],
		];
	for (let d = 0; d < Il.length; d++) Pr(n, Il[d], of, vr, u);
	for (let d = 0; d < Nl.length; d++) Pr(n, Nl[d], sf, rf, c);
	To(of, { tld: !0, ascii: !0 }, e),
		To(sf, { utld: !0, alpha: !0 }, e),
		Pr(n, "file", Yl, vr, u),
		Pr(n, "mailto", Yl, vr, u),
		Pr(n, "http", oi, vr, u),
		Pr(n, "https", oi, vr, u),
		Pr(n, "ftp", oi, vr, u),
		Pr(n, "ftps", oi, vr, u),
		To(Yl, { scheme: !0, ascii: !0 }, e),
		To(oi, { slashscheme: !0, ascii: !0 }, e),
		(t = t.sort((d, h) => (d[0] > h[0] ? 1 : -1)));
	for (let d = 0; d < t.length; d++) {
		const h = t[d][0],
			g = t[d][1] ? { [V5]: !0 } : { [W5]: !0 };
		h.indexOf("-") >= 0
			? (g[nf] = !0)
			: Xo.test(h)
			? Kc.test(h)
				? (g[Gl] = !0)
				: (g[ef] = !0)
			: (g[Zd] = !0),
			Xg(n, h, h, g);
	}
	return (
		Xg(n, "localhost", Hs, { ascii: !0 }),
		(n.jd = new sn(su)),
		{ start: n, tokens: Ii({ groups: e }, I2) }
	);
}
function Y5(t, e) {
	const n = Q5(e.replace(/[A-Z]/g, (l) => l.toLowerCase())),
		r = n.length,
		o = [];
	let i = 0,
		s = 0;
	for (; s < r; ) {
		let l = t,
			a = null,
			u = 0,
			c = null,
			d = -1,
			h = -1;
		for (; s < r && (a = l.go(n[s])); )
			(l = a),
				l.accepts()
					? ((d = 0), (h = 0), (c = l))
					: d >= 0 && ((d += n[s].length), h++),
				(u += n[s].length),
				(i += n[s].length),
				s++;
		(i -= d),
			(s -= h),
			(u -= d),
			o.push({ t: c.t, v: e.slice(i - u, i), s: i - u, e: i });
	}
	return o;
}
function Q5(t) {
	const e = [],
		n = t.length;
	let r = 0;
	for (; r < n; ) {
		let o = t.charCodeAt(r),
			i,
			s =
				o < 55296 ||
				o > 56319 ||
				r + 1 === n ||
				(i = t.charCodeAt(r + 1)) < 56320 ||
				i > 57343
					? t[r]
					: t.slice(r, r + 2);
		e.push(s), (r += s.length);
	}
	return e;
}
function Pr(t, e, n, r, o) {
	let i;
	const s = e.length;
	for (let l = 0; l < s - 1; l++) {
		const a = e[l];
		t.j[a]
			? (i = t.j[a])
			: ((i = new sn(r)), (i.jr = o.slice()), (t.j[a] = i)),
			(t = i);
	}
	return (i = new sn(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
}
function t1(t) {
	const e = [],
		n = [];
	let r = 0,
		o = "0123456789";
	for (; r < t.length; ) {
		let i = 0;
		for (; o.indexOf(t[r + i]) >= 0; ) i++;
		if (i > 0) {
			e.push(n.join(""));
			for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--)
				n.pop();
			r += i;
		} else n.push(t[r]), r++;
	}
	return e;
}
const Fs = {
	defaultProtocol: "http",
	events: null,
	format: n1,
	formatHref: n1,
	nl2br: !1,
	tagName: "a",
	target: null,
	rel: null,
	validate: !0,
	truncate: 1 / 0,
	className: null,
	attributes: null,
	ignoreTags: [],
	render: null,
};
function Nh(t, e) {
	e === void 0 && (e = null);
	let n = Ii({}, Fs);
	t && (n = Ii(n, t instanceof Nh ? t.o : t));
	const r = n.ignoreTags,
		o = [];
	for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
	(this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
}
Nh.prototype = {
	o: Fs,
	ignoreTags: [],
	defaultRender(t) {
		return t;
	},
	check(t) {
		return this.get("validate", t.toString(), t);
	},
	get(t, e, n) {
		const r = e != null;
		let o = this.o[t];
		return (
			o &&
			(typeof o == "object"
				? ((o = n.t in o ? o[n.t] : Fs[t]),
				  typeof o == "function" && r && (o = o(e, n)))
				: typeof o == "function" && r && (o = o(e, n.t, n)),
			o)
		);
	},
	getObj(t, e, n) {
		let r = this.o[t];
		return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
	},
	render(t) {
		const e = t.render(this);
		return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
	},
};
function n1(t) {
	return t;
}
function N2(t, e) {
	(this.t = "token"), (this.v = t), (this.tk = e);
}
N2.prototype = {
	isLink: !1,
	toString() {
		return this.v;
	},
	toHref(t) {
		return this.toString();
	},
	toFormattedString(t) {
		const e = this.toString(),
			n = t.get("truncate", e, this),
			r = t.get("format", e, this);
		return n && r.length > n ? r.substring(0, n) + "" : r;
	},
	toFormattedHref(t) {
		return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
	},
	startIndex() {
		return this.tk[0].s;
	},
	endIndex() {
		return this.tk[this.tk.length - 1].e;
	},
	toObject(t) {
		return (
			t === void 0 && (t = Fs.defaultProtocol),
			{
				type: this.t,
				value: this.toString(),
				isLink: this.isLink,
				href: this.toHref(t),
				start: this.startIndex(),
				end: this.endIndex(),
			}
		);
	},
	toFormattedObject(t) {
		return {
			type: this.t,
			value: this.toFormattedString(t),
			isLink: this.isLink,
			href: this.toFormattedHref(t),
			start: this.startIndex(),
			end: this.endIndex(),
		};
	},
	validate(t) {
		return t.get("validate", this.toString(), this);
	},
	render(t) {
		const e = this,
			n = this.toHref(t.get("defaultProtocol")),
			r = t.get("formatHref", n, this),
			o = t.get("tagName", n, e),
			i = this.toFormattedString(t),
			s = {},
			l = t.get("className", n, e),
			a = t.get("target", n, e),
			u = t.get("rel", n, e),
			c = t.getObj("attributes", n, e),
			d = t.getObj("events", n, e);
		return (
			(s.href = r),
			l && (s.class = l),
			a && (s.target = a),
			u && (s.rel = u),
			c && Ii(s, c),
			{ tagName: o, attributes: s, content: i, eventListeners: d }
		);
	},
};
function Ku(t, e) {
	class n extends N2 {
		constructor(o, i) {
			super(o, i), (this.t = t);
		}
	}
	for (const r in e) n.prototype[r] = e[r];
	return (n.t = t), n;
}
const r1 = Ku("email", {
		isLink: !0,
		toHref() {
			return "mailto:" + this.toString();
		},
	}),
	o1 = Ku("text"),
	X5 = Ku("nl"),
	Dl = Ku("url", {
		isLink: !0,
		toHref(t) {
			return (
				t === void 0 && (t = Fs.defaultProtocol),
				this.hasProtocol() ? this.v : `${t}://${this.v}`
			);
		},
		hasProtocol() {
			const t = this.tk;
			return t.length >= 2 && t[0].t !== Hs && t[1].t === Kr;
		},
	}),
	kn = (t) => new sn(t);
function Z5(t) {
	let { groups: e } = t;
	const n = e.domain.concat([
			Ka,
			Ja,
			Fr,
			Ga,
			Ya,
			Qa,
			Xa,
			Za,
			Gn,
			Th,
			eu,
			tu,
			nu,
			ru,
			Yn,
			su,
			ys,
			iu,
		]),
		r = [
			qa,
			Kr,
			Oh,
			Jn,
			Rh,
			ou,
			Ph,
			Ih,
			ja,
			La,
			ms,
			gs,
			Ia,
			Pa,
			Na,
			Da,
			$a,
			Ba,
			za,
			Ha,
			Fa,
			Va,
			Wa,
			Ua,
		],
		o = [
			Ka,
			qa,
			Ja,
			Ga,
			Ya,
			Qa,
			Xa,
			Za,
			Gn,
			ms,
			gs,
			eu,
			tu,
			nu,
			ru,
			ou,
			Yn,
			su,
			ys,
			iu,
		],
		i = kn(),
		s = oe(i, ys);
	ze(s, o, s), ze(s, e.domain, s);
	const l = kn(),
		a = kn(),
		u = kn();
	ze(i, e.domain, l),
		ze(i, e.scheme, a),
		ze(i, e.slashscheme, u),
		ze(l, o, s),
		ze(l, e.domain, l);
	const c = oe(l, Fr);
	oe(s, Fr, c), oe(a, Fr, c), oe(u, Fr, c);
	const d = oe(s, Jn);
	ze(d, o, s), ze(d, e.domain, s);
	const h = kn();
	ze(c, e.domain, h), ze(h, e.domain, h);
	const p = oe(h, Jn);
	ze(p, e.domain, h);
	const g = kn(r1);
	ze(p, e.tld, g), ze(p, e.utld, g), oe(c, Hs, g);
	const y = oe(h, Gn);
	ze(y, e.domain, h), ze(g, e.domain, h), oe(g, Jn, p), oe(g, Gn, y);
	const b = oe(g, Kr);
	ze(b, e.numeric, r1);
	const w = oe(l, Gn),
		S = oe(l, Jn);
	ze(w, e.domain, l), ze(S, o, s), ze(S, e.domain, l);
	const E = kn(Dl);
	ze(S, e.tld, E),
		ze(S, e.utld, E),
		ze(E, e.domain, l),
		ze(E, o, s),
		oe(E, Jn, S),
		oe(E, Gn, w),
		oe(E, Fr, c);
	const f = oe(E, Kr),
		v = kn(Dl);
	ze(f, e.numeric, v);
	const m = kn(Dl),
		x = kn();
	ze(m, n, m),
		ze(m, r, x),
		ze(x, n, m),
		ze(x, r, x),
		oe(E, Yn, m),
		oe(v, Yn, m);
	const k = oe(a, Kr),
		C = oe(u, Kr),
		_ = oe(C, Yn),
		T = oe(_, Yn);
	ze(a, e.domain, l),
		oe(a, Jn, S),
		oe(a, Gn, w),
		ze(u, e.domain, l),
		oe(u, Jn, S),
		oe(u, Gn, w),
		ze(k, e.domain, m),
		oe(k, Yn, m),
		ze(T, e.domain, m),
		ze(T, n, m),
		oe(T, Yn, m);
	const R = [
		[ms, gs],
		[Pa, Ia],
		[Na, Da],
		[ja, La],
		[$a, Ba],
		[za, Ha],
		[Fa, Va],
		[Wa, Ua],
	];
	for (let P = 0; P < R.length; P++) {
		const [N, D] = R[P],
			M = oe(m, N);
		oe(x, N, M), oe(M, D, m);
		const I = kn(Dl);
		ze(M, n, I);
		const $ = kn();
		ze(M, r),
			ze(I, n, I),
			ze(I, r, $),
			ze($, n, I),
			ze($, r, $),
			oe(I, D, m),
			oe($, D, m);
	}
	return oe(i, Hs, E), oe(i, Ah, X5), { start: i, tokens: I2 };
}
function e6(t, e, n) {
	let r = n.length,
		o = 0,
		i = [],
		s = [];
	for (; o < r; ) {
		let l = t,
			a = null,
			u = null,
			c = 0,
			d = null,
			h = -1;
		for (; o < r && !(a = l.go(n[o].t)); ) s.push(n[o++]);
		for (; o < r && (u = a || l.go(n[o].t)); )
			(a = null),
				(l = u),
				l.accepts() ? ((h = 0), (d = l)) : h >= 0 && h++,
				o++,
				c++;
		if (h < 0) (o -= c), o < r && (s.push(n[o]), o++);
		else {
			s.length > 0 && (i.push(qc(o1, e, s)), (s = [])),
				(o -= h),
				(c -= h);
			const p = d.t,
				g = n.slice(o - c, o);
			i.push(qc(p, e, g));
		}
	}
	return s.length > 0 && i.push(qc(o1, e, s)), i;
}
function qc(t, e, n) {
	const r = n[0].s,
		o = n[n.length - 1].e,
		i = e.slice(r, o);
	return new t(i, n);
}
const t6 =
		(typeof console != "undefined" && console && console.warn) ||
		(() => {}),
	n6 =
		"until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
	ht = {
		scanner: null,
		parser: null,
		tokenQueue: [],
		pluginQueue: [],
		customSchemes: [],
		initialized: !1,
	};
function r6() {
	(sn.groups = {}),
		(ht.scanner = null),
		(ht.parser = null),
		(ht.tokenQueue = []),
		(ht.pluginQueue = []),
		(ht.customSchemes = []),
		(ht.initialized = !1);
}
function i1(t, e) {
	if (
		(e === void 0 && (e = !1),
		ht.initialized &&
			t6(
				`linkifyjs: already initialized - will not register custom scheme "${t}" ${n6}`
			),
		!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
	)
		throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
	ht.customSchemes.push([t, e]);
}
function o6() {
	ht.scanner = G5(ht.customSchemes);
	for (let t = 0; t < ht.tokenQueue.length; t++)
		ht.tokenQueue[t][1]({ scanner: ht.scanner });
	ht.parser = Z5(ht.scanner.tokens);
	for (let t = 0; t < ht.pluginQueue.length; t++)
		ht.pluginQueue[t][1]({ scanner: ht.scanner, parser: ht.parser });
	ht.initialized = !0;
}
function i6(t) {
	return (
		ht.initialized || o6(), e6(ht.parser.start, t, Y5(ht.scanner.start, t))
	);
}
function Dh(t, e, n) {
	if (
		(e === void 0 && (e = null),
		n === void 0 && (n = null),
		e && typeof e == "object")
	) {
		if (n)
			throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
		(n = e), (e = null);
	}
	const r = new Nh(n),
		o = i6(t),
		i = [];
	for (let s = 0; s < o.length; s++) {
		const l = o[s];
		l.isLink &&
			(!e || l.t === e) &&
			r.check(l) &&
			i.push(l.toFormattedObject(r));
	}
	return i;
}
function s6(t) {
	return new wt({
		key: new Rt("autolink"),
		appendTransaction: (e, n, r) => {
			const o = e.some((u) => u.docChanged) && !n.doc.eq(r.doc),
				i = e.some((u) => u.getMeta("preventAutolink"));
			if (!o || i) return;
			const { tr: s } = r,
				l = dA(n.doc, [...e]);
			if (
				(bA(l).forEach(({ newRange: u }) => {
					const c = hA(r.doc, u, (p) => p.isTextblock);
					let d, h;
					if (
						(c.length > 1
							? ((d = c[0]),
							  (h = r.doc.textBetween(
									d.pos,
									d.pos + d.node.nodeSize,
									void 0,
									" "
							  )))
							: c.length &&
							  r.doc
									.textBetween(u.from, u.to, " ", " ")
									.endsWith(" ") &&
							  ((d = c[0]),
							  (h = r.doc.textBetween(
									d.pos,
									u.to,
									void 0,
									" "
							  ))),
						d && h)
					) {
						const p = h.split(" ").filter((b) => b !== "");
						if (p.length <= 0) return !1;
						const g = p[p.length - 1],
							y = d.pos + h.lastIndexOf(g);
						if (!g) return !1;
						Dh(g)
							.filter((b) => b.isLink)
							.map((b) =>
								ye(z({}, b), {
									from: y + b.start + 1,
									to: y + b.end + 1,
								})
							)
							.filter((b) =>
								r.schema.marks.code
									? !r.doc.rangeHasMark(
											b.from,
											b.to,
											r.schema.marks.code
									  )
									: !0
							)
							.filter((b) =>
								t.validate ? t.validate(b.value) : !0
							)
							.forEach((b) => {
								_h(b.from, b.to, r.doc).some(
									(w) => w.mark.type === t.type
								) ||
									s.addMark(
										b.from,
										b.to,
										t.type.create({ href: b.href })
									);
							});
					}
				}),
				!!s.steps.length)
			)
				return s;
		},
	});
}
function l6(t) {
	return new wt({
		key: new Rt("handleClickLink"),
		props: {
			handleClick: (e, n, r) => {
				var o, i;
				if (r.button !== 0 || r.target.nodeName !== "A") return !1;
				const l = o2(e.state, t.type.name),
					a = r.target,
					u =
						(o = a == null ? void 0 : a.href) !== null &&
						o !== void 0
							? o
							: l.href,
					c =
						(i = a == null ? void 0 : a.target) !== null &&
						i !== void 0
							? i
							: l.target;
				return a && u ? (e.editable && window.open(u, c), !0) : !1;
			},
		},
	});
}
function a6(t) {
	return new wt({
		key: new Rt("handlePasteLink"),
		props: {
			handlePaste: (e, n, r) => {
				const { state: o } = e,
					{ selection: i } = o,
					{ empty: s } = i;
				if (s) return !1;
				let l = "";
				r.content.forEach((u) => {
					l += u.textContent;
				});
				const a = Dh(l).find((u) => u.isLink && u.value === l);
				return !l || !a
					? !1
					: (t.editor.commands.setMark(t.type, { href: a.href }), !0);
			},
		},
	});
}
const u6 = vn.create({
		name: "link",
		priority: 1e3,
		keepOnSplit: !1,
		onCreate() {
			this.options.protocols.forEach((t) => {
				if (typeof t == "string") {
					i1(t);
					return;
				}
				i1(t.scheme, t.optionalSlashes);
			});
		},
		onDestroy() {
			r6();
		},
		inclusive() {
			return this.options.autolink;
		},
		addOptions() {
			return {
				openOnClick: !0,
				linkOnPaste: !0,
				autolink: !0,
				protocols: [],
				HTMLAttributes: {
					target: "_blank",
					rel: "noopener noreferrer nofollow",
					class: null,
				},
				validate: void 0,
			};
		},
		addAttributes() {
			return {
				href: { default: null },
				target: { default: this.options.HTMLAttributes.target },
				rel: { default: this.options.HTMLAttributes.rel },
				class: { default: this.options.HTMLAttributes.class },
			};
		},
		parseHTML() {
			return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			var e;
			return !((e = t.href) === null || e === void 0) &&
				e.startsWith("javascript:")
				? [
						"a",
						Ze(
							this.options.HTMLAttributes,
							ye(z({}, t), { href: "" })
						),
						0,
				  ]
				: ["a", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setLink:
					(t) =>
					({ chain: e }) =>
						e()
							.setMark(this.name, t)
							.setMeta("preventAutolink", !0)
							.run(),
				toggleLink:
					(t) =>
					({ chain: e }) =>
						e()
							.toggleMark(this.name, t, {
								extendEmptyMarkRange: !0,
							})
							.setMeta("preventAutolink", !0)
							.run(),
				unsetLink:
					() =>
					({ chain: t }) =>
						t()
							.unsetMark(this.name, { extendEmptyMarkRange: !0 })
							.setMeta("preventAutolink", !0)
							.run(),
			};
		},
		addPasteRules() {
			return [
				so({
					find: (t, e) => {
						var n;
						const r =
								(n = e == null ? void 0 : e.clipboardData) ===
									null || n === void 0
									? void 0
									: n.getData("text/html"),
							o = [];
						if (r) {
							const i = new DOMParser().parseFromString(
									r,
									"text/html"
								),
								s = i.querySelectorAll("a");
							s.length &&
								[...s].forEach((l) =>
									o.push({
										text: l.innerText,
										data: { href: l.getAttribute("href") },
										index:
											i.body.innerText.indexOf(
												l.innerText
											) + l.innerText.length,
									})
								);
						}
						if (t) {
							const i = Dh(t).filter((s) => s.isLink);
							i.length &&
								i.forEach((s) =>
									o.push({
										text: s.value,
										data: { href: s.href },
										index: s.start,
									})
								);
						}
						return o;
					},
					type: this.type,
					getAttributes: (t) => {
						var e;
						return {
							href:
								(e = t.data) === null || e === void 0
									? void 0
									: e.href,
						};
					},
				}),
			];
		},
		addProseMirrorPlugins() {
			const t = [];
			return (
				this.options.autolink &&
					t.push(
						s6({ type: this.type, validate: this.options.validate })
					),
				this.options.openOnClick && t.push(l6({ type: this.type })),
				this.options.linkOnPaste &&
					t.push(a6({ editor: this.editor, type: this.type })),
				t
			);
		},
	}),
	c6 = (t) => xt({ find: /--$/, replace: t != null ? t : "" }),
	d6 = (t) => xt({ find: /\.\.\.$/, replace: t != null ? t : "" }),
	f6 = (t) =>
		xt({
			find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
			replace: t != null ? t : "",
		}),
	h6 = (t) => xt({ find: /"$/, replace: t != null ? t : "" }),
	p6 = (t) =>
		xt({
			find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
			replace: t != null ? t : "",
		}),
	m6 = (t) => xt({ find: /'$/, replace: t != null ? t : "" }),
	g6 = (t) => xt({ find: /<-$/, replace: t != null ? t : "" }),
	y6 = (t) => xt({ find: /->$/, replace: t != null ? t : "" }),
	v6 = (t) => xt({ find: /\(c\)$/, replace: t != null ? t : "" }),
	b6 = (t) => xt({ find: /\(tm\)$/, replace: t != null ? t : "" }),
	w6 = (t) => xt({ find: /\(sm\)$/, replace: t != null ? t : "" }),
	x6 = (t) => xt({ find: /\(r\)$/, replace: t != null ? t : "" }),
	k6 = (t) => xt({ find: /(?:^|\s)(1\/2)\s$/, replace: t != null ? t : "" }),
	S6 = (t) => xt({ find: /\+\/-$/, replace: t != null ? t : "" }),
	_6 = (t) => xt({ find: /!=$/, replace: t != null ? t : "" }),
	C6 = (t) => xt({ find: /<<$/, replace: t != null ? t : "" }),
	M6 = (t) => xt({ find: />>$/, replace: t != null ? t : "" }),
	E6 = (t) =>
		xt({ find: /\d+\s?([*x])\s?\d+$/, replace: t != null ? t : "" }),
	T6 = (t) => xt({ find: /\^2$/, replace: t != null ? t : "" }),
	A6 = (t) => xt({ find: /\^3$/, replace: t != null ? t : "" }),
	O6 = (t) => xt({ find: /(?:^|\s)(1\/4)\s$/, replace: t != null ? t : "" }),
	R6 = (t) => xt({ find: /(?:^|\s)(3\/4)\s$/, replace: t != null ? t : "" }),
	P6 = Ot.create({
		name: "typography",
		addInputRules() {
			const t = [];
			return (
				this.options.emDash !== !1 && t.push(c6(this.options.emDash)),
				this.options.ellipsis !== !1 &&
					t.push(d6(this.options.ellipsis)),
				this.options.openDoubleQuote !== !1 &&
					t.push(f6(this.options.openDoubleQuote)),
				this.options.closeDoubleQuote !== !1 &&
					t.push(h6(this.options.closeDoubleQuote)),
				this.options.openSingleQuote !== !1 &&
					t.push(p6(this.options.openSingleQuote)),
				this.options.closeSingleQuote !== !1 &&
					t.push(m6(this.options.closeSingleQuote)),
				this.options.leftArrow !== !1 &&
					t.push(g6(this.options.leftArrow)),
				this.options.rightArrow !== !1 &&
					t.push(y6(this.options.rightArrow)),
				this.options.copyright !== !1 &&
					t.push(v6(this.options.copyright)),
				this.options.trademark !== !1 &&
					t.push(b6(this.options.trademark)),
				this.options.servicemark !== !1 &&
					t.push(w6(this.options.servicemark)),
				this.options.registeredTrademark !== !1 &&
					t.push(x6(this.options.registeredTrademark)),
				this.options.oneHalf !== !1 && t.push(k6(this.options.oneHalf)),
				this.options.plusMinus !== !1 &&
					t.push(S6(this.options.plusMinus)),
				this.options.notEqual !== !1 &&
					t.push(_6(this.options.notEqual)),
				this.options.laquo !== !1 && t.push(C6(this.options.laquo)),
				this.options.raquo !== !1 && t.push(M6(this.options.raquo)),
				this.options.multiplication !== !1 &&
					t.push(E6(this.options.multiplication)),
				this.options.superscriptTwo !== !1 &&
					t.push(T6(this.options.superscriptTwo)),
				this.options.superscriptThree !== !1 &&
					t.push(A6(this.options.superscriptThree)),
				this.options.oneQuarter !== !1 &&
					t.push(O6(this.options.oneQuarter)),
				this.options.threeQuarters !== !1 &&
					t.push(R6(this.options.threeQuarters)),
				t
			);
		},
	}),
	I6 = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = nl(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	N6 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,
	D6 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g,
	j6 = vn.create({
		name: "highlight",
		addOptions() {
			return { multicolor: !1, HTMLAttributes: {} };
		},
		addAttributes() {
			return this.options.multicolor
				? {
						color: {
							default: null,
							parseHTML: (t) =>
								t.getAttribute("data-color") ||
								t.style.backgroundColor,
							renderHTML: (t) =>
								t.color
									? {
											"data-color": t.color,
											style: `background-color: ${t.color}; color: inherit`,
									  }
									: {},
						},
				  }
				: {};
		},
		parseHTML() {
			return [{ tag: "mark" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["mark", Ze(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setHighlight:
					(t) =>
					({ commands: e }) =>
						e.setMark(this.name, t),
				toggleHighlight:
					(t) =>
					({ commands: e }) =>
						e.toggleMark(this.name, t),
				unsetHighlight:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-h": () => this.editor.commands.toggleHighlight(),
			};
		},
		addInputRules() {
			return [Fo({ find: N6, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: D6, type: this.type })];
		},
	}),
	L6 = Ot.create({
		name: "color",
		addOptions() {
			return { types: ["textStyle"] };
		},
		addGlobalAttributes() {
			return [
				{
					types: this.options.types,
					attributes: {
						color: {
							default: null,
							parseHTML: (t) => {
								var e;
								return (e = t.style.color) === null ||
									e === void 0
									? void 0
									: e.replace(/['"]+/g, "");
							},
							renderHTML: (t) =>
								t.color ? { style: `color: ${t.color}` } : {},
						},
					},
				},
			];
		},
		addCommands() {
			return {
				setColor:
					(t) =>
					({ chain: e }) =>
						e().setMark("textStyle", { color: t }).run(),
				unsetColor:
					() =>
					({ chain: t }) =>
						t()
							.setMark("textStyle", { color: null })
							.removeEmptyTextStyle()
							.run(),
			};
		},
	});
function $6(t) {
	var e;
	const {
			char: n,
			allowSpaces: r,
			allowedPrefixes: o,
			startOfLine: i,
			$position: s,
		} = t,
		l = XA(n),
		a = new RegExp(`\\s${l}$`),
		u = i ? "^" : "",
		c = r
			? new RegExp(`${u}${l}.*?(?=\\s${l}|$)`, "gm")
			: new RegExp(`${u}(?:^)?${l}[^\\s${l}]*`, "gm"),
		d =
			((e = s.nodeBefore) === null || e === void 0 ? void 0 : e.isText) &&
			s.nodeBefore.text;
	if (!d) return null;
	const h = s.pos - d.length,
		p = Array.from(d.matchAll(c)).pop();
	if (!p || p.input === void 0 || p.index === void 0) return null;
	const g = p.input.slice(Math.max(0, p.index - 1), p.index),
		y = new RegExp(`^[${o == null ? void 0 : o.join("")}\0]?$`).test(g);
	if (o !== null && !y) return null;
	const b = h + p.index;
	let w = b + p[0].length;
	return (
		r && a.test(d.slice(w - 1, w + 1)) && ((p[0] += " "), (w += 1)),
		b < s.pos && w >= s.pos
			? {
					range: { from: b, to: w },
					query: p[0].slice(n.length),
					text: p[0],
			  }
			: null
	);
}
const B6 = new Rt("suggestion");
function z6({
	pluginKey: t = B6,
	editor: e,
	char: n = "@",
	allowSpaces: r = !1,
	allowedPrefixes: o = [" "],
	startOfLine: i = !1,
	decorationTag: s = "span",
	decorationClass: l = "suggestion",
	command: a = () => null,
	items: u = () => [],
	render: c = () => ({}),
	allow: d = () => !0,
}) {
	let h;
	const p = c == null ? void 0 : c(),
		g = new wt({
			key: t,
			view() {
				return {
					update: (y, b) =>
						hr(this, null, function* () {
							var w, S, E, f, v, m, x;
							const k =
									(w = this.key) === null || w === void 0
										? void 0
										: w.getState(b),
								C =
									(S = this.key) === null || S === void 0
										? void 0
										: S.getState(y.state),
								_ =
									k.active &&
									C.active &&
									k.range.from !== C.range.from,
								T = !k.active && C.active,
								R = k.active && !C.active,
								P = !T && !R && k.query !== C.query,
								N = T || _,
								D = P && !_,
								M = R || _;
							if (!N && !D && !M) return;
							const I = M && !N ? k : C,
								$ = y.dom.querySelector(
									`[data-decoration-id="${I.decorationId}"]`
								);
							(h = {
								editor: e,
								range: I.range,
								query: I.query,
								text: I.text,
								items: [],
								command: (V) => {
									a({ editor: e, range: I.range, props: V });
								},
								decorationNode: $,
								clientRect: $
									? () => {
											var V;
											const { decorationId: ie } =
													(V = this.key) === null ||
													V === void 0
														? void 0
														: V.getState(e.state),
												Y = y.dom.querySelector(
													`[data-decoration-id="${ie}"]`
												);
											return (
												(Y == null
													? void 0
													: Y.getBoundingClientRect()) ||
												null
											);
									  }
									: null,
							}),
								N &&
									((E =
										p == null
											? void 0
											: p.onBeforeStart) === null ||
										E === void 0 ||
										E.call(p, h)),
								D &&
									((f =
										p == null
											? void 0
											: p.onBeforeUpdate) === null ||
										f === void 0 ||
										f.call(p, h)),
								(D || N) &&
									(h.items = yield u({
										editor: e,
										query: I.query,
									})),
								M &&
									((v = p == null ? void 0 : p.onExit) ===
										null ||
										v === void 0 ||
										v.call(p, h)),
								D &&
									((m = p == null ? void 0 : p.onUpdate) ===
										null ||
										m === void 0 ||
										m.call(p, h)),
								N &&
									((x = p == null ? void 0 : p.onStart) ===
										null ||
										x === void 0 ||
										x.call(p, h));
						}),
					destroy: () => {
						var y;
						h &&
							((y = p == null ? void 0 : p.onExit) === null ||
								y === void 0 ||
								y.call(p, h));
					},
				};
			},
			state: {
				init() {
					return {
						active: !1,
						range: { from: 0, to: 0 },
						query: null,
						text: null,
						composing: !1,
					};
				},
				apply(y, b, w, S) {
					const { isEditable: E } = e,
						{ composing: f } = e.view,
						{ selection: v } = y,
						{ empty: m, from: x } = v,
						k = z({}, b);
					if (((k.composing = f), E && (m || e.view.composing))) {
						(x < b.range.from || x > b.range.to) &&
							!f &&
							!b.composing &&
							(k.active = !1);
						const C = $6({
								char: n,
								allowSpaces: r,
								allowedPrefixes: o,
								startOfLine: i,
								$position: v.$from,
							}),
							_ = `id_${Math.floor(Math.random() * 4294967295)}`;
						C && d({ editor: e, state: S, range: C.range })
							? ((k.active = !0),
							  (k.decorationId = b.decorationId
									? b.decorationId
									: _),
							  (k.range = C.range),
							  (k.query = C.query),
							  (k.text = C.text))
							: (k.active = !1);
					} else k.active = !1;
					return (
						k.active ||
							((k.decorationId = null),
							(k.range = { from: 0, to: 0 }),
							(k.query = null),
							(k.text = null)),
						k
					);
				},
			},
			props: {
				handleKeyDown(y, b) {
					var w;
					const { active: S, range: E } = g.getState(y.state);
					return (
						(S &&
							((w = p == null ? void 0 : p.onKeyDown) === null ||
							w === void 0
								? void 0
								: w.call(p, {
										view: y,
										event: b,
										range: E,
								  }))) ||
						!1
					);
				},
				decorations(y) {
					const {
						active: b,
						range: w,
						decorationId: S,
					} = g.getState(y);
					return b
						? ft.create(y.doc, [
								Kt.inline(w.from, w.to, {
									nodeName: s,
									class: l,
									"data-decoration-id": S,
								}),
						  ])
						: null;
				},
			},
		});
	return g;
}
const H6 = new Rt("mention"),
	F6 = Tt.create({
		name: "mention",
		addOptions() {
			return {
				HTMLAttributes: {},
				renderLabel({ options: t, node: e }) {
					var n;
					return `${t.suggestion.char}${
						(n = e.attrs.label) !== null && n !== void 0
							? n
							: e.attrs.id
					}`;
				},
				suggestion: {
					char: "@",
					pluginKey: H6,
					command: ({ editor: t, range: e, props: n }) => {
						var r, o;
						const i = t.view.state.selection.$to.nodeAfter;
						((r = i == null ? void 0 : i.text) === null ||
						r === void 0
							? void 0
							: r.startsWith(" ")) && (e.to += 1),
							t
								.chain()
								.focus()
								.insertContentAt(e, [
									{ type: this.name, attrs: n },
									{ type: "text", text: " " },
								])
								.run(),
							(o = window.getSelection()) === null ||
								o === void 0 ||
								o.collapseToEnd();
					},
					allow: ({ state: t, range: e }) => {
						const n = t.doc.resolve(e.from),
							r = t.schema.nodes[this.name];
						return !!n.parent.type.contentMatch.matchType(r);
					},
				},
			};
		},
		group: "inline",
		inline: !0,
		selectable: !1,
		atom: !0,
		addAttributes() {
			return {
				id: {
					default: null,
					parseHTML: (t) => t.getAttribute("data-id"),
					renderHTML: (t) => (t.id ? { "data-id": t.id } : {}),
				},
				label: {
					default: null,
					parseHTML: (t) => t.getAttribute("data-label"),
					renderHTML: (t) =>
						t.label ? { "data-label": t.label } : {},
				},
			};
		},
		parseHTML() {
			return [{ tag: `span[data-type="${this.name}"]` }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				"span",
				Ze({ "data-type": this.name }, this.options.HTMLAttributes, e),
				this.options.renderLabel({ options: this.options, node: t }),
			];
		},
		renderText({ node: t }) {
			return this.options.renderLabel({ options: this.options, node: t });
		},
		addKeyboardShortcuts() {
			return {
				Backspace: () =>
					this.editor.commands.command(({ tr: t, state: e }) => {
						let n = !1;
						const { selection: r } = e,
							{ empty: o, anchor: i } = r;
						return o
							? (e.doc.nodesBetween(i - 1, i, (s, l) => {
									if (s.type.name === this.name)
										return (
											(n = !0),
											t.insertText(
												this.options.suggestion.char ||
													"",
												l,
												l + s.nodeSize
											),
											!1
										);
							  }),
							  n)
							: !1;
					}),
			};
		},
		addProseMirrorPlugins() {
			return [z6(z({ editor: this.editor }, this.options.suggestion))];
		},
	}),
	V6 = {
		props: {
			items: { type: Array, required: !0 },
			command: { type: Function, required: !0 },
		},
		data() {
			return { selectedIndex: 0 };
		},
		watch: {
			items() {
				this.selectedIndex = 0;
			},
		},
		methods: {
			onKeyDown({ event: t }) {
				return t.key === "ArrowUp"
					? (this.upHandler(), !0)
					: t.key === "ArrowDown"
					? (this.downHandler(), !0)
					: t.key === "Enter"
					? (this.enterHandler(), !0)
					: !1;
			},
			upHandler() {
				this.selectedIndex =
					(this.selectedIndex + this.items.length - 1) %
					this.items.length;
			},
			downHandler() {
				this.selectedIndex =
					(this.selectedIndex + 1) % this.items.length;
			},
			enterHandler() {
				this.selectItem(this.selectedIndex);
			},
			selectItem(t) {
				const e = this.items[t];
				e && this.command({ id: e.value, label: e.label });
			},
		},
	},
	W6 = {
		key: 0,
		class: "min-w-40 rounded-lg border bg-white p-1 text-base shadow-lg",
	},
	U6 = ["onClick", "onMouseover"];
function K6(t, e, n, r, o, i) {
	return (
		j(),
		q("div", null, [
			n.items.length
				? (j(),
				  q("div", W6, [
						(j(!0),
						q(
							Ne,
							null,
							Pt(
								n.items,
								(s, l) => (
									j(),
									q(
										"button",
										{
											class: we([
												l === o.selectedIndex
													? "bg-gray-100"
													: "text-gray-900",
												"flex w-full items-center whitespace-nowrap rounded-md px-2 py-2 text-sm",
											]),
											key: l,
											onClick: (a) => i.selectItem(l),
											onMouseover: (a) =>
												(o.selectedIndex = l),
										},
										Qe(s.label),
										43,
										U6
									)
								)
							),
							128
						)),
				  ]))
				: Ve("", !0),
		])
	);
}
const q6 = je(V6, [["render", K6]]);
function J6(t) {
	return F6.configure({
		HTMLAttributes: { class: "mention" },
		suggestion: G6(t),
	});
}
function G6(t) {
	return {
		items: ({ query: e }) =>
			t
				.filter((n) =>
					n.label.toLowerCase().startsWith(e.toLowerCase())
				)
				.slice(0, 5),
		render: () => {
			let e, n;
			return {
				onStart: (r) => {
					(e = new A4(q6, { props: r, editor: r.editor })),
						r.clientRect &&
							(n = Ko("body", {
								getReferenceClientRect: r.clientRect,
								appendTo: () => document.body,
								content: e.element,
								showOnCreate: !0,
								interactive: !0,
								trigger: "manual",
								placement: "bottom-start",
							}));
				},
				onUpdate(r) {
					e.updateProps(r),
						r.clientRect &&
							n[0].setProps({
								getReferenceClientRect: r.clientRect,
							});
				},
				onKeyDown(r) {
					var o;
					return r.event.key === "Escape"
						? (n[0].hide(), !0)
						: (o = e.ref) == null
						? void 0
						: o.onKeyDown(r);
				},
				onExit() {
					n[0].destroy(), e.destroy();
				},
			};
		},
	};
}
const Y6 = {
		name: "TipTapMenu",
		props: ["buttons"],
		inject: ["editor"],
		components: { Popover: Ru },
		methods: {
			onButtonClick(t) {
				t.action(this.editor);
			},
		},
	},
	Q6 = { class: "inline-flex bg-white px-1 py-1" },
	X6 = { class: "inline-flex items-center gap-1" },
	Z6 = { key: 0, class: "h-4 w-[2px] border-l" },
	eR = { key: 1, class: "shrink-0" },
	tR = ["onClick", "set"],
	nR = { key: 1 },
	rR = { class: "rounded border bg-white p-1 shadow-md" },
	oR = { class: "w-full" },
	iR = ["onClick"],
	sR = ["onClick", "title"],
	lR = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" };
function aR(t, e, n, r, o, i) {
	const s = nt("Popover");
	return (
		j(),
		q("div", Q6, [
			U("div", X6, [
				(j(!0),
				q(
					Ne,
					null,
					Pt(
						n.buttons,
						(l) => (
							j(),
							q(
								Ne,
								{ key: l.label },
								[
									l.type === "separator"
										? (j(), q("div", Z6))
										: l.map
										? (j(),
										  q("div", eR, [
												be(
													s,
													null,
													{
														target: He(
															({
																togglePopover:
																	a,
															}) => [
																U(
																	"button",
																	{
																		class: "rounded px-2 py-1 text-base font-medium text-gray-800 transition-colors hover:bg-gray-100",
																		onClick:
																			a,
																		set: (t.activeBtn =
																			l.find(
																				(
																					u
																				) =>
																					u.isActive(
																						i.editor
																					)
																			) ||
																			l[0]),
																	},
																	[
																		t
																			.activeBtn
																			.icon
																			? (j(),
																			  Fe(
																					zn(
																						t
																							.activeBtn
																							.icon
																					),
																					{
																						key: 0,
																						class: "h-4 w-4",
																					}
																			  ))
																			: (j(),
																			  q(
																					"span",
																					nR,
																					Qe(
																						t
																							.activeBtn
																							.label
																					),
																					1
																			  )),
																	],
																	8,
																	tR
																),
															]
														),
														body: He(
															({ close: a }) => [
																U("ul", rR, [
																	(j(!0),
																	q(
																		Ne,
																		null,
																		Pt(
																			l,
																			(
																				u
																			) =>
																				e0(
																					(j(),
																					q(
																						"li",
																						oR,
																						[
																							U(
																								"button",
																								{
																									class: "w-full rounded px-2 py-1 text-left text-base hover:bg-gray-50",
																									onClick:
																										() => {
																											i.onButtonClick(
																												u
																											),
																												a();
																										},
																								},
																								Qe(
																									u.label
																								),
																								9,
																								iR
																							),
																						],
																						512
																					)),
																					[
																						[
																							E0,
																							u.isDisabled
																								? !u.isDisabled(
																										i.editor
																								  )
																								: !0,
																						],
																					]
																				)
																		),
																		256
																	)),
																]),
															]
														),
														_: 2,
													},
													1024
												),
										  ]))
										: (j(),
										  Fe(
												zn(l.component || "div"),
												Ut(
													Ht(
														{ key: 2 },
														{ editor: i.editor }
													)
												),
												{
													default: He((a) => [
														U(
															"button",
															{
																class: we([
																	"flex rounded p-1 text-gray-800 transition-colors",
																	l.isActive(
																		i.editor
																	) ||
																	(a !=
																		null &&
																		a.isActive)
																		? "bg-gray-100"
																		: "hover:bg-gray-100",
																]),
																onClick: (u) =>
																	a != null &&
																	a.onClick
																		? a.onClick(
																				l
																		  )
																		: i.onButtonClick(
																				l
																		  ),
																title: l.label,
															},
															[
																l.icon
																	? (j(),
																	  Fe(
																			zn(
																				l.icon
																			),
																			{
																				key: 0,
																				class: "h-4 w-4",
																			}
																	  ))
																	: (j(),
																	  q(
																			"span",
																			lR,
																			Qe(
																				l.text
																			),
																			1
																	  )),
															],
															10,
															sR
														),
													]),
													_: 2,
												},
												1040
										  )),
								],
								64
							)
						)
					),
					128
				)),
			]),
		])
	);
}
const D2 = je(Y6, [["render", aR]]),
	uR = {},
	cR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	dR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	fR = U(
		"path",
		{
			d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z",
			fill: "currentColor",
		},
		null,
		-1
	),
	hR = [dR, fR];
function pR(t, e) {
	return j(), q("svg", cR, hR);
}
const mR = je(uR, [["render", pR]]),
	gR = {},
	yR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	vR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	bR = U(
		"path",
		{
			d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z",
			fill: "currentColor",
		},
		null,
		-1
	),
	wR = [vR, bR];
function xR(t, e) {
	return j(), q("svg", yR, wR);
}
const kR = je(gR, [["render", xR]]),
	SR = {},
	_R = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	CR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	MR = U(
		"path",
		{
			d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	ER = [CR, MR];
function TR(t, e) {
	return j(), q("svg", _R, ER);
}
const AR = je(SR, [["render", TR]]),
	OR = {},
	RR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	PR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	IR = U(
		"path",
		{
			d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z",
			fill: "currentColor",
		},
		null,
		-1
	),
	NR = [PR, IR];
function DR(t, e) {
	return j(), q("svg", RR, NR);
}
const jR = je(OR, [["render", DR]]),
	LR = {},
	$R = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	BR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	zR = U(
		"path",
		{
			d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	HR = [BR, zR];
function FR(t, e) {
	return j(), q("svg", $R, HR);
}
const VR = je(LR, [["render", FR]]),
	WR = {},
	UR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	KR = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	qR = U(
		"path",
		{
			d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	JR = [KR, qR];
function GR(t, e) {
	return j(), q("svg", UR, JR);
}
const YR = je(WR, [["render", GR]]),
	QR = {},
	XR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	ZR = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	eP = U(
		"path",
		{ d: "M13 6v15h-2V6H5V4h14v2z", fill: "currentColor" },
		null,
		-1
	),
	tP = [ZR, eP];
function nP(t, e) {
	return j(), q("svg", XR, tP);
}
const rP = je(QR, [["render", nP]]),
	oP = {},
	iP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	sP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	lP = U(
		"path",
		{
			d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
			fill: "currentColor",
		},
		null,
		-1
	),
	aP = [sP, lP];
function uP(t, e) {
	return j(), q("svg", iP, aP);
}
const cP = je(oP, [["render", uP]]),
	dP = {},
	fP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	hP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	pP = U(
		"path",
		{
			d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
			fill: "currentColor",
		},
		null,
		-1
	),
	mP = [hP, pP];
function gP(t, e) {
	return j(), q("svg", fP, mP);
}
const yP = je(dP, [["render", gP]]),
	vP = {},
	bP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	wP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	xP = U(
		"path",
		{
			d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	kP = [wP, xP];
function SP(t, e) {
	return j(), q("svg", bP, kP);
}
const _P = je(vP, [["render", SP]]),
	CP = {},
	MP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	EP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	TP = U(
		"path",
		{
			d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	AP = [EP, TP];
function OP(t, e) {
	return j(), q("svg", MP, AP);
}
const RP = je(CP, [["render", OP]]),
	PP = {},
	IP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	NP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	DP = U(
		"path",
		{
			d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	jP = [NP, DP];
function LP(t, e) {
	return j(), q("svg", IP, jP);
}
const $P = je(PP, [["render", LP]]),
	BP = {},
	zP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	HP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	FP = U(
		"path",
		{
			d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	VP = [HP, FP];
function WP(t, e) {
	return j(), q("svg", zP, VP);
}
const UP = je(BP, [["render", WP]]),
	KP = {},
	qP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	JP = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	GP = U(
		"path",
		{
			d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	YP = [JP, GP];
function QP(t, e) {
	return j(), q("svg", qP, YP);
}
const XP = je(KP, [["render", QP]]),
	ZP = {},
	eI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	tI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	nI = U(
		"path",
		{
			d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	rI = [tI, nI];
function oI(t, e) {
	return j(), q("svg", eI, rI);
}
const iI = je(ZP, [["render", oI]]),
	sI = {},
	lI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	aI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	uI = U(
		"path",
		{
			d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	cI = [aI, uI];
function dI(t, e) {
	return j(), q("svg", lI, cI);
}
const fI = je(sI, [["render", dI]]),
	hI = {},
	pI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	mI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	gI = U(
		"path",
		{
			d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z",
			fill: "currentColor",
		},
		null,
		-1
	),
	yI = [mI, gI];
function vI(t, e) {
	return j(), q("svg", pI, yI);
}
const bI = je(hI, [["render", vI]]),
	wI = {},
	xI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	kI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	SI = U(
		"path",
		{
			d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z",
			fill: "currentColor",
		},
		null,
		-1
	),
	_I = [kI, SI];
function CI(t, e) {
	return j(), q("svg", xI, _I);
}
const MI = je(wI, [["render", CI]]),
	EI = {},
	TI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	AI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	OI = U(
		"path",
		{
			d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
			fill: "currentColor",
		},
		null,
		-1
	),
	RI = [AI, OI];
function PI(t, e) {
	return j(), q("svg", TI, RI);
}
const II = je(EI, [["render", PI]]),
	NI = {},
	DI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	jI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	LI = U(
		"path",
		{
			d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z",
			fill: "currentColor",
		},
		null,
		-1
	),
	$I = [jI, LI];
function BI(t, e) {
	return j(), q("svg", DI, $I);
}
const zI = je(NI, [["render", BI]]),
	HI = {},
	FI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	VI = U("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	WI = U(
		"path",
		{
			d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-1 2H3v12h12V6zM8 8h2v3h3v2H9.999L10 16H8l-.001-3H5v-2h3V8zm13 .841l-4 2.8v.718l4 2.8V8.84z",
			fill: "currentColor",
		},
		null,
		-1
	),
	UI = [VI, WI];
function KI(t, e) {
	return j(), q("svg", FI, UI);
}
const qI = je(HI, [["render", KI]]),
	JI = {},
	GI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	YI = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	QI = U(
		"path",
		{
			d: "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z",
			fill: "currentColor",
		},
		null,
		-1
	),
	XI = [YI, QI];
function ZI(t, e) {
	return j(), q("svg", GI, XI);
}
const eN = je(JI, [["render", ZI]]),
	tN = {},
	nN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	rN = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	oN = U(
		"path",
		{
			d: "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z",
			fill: "currentColor",
		},
		null,
		-1
	),
	iN = [rN, oN];
function sN(t, e) {
	return j(), q("svg", nN, iN);
}
const lN = je(tN, [["render", sN]]),
	aN = {},
	uN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	cN = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	dN = U(
		"path",
		{
			d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	fN = [cN, dN];
function hN(t, e) {
	return j(), q("svg", uN, fN);
}
const pN = je(aN, [["render", hN]]),
	mN = {},
	gN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	yN = U("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	vN = U(
		"path",
		{
			d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z",
			fill: "currentColor",
		},
		null,
		-1
	),
	bN = [yN, vN];
function wN(t, e) {
	return j(), q("svg", gN, bN);
}
const xN = je(mN, [["render", wN]]),
	kN = {
		Paragraph: {
			label: "Paragraph",
			icon: rP,
			action: (t) => t.chain().focus().setParagraph().run(),
			isActive: (t) => t.isActive("paragraph"),
		},
		"Heading 1": {
			label: "Heading 1",
			text: "H1",
			icon: mR,
			action: (t) => t.chain().focus().toggleHeading({ level: 1 }).run(),
			isActive: (t) => t.isActive("heading", { level: 1 }),
		},
		"Heading 2": {
			label: "Heading 2",
			text: "H2",
			icon: kR,
			action: (t) => t.chain().focus().toggleHeading({ level: 2 }).run(),
			isActive: (t) => t.isActive("heading", { level: 2 }),
		},
		"Heading 3": {
			label: "Heading 3",
			text: "H3",
			icon: AR,
			action: (t) => t.chain().focus().toggleHeading({ level: 3 }).run(),
			isActive: (t) => t.isActive("heading", { level: 3 }),
		},
		"Heading 4": {
			label: "Heading 4",
			text: "H4",
			icon: jR,
			action: (t) => t.chain().focus().toggleHeading({ level: 4 }).run(),
			isActive: (t) => t.isActive("heading", { level: 4 }),
		},
		"Heading 5": {
			label: "Heading 5",
			text: "H5",
			icon: VR,
			action: (t) => t.chain().focus().toggleHeading({ level: 5 }).run(),
			isActive: (t) => t.isActive("heading", { level: 5 }),
		},
		"Heading 6": {
			label: "Heading 6",
			text: "H6",
			icon: YR,
			action: (t) => t.chain().focus().toggleHeading({ level: 6 }).run(),
			isActive: (t) => t.isActive("heading", { level: 6 }),
		},
		Bold: {
			label: "Bold",
			icon: cP,
			action: (t) => t.chain().focus().toggleBold().run(),
			isActive: (t) => t.isActive("bold"),
		},
		Italic: {
			label: "Italic",
			icon: yP,
			action: (t) => t.chain().focus().toggleItalic().run(),
			isActive: (t) => t.isActive("italic"),
		},
		Underline: {
			label: "Underline",
			icon: _P,
			action: (t) => t.chain().focus().toggleUnderline().run(),
			isActive: (t) => t.isActive("underline"),
		},
		"Bullet List": {
			label: "Bullet List",
			icon: fI,
			action: (t) => t.chain().focus().toggleBulletList().run(),
			isActive: (t) => t.isActive("bulletList"),
		},
		"Numbered List": {
			label: "Numbered List",
			icon: iI,
			action: (t) => t.chain().focus().toggleOrderedList().run(),
			isActive: (t) => t.isActive("orderedList"),
		},
		"Align Center": {
			label: "Align Center",
			icon: RP,
			action: (t) => t.chain().focus().setTextAlign("center").run(),
			isActive: (t) => t.isActive({ textAlign: "center" }),
		},
		"Align Left": {
			label: "Align Left",
			icon: $P,
			action: (t) => t.chain().focus().setTextAlign("left").run(),
			isActive: (t) => t.isActive({ textAlign: "left" }),
		},
		"Align Right": {
			label: "Align Right",
			icon: UP,
			action: (t) => t.chain().focus().setTextAlign("right").run(),
			isActive: (t) => t.isActive({ textAlign: "right" }),
		},
		FontColor: {
			label: "Font Color",
			icon: XP,
			isActive: (t) => t.isActive("textStyle") || t.isActive("highlight"),
			component: pl(() =>
				gl(() => import("./FontColor-67MjDpop.js"), __vite__mapDeps([]))
			),
		},
		Blockquote: {
			label: "Blockquote",
			icon: bI,
			action: (t) => t.chain().focus().toggleBlockquote().run(),
			isActive: (t) => t.isActive("blockquote"),
		},
		Code: {
			label: "Code",
			icon: MI,
			action: (t) => t.chain().focus().toggleCodeBlock().run(),
			isActive: (t) => t.isActive("codeBlock"),
		},
		"Horizontal Rule": {
			label: "Horizontal Rule",
			icon: pN,
			action: (t) => t.chain().focus().setHorizontalRule().run(),
			isActive: (t) => !1,
		},
		Link: {
			label: "Link",
			icon: II,
			isActive: (t) => t.isActive("link"),
			component: pl(() =>
				gl(
					() => import("./InsertLink-PJVOdU-g.js"),
					__vite__mapDeps([])
				)
			),
		},
		Image: {
			label: "Image",
			icon: zI,
			isActive: (t) => !1,
			component: pl(() =>
				gl(
					() => import("./InsertImage-pFxauZ_l.js"),
					__vite__mapDeps([])
				)
			),
		},
		Video: {
			label: "Video",
			icon: qI,
			isActive: (t) => !1,
			component: pl(() =>
				gl(
					() => import("./InsertVideo-5zm7I1WB.js"),
					__vite__mapDeps([])
				)
			),
		},
		Undo: {
			label: "Undo",
			icon: eN,
			action: (t) => t.chain().focus().undo().run(),
			isActive: (t) => !1,
		},
		Redo: {
			label: "Redo",
			icon: lN,
			action: (t) => t.chain().focus().redo().run(),
			isActive: (t) => !1,
		},
		InsertTable: {
			label: "Insert Table",
			icon: xN,
			action: (t) =>
				t
					.chain()
					.focus()
					.insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
					.run(),
			isActive: (t) => !1,
		},
		AddColumnBefore: {
			label: "Add Column Before",
			action: (t) => t.chain().focus().addColumnBefore().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addColumnBefore(),
		},
		AddColumnAfter: {
			label: "Add Column After",
			action: (t) => t.chain().focus().addColumnAfter().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addColumnAfter(),
		},
		DeleteColumn: {
			label: "Delete Column",
			action: (t) => t.chain().focus().deleteColumn().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteColumn(),
		},
		AddRowBefore: {
			label: "Add Row Before",
			action: (t) => t.chain().focus().addRowBefore().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addRowBefore(),
		},
		AddRowAfter: {
			label: "Add Row After",
			action: (t) => t.chain().focus().addRowAfter().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addRowAfter(),
		},
		DeleteRow: {
			label: "Delete Row",
			action: (t) => t.chain().focus().deleteRow().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteRow(),
		},
		DeleteTable: {
			label: "Delete Table",
			action: (t) => t.chain().focus().deleteTable().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteTable(),
		},
		MergeCells: {
			label: "Merge Cells",
			action: (t) => t.chain().focus().mergeCells().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().mergeCells(),
		},
		SplitCell: {
			label: "Split Cell",
			action: (t) => t.chain().focus().splitCell().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().splitCell(),
		},
		ToggleHeaderColumn: {
			label: "Toggle Header Column",
			action: (t) => t.chain().focus().toggleHeaderColumn().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderColumn(),
		},
		ToggleHeaderRow: {
			label: "Toggle Header Row",
			action: (t) => t.chain().focus().toggleHeaderRow().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderRow(),
		},
		ToggleHeaderCell: {
			label: "Toggle Header Cell",
			action: (t) => t.chain().focus().toggleHeaderCell().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderCell(),
		},
		Separator: { type: "separator" },
	};
function qu(t) {
	return t instanceof Array ? t.map(qu) : typeof t == "object" ? t : kN[t];
}
const SN = {
	name: "TextEditorFixedMenu",
	props: ["buttons"],
	components: { Menu: D2 },
	inject: ["editor"],
	computed: {
		fixedMenuButtons() {
			if (!this.buttons) return !1;
			let t;
			return (
				Array.isArray(this.buttons)
					? (t = this.buttons)
					: (t = [
							[
								"Heading 1",
								"Heading 2",
								"Heading 3",
								"Heading 4",
								"Heading 5",
								"Heading 6",
							],
							"Paragraph",
							"Separator",
							"Bold",
							"Italic",
							"Separator",
							"Bullet List",
							"Numbered List",
							"Separator",
							"Align Left",
							"Align Center",
							"Align Right",
							"FontColor",
							"Separator",
							"Image",
							"Video",
							"Link",
							"Blockquote",
							"Code",
							"Horizontal Rule",
							[
								"InsertTable",
								"AddColumnBefore",
								"AddColumnAfter",
								"DeleteColumn",
								"AddRowBefore",
								"AddRowAfter",
								"DeleteRow",
								"MergeCells",
								"SplitCell",
								"ToggleHeaderColumn",
								"ToggleHeaderRow",
								"ToggleHeaderCell",
								"DeleteTable",
							],
							"Separator",
							"Undo",
							"Redo",
					  ]),
				t.map(qu)
			);
		},
	},
};
function _N(t, e, n, r, o, i) {
	const s = nt("Menu");
	return i.fixedMenuButtons
		? (j(),
		  Fe(s, { key: 0, buttons: i.fixedMenuButtons }, null, 8, ["buttons"]))
		: Ve("", !0);
}
const CN = je(SN, [["render", _N]]),
	MN = {
		name: "TextEditorBubbleMenu",
		props: ["buttons", "options"],
		components: { BubbleMenu: C4, Menu: D2 },
		inject: ["editor"],
		computed: {
			bubbleMenuButtons() {
				if (!this.buttons) return !1;
				let t;
				return (
					Array.isArray(this.buttons)
						? (t = this.buttons)
						: (t = [
								"Paragraph",
								"Heading 2",
								"Heading 3",
								"Separator",
								"Bold",
								"Italic",
								"Link",
								"Separator",
								"Bullet List",
								"Numbered List",
								"Separator",
								"Image",
								"Video",
								"Blockquote",
								"Code",
								[
									"InsertTable",
									"AddColumnBefore",
									"AddColumnAfter",
									"DeleteColumn",
									"AddRowBefore",
									"AddRowAfter",
									"DeleteRow",
									"MergeCells",
									"SplitCell",
									"ToggleHeaderColumn",
									"ToggleHeaderRow",
									"ToggleHeaderCell",
									"DeleteTable",
								],
						  ]),
					t.map(qu)
				);
			},
		},
	};
function EN(t, e, n, r, o, i) {
	const s = nt("Menu"),
		l = nt("BubbleMenu");
	return i.bubbleMenuButtons
		? (j(),
		  Fe(
				l,
				Ht(
					{
						key: 0,
						class: "bubble-menu rounded-md shadow-sm",
						"tippy-options": { duration: 100 },
						editor: i.editor,
					},
					n.options
				),
				{
					default: He(() => [
						be(
							s,
							{
								class: "rounded-md border border-gray-100 shadow-lg",
								buttons: i.bubbleMenuButtons,
							},
							null,
							8,
							["buttons"]
						),
					]),
					_: 1,
				},
				16,
				["editor"]
		  ))
		: Ve("", !0);
}
const TN = je(MN, [["render", EN]]),
	AN = {
		name: "TextEditorFloatingMenu",
		props: ["buttons"],
		components: { FloatingMenu: T4 },
		inject: ["editor"],
		computed: {
			floatingMenuButtons() {
				if (!this.buttons) return !1;
				let t;
				return (
					Array.isArray(this.buttons)
						? (t = this.buttons)
						: (t = [
								"Paragraph",
								"Heading 2",
								"Heading 3",
								"Bullet List",
								"Numbered List",
								"Blockquote",
								"Code",
								"Horizontal Rule",
						  ]),
					t.map(qu)
				);
			},
		},
	},
	ON = ["onClick", "title"],
	RN = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" };
function PN(t, e, n, r, o, i) {
	const s = nt("FloatingMenu");
	return i.floatingMenuButtons
		? (j(),
		  Fe(
				s,
				{
					key: 0,
					"tippy-options": { duration: 100 },
					editor: i.editor,
					class: "flex",
				},
				{
					default: He(() => [
						(j(!0),
						q(
							Ne,
							null,
							Pt(
								i.floatingMenuButtons,
								(l) => (
									j(),
									q(
										"button",
										{
											key: l.label,
											class: we([
												"flex rounded p-1 text-gray-800 transition-colors",
												l.isActive(i.editor)
													? "bg-gray-100"
													: "hover:bg-gray-100",
											]),
											onClick: () => l.action(i.editor),
											title: l.label,
										},
										[
											l.icon
												? (j(),
												  Fe(zn(l.icon), {
														key: 0,
														class: "h-4 w-4",
												  }))
												: (j(),
												  q("span", RN, Qe(l.text), 1)),
										],
										10,
										ON
									)
								)
							),
							128
						)),
					]),
					_: 1,
				},
				8,
				["editor"]
		  ))
		: Ve("", !0);
}
const IN = je(AN, [["render", PN]]);
var j2 = { exports: {} };
(function (t) {
	(function () {
		function e(f) {
			var v = {
				omitExtraWLInCodeBlocks: {
					defaultValue: !1,
					describe:
						"Omit the default extra whiteline added to code blocks",
					type: "boolean",
				},
				noHeaderId: {
					defaultValue: !1,
					describe: "Turn on/off generated header id",
					type: "boolean",
				},
				prefixHeaderId: {
					defaultValue: !1,
					describe:
						"Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
					type: "string",
				},
				rawPrefixHeaderId: {
					defaultValue: !1,
					describe:
						'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
					type: "boolean",
				},
				ghCompatibleHeaderId: {
					defaultValue: !1,
					describe:
						"Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
					type: "boolean",
				},
				rawHeaderId: {
					defaultValue: !1,
					describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
					type: "boolean",
				},
				headerLevelStart: {
					defaultValue: !1,
					describe: "The header blocks level start",
					type: "integer",
				},
				parseImgDimensions: {
					defaultValue: !1,
					describe: "Turn on/off image dimension parsing",
					type: "boolean",
				},
				simplifiedAutoLink: {
					defaultValue: !1,
					describe: "Turn on/off GFM autolink style",
					type: "boolean",
				},
				excludeTrailingPunctuationFromURLs: {
					defaultValue: !1,
					describe:
						"Excludes trailing punctuation from links generated with autoLinking",
					type: "boolean",
				},
				literalMidWordUnderscores: {
					defaultValue: !1,
					describe:
						"Parse midword underscores as literal underscores",
					type: "boolean",
				},
				literalMidWordAsterisks: {
					defaultValue: !1,
					describe: "Parse midword asterisks as literal asterisks",
					type: "boolean",
				},
				strikethrough: {
					defaultValue: !1,
					describe: "Turn on/off strikethrough support",
					type: "boolean",
				},
				tables: {
					defaultValue: !1,
					describe: "Turn on/off tables support",
					type: "boolean",
				},
				tablesHeaderId: {
					defaultValue: !1,
					describe: "Add an id to table headers",
					type: "boolean",
				},
				ghCodeBlocks: {
					defaultValue: !0,
					describe: "Turn on/off GFM fenced code blocks support",
					type: "boolean",
				},
				tasklists: {
					defaultValue: !1,
					describe: "Turn on/off GFM tasklist support",
					type: "boolean",
				},
				smoothLivePreview: {
					defaultValue: !1,
					describe:
						"Prevents weird effects in live previews due to incomplete input",
					type: "boolean",
				},
				smartIndentationFix: {
					defaultValue: !1,
					describe: "Tries to smartly fix indentation in es6 strings",
					type: "boolean",
				},
				disableForced4SpacesIndentedSublists: {
					defaultValue: !1,
					describe:
						"Disables the requirement of indenting nested sublists by 4 spaces",
					type: "boolean",
				},
				simpleLineBreaks: {
					defaultValue: !1,
					describe: "Parses simple line breaks as <br> (GFM Style)",
					type: "boolean",
				},
				requireSpaceBeforeHeadingText: {
					defaultValue: !1,
					describe:
						"Makes adding a space between `#` and the header text mandatory (GFM Style)",
					type: "boolean",
				},
				ghMentions: {
					defaultValue: !1,
					describe: "Enables github @mentions",
					type: "boolean",
				},
				ghMentionsLink: {
					defaultValue: "https://github.com/{u}",
					describe:
						"Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
					type: "string",
				},
				encodeEmails: {
					defaultValue: !0,
					describe:
						"Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
					type: "boolean",
				},
				openLinksInNewWindow: {
					defaultValue: !1,
					describe: "Open all links in new windows",
					type: "boolean",
				},
				backslashEscapesHTMLTags: {
					defaultValue: !1,
					describe:
						"Support for HTML Tag escaping. ex: <div>foo</div>",
					type: "boolean",
				},
				emoji: {
					defaultValue: !1,
					describe:
						"Enable emoji support. Ex: `this is a :smile: emoji`",
					type: "boolean",
				},
				underline: {
					defaultValue: !1,
					describe:
						"Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
					type: "boolean",
				},
				ellipsis: {
					defaultValue: !0,
					describe:
						"Replaces three dots with the ellipsis unicode character",
					type: "boolean",
				},
				completeHTMLDocument: {
					defaultValue: !1,
					describe:
						"Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
					type: "boolean",
				},
				metadata: {
					defaultValue: !1,
					describe:
						"Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).",
					type: "boolean",
				},
				splitAdjacentBlockquotes: {
					defaultValue: !1,
					describe: "Split adjacent blockquote blocks",
					type: "boolean",
				},
			};
			if (f === !1) return JSON.parse(JSON.stringify(v));
			var m = {};
			for (var x in v) v.hasOwnProperty(x) && (m[x] = v[x].defaultValue);
			return m;
		}
		function n() {
			var f = e(!0),
				v = {};
			for (var m in f) f.hasOwnProperty(m) && (v[m] = !0);
			return v;
		}
		var r = {},
			o = {},
			i = {},
			s = e(!0),
			l = "vanilla",
			a = {
				github: {
					omitExtraWLInCodeBlocks: !0,
					simplifiedAutoLink: !0,
					excludeTrailingPunctuationFromURLs: !0,
					literalMidWordUnderscores: !0,
					strikethrough: !0,
					tables: !0,
					tablesHeaderId: !0,
					ghCodeBlocks: !0,
					tasklists: !0,
					disableForced4SpacesIndentedSublists: !0,
					simpleLineBreaks: !0,
					requireSpaceBeforeHeadingText: !0,
					ghCompatibleHeaderId: !0,
					ghMentions: !0,
					backslashEscapesHTMLTags: !0,
					emoji: !0,
					splitAdjacentBlockquotes: !0,
				},
				original: { noHeaderId: !0, ghCodeBlocks: !1 },
				ghost: {
					omitExtraWLInCodeBlocks: !0,
					parseImgDimensions: !0,
					simplifiedAutoLink: !0,
					excludeTrailingPunctuationFromURLs: !0,
					literalMidWordUnderscores: !0,
					strikethrough: !0,
					tables: !0,
					tablesHeaderId: !0,
					ghCodeBlocks: !0,
					tasklists: !0,
					smoothLivePreview: !0,
					simpleLineBreaks: !0,
					requireSpaceBeforeHeadingText: !0,
					ghMentions: !1,
					encodeEmails: !0,
				},
				vanilla: e(!0),
				allOn: n(),
			};
		(r.helper = {}),
			(r.extensions = {}),
			(r.setOption = function (f, v) {
				return (s[f] = v), this;
			}),
			(r.getOption = function (f) {
				return s[f];
			}),
			(r.getOptions = function () {
				return s;
			}),
			(r.resetOptions = function () {
				s = e(!0);
			}),
			(r.setFlavor = function (f) {
				if (!a.hasOwnProperty(f))
					throw Error(f + " flavor was not found");
				r.resetOptions();
				var v = a[f];
				l = f;
				for (var m in v) v.hasOwnProperty(m) && (s[m] = v[m]);
			}),
			(r.getFlavor = function () {
				return l;
			}),
			(r.getFlavorOptions = function (f) {
				if (a.hasOwnProperty(f)) return a[f];
			}),
			(r.getDefaultOptions = function (f) {
				return e(f);
			}),
			(r.subParser = function (f, v) {
				if (r.helper.isString(f))
					if (typeof v != "undefined") o[f] = v;
					else {
						if (o.hasOwnProperty(f)) return o[f];
						throw Error(
							"SubParser named " + f + " not registered!"
						);
					}
			}),
			(r.extension = function (f, v) {
				if (!r.helper.isString(f))
					throw Error("Extension 'name' must be a string");
				if (((f = r.helper.stdExtName(f)), r.helper.isUndefined(v))) {
					if (!i.hasOwnProperty(f))
						throw Error(
							"Extension named " + f + " is not registered!"
						);
					return i[f];
				} else {
					typeof v == "function" && (v = v()),
						r.helper.isArray(v) || (v = [v]);
					var m = u(v, f);
					if (m.valid) i[f] = v;
					else throw Error(m.error);
				}
			}),
			(r.getAllExtensions = function () {
				return i;
			}),
			(r.removeExtension = function (f) {
				delete i[f];
			}),
			(r.resetExtensions = function () {
				i = {};
			});
		function u(f, v) {
			var m = v
					? "Error in " + v + " extension->"
					: "Error in unnamed extension",
				x = { valid: !0, error: "" };
			r.helper.isArray(f) || (f = [f]);
			for (var k = 0; k < f.length; ++k) {
				var C = m + " sub-extension " + k + ": ",
					_ = f[k];
				if (typeof _ != "object")
					return (
						(x.valid = !1),
						(x.error =
							C +
							"must be an object, but " +
							typeof _ +
							" given"),
						x
					);
				if (!r.helper.isString(_.type))
					return (
						(x.valid = !1),
						(x.error =
							C +
							'property "type" must be a string, but ' +
							typeof _.type +
							" given"),
						x
					);
				var T = (_.type = _.type.toLowerCase());
				if (
					(T === "language" && (T = _.type = "lang"),
					T === "html" && (T = _.type = "output"),
					T !== "lang" && T !== "output" && T !== "listener")
				)
					return (
						(x.valid = !1),
						(x.error =
							C +
							"type " +
							T +
							' is not recognized. Valid values: "lang/language", "output/html" or "listener"'),
						x
					);
				if (T === "listener") {
					if (r.helper.isUndefined(_.listeners))
						return (
							(x.valid = !1),
							(x.error =
								C +
								'. Extensions of type "listener" must have a property called "listeners"'),
							x
						);
				} else if (
					r.helper.isUndefined(_.filter) &&
					r.helper.isUndefined(_.regex)
				)
					return (
						(x.valid = !1),
						(x.error =
							C +
							T +
							' extensions must define either a "regex" property or a "filter" method'),
						x
					);
				if (_.listeners) {
					if (typeof _.listeners != "object")
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"listeners" property must be an object but ' +
								typeof _.listeners +
								" given"),
							x
						);
					for (var R in _.listeners)
						if (
							_.listeners.hasOwnProperty(R) &&
							typeof _.listeners[R] != "function"
						)
							return (
								(x.valid = !1),
								(x.error =
									C +
									'"listeners" property must be an hash of [event name]: [callback]. listeners.' +
									R +
									" must be a function but " +
									typeof _.listeners[R] +
									" given"),
								x
							);
				}
				if (_.filter) {
					if (typeof _.filter != "function")
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"filter" must be a function, but ' +
								typeof _.filter +
								" given"),
							x
						);
				} else if (_.regex) {
					if (
						(r.helper.isString(_.regex) &&
							(_.regex = new RegExp(_.regex, "g")),
						!(_.regex instanceof RegExp))
					)
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"regex" property must either be a string or a RegExp object, but ' +
								typeof _.regex +
								" given"),
							x
						);
					if (r.helper.isUndefined(_.replace))
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"regex" extensions must implement a replace string or function'),
							x
						);
				}
			}
			return x;
		}
		(r.validateExtension = function (f) {
			var v = u(f, null);
			return v.valid ? !0 : (console.warn(v.error), !1);
		}),
			r.hasOwnProperty("helper") || (r.helper = {}),
			(r.helper.isString = function (f) {
				return typeof f == "string" || f instanceof String;
			}),
			(r.helper.isFunction = function (f) {
				var v = {};
				return f && v.toString.call(f) === "[object Function]";
			}),
			(r.helper.isArray = function (f) {
				return Array.isArray(f);
			}),
			(r.helper.isUndefined = function (f) {
				return typeof f == "undefined";
			}),
			(r.helper.forEach = function (f, v) {
				if (r.helper.isUndefined(f))
					throw new Error("obj param is required");
				if (r.helper.isUndefined(v))
					throw new Error("callback param is required");
				if (!r.helper.isFunction(v))
					throw new Error(
						"callback param must be a function/closure"
					);
				if (typeof f.forEach == "function") f.forEach(v);
				else if (r.helper.isArray(f))
					for (var m = 0; m < f.length; m++) v(f[m], m, f);
				else if (typeof f == "object")
					for (var x in f) f.hasOwnProperty(x) && v(f[x], x, f);
				else
					throw new Error(
						"obj does not seem to be an array or an iterable object"
					);
			}),
			(r.helper.stdExtName = function (f) {
				return f
					.replace(/[_?*+\/\\.^-]/g, "")
					.replace(/\s/g, "")
					.toLowerCase();
			});
		function c(f, v) {
			var m = v.charCodeAt(0);
			return "E" + m + "E";
		}
		(r.helper.escapeCharactersCallback = c),
			(r.helper.escapeCharacters = function (f, v, m) {
				var x = "([" + v.replace(/([\[\]\\])/g, "\\$1") + "])";
				m && (x = "\\\\" + x);
				var k = new RegExp(x, "g");
				return (f = f.replace(k, c)), f;
			}),
			(r.helper.unescapeHTMLEntities = function (f) {
				return f
					.replace(/&quot;/g, '"')
					.replace(/&lt;/g, "<")
					.replace(/&gt;/g, ">")
					.replace(/&amp;/g, "&");
			});
		var d = function (f, v, m, x) {
			var k = x || "",
				C = k.indexOf("g") > -1,
				_ = new RegExp(v + "|" + m, "g" + k.replace(/g/g, "")),
				T = new RegExp(v, k.replace(/g/g, "")),
				R = [],
				P,
				N,
				D,
				M,
				I;
			do
				for (P = 0; (D = _.exec(f)); )
					if (T.test(D[0]))
						P++ || ((N = _.lastIndex), (M = N - D[0].length));
					else if (P && !--P) {
						I = D.index + D[0].length;
						var $ = {
							left: { start: M, end: N },
							match: { start: N, end: D.index },
							right: { start: D.index, end: I },
							wholeMatch: { start: M, end: I },
						};
						if ((R.push($), !C)) return R;
					}
			while (P && (_.lastIndex = N));
			return R;
		};
		(r.helper.matchRecursiveRegExp = function (f, v, m, x) {
			for (var k = d(f, v, m, x), C = [], _ = 0; _ < k.length; ++_)
				C.push([
					f.slice(k[_].wholeMatch.start, k[_].wholeMatch.end),
					f.slice(k[_].match.start, k[_].match.end),
					f.slice(k[_].left.start, k[_].left.end),
					f.slice(k[_].right.start, k[_].right.end),
				]);
			return C;
		}),
			(r.helper.replaceRecursiveRegExp = function (f, v, m, x, k) {
				if (!r.helper.isFunction(v)) {
					var C = v;
					v = function () {
						return C;
					};
				}
				var _ = d(f, m, x, k),
					T = f,
					R = _.length;
				if (R > 0) {
					var P = [];
					_[0].wholeMatch.start !== 0 &&
						P.push(f.slice(0, _[0].wholeMatch.start));
					for (var N = 0; N < R; ++N)
						P.push(
							v(
								f.slice(
									_[N].wholeMatch.start,
									_[N].wholeMatch.end
								),
								f.slice(_[N].match.start, _[N].match.end),
								f.slice(_[N].left.start, _[N].left.end),
								f.slice(_[N].right.start, _[N].right.end)
							)
						),
							N < R - 1 &&
								P.push(
									f.slice(
										_[N].wholeMatch.end,
										_[N + 1].wholeMatch.start
									)
								);
					_[R - 1].wholeMatch.end < f.length &&
						P.push(f.slice(_[R - 1].wholeMatch.end)),
						(T = P.join(""));
				}
				return T;
			}),
			(r.helper.regexIndexOf = function (f, v, m) {
				if (!r.helper.isString(f))
					throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
				if (!(v instanceof RegExp))
					throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
				var x = f.substring(m || 0).search(v);
				return x >= 0 ? x + (m || 0) : x;
			}),
			(r.helper.splitAtIndex = function (f, v) {
				if (!r.helper.isString(f))
					throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
				return [f.substring(0, v), f.substring(v)];
			}),
			(r.helper.encodeEmailAddress = function (f) {
				var v = [
					function (m) {
						return "&#" + m.charCodeAt(0) + ";";
					},
					function (m) {
						return "&#x" + m.charCodeAt(0).toString(16) + ";";
					},
					function (m) {
						return m;
					},
				];
				return (
					(f = f.replace(/./g, function (m) {
						if (m === "@") m = v[Math.floor(Math.random() * 2)](m);
						else {
							var x = Math.random();
							m =
								x > 0.9
									? v[2](m)
									: x > 0.45
									? v[1](m)
									: v[0](m);
						}
						return m;
					})),
					f
				);
			}),
			(r.helper.padEnd = function (v, m, x) {
				return (
					(m = m >> 0),
					(x = String(x || " ")),
					v.length > m
						? String(v)
						: ((m = m - v.length),
						  m > x.length && (x += x.repeat(m / x.length)),
						  String(v) + x.slice(0, m))
				);
			}),
			typeof console == "undefined" &&
				(console = {
					warn: function (f) {
						alert(f);
					},
					log: function (f) {
						alert(f);
					},
					error: function (f) {
						throw f;
					},
				}),
			(r.helper.regexes = { asteriskDashAndColon: /([*_:~])/g }),
			(r.helper.emojis = {
				"+1": "",
				"-1": "",
				100: "",
				1234: "",
				"1st_place_medal": "",
				"2nd_place_medal": "",
				"3rd_place_medal": "",
				"8ball": "",
				a: "",
				ab: "",
				abc: "",
				abcd: "",
				accept: "",
				aerial_tramway: "",
				airplane: "",
				alarm_clock: "",
				alembic: "",
				alien: "",
				ambulance: "",
				amphora: "",
				anchor: "",
				angel: "",
				anger: "",
				angry: "",
				anguished: "",
				ant: "",
				apple: "",
				aquarius: "",
				aries: "",
				arrow_backward: "",
				arrow_double_down: "",
				arrow_double_up: "",
				arrow_down: "",
				arrow_down_small: "",
				arrow_forward: "",
				arrow_heading_down: "",
				arrow_heading_up: "",
				arrow_left: "",
				arrow_lower_left: "",
				arrow_lower_right: "",
				arrow_right: "",
				arrow_right_hook: "",
				arrow_up: "",
				arrow_up_down: "",
				arrow_up_small: "",
				arrow_upper_left: "",
				arrow_upper_right: "",
				arrows_clockwise: "",
				arrows_counterclockwise: "",
				art: "",
				articulated_lorry: "",
				artificial_satellite: "",
				astonished: "",
				athletic_shoe: "",
				atm: "",
				atom_symbol: "",
				avocado: "",
				b: "",
				baby: "",
				baby_bottle: "",
				baby_chick: "",
				baby_symbol: "",
				back: "",
				bacon: "",
				badminton: "",
				baggage_claim: "",
				baguette_bread: "",
				balance_scale: "",
				balloon: "",
				ballot_box: "",
				ballot_box_with_check: "",
				bamboo: "",
				banana: "",
				bangbang: "",
				bank: "",
				bar_chart: "",
				barber: "",
				baseball: "",
				basketball: "",
				basketball_man: "",
				basketball_woman: "&zwj;",
				bat: "",
				bath: "",
				bathtub: "",
				battery: "",
				beach_umbrella: "",
				bear: "",
				bed: "",
				bee: "",
				beer: "",
				beers: "",
				beetle: "",
				beginner: "",
				bell: "",
				bellhop_bell: "",
				bento: "",
				biking_man: "",
				bike: "",
				biking_woman: "&zwj;",
				bikini: "",
				biohazard: "",
				bird: "",
				birthday: "",
				black_circle: "",
				black_flag: "",
				black_heart: "",
				black_joker: "",
				black_large_square: "",
				black_medium_small_square: "",
				black_medium_square: "",
				black_nib: "",
				black_small_square: "",
				black_square_button: "",
				blonde_man: "",
				blonde_woman: "&zwj;",
				blossom: "",
				blowfish: "",
				blue_book: "",
				blue_car: "",
				blue_heart: "",
				blush: "",
				boar: "",
				boat: "",
				bomb: "",
				book: "",
				bookmark: "",
				bookmark_tabs: "",
				books: "",
				boom: "",
				boot: "",
				bouquet: "",
				bowing_man: "",
				bow_and_arrow: "",
				bowing_woman: "&zwj;",
				bowling: "",
				boxing_glove: "",
				boy: "",
				bread: "",
				bride_with_veil: "",
				bridge_at_night: "",
				briefcase: "",
				broken_heart: "",
				bug: "",
				building_construction: "",
				bulb: "",
				bullettrain_front: "",
				bullettrain_side: "",
				burrito: "",
				bus: "",
				business_suit_levitating: "",
				busstop: "",
				bust_in_silhouette: "",
				busts_in_silhouette: "",
				butterfly: "",
				cactus: "",
				cake: "",
				calendar: "",
				call_me_hand: "",
				calling: "",
				camel: "",
				camera: "",
				camera_flash: "",
				camping: "",
				cancer: "",
				candle: "",
				candy: "",
				canoe: "",
				capital_abcd: "",
				capricorn: "",
				car: "",
				card_file_box: "",
				card_index: "",
				card_index_dividers: "",
				carousel_horse: "",
				carrot: "",
				cat: "",
				cat2: "",
				cd: "",
				chains: "",
				champagne: "",
				chart: "",
				chart_with_downwards_trend: "",
				chart_with_upwards_trend: "",
				checkered_flag: "",
				cheese: "",
				cherries: "",
				cherry_blossom: "",
				chestnut: "",
				chicken: "",
				children_crossing: "",
				chipmunk: "",
				chocolate_bar: "",
				christmas_tree: "",
				church: "",
				cinema: "",
				circus_tent: "",
				city_sunrise: "",
				city_sunset: "",
				cityscape: "",
				cl: "",
				clamp: "",
				clap: "",
				clapper: "",
				classical_building: "",
				clinking_glasses: "",
				clipboard: "",
				clock1: "",
				clock10: "",
				clock1030: "",
				clock11: "",
				clock1130: "",
				clock12: "",
				clock1230: "",
				clock130: "",
				clock2: "",
				clock230: "",
				clock3: "",
				clock330: "",
				clock4: "",
				clock430: "",
				clock5: "",
				clock530: "",
				clock6: "",
				clock630: "",
				clock7: "",
				clock730: "",
				clock8: "",
				clock830: "",
				clock9: "",
				clock930: "",
				closed_book: "",
				closed_lock_with_key: "",
				closed_umbrella: "",
				cloud: "",
				cloud_with_lightning: "",
				cloud_with_lightning_and_rain: "",
				cloud_with_rain: "",
				cloud_with_snow: "",
				clown_face: "",
				clubs: "",
				cocktail: "",
				coffee: "",
				coffin: "",
				cold_sweat: "",
				comet: "",
				computer: "",
				computer_mouse: "",
				confetti_ball: "",
				confounded: "",
				confused: "",
				congratulations: "",
				construction: "",
				construction_worker_man: "",
				construction_worker_woman: "&zwj;",
				control_knobs: "",
				convenience_store: "",
				cookie: "",
				cool: "",
				policeman: "",
				copyright: "",
				corn: "",
				couch_and_lamp: "",
				couple: "",
				couple_with_heart_woman_man: "",
				couple_with_heart_man_man: "&zwj;&zwj;",
				couple_with_heart_woman_woman: "&zwj;&zwj;",
				couplekiss_man_man: "&zwj;&zwj;&zwj;",
				couplekiss_man_woman: "",
				couplekiss_woman_woman: "&zwj;&zwj;&zwj;",
				cow: "",
				cow2: "",
				cowboy_hat_face: "",
				crab: "",
				crayon: "",
				credit_card: "",
				crescent_moon: "",
				cricket: "",
				crocodile: "",
				croissant: "",
				crossed_fingers: "",
				crossed_flags: "",
				crossed_swords: "",
				crown: "",
				cry: "",
				crying_cat_face: "",
				crystal_ball: "",
				cucumber: "",
				cupid: "",
				curly_loop: "",
				currency_exchange: "",
				curry: "",
				custard: "",
				customs: "",
				cyclone: "",
				dagger: "",
				dancer: "",
				dancing_women: "",
				dancing_men: "&zwj;",
				dango: "",
				dark_sunglasses: "",
				dart: "",
				dash: "",
				date: "",
				deciduous_tree: "",
				deer: "",
				department_store: "",
				derelict_house: "",
				desert: "",
				desert_island: "",
				desktop_computer: "",
				male_detective: "",
				diamond_shape_with_a_dot_inside: "",
				diamonds: "",
				disappointed: "",
				disappointed_relieved: "",
				dizzy: "",
				dizzy_face: "",
				do_not_litter: "",
				dog: "",
				dog2: "",
				dollar: "",
				dolls: "",
				dolphin: "",
				door: "",
				doughnut: "",
				dove: "",
				dragon: "",
				dragon_face: "",
				dress: "",
				dromedary_camel: "",
				drooling_face: "",
				droplet: "",
				drum: "",
				duck: "",
				dvd: "",
				"e-mail": "",
				eagle: "",
				ear: "",
				ear_of_rice: "",
				earth_africa: "",
				earth_americas: "",
				earth_asia: "",
				egg: "",
				eggplant: "",
				eight_pointed_black_star: "",
				eight_spoked_asterisk: "",
				electric_plug: "",
				elephant: "",
				email: "",
				end: "",
				envelope_with_arrow: "",
				euro: "",
				european_castle: "",
				european_post_office: "",
				evergreen_tree: "",
				exclamation: "",
				expressionless: "",
				eye: "",
				eye_speech_bubble: "&zwj;",
				eyeglasses: "",
				eyes: "",
				face_with_head_bandage: "",
				face_with_thermometer: "",
				fist_oncoming: "",
				factory: "",
				fallen_leaf: "",
				family_man_woman_boy: "",
				family_man_boy: "&zwj;",
				family_man_boy_boy: "&zwj;&zwj;",
				family_man_girl: "&zwj;",
				family_man_girl_boy: "&zwj;&zwj;",
				family_man_girl_girl: "&zwj;&zwj;",
				family_man_man_boy: "&zwj;&zwj;",
				family_man_man_boy_boy: "&zwj;&zwj;&zwj;",
				family_man_man_girl: "&zwj;&zwj;",
				family_man_man_girl_boy: "&zwj;&zwj;&zwj;",
				family_man_man_girl_girl: "&zwj;&zwj;&zwj;",
				family_man_woman_boy_boy: "&zwj;&zwj;&zwj;",
				family_man_woman_girl: "&zwj;&zwj;",
				family_man_woman_girl_boy: "&zwj;&zwj;&zwj;",
				family_man_woman_girl_girl: "&zwj;&zwj;&zwj;",
				family_woman_boy: "&zwj;",
				family_woman_boy_boy: "&zwj;&zwj;",
				family_woman_girl: "&zwj;",
				family_woman_girl_boy: "&zwj;&zwj;",
				family_woman_girl_girl: "&zwj;&zwj;",
				family_woman_woman_boy: "&zwj;&zwj;",
				family_woman_woman_boy_boy: "&zwj;&zwj;&zwj;",
				family_woman_woman_girl: "&zwj;&zwj;",
				family_woman_woman_girl_boy: "&zwj;&zwj;&zwj;",
				family_woman_woman_girl_girl: "&zwj;&zwj;&zwj;",
				fast_forward: "",
				fax: "",
				fearful: "",
				feet: "",
				female_detective: "&zwj;",
				ferris_wheel: "",
				ferry: "",
				field_hockey: "",
				file_cabinet: "",
				file_folder: "",
				film_projector: "",
				film_strip: "",
				fire: "",
				fire_engine: "",
				fireworks: "",
				first_quarter_moon: "",
				first_quarter_moon_with_face: "",
				fish: "",
				fish_cake: "",
				fishing_pole_and_fish: "",
				fist_raised: "",
				fist_left: "",
				fist_right: "",
				flags: "",
				flashlight: "",
				fleur_de_lis: "",
				flight_arrival: "",
				flight_departure: "",
				floppy_disk: "",
				flower_playing_cards: "",
				flushed: "",
				fog: "",
				foggy: "",
				football: "",
				footprints: "",
				fork_and_knife: "",
				fountain: "",
				fountain_pen: "",
				four_leaf_clover: "",
				fox_face: "",
				framed_picture: "",
				free: "",
				fried_egg: "",
				fried_shrimp: "",
				fries: "",
				frog: "",
				frowning: "",
				frowning_face: "",
				frowning_man: "&zwj;",
				frowning_woman: "",
				middle_finger: "",
				fuelpump: "",
				full_moon: "",
				full_moon_with_face: "",
				funeral_urn: "",
				game_die: "",
				gear: "",
				gem: "",
				gemini: "",
				ghost: "",
				gift: "",
				gift_heart: "",
				girl: "",
				globe_with_meridians: "",
				goal_net: "",
				goat: "",
				golf: "",
				golfing_man: "",
				golfing_woman: "&zwj;",
				gorilla: "",
				grapes: "",
				green_apple: "",
				green_book: "",
				green_heart: "",
				green_salad: "",
				grey_exclamation: "",
				grey_question: "",
				grimacing: "",
				grin: "",
				grinning: "",
				guardsman: "",
				guardswoman: "&zwj;",
				guitar: "",
				gun: "",
				haircut_woman: "",
				haircut_man: "&zwj;",
				hamburger: "",
				hammer: "",
				hammer_and_pick: "",
				hammer_and_wrench: "",
				hamster: "",
				hand: "",
				handbag: "",
				handshake: "",
				hankey: "",
				hatched_chick: "",
				hatching_chick: "",
				headphones: "",
				hear_no_evil: "",
				heart: "",
				heart_decoration: "",
				heart_eyes: "",
				heart_eyes_cat: "",
				heartbeat: "",
				heartpulse: "",
				hearts: "",
				heavy_check_mark: "",
				heavy_division_sign: "",
				heavy_dollar_sign: "",
				heavy_heart_exclamation: "",
				heavy_minus_sign: "",
				heavy_multiplication_x: "",
				heavy_plus_sign: "",
				helicopter: "",
				herb: "",
				hibiscus: "",
				high_brightness: "",
				high_heel: "",
				hocho: "",
				hole: "",
				honey_pot: "",
				horse: "",
				horse_racing: "",
				hospital: "",
				hot_pepper: "",
				hotdog: "",
				hotel: "",
				hotsprings: "",
				hourglass: "",
				hourglass_flowing_sand: "",
				house: "",
				house_with_garden: "",
				houses: "",
				hugs: "",
				hushed: "",
				ice_cream: "",
				ice_hockey: "",
				ice_skate: "",
				icecream: "",
				id: "",
				ideograph_advantage: "",
				imp: "",
				inbox_tray: "",
				incoming_envelope: "",
				tipping_hand_woman: "",
				information_source: "",
				innocent: "",
				interrobang: "",
				iphone: "",
				izakaya_lantern: "",
				jack_o_lantern: "",
				japan: "",
				japanese_castle: "",
				japanese_goblin: "",
				japanese_ogre: "",
				jeans: "",
				joy: "",
				joy_cat: "",
				joystick: "",
				kaaba: "",
				key: "",
				keyboard: "",
				keycap_ten: "",
				kick_scooter: "",
				kimono: "",
				kiss: "",
				kissing: "",
				kissing_cat: "",
				kissing_closed_eyes: "",
				kissing_heart: "",
				kissing_smiling_eyes: "",
				kiwi_fruit: "",
				koala: "",
				koko: "",
				label: "",
				large_blue_circle: "",
				large_blue_diamond: "",
				large_orange_diamond: "",
				last_quarter_moon: "",
				last_quarter_moon_with_face: "",
				latin_cross: "",
				laughing: "",
				leaves: "",
				ledger: "",
				left_luggage: "",
				left_right_arrow: "",
				leftwards_arrow_with_hook: "",
				lemon: "",
				leo: "",
				leopard: "",
				level_slider: "",
				libra: "",
				light_rail: "",
				link: "",
				lion: "",
				lips: "",
				lipstick: "",
				lizard: "",
				lock: "",
				lock_with_ink_pen: "",
				lollipop: "",
				loop: "",
				loud_sound: "",
				loudspeaker: "",
				love_hotel: "",
				love_letter: "",
				low_brightness: "",
				lying_face: "",
				m: "",
				mag: "",
				mag_right: "",
				mahjong: "",
				mailbox: "",
				mailbox_closed: "",
				mailbox_with_mail: "",
				mailbox_with_no_mail: "",
				man: "",
				man_artist: "&zwj;",
				man_astronaut: "&zwj;",
				man_cartwheeling: "&zwj;",
				man_cook: "&zwj;",
				man_dancing: "",
				man_facepalming: "&zwj;",
				man_factory_worker: "&zwj;",
				man_farmer: "&zwj;",
				man_firefighter: "&zwj;",
				man_health_worker: "&zwj;",
				man_in_tuxedo: "",
				man_judge: "&zwj;",
				man_juggling: "&zwj;",
				man_mechanic: "&zwj;",
				man_office_worker: "&zwj;",
				man_pilot: "&zwj;",
				man_playing_handball: "&zwj;",
				man_playing_water_polo: "&zwj;",
				man_scientist: "&zwj;",
				man_shrugging: "&zwj;",
				man_singer: "&zwj;",
				man_student: "&zwj;",
				man_teacher: "&zwj;",
				man_technologist: "&zwj;",
				man_with_gua_pi_mao: "",
				man_with_turban: "",
				tangerine: "",
				mans_shoe: "",
				mantelpiece_clock: "",
				maple_leaf: "",
				martial_arts_uniform: "",
				mask: "",
				massage_woman: "",
				massage_man: "&zwj;",
				meat_on_bone: "",
				medal_military: "",
				medal_sports: "",
				mega: "",
				melon: "",
				memo: "",
				men_wrestling: "&zwj;",
				menorah: "",
				mens: "",
				metal: "",
				metro: "",
				microphone: "",
				microscope: "",
				milk_glass: "",
				milky_way: "",
				minibus: "",
				minidisc: "",
				mobile_phone_off: "",
				money_mouth_face: "",
				money_with_wings: "",
				moneybag: "",
				monkey: "",
				monkey_face: "",
				monorail: "",
				moon: "",
				mortar_board: "",
				mosque: "",
				motor_boat: "",
				motor_scooter: "",
				motorcycle: "",
				motorway: "",
				mount_fuji: "",
				mountain: "",
				mountain_biking_man: "",
				mountain_biking_woman: "&zwj;",
				mountain_cableway: "",
				mountain_railway: "",
				mountain_snow: "",
				mouse: "",
				mouse2: "",
				movie_camera: "",
				moyai: "",
				mrs_claus: "",
				muscle: "",
				mushroom: "",
				musical_keyboard: "",
				musical_note: "",
				musical_score: "",
				mute: "",
				nail_care: "",
				name_badge: "",
				national_park: "",
				nauseated_face: "",
				necktie: "",
				negative_squared_cross_mark: "",
				nerd_face: "",
				neutral_face: "",
				new: "",
				new_moon: "",
				new_moon_with_face: "",
				newspaper: "",
				newspaper_roll: "",
				next_track_button: "",
				ng: "",
				no_good_man: "&zwj;",
				no_good_woman: "",
				night_with_stars: "",
				no_bell: "",
				no_bicycles: "",
				no_entry: "",
				no_entry_sign: "",
				no_mobile_phones: "",
				no_mouth: "",
				no_pedestrians: "",
				no_smoking: "",
				"non-potable_water": "",
				nose: "",
				notebook: "",
				notebook_with_decorative_cover: "",
				notes: "",
				nut_and_bolt: "",
				o: "",
				o2: "",
				ocean: "",
				octopus: "",
				oden: "",
				office: "",
				oil_drum: "",
				ok: "",
				ok_hand: "",
				ok_man: "&zwj;",
				ok_woman: "",
				old_key: "",
				older_man: "",
				older_woman: "",
				om: "",
				on: "",
				oncoming_automobile: "",
				oncoming_bus: "",
				oncoming_police_car: "",
				oncoming_taxi: "",
				open_file_folder: "",
				open_hands: "",
				open_mouth: "",
				open_umbrella: "",
				ophiuchus: "",
				orange_book: "",
				orthodox_cross: "",
				outbox_tray: "",
				owl: "",
				ox: "",
				package: "",
				page_facing_up: "",
				page_with_curl: "",
				pager: "",
				paintbrush: "",
				palm_tree: "",
				pancakes: "",
				panda_face: "",
				paperclip: "",
				paperclips: "",
				parasol_on_ground: "",
				parking: "",
				part_alternation_mark: "",
				partly_sunny: "",
				passenger_ship: "",
				passport_control: "",
				pause_button: "",
				peace_symbol: "",
				peach: "",
				peanuts: "",
				pear: "",
				pen: "",
				pencil2: "",
				penguin: "",
				pensive: "",
				performing_arts: "",
				persevere: "",
				person_fencing: "",
				pouting_woman: "",
				phone: "",
				pick: "",
				pig: "",
				pig2: "",
				pig_nose: "",
				pill: "",
				pineapple: "",
				ping_pong: "",
				pisces: "",
				pizza: "",
				place_of_worship: "",
				plate_with_cutlery: "",
				play_or_pause_button: "",
				point_down: "",
				point_left: "",
				point_right: "",
				point_up: "",
				point_up_2: "",
				police_car: "",
				policewoman: "&zwj;",
				poodle: "",
				popcorn: "",
				post_office: "",
				postal_horn: "",
				postbox: "",
				potable_water: "",
				potato: "",
				pouch: "",
				poultry_leg: "",
				pound: "",
				rage: "",
				pouting_cat: "",
				pouting_man: "&zwj;",
				pray: "",
				prayer_beads: "",
				pregnant_woman: "",
				previous_track_button: "",
				prince: "",
				princess: "",
				printer: "",
				purple_heart: "",
				purse: "",
				pushpin: "",
				put_litter_in_its_place: "",
				question: "",
				rabbit: "",
				rabbit2: "",
				racehorse: "",
				racing_car: "",
				radio: "",
				radio_button: "",
				radioactive: "",
				railway_car: "",
				railway_track: "",
				rainbow: "",
				rainbow_flag: "&zwj;",
				raised_back_of_hand: "",
				raised_hand_with_fingers_splayed: "",
				raised_hands: "",
				raising_hand_woman: "",
				raising_hand_man: "&zwj;",
				ram: "",
				ramen: "",
				rat: "",
				record_button: "",
				recycle: "",
				red_circle: "",
				registered: "",
				relaxed: "",
				relieved: "",
				reminder_ribbon: "",
				repeat: "",
				repeat_one: "",
				rescue_worker_helmet: "",
				restroom: "",
				revolving_hearts: "",
				rewind: "",
				rhinoceros: "",
				ribbon: "",
				rice: "",
				rice_ball: "",
				rice_cracker: "",
				rice_scene: "",
				right_anger_bubble: "",
				ring: "",
				robot: "",
				rocket: "",
				rofl: "",
				roll_eyes: "",
				roller_coaster: "",
				rooster: "",
				rose: "",
				rosette: "",
				rotating_light: "",
				round_pushpin: "",
				rowing_man: "",
				rowing_woman: "&zwj;",
				rugby_football: "",
				running_man: "",
				running_shirt_with_sash: "",
				running_woman: "&zwj;",
				sa: "",
				sagittarius: "",
				sake: "",
				sandal: "",
				santa: "",
				satellite: "",
				saxophone: "",
				school: "",
				school_satchel: "",
				scissors: "",
				scorpion: "",
				scorpius: "",
				scream: "",
				scream_cat: "",
				scroll: "",
				seat: "",
				secret: "",
				see_no_evil: "",
				seedling: "",
				selfie: "",
				shallow_pan_of_food: "",
				shamrock: "",
				shark: "",
				shaved_ice: "",
				sheep: "",
				shell: "",
				shield: "",
				shinto_shrine: "",
				ship: "",
				shirt: "",
				shopping: "",
				shopping_cart: "",
				shower: "",
				shrimp: "",
				signal_strength: "",
				six_pointed_star: "",
				ski: "",
				skier: "",
				skull: "",
				skull_and_crossbones: "",
				sleeping: "",
				sleeping_bed: "",
				sleepy: "",
				slightly_frowning_face: "",
				slightly_smiling_face: "",
				slot_machine: "",
				small_airplane: "",
				small_blue_diamond: "",
				small_orange_diamond: "",
				small_red_triangle: "",
				small_red_triangle_down: "",
				smile: "",
				smile_cat: "",
				smiley: "",
				smiley_cat: "",
				smiling_imp: "",
				smirk: "",
				smirk_cat: "",
				smoking: "",
				snail: "",
				snake: "",
				sneezing_face: "",
				snowboarder: "",
				snowflake: "",
				snowman: "",
				snowman_with_snow: "",
				sob: "",
				soccer: "",
				soon: "",
				sos: "",
				sound: "",
				space_invader: "",
				spades: "",
				spaghetti: "",
				sparkle: "",
				sparkler: "",
				sparkles: "",
				sparkling_heart: "",
				speak_no_evil: "",
				speaker: "",
				speaking_head: "",
				speech_balloon: "",
				speedboat: "",
				spider: "",
				spider_web: "",
				spiral_calendar: "",
				spiral_notepad: "",
				spoon: "",
				squid: "",
				stadium: "",
				star: "",
				star2: "",
				star_and_crescent: "",
				star_of_david: "",
				stars: "",
				station: "",
				statue_of_liberty: "",
				steam_locomotive: "",
				stew: "",
				stop_button: "",
				stop_sign: "",
				stopwatch: "",
				straight_ruler: "",
				strawberry: "",
				stuck_out_tongue: "",
				stuck_out_tongue_closed_eyes: "",
				stuck_out_tongue_winking_eye: "",
				studio_microphone: "",
				stuffed_flatbread: "",
				sun_behind_large_cloud: "",
				sun_behind_rain_cloud: "",
				sun_behind_small_cloud: "",
				sun_with_face: "",
				sunflower: "",
				sunglasses: "",
				sunny: "",
				sunrise: "",
				sunrise_over_mountains: "",
				surfing_man: "",
				surfing_woman: "&zwj;",
				sushi: "",
				suspension_railway: "",
				sweat: "",
				sweat_drops: "",
				sweat_smile: "",
				sweet_potato: "",
				swimming_man: "",
				swimming_woman: "&zwj;",
				symbols: "",
				synagogue: "",
				syringe: "",
				taco: "",
				tada: "",
				tanabata_tree: "",
				taurus: "",
				taxi: "",
				tea: "",
				telephone_receiver: "",
				telescope: "",
				tennis: "",
				tent: "",
				thermometer: "",
				thinking: "",
				thought_balloon: "",
				ticket: "",
				tickets: "",
				tiger: "",
				tiger2: "",
				timer_clock: "",
				tipping_hand_man: "&zwj;",
				tired_face: "",
				tm: "",
				toilet: "",
				tokyo_tower: "",
				tomato: "",
				tongue: "",
				top: "",
				tophat: "",
				tornado: "",
				trackball: "",
				tractor: "",
				traffic_light: "",
				train: "",
				train2: "",
				tram: "",
				triangular_flag_on_post: "",
				triangular_ruler: "",
				trident: "",
				triumph: "",
				trolleybus: "",
				trophy: "",
				tropical_drink: "",
				tropical_fish: "",
				truck: "",
				trumpet: "",
				tulip: "",
				tumbler_glass: "",
				turkey: "",
				turtle: "",
				tv: "",
				twisted_rightwards_arrows: "",
				two_hearts: "",
				two_men_holding_hands: "",
				two_women_holding_hands: "",
				u5272: "",
				u5408: "",
				u55b6: "",
				u6307: "",
				u6708: "",
				u6709: "",
				u6e80: "",
				u7121: "",
				u7533: "",
				u7981: "",
				u7a7a: "",
				umbrella: "",
				unamused: "",
				underage: "",
				unicorn: "",
				unlock: "",
				up: "",
				upside_down_face: "",
				v: "",
				vertical_traffic_light: "",
				vhs: "",
				vibration_mode: "",
				video_camera: "",
				video_game: "",
				violin: "",
				virgo: "",
				volcano: "",
				volleyball: "",
				vs: "",
				vulcan_salute: "",
				walking_man: "",
				walking_woman: "&zwj;",
				waning_crescent_moon: "",
				waning_gibbous_moon: "",
				warning: "",
				wastebasket: "",
				watch: "",
				water_buffalo: "",
				watermelon: "",
				wave: "",
				wavy_dash: "",
				waxing_crescent_moon: "",
				wc: "",
				weary: "",
				wedding: "",
				weight_lifting_man: "",
				weight_lifting_woman: "&zwj;",
				whale: "",
				whale2: "",
				wheel_of_dharma: "",
				wheelchair: "",
				white_check_mark: "",
				white_circle: "",
				white_flag: "",
				white_flower: "",
				white_large_square: "",
				white_medium_small_square: "",
				white_medium_square: "",
				white_small_square: "",
				white_square_button: "",
				wilted_flower: "",
				wind_chime: "",
				wind_face: "",
				wine_glass: "",
				wink: "",
				wolf: "",
				woman: "",
				woman_artist: "&zwj;",
				woman_astronaut: "&zwj;",
				woman_cartwheeling: "&zwj;",
				woman_cook: "&zwj;",
				woman_facepalming: "&zwj;",
				woman_factory_worker: "&zwj;",
				woman_farmer: "&zwj;",
				woman_firefighter: "&zwj;",
				woman_health_worker: "&zwj;",
				woman_judge: "&zwj;",
				woman_juggling: "&zwj;",
				woman_mechanic: "&zwj;",
				woman_office_worker: "&zwj;",
				woman_pilot: "&zwj;",
				woman_playing_handball: "&zwj;",
				woman_playing_water_polo: "&zwj;",
				woman_scientist: "&zwj;",
				woman_shrugging: "&zwj;",
				woman_singer: "&zwj;",
				woman_student: "&zwj;",
				woman_teacher: "&zwj;",
				woman_technologist: "&zwj;",
				woman_with_turban: "&zwj;",
				womans_clothes: "",
				womans_hat: "",
				women_wrestling: "&zwj;",
				womens: "",
				world_map: "",
				worried: "",
				wrench: "",
				writing_hand: "",
				x: "",
				yellow_heart: "",
				yen: "",
				yin_yang: "",
				yum: "",
				zap: "",
				zipper_mouth_face: "",
				zzz: "",
				octocat:
					'<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
				showdown: `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`,
			}),
			(r.Converter = function (f) {
				var v = {},
					m = [],
					x = [],
					k = {},
					C = l,
					_ = { parsed: {}, raw: "", format: "" };
				T();
				function T() {
					f = f || {};
					for (var M in s) s.hasOwnProperty(M) && (v[M] = s[M]);
					if (typeof f == "object")
						for (var I in f) f.hasOwnProperty(I) && (v[I] = f[I]);
					else
						throw Error(
							"Converter expects the passed parameter to be an object, but " +
								typeof f +
								" was passed instead."
						);
					v.extensions && r.helper.forEach(v.extensions, R);
				}
				function R(M, I) {
					if (((I = I || null), r.helper.isString(M)))
						if (
							((M = r.helper.stdExtName(M)),
							(I = M),
							r.extensions[M])
						) {
							console.warn(
								"DEPRECATION WARNING: " +
									M +
									" is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"
							),
								P(r.extensions[M], M);
							return;
						} else if (!r.helper.isUndefined(i[M])) M = i[M];
						else
							throw Error(
								'Extension "' +
									M +
									'" could not be loaded. It was either not found or is not a valid extension.'
							);
					typeof M == "function" && (M = M()),
						r.helper.isArray(M) || (M = [M]);
					var $ = u(M, I);
					if (!$.valid) throw Error($.error);
					for (var V = 0; V < M.length; ++V) {
						switch (M[V].type) {
							case "lang":
								m.push(M[V]);
								break;
							case "output":
								x.push(M[V]);
								break;
						}
						if (M[V].hasOwnProperty("listeners"))
							for (var ie in M[V].listeners)
								M[V].listeners.hasOwnProperty(ie) &&
									N(ie, M[V].listeners[ie]);
					}
				}
				function P(M, I) {
					typeof M == "function" && (M = M(new r.Converter())),
						r.helper.isArray(M) || (M = [M]);
					var $ = u(M, I);
					if (!$.valid) throw Error($.error);
					for (var V = 0; V < M.length; ++V)
						switch (M[V].type) {
							case "lang":
								m.push(M[V]);
								break;
							case "output":
								x.push(M[V]);
								break;
							default:
								throw Error(
									"Extension loader error: Type unrecognized!!!"
								);
						}
				}
				function N(M, I) {
					if (!r.helper.isString(M))
						throw Error(
							"Invalid argument in converter.listen() method: name must be a string, but " +
								typeof M +
								" given"
						);
					if (typeof I != "function")
						throw Error(
							"Invalid argument in converter.listen() method: callback must be a function, but " +
								typeof I +
								" given"
						);
					k.hasOwnProperty(M) || (k[M] = []), k[M].push(I);
				}
				function D(M) {
					var I = M.match(/^\s*/)[0].length,
						$ = new RegExp("^\\s{0," + I + "}", "gm");
					return M.replace($, "");
				}
				(this._dispatch = function (I, $, V, ie) {
					if (k.hasOwnProperty(I))
						for (var Y = 0; Y < k[I].length; ++Y) {
							var he = k[I][Y](I, $, this, V, ie);
							he && typeof he != "undefined" && ($ = he);
						}
					return $;
				}),
					(this.listen = function (M, I) {
						return N(M, I), this;
					}),
					(this.makeHtml = function (M) {
						if (!M) return M;
						var I = {
							gHtmlBlocks: [],
							gHtmlMdBlocks: [],
							gHtmlSpans: [],
							gUrls: {},
							gTitles: {},
							gDimensions: {},
							gListLevel: 0,
							hashLinkCounts: {},
							langExtensions: m,
							outputModifiers: x,
							converter: this,
							ghCodeBlocks: [],
							metadata: { parsed: {}, raw: "", format: "" },
						};
						return (
							(M = M.replace(//g, "T")),
							(M = M.replace(/\$/g, "D")),
							(M = M.replace(
								/\r\n/g,
								`
`
							)),
							(M = M.replace(
								/\r/g,
								`
`
							)),
							(M = M.replace(/\u00A0/g, "&nbsp;")),
							v.smartIndentationFix && (M = D(M)),
							(M =
								`

` +
								M +
								`

`),
							(M = r.subParser("detab")(M, v, I)),
							(M = M.replace(/^[ \t]+$/gm, "")),
							r.helper.forEach(m, function ($) {
								M = r.subParser("runExtension")($, M, v, I);
							}),
							(M = r.subParser("metadata")(M, v, I)),
							(M = r.subParser("hashPreCodeTags")(M, v, I)),
							(M = r.subParser("githubCodeBlocks")(M, v, I)),
							(M = r.subParser("hashHTMLBlocks")(M, v, I)),
							(M = r.subParser("hashCodeTags")(M, v, I)),
							(M = r.subParser("stripLinkDefinitions")(M, v, I)),
							(M = r.subParser("blockGamut")(M, v, I)),
							(M = r.subParser("unhashHTMLSpans")(M, v, I)),
							(M = r.subParser("unescapeSpecialChars")(M, v, I)),
							(M = M.replace(/D/g, "$$")),
							(M = M.replace(/T/g, "")),
							(M = r.subParser("completeHTMLDocument")(M, v, I)),
							r.helper.forEach(x, function ($) {
								M = r.subParser("runExtension")($, M, v, I);
							}),
							(_ = I.metadata),
							M
						);
					}),
					(this.makeMarkdown = this.makeMd =
						function (M, I) {
							if (
								((M = M.replace(
									/\r\n/g,
									`
`
								)),
								(M = M.replace(
									/\r/g,
									`
`
								)),
								(M = M.replace(/>[ \t]+</, ">NBSP;<")),
								!I)
							)
								if (window && window.document)
									I = window.document;
								else
									throw new Error(
										"HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM"
									);
							var $ = I.createElement("div");
							$.innerHTML = M;
							var V = { preList: Ce($) };
							Le($);
							for (
								var ie = $.childNodes, Y = "", he = 0;
								he < ie.length;
								he++
							)
								Y += r.subParser("makeMarkdown.node")(
									ie[he],
									V
								);
							function Le(Me) {
								for (
									var Te = 0;
									Te < Me.childNodes.length;
									++Te
								) {
									var B = Me.childNodes[Te];
									B.nodeType === 3
										? !/\S/.test(B.nodeValue) &&
										  !/^[ ]+$/.test(B.nodeValue)
											? (Me.removeChild(B), --Te)
											: ((B.nodeValue = B.nodeValue
													.split(
														`
`
													)
													.join(" ")),
											  (B.nodeValue =
													B.nodeValue.replace(
														/(\s)+/g,
														"$1"
													)))
										: B.nodeType === 1 && Le(B);
								}
							}
							function Ce(Me) {
								for (
									var Te = Me.querySelectorAll("pre"),
										B = [],
										Z = 0;
									Z < Te.length;
									++Z
								)
									if (
										Te[Z].childElementCount === 1 &&
										Te[
											Z
										].firstChild.tagName.toLowerCase() ===
											"code"
									) {
										var ne =
												Te[
													Z
												].firstChild.innerHTML.trim(),
											ce =
												Te[Z].firstChild.getAttribute(
													"data-language"
												) || "";
										if (ce === "")
											for (
												var $e =
														Te[
															Z
														].firstChild.className.split(
															" "
														),
													Je = 0;
												Je < $e.length;
												++Je
											) {
												var A =
													$e[Je].match(
														/^language-(.+)$/
													);
												if (A !== null) {
													ce = A[1];
													break;
												}
											}
										(ne =
											r.helper.unescapeHTMLEntities(ne)),
											B.push(ne),
											(Te[Z].outerHTML =
												'<precode language="' +
												ce +
												'" precodenum="' +
												Z.toString() +
												'"></precode>');
									} else
										B.push(Te[Z].innerHTML),
											(Te[Z].innerHTML = ""),
											Te[Z].setAttribute(
												"prenum",
												Z.toString()
											);
								return B;
							}
							return Y;
						}),
					(this.setOption = function (M, I) {
						v[M] = I;
					}),
					(this.getOption = function (M) {
						return v[M];
					}),
					(this.getOptions = function () {
						return v;
					}),
					(this.addExtension = function (M, I) {
						(I = I || null), R(M, I);
					}),
					(this.useExtension = function (M) {
						R(M);
					}),
					(this.setFlavor = function (M) {
						if (!a.hasOwnProperty(M))
							throw Error(M + " flavor was not found");
						var I = a[M];
						C = M;
						for (var $ in I) I.hasOwnProperty($) && (v[$] = I[$]);
					}),
					(this.getFlavor = function () {
						return C;
					}),
					(this.removeExtension = function (M) {
						r.helper.isArray(M) || (M = [M]);
						for (var I = 0; I < M.length; ++I) {
							for (var $ = M[I], V = 0; V < m.length; ++V)
								m[V] === $ && m.splice(V, 1);
							for (var ie = 0; ie < x.length; ++ie)
								x[ie] === $ && x.splice(ie, 1);
						}
					}),
					(this.getAllExtensions = function () {
						return { language: m, output: x };
					}),
					(this.getMetadata = function (M) {
						return M ? _.raw : _.parsed;
					}),
					(this.getMetadataFormat = function () {
						return _.format;
					}),
					(this._setMetadataPair = function (M, I) {
						_.parsed[M] = I;
					}),
					(this._setMetadataFormat = function (M) {
						_.format = M;
					}),
					(this._setMetadataRaw = function (M) {
						_.raw = M;
					});
			}),
			r.subParser("anchors", function (f, v, m) {
				f = m.converter._dispatch("anchors.before", f, v, m);
				var x = function (k, C, _, T, R, P, N) {
					if (
						(r.helper.isUndefined(N) && (N = ""),
						(_ = _.toLowerCase()),
						k.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
					)
						T = "";
					else if (!T)
						if (
							(_ || (_ = C.toLowerCase().replace(/ ?\n/g, " ")),
							(T = "#" + _),
							!r.helper.isUndefined(m.gUrls[_]))
						)
							(T = m.gUrls[_]),
								r.helper.isUndefined(m.gTitles[_]) ||
									(N = m.gTitles[_]);
						else return k;
					T = T.replace(
						r.helper.regexes.asteriskDashAndColon,
						r.helper.escapeCharactersCallback
					);
					var D = '<a href="' + T + '"';
					return (
						N !== "" &&
							N !== null &&
							((N = N.replace(/"/g, "&quot;")),
							(N = N.replace(
								r.helper.regexes.asteriskDashAndColon,
								r.helper.escapeCharactersCallback
							)),
							(D += ' title="' + N + '"')),
						v.openLinksInNewWindow &&
							!/^#/.test(T) &&
							(D +=
								' rel="noopener noreferrer" target="E95Eblank"'),
						(D += ">" + C + "</a>"),
						D
					);
				};
				return (
					(f = f.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g,
						x
					)),
					(f = f.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
						x
					)),
					(f = f.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
						x
					)),
					(f = f.replace(/\[([^\[\]]+)]()()()()()/g, x)),
					v.ghMentions &&
						(f = f.replace(
							/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gim,
							function (k, C, _, T, R) {
								if (_ === "\\") return C + T;
								if (!r.helper.isString(v.ghMentionsLink))
									throw new Error(
										"ghMentionsLink option must be a string"
									);
								var P = v.ghMentionsLink.replace(/\{u}/g, R),
									N = "";
								return (
									v.openLinksInNewWindow &&
										(N =
											' rel="noopener noreferrer" target="E95Eblank"'),
									C +
										'<a href="' +
										P +
										'"' +
										N +
										">" +
										T +
										"</a>"
								);
							}
						)),
					(f = m.converter._dispatch("anchors.after", f, v, m)),
					f
				);
			});
		var h =
				/([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
			p =
				/([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
			g = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
			y =
				/(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gim,
			b = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
			w = function (f) {
				return function (v, m, x, k, C, _, T) {
					x = x.replace(
						r.helper.regexes.asteriskDashAndColon,
						r.helper.escapeCharactersCallback
					);
					var R = x,
						P = "",
						N = "",
						D = m || "",
						M = T || "";
					return (
						/^www\./i.test(x) &&
							(x = x.replace(/^www\./i, "http://www.")),
						f.excludeTrailingPunctuationFromURLs && _ && (P = _),
						f.openLinksInNewWindow &&
							(N =
								' rel="noopener noreferrer" target="E95Eblank"'),
						D + '<a href="' + x + '"' + N + ">" + R + "</a>" + P + M
					);
				};
			},
			S = function (f, v) {
				return function (m, x, k) {
					var C = "mailto:";
					return (
						(x = x || ""),
						(k = r.subParser("unescapeSpecialChars")(k, f, v)),
						f.encodeEmails
							? ((C = r.helper.encodeEmailAddress(C + k)),
							  (k = r.helper.encodeEmailAddress(k)))
							: (C = C + k),
						x + '<a href="' + C + '">' + k + "</a>"
					);
				};
			};
		r.subParser("autoLinks", function (f, v, m) {
			return (
				(f = m.converter._dispatch("autoLinks.before", f, v, m)),
				(f = f.replace(g, w(v))),
				(f = f.replace(b, S(v, m))),
				(f = m.converter._dispatch("autoLinks.after", f, v, m)),
				f
			);
		}),
			r.subParser("simplifiedAutoLinks", function (f, v, m) {
				return (
					v.simplifiedAutoLink &&
						((f = m.converter._dispatch(
							"simplifiedAutoLinks.before",
							f,
							v,
							m
						)),
						v.excludeTrailingPunctuationFromURLs
							? (f = f.replace(p, w(v)))
							: (f = f.replace(h, w(v))),
						(f = f.replace(y, S(v, m))),
						(f = m.converter._dispatch(
							"simplifiedAutoLinks.after",
							f,
							v,
							m
						))),
					f
				);
			}),
			r.subParser("blockGamut", function (f, v, m) {
				return (
					(f = m.converter._dispatch("blockGamut.before", f, v, m)),
					(f = r.subParser("blockQuotes")(f, v, m)),
					(f = r.subParser("headers")(f, v, m)),
					(f = r.subParser("horizontalRule")(f, v, m)),
					(f = r.subParser("lists")(f, v, m)),
					(f = r.subParser("codeBlocks")(f, v, m)),
					(f = r.subParser("tables")(f, v, m)),
					(f = r.subParser("hashHTMLBlocks")(f, v, m)),
					(f = r.subParser("paragraphs")(f, v, m)),
					(f = m.converter._dispatch("blockGamut.after", f, v, m)),
					f
				);
			}),
			r.subParser("blockQuotes", function (f, v, m) {
				(f = m.converter._dispatch("blockQuotes.before", f, v, m)),
					(f =
						f +
						`

`);
				var x = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
				return (
					v.splitAdjacentBlockquotes &&
						(x = /^ {0,3}>[\s\S]*?(?:\n\n)/gm),
					(f = f.replace(x, function (k) {
						return (
							(k = k.replace(/^[ \t]*>[ \t]?/gm, "")),
							(k = k.replace(/0/g, "")),
							(k = k.replace(/^[ \t]+$/gm, "")),
							(k = r.subParser("githubCodeBlocks")(k, v, m)),
							(k = r.subParser("blockGamut")(k, v, m)),
							(k = k.replace(/(^|\n)/g, "$1  ")),
							(k = k.replace(
								/(\s*<pre>[^\r]+?<\/pre>)/gm,
								function (C, _) {
									var T = _;
									return (
										(T = T.replace(/^  /gm, "0")),
										(T = T.replace(/0/g, "")),
										T
									);
								}
							)),
							r.subParser("hashBlock")(
								`<blockquote>
` +
									k +
									`
</blockquote>`,
								v,
								m
							)
						);
					})),
					(f = m.converter._dispatch("blockQuotes.after", f, v, m)),
					f
				);
			}),
			r.subParser("codeBlocks", function (f, v, m) {
				(f = m.converter._dispatch("codeBlocks.before", f, v, m)),
					(f += "0");
				var x =
					/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
				return (
					(f = f.replace(x, function (k, C, _) {
						var T = C,
							R = _,
							P = `
`;
						return (
							(T = r.subParser("outdent")(T, v, m)),
							(T = r.subParser("encodeCode")(T, v, m)),
							(T = r.subParser("detab")(T, v, m)),
							(T = T.replace(/^\n+/g, "")),
							(T = T.replace(/\n+$/g, "")),
							v.omitExtraWLInCodeBlocks && (P = ""),
							(T = "<pre><code>" + T + P + "</code></pre>"),
							r.subParser("hashBlock")(T, v, m) + R
						);
					})),
					(f = f.replace(/0/, "")),
					(f = m.converter._dispatch("codeBlocks.after", f, v, m)),
					f
				);
			}),
			r.subParser("codeSpans", function (f, v, m) {
				return (
					(f = m.converter._dispatch("codeSpans.before", f, v, m)),
					typeof f == "undefined" && (f = ""),
					(f = f.replace(
						/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
						function (x, k, C, _) {
							var T = _;
							return (
								(T = T.replace(/^([ \t]*)/g, "")),
								(T = T.replace(/[ \t]*$/g, "")),
								(T = r.subParser("encodeCode")(T, v, m)),
								(T = k + "<code>" + T + "</code>"),
								(T = r.subParser("hashHTMLSpans")(T, v, m)),
								T
							);
						}
					)),
					(f = m.converter._dispatch("codeSpans.after", f, v, m)),
					f
				);
			}),
			r.subParser("completeHTMLDocument", function (f, v, m) {
				if (!v.completeHTMLDocument) return f;
				f = m.converter._dispatch(
					"completeHTMLDocument.before",
					f,
					v,
					m
				);
				var x = "html",
					k = `<!DOCTYPE HTML>
`,
					C = "",
					_ = `<meta charset="utf-8">
`,
					T = "",
					R = "";
				typeof m.metadata.parsed.doctype != "undefined" &&
					((k =
						"<!DOCTYPE " +
						m.metadata.parsed.doctype +
						`>
`),
					(x = m.metadata.parsed.doctype.toString().toLowerCase()),
					(x === "html" || x === "html5") &&
						(_ = '<meta charset="utf-8">'));
				for (var P in m.metadata.parsed)
					if (m.metadata.parsed.hasOwnProperty(P))
						switch (P.toLowerCase()) {
							case "doctype":
								break;
							case "title":
								C =
									"<title>" +
									m.metadata.parsed.title +
									`</title>
`;
								break;
							case "charset":
								x === "html" || x === "html5"
									? (_ =
											'<meta charset="' +
											m.metadata.parsed.charset +
											`">
`)
									: (_ =
											'<meta name="charset" content="' +
											m.metadata.parsed.charset +
											`">
`);
								break;
							case "language":
							case "lang":
								(T = ' lang="' + m.metadata.parsed[P] + '"'),
									(R +=
										'<meta name="' +
										P +
										'" content="' +
										m.metadata.parsed[P] +
										`">
`);
								break;
							default:
								R +=
									'<meta name="' +
									P +
									'" content="' +
									m.metadata.parsed[P] +
									`">
`;
						}
				return (
					(f =
						k +
						"<html" +
						T +
						`>
<head>
` +
						C +
						_ +
						R +
						`</head>
<body>
` +
						f.trim() +
						`
</body>
</html>`),
					(f = m.converter._dispatch(
						"completeHTMLDocument.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("detab", function (f, v, m) {
				return (
					(f = m.converter._dispatch("detab.before", f, v, m)),
					(f = f.replace(/\t(?=\t)/g, "    ")),
					(f = f.replace(/\t/g, "AB")),
					(f = f.replace(/B(.+?)A/g, function (x, k) {
						for (
							var C = k, _ = 4 - (C.length % 4), T = 0;
							T < _;
							T++
						)
							C += " ";
						return C;
					})),
					(f = f.replace(/A/g, "    ")),
					(f = f.replace(/B/g, "")),
					(f = m.converter._dispatch("detab.after", f, v, m)),
					f
				);
			}),
			r.subParser("ellipsis", function (f, v, m) {
				return (
					v.ellipsis &&
						((f = m.converter._dispatch(
							"ellipsis.before",
							f,
							v,
							m
						)),
						(f = f.replace(/\.\.\./g, "")),
						(f = m.converter._dispatch("ellipsis.after", f, v, m))),
					f
				);
			}),
			r.subParser("emoji", function (f, v, m) {
				if (!v.emoji) return f;
				f = m.converter._dispatch("emoji.before", f, v, m);
				var x = /:([\S]+?):/g;
				return (
					(f = f.replace(x, function (k, C) {
						return r.helper.emojis.hasOwnProperty(C)
							? r.helper.emojis[C]
							: k;
					})),
					(f = m.converter._dispatch("emoji.after", f, v, m)),
					f
				);
			}),
			r.subParser("encodeAmpsAndAngles", function (f, v, m) {
				return (
					(f = m.converter._dispatch(
						"encodeAmpsAndAngles.before",
						f,
						v,
						m
					)),
					(f = f.replace(
						/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,
						"&amp;"
					)),
					(f = f.replace(/<(?![a-z\/?$!])/gi, "&lt;")),
					(f = f.replace(/</g, "&lt;")),
					(f = f.replace(/>/g, "&gt;")),
					(f = m.converter._dispatch(
						"encodeAmpsAndAngles.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("encodeBackslashEscapes", function (f, v, m) {
				return (
					(f = m.converter._dispatch(
						"encodeBackslashEscapes.before",
						f,
						v,
						m
					)),
					(f = f.replace(
						/\\(\\)/g,
						r.helper.escapeCharactersCallback
					)),
					(f = f.replace(
						/\\([`*_{}\[\]()>#+.!~=|:-])/g,
						r.helper.escapeCharactersCallback
					)),
					(f = m.converter._dispatch(
						"encodeBackslashEscapes.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("encodeCode", function (f, v, m) {
				return (
					(f = m.converter._dispatch("encodeCode.before", f, v, m)),
					(f = f
						.replace(/&/g, "&amp;")
						.replace(/</g, "&lt;")
						.replace(/>/g, "&gt;")
						.replace(
							/([*_{}\[\]\\=~-])/g,
							r.helper.escapeCharactersCallback
						)),
					(f = m.converter._dispatch("encodeCode.after", f, v, m)),
					f
				);
			}),
			r.subParser(
				"escapeSpecialCharsWithinTagAttributes",
				function (f, v, m) {
					f = m.converter._dispatch(
						"escapeSpecialCharsWithinTagAttributes.before",
						f,
						v,
						m
					);
					var x = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
						k = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
					return (
						(f = f.replace(x, function (C) {
							return C.replace(
								/(.)<\/?code>(?=.)/g,
								"$1`"
							).replace(
								/([\\`*_~=|])/g,
								r.helper.escapeCharactersCallback
							);
						})),
						(f = f.replace(k, function (C) {
							return C.replace(
								/([\\`*_~=|])/g,
								r.helper.escapeCharactersCallback
							);
						})),
						(f = m.converter._dispatch(
							"escapeSpecialCharsWithinTagAttributes.after",
							f,
							v,
							m
						)),
						f
					);
				}
			),
			r.subParser("githubCodeBlocks", function (f, v, m) {
				return v.ghCodeBlocks
					? ((f = m.converter._dispatch(
							"githubCodeBlocks.before",
							f,
							v,
							m
					  )),
					  (f += "0"),
					  (f = f.replace(
							/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g,
							function (x, k, C, _) {
								var T = v.omitExtraWLInCodeBlocks
									? ""
									: `
`;
								return (
									(_ = r.subParser("encodeCode")(_, v, m)),
									(_ = r.subParser("detab")(_, v, m)),
									(_ = _.replace(/^\n+/g, "")),
									(_ = _.replace(/\n+$/g, "")),
									(_ =
										"<pre><code" +
										(C
											? ' class="' +
											  C +
											  " language-" +
											  C +
											  '"'
											: "") +
										">" +
										_ +
										T +
										"</code></pre>"),
									(_ = r.subParser("hashBlock")(_, v, m)),
									`

G` +
										(m.ghCodeBlocks.push({
											text: x,
											codeblock: _,
										}) -
											1) +
										`G

`
								);
							}
					  )),
					  (f = f.replace(/0/, "")),
					  m.converter._dispatch("githubCodeBlocks.after", f, v, m))
					: f;
			}),
			r.subParser("hashBlock", function (f, v, m) {
				return (
					(f = m.converter._dispatch("hashBlock.before", f, v, m)),
					(f = f.replace(/(^\n+|\n+$)/g, "")),
					(f =
						`

K` +
						(m.gHtmlBlocks.push(f) - 1) +
						`K

`),
					(f = m.converter._dispatch("hashBlock.after", f, v, m)),
					f
				);
			}),
			r.subParser("hashCodeTags", function (f, v, m) {
				f = m.converter._dispatch("hashCodeTags.before", f, v, m);
				var x = function (k, C, _, T) {
					var R = _ + r.subParser("encodeCode")(C, v, m) + T;
					return "C" + (m.gHtmlSpans.push(R) - 1) + "C";
				};
				return (
					(f = r.helper.replaceRecursiveRegExp(
						f,
						x,
						"<code\\b[^>]*>",
						"</code>",
						"gim"
					)),
					(f = m.converter._dispatch("hashCodeTags.after", f, v, m)),
					f
				);
			}),
			r.subParser("hashElement", function (f, v, m) {
				return function (x, k) {
					var C = k;
					return (
						(C = C.replace(
							/\n\n/g,
							`
`
						)),
						(C = C.replace(/^\n/, "")),
						(C = C.replace(/\n+$/g, "")),
						(C =
							`

K` +
							(m.gHtmlBlocks.push(C) - 1) +
							`K

`),
						C
					);
				};
			}),
			r.subParser("hashHTMLBlocks", function (f, v, m) {
				f = m.converter._dispatch("hashHTMLBlocks.before", f, v, m);
				var x = [
						"pre",
						"div",
						"h1",
						"h2",
						"h3",
						"h4",
						"h5",
						"h6",
						"blockquote",
						"table",
						"dl",
						"ol",
						"ul",
						"script",
						"noscript",
						"form",
						"fieldset",
						"iframe",
						"math",
						"style",
						"section",
						"header",
						"footer",
						"nav",
						"article",
						"aside",
						"address",
						"audio",
						"canvas",
						"figure",
						"hgroup",
						"output",
						"video",
						"p",
					],
					k = function (M, I, $, V) {
						var ie = M;
						return (
							$.search(/\bmarkdown\b/) !== -1 &&
								(ie = $ + m.converter.makeHtml(I) + V),
							`

K` +
								(m.gHtmlBlocks.push(ie) - 1) +
								`K

`
						);
					};
				v.backslashEscapesHTMLTags &&
					(f = f.replace(/\\<(\/?[^>]+?)>/g, function (M, I) {
						return "&lt;" + I + "&gt;";
					}));
				for (var C = 0; C < x.length; ++C)
					for (
						var _,
							T = new RegExp(
								"^ {0,3}(<" + x[C] + "\\b[^>]*>)",
								"im"
							),
							R = "<" + x[C] + "\\b[^>]*>",
							P = "</" + x[C] + ">";
						(_ = r.helper.regexIndexOf(f, T)) !== -1;

					) {
						var N = r.helper.splitAtIndex(f, _),
							D = r.helper.replaceRecursiveRegExp(
								N[1],
								k,
								R,
								P,
								"im"
							);
						if (D === N[1]) break;
						f = N[0].concat(D);
					}
				return (
					(f = f.replace(
						/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
						r.subParser("hashElement")(f, v, m)
					)),
					(f = r.helper.replaceRecursiveRegExp(
						f,
						function (M) {
							return (
								`

K` +
								(m.gHtmlBlocks.push(M) - 1) +
								`K

`
							);
						},
						"^ {0,3}<!--",
						"-->",
						"gm"
					)),
					(f = f.replace(
						/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
						r.subParser("hashElement")(f, v, m)
					)),
					(f = m.converter._dispatch(
						"hashHTMLBlocks.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("hashHTMLSpans", function (f, v, m) {
				f = m.converter._dispatch("hashHTMLSpans.before", f, v, m);
				function x(k) {
					return "C" + (m.gHtmlSpans.push(k) - 1) + "C";
				}
				return (
					(f = f.replace(/<[^>]+?\/>/gi, function (k) {
						return x(k);
					})),
					(f = f.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (k) {
						return x(k);
					})),
					(f = f.replace(
						/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g,
						function (k) {
							return x(k);
						}
					)),
					(f = f.replace(/<[^>]+?>/gi, function (k) {
						return x(k);
					})),
					(f = m.converter._dispatch("hashHTMLSpans.after", f, v, m)),
					f
				);
			}),
			r.subParser("unhashHTMLSpans", function (f, v, m) {
				f = m.converter._dispatch("unhashHTMLSpans.before", f, v, m);
				for (var x = 0; x < m.gHtmlSpans.length; ++x) {
					for (var k = m.gHtmlSpans[x], C = 0; /C(\d+)C/.test(k); ) {
						var _ = RegExp.$1;
						if (
							((k = k.replace("C" + _ + "C", m.gHtmlSpans[_])),
							C === 10)
						) {
							console.error(
								"maximum nesting of 10 spans reached!!!"
							);
							break;
						}
						++C;
					}
					f = f.replace("C" + x + "C", k);
				}
				return (
					(f = m.converter._dispatch(
						"unhashHTMLSpans.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("hashPreCodeTags", function (f, v, m) {
				f = m.converter._dispatch("hashPreCodeTags.before", f, v, m);
				var x = function (k, C, _, T) {
					var R = _ + r.subParser("encodeCode")(C, v, m) + T;
					return (
						`

G` +
						(m.ghCodeBlocks.push({ text: k, codeblock: R }) - 1) +
						`G

`
					);
				};
				return (
					(f = r.helper.replaceRecursiveRegExp(
						f,
						x,
						"^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>",
						"^ {0,3}</code>\\s*</pre>",
						"gim"
					)),
					(f = m.converter._dispatch(
						"hashPreCodeTags.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("headers", function (f, v, m) {
				f = m.converter._dispatch("headers.before", f, v, m);
				var x = isNaN(parseInt(v.headerLevelStart))
						? 1
						: parseInt(v.headerLevelStart),
					k = v.smoothLivePreview
						? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm
						: /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
					C = v.smoothLivePreview
						? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm
						: /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
				(f = f.replace(k, function (R, P) {
					var N = r.subParser("spanGamut")(P, v, m),
						D = v.noHeaderId ? "" : ' id="' + T(P) + '"',
						M = x,
						I = "<h" + M + D + ">" + N + "</h" + M + ">";
					return r.subParser("hashBlock")(I, v, m);
				})),
					(f = f.replace(C, function (R, P) {
						var N = r.subParser("spanGamut")(P, v, m),
							D = v.noHeaderId ? "" : ' id="' + T(P) + '"',
							M = x + 1,
							I = "<h" + M + D + ">" + N + "</h" + M + ">";
						return r.subParser("hashBlock")(I, v, m);
					}));
				var _ = v.requireSpaceBeforeHeadingText
					? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm
					: /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
				f = f.replace(_, function (R, P, N) {
					var D = N;
					v.customizedHeaderId &&
						(D = N.replace(/\s?\{([^{]+?)}\s*$/, ""));
					var M = r.subParser("spanGamut")(D, v, m),
						I = v.noHeaderId ? "" : ' id="' + T(N) + '"',
						$ = x - 1 + P.length,
						V = "<h" + $ + I + ">" + M + "</h" + $ + ">";
					return r.subParser("hashBlock")(V, v, m);
				});
				function T(R) {
					var P, N;
					if (v.customizedHeaderId) {
						var D = R.match(/\{([^{]+?)}\s*$/);
						D && D[1] && (R = D[1]);
					}
					return (
						(P = R),
						r.helper.isString(v.prefixHeaderId)
							? (N = v.prefixHeaderId)
							: v.prefixHeaderId === !0
							? (N = "section-")
							: (N = ""),
						v.rawPrefixHeaderId || (P = N + P),
						v.ghCompatibleHeaderId
							? (P = P.replace(/ /g, "-")
									.replace(/&amp;/g, "")
									.replace(/T/g, "")
									.replace(/D/g, "")
									.replace(
										/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g,
										""
									)
									.toLowerCase())
							: v.rawHeaderId
							? (P = P.replace(/ /g, "-")
									.replace(/&amp;/g, "&")
									.replace(/T/g, "")
									.replace(/D/g, "$")
									.replace(/["']/g, "-")
									.toLowerCase())
							: (P = P.replace(/[^\w]/g, "").toLowerCase()),
						v.rawPrefixHeaderId && (P = N + P),
						m.hashLinkCounts[P]
							? (P = P + "-" + m.hashLinkCounts[P]++)
							: (m.hashLinkCounts[P] = 1),
						P
					);
				}
				return (f = m.converter._dispatch("headers.after", f, v, m)), f;
			}),
			r.subParser("horizontalRule", function (f, v, m) {
				f = m.converter._dispatch("horizontalRule.before", f, v, m);
				var x = r.subParser("hashBlock")("<hr />", v, m);
				return (
					(f = f.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, x)),
					(f = f.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, x)),
					(f = f.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, x)),
					(f = m.converter._dispatch(
						"horizontalRule.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("images", function (f, v, m) {
				f = m.converter._dispatch("images.before", f, v, m);
				var x =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
					k =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
					C =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
					_ = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
					T = /!\[([^\[\]]+)]()()()()()/g;
				function R(N, D, M, I, $, V, ie, Y) {
					return (
						(I = I.replace(/\s/g, "")), P(N, D, M, I, $, V, ie, Y)
					);
				}
				function P(N, D, M, I, $, V, ie, Y) {
					var he = m.gUrls,
						Le = m.gTitles,
						Ce = m.gDimensions;
					if (
						((M = M.toLowerCase()),
						Y || (Y = ""),
						N.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
					)
						I = "";
					else if (I === "" || I === null)
						if (
							((M === "" || M === null) &&
								(M = D.toLowerCase().replace(/ ?\n/g, " ")),
							(I = "#" + M),
							!r.helper.isUndefined(he[M]))
						)
							(I = he[M]),
								r.helper.isUndefined(Le[M]) || (Y = Le[M]),
								r.helper.isUndefined(Ce[M]) ||
									(($ = Ce[M].width), (V = Ce[M].height));
						else return N;
					(D = D.replace(/"/g, "&quot;").replace(
						r.helper.regexes.asteriskDashAndColon,
						r.helper.escapeCharactersCallback
					)),
						(I = I.replace(
							r.helper.regexes.asteriskDashAndColon,
							r.helper.escapeCharactersCallback
						));
					var Me = '<img src="' + I + '" alt="' + D + '"';
					return (
						Y &&
							r.helper.isString(Y) &&
							((Y = Y.replace(/"/g, "&quot;").replace(
								r.helper.regexes.asteriskDashAndColon,
								r.helper.escapeCharactersCallback
							)),
							(Me += ' title="' + Y + '"')),
						$ &&
							V &&
							(($ = $ === "*" ? "auto" : $),
							(V = V === "*" ? "auto" : V),
							(Me += ' width="' + $ + '"'),
							(Me += ' height="' + V + '"')),
						(Me += " />"),
						Me
					);
				}
				return (
					(f = f.replace(_, P)),
					(f = f.replace(C, R)),
					(f = f.replace(k, P)),
					(f = f.replace(x, P)),
					(f = f.replace(T, P)),
					(f = m.converter._dispatch("images.after", f, v, m)),
					f
				);
			}),
			r.subParser("italicsAndBold", function (f, v, m) {
				f = m.converter._dispatch("italicsAndBold.before", f, v, m);
				function x(k, C, _) {
					return C + k + _;
				}
				return (
					v.literalMidWordUnderscores
						? ((f = f.replace(
								/\b___(\S[\s\S]*?)___\b/g,
								function (k, C) {
									return x(
										C,
										"<strong><em>",
										"</em></strong>"
									);
								}
						  )),
						  (f = f.replace(
								/\b__(\S[\s\S]*?)__\b/g,
								function (k, C) {
									return x(C, "<strong>", "</strong>");
								}
						  )),
						  (f = f.replace(
								/\b_(\S[\s\S]*?)_\b/g,
								function (k, C) {
									return x(C, "<em>", "</em>");
								}
						  )))
						: ((f = f.replace(
								/___(\S[\s\S]*?)___/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong><em>", "</em></strong>")
										: k;
								}
						  )),
						  (f = f.replace(/__(\S[\s\S]*?)__/g, function (k, C) {
								return /\S$/.test(C)
									? x(C, "<strong>", "</strong>")
									: k;
						  })),
						  (f = f.replace(
								/_([^\s_][\s\S]*?)_/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<em>", "</em>")
										: k;
								}
						  ))),
					v.literalMidWordAsterisks
						? ((f = f.replace(
								/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g,
								function (k, C, _) {
									return x(
										_,
										C + "<strong><em>",
										"</em></strong>"
									);
								}
						  )),
						  (f = f.replace(
								/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g,
								function (k, C, _) {
									return x(_, C + "<strong>", "</strong>");
								}
						  )),
						  (f = f.replace(
								/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g,
								function (k, C, _) {
									return x(_, C + "<em>", "</em>");
								}
						  )))
						: ((f = f.replace(
								/\*\*\*(\S[\s\S]*?)\*\*\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong><em>", "</em></strong>")
										: k;
								}
						  )),
						  (f = f.replace(
								/\*\*(\S[\s\S]*?)\*\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong>", "</strong>")
										: k;
								}
						  )),
						  (f = f.replace(
								/\*([^\s*][\s\S]*?)\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<em>", "</em>")
										: k;
								}
						  ))),
					(f = m.converter._dispatch(
						"italicsAndBold.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("lists", function (f, v, m) {
				function x(_, T) {
					m.gListLevel++,
						(_ = _.replace(
							/\n{2,}$/,
							`
`
						)),
						(_ += "0");
					var R =
							/(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
						P = /\n[ \t]*\n(?!0)/.test(_);
					return (
						v.disableForced4SpacesIndentedSublists &&
							(R =
								/(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm),
						(_ = _.replace(R, function (N, D, M, I, $, V, ie) {
							ie = ie && ie.trim() !== "";
							var Y = r.subParser("outdent")($, v, m),
								he = "";
							return (
								V &&
									v.tasklists &&
									((he =
										' class="task-list-item" style="list-style-type: none;"'),
									(Y = Y.replace(
										/^[ \t]*\[(x|X| )?]/m,
										function () {
											var Le =
												'<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
											return (
												ie && (Le += " checked"),
												(Le += ">"),
												Le
											);
										}
									))),
								(Y = Y.replace(
									/^([-*+]|\d\.)[ \t]+[\S\n ]*/g,
									function (Le) {
										return "A" + Le;
									}
								)),
								D || Y.search(/\n{2,}/) > -1
									? ((Y = r.subParser("githubCodeBlocks")(
											Y,
											v,
											m
									  )),
									  (Y = r.subParser("blockGamut")(Y, v, m)))
									: ((Y = r.subParser("lists")(Y, v, m)),
									  (Y = Y.replace(/\n$/, "")),
									  (Y = r.subParser("hashHTMLBlocks")(
											Y,
											v,
											m
									  )),
									  (Y = Y.replace(
											/\n\n+/g,
											`

`
									  )),
									  P
											? (Y = r.subParser("paragraphs")(
													Y,
													v,
													m
											  ))
											: (Y = r.subParser("spanGamut")(
													Y,
													v,
													m
											  ))),
								(Y = Y.replace("A", "")),
								(Y =
									"<li" +
									he +
									">" +
									Y +
									`</li>
`),
								Y
							);
						})),
						(_ = _.replace(/0/g, "")),
						m.gListLevel--,
						T && (_ = _.replace(/\s+$/, "")),
						_
					);
				}
				function k(_, T) {
					if (T === "ol") {
						var R = _.match(/^ *(\d+)\./);
						if (R && R[1] !== "1") return ' start="' + R[1] + '"';
					}
					return "";
				}
				function C(_, T, R) {
					var P = v.disableForced4SpacesIndentedSublists
							? /^ ?\d+\.[ \t]/gm
							: /^ {0,3}\d+\.[ \t]/gm,
						N = v.disableForced4SpacesIndentedSublists
							? /^ ?[*+-][ \t]/gm
							: /^ {0,3}[*+-][ \t]/gm,
						D = T === "ul" ? P : N,
						M = "";
					if (_.search(D) !== -1)
						(function $(V) {
							var ie = V.search(D),
								Y = k(_, T);
							ie !== -1
								? ((M +=
										`

<` +
										T +
										Y +
										`>
` +
										x(V.slice(0, ie), !!R) +
										"</" +
										T +
										`>
`),
								  (T = T === "ul" ? "ol" : "ul"),
								  (D = T === "ul" ? P : N),
								  $(V.slice(ie)))
								: (M +=
										`

<` +
										T +
										Y +
										`>
` +
										x(V, !!R) +
										"</" +
										T +
										`>
`);
						})(_);
					else {
						var I = k(_, T);
						M =
							`

<` +
							T +
							I +
							`>
` +
							x(_, !!R) +
							"</" +
							T +
							`>
`;
					}
					return M;
				}
				return (
					(f = m.converter._dispatch("lists.before", f, v, m)),
					(f += "0"),
					m.gListLevel
						? (f = f.replace(
								/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
								function (_, T, R) {
									var P =
										R.search(/[*+-]/g) > -1 ? "ul" : "ol";
									return C(T, P, !0);
								}
						  ))
						: (f = f.replace(
								/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
								function (_, T, R, P) {
									var N =
										P.search(/[*+-]/g) > -1 ? "ul" : "ol";
									return C(R, N, !1);
								}
						  )),
					(f = f.replace(/0/, "")),
					(f = m.converter._dispatch("lists.after", f, v, m)),
					f
				);
			}),
			r.subParser("metadata", function (f, v, m) {
				if (!v.metadata) return f;
				f = m.converter._dispatch("metadata.before", f, v, m);
				function x(k) {
					(m.metadata.raw = k),
						(k = k.replace(/&/g, "&amp;").replace(/"/g, "&quot;")),
						(k = k.replace(/\n {4}/g, " ")),
						k.replace(
							/^([\S ]+): +([\s\S]+?)$/gm,
							function (C, _, T) {
								return (m.metadata.parsed[_] = T), "";
							}
						);
				}
				return (
					(f = f.replace(
						/^\s*+(\S*?)\n([\s\S]+?)\n+\n/,
						function (k, C, _) {
							return x(_), "M";
						}
					)),
					(f = f.replace(
						/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/,
						function (k, C, _) {
							return C && (m.metadata.format = C), x(_), "M";
						}
					)),
					(f = f.replace(/M/g, "")),
					(f = m.converter._dispatch("metadata.after", f, v, m)),
					f
				);
			}),
			r.subParser("outdent", function (f, v, m) {
				return (
					(f = m.converter._dispatch("outdent.before", f, v, m)),
					(f = f.replace(/^(\t|[ ]{1,4})/gm, "0")),
					(f = f.replace(/0/g, "")),
					(f = m.converter._dispatch("outdent.after", f, v, m)),
					f
				);
			}),
			r.subParser("paragraphs", function (f, v, m) {
				(f = m.converter._dispatch("paragraphs.before", f, v, m)),
					(f = f.replace(/^\n+/g, "")),
					(f = f.replace(/\n+$/g, ""));
				for (
					var x = f.split(/\n{2,}/g), k = [], C = x.length, _ = 0;
					_ < C;
					_++
				) {
					var T = x[_];
					T.search(/(K|G)(\d+)\1/g) >= 0
						? k.push(T)
						: T.search(/\S/) >= 0 &&
						  ((T = r.subParser("spanGamut")(T, v, m)),
						  (T = T.replace(/^([ \t]*)/g, "<p>")),
						  (T += "</p>"),
						  k.push(T));
				}
				for (C = k.length, _ = 0; _ < C; _++) {
					for (
						var R = "", P = k[_], N = !1;
						/(K|G)(\d+)\1/.test(P);

					) {
						var D = RegExp.$1,
							M = RegExp.$2;
						D === "K"
							? (R = m.gHtmlBlocks[M])
							: N
							? (R = r.subParser("encodeCode")(
									m.ghCodeBlocks[M].text,
									v,
									m
							  ))
							: (R = m.ghCodeBlocks[M].codeblock),
							(R = R.replace(/\$/g, "$$$$")),
							(P = P.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, R)),
							/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(P) && (N = !0);
					}
					k[_] = P;
				}
				return (
					(f = k.join(`
`)),
					(f = f.replace(/^\n+/g, "")),
					(f = f.replace(/\n+$/g, "")),
					m.converter._dispatch("paragraphs.after", f, v, m)
				);
			}),
			r.subParser("runExtension", function (f, v, m, x) {
				if (f.filter) v = f.filter(v, x.converter, m);
				else if (f.regex) {
					var k = f.regex;
					k instanceof RegExp || (k = new RegExp(k, "g")),
						(v = v.replace(k, f.replace));
				}
				return v;
			}),
			r.subParser("spanGamut", function (f, v, m) {
				return (
					(f = m.converter._dispatch("spanGamut.before", f, v, m)),
					(f = r.subParser("codeSpans")(f, v, m)),
					(f = r.subParser("escapeSpecialCharsWithinTagAttributes")(
						f,
						v,
						m
					)),
					(f = r.subParser("encodeBackslashEscapes")(f, v, m)),
					(f = r.subParser("images")(f, v, m)),
					(f = r.subParser("anchors")(f, v, m)),
					(f = r.subParser("autoLinks")(f, v, m)),
					(f = r.subParser("simplifiedAutoLinks")(f, v, m)),
					(f = r.subParser("emoji")(f, v, m)),
					(f = r.subParser("underline")(f, v, m)),
					(f = r.subParser("italicsAndBold")(f, v, m)),
					(f = r.subParser("strikethrough")(f, v, m)),
					(f = r.subParser("ellipsis")(f, v, m)),
					(f = r.subParser("hashHTMLSpans")(f, v, m)),
					(f = r.subParser("encodeAmpsAndAngles")(f, v, m)),
					v.simpleLineBreaks
						? /\n\nK/.test(f) ||
						  (f = f.replace(
								/\n+/g,
								`<br />
`
						  ))
						: (f = f.replace(
								/  +\n/g,
								`<br />
`
						  )),
					(f = m.converter._dispatch("spanGamut.after", f, v, m)),
					f
				);
			}),
			r.subParser("strikethrough", function (f, v, m) {
				function x(k) {
					return (
						v.simplifiedAutoLink &&
							(k = r.subParser("simplifiedAutoLinks")(k, v, m)),
						"<del>" + k + "</del>"
					);
				}
				return (
					v.strikethrough &&
						((f = m.converter._dispatch(
							"strikethrough.before",
							f,
							v,
							m
						)),
						(f = f.replace(
							/(?:~){2}([\s\S]+?)(?:~){2}/g,
							function (k, C) {
								return x(C);
							}
						)),
						(f = m.converter._dispatch(
							"strikethrough.after",
							f,
							v,
							m
						))),
					f
				);
			}),
			r.subParser("stripLinkDefinitions", function (f, v, m) {
				var x =
						/^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm,
					k =
						/^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
				f += "0";
				var C = function (_, T, R, P, N, D, M) {
					return (
						(T = T.toLowerCase()),
						f.toLowerCase().split(T).length - 1 < 2
							? _
							: (R.match(/^data:.+?\/.+?;base64,/)
									? (m.gUrls[T] = R.replace(/\s/g, ""))
									: (m.gUrls[T] = r.subParser(
											"encodeAmpsAndAngles"
									  )(R, v, m)),
							  D
									? D + M
									: (M &&
											(m.gTitles[T] = M.replace(
												/"|'/g,
												"&quot;"
											)),
									  v.parseImgDimensions &&
											P &&
											N &&
											(m.gDimensions[T] = {
												width: P,
												height: N,
											}),
									  ""))
					);
				};
				return (
					(f = f.replace(k, C)),
					(f = f.replace(x, C)),
					(f = f.replace(/0/, "")),
					f
				);
			}),
			r.subParser("tables", function (f, v, m) {
				if (!v.tables) return f;
				var x =
						/^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm,
					k =
						/^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
				function C(N) {
					return /^:[ \t]*--*$/.test(N)
						? ' style="text-align:left;"'
						: /^--*[ \t]*:[ \t]*$/.test(N)
						? ' style="text-align:right;"'
						: /^:[ \t]*--*[ \t]*:$/.test(N)
						? ' style="text-align:center;"'
						: "";
				}
				function _(N, D) {
					var M = "";
					return (
						(N = N.trim()),
						(v.tablesHeaderId || v.tableHeaderId) &&
							(M =
								' id="' +
								N.replace(/ /g, "_").toLowerCase() +
								'"'),
						(N = r.subParser("spanGamut")(N, v, m)),
						"<th" +
							M +
							D +
							">" +
							N +
							`</th>
`
					);
				}
				function T(N, D) {
					var M = r.subParser("spanGamut")(N, v, m);
					return (
						"<td" +
						D +
						">" +
						M +
						`</td>
`
					);
				}
				function R(N, D) {
					for (
						var M = `<table>
<thead>
<tr>
`,
							I = N.length,
							$ = 0;
						$ < I;
						++$
					)
						M += N[$];
					for (
						M += `</tr>
</thead>
<tbody>
`,
							$ = 0;
						$ < D.length;
						++$
					) {
						M += `<tr>
`;
						for (var V = 0; V < I; ++V) M += D[$][V];
						M += `</tr>
`;
					}
					return (
						(M += `</tbody>
</table>
`),
						M
					);
				}
				function P(N) {
					var D,
						M = N.split(`
`);
					for (D = 0; D < M.length; ++D)
						/^ {0,3}\|/.test(M[D]) &&
							(M[D] = M[D].replace(/^ {0,3}\|/, "")),
							/\|[ \t]*$/.test(M[D]) &&
								(M[D] = M[D].replace(/\|[ \t]*$/, "")),
							(M[D] = r.subParser("codeSpans")(M[D], v, m));
					var I = M[0].split("|").map(function (Me) {
							return Me.trim();
						}),
						$ = M[1].split("|").map(function (Me) {
							return Me.trim();
						}),
						V = [],
						ie = [],
						Y = [],
						he = [];
					for (M.shift(), M.shift(), D = 0; D < M.length; ++D)
						M[D].trim() !== "" &&
							V.push(
								M[D].split("|").map(function (Me) {
									return Me.trim();
								})
							);
					if (I.length < $.length) return N;
					for (D = 0; D < $.length; ++D) Y.push(C($[D]));
					for (D = 0; D < I.length; ++D)
						r.helper.isUndefined(Y[D]) && (Y[D] = ""),
							ie.push(_(I[D], Y[D]));
					for (D = 0; D < V.length; ++D) {
						for (var Le = [], Ce = 0; Ce < ie.length; ++Ce)
							r.helper.isUndefined(V[D][Ce]),
								Le.push(T(V[D][Ce], Y[Ce]));
						he.push(Le);
					}
					return R(ie, he);
				}
				return (
					(f = m.converter._dispatch("tables.before", f, v, m)),
					(f = f.replace(
						/\\(\|)/g,
						r.helper.escapeCharactersCallback
					)),
					(f = f.replace(x, P)),
					(f = f.replace(k, P)),
					(f = m.converter._dispatch("tables.after", f, v, m)),
					f
				);
			}),
			r.subParser("underline", function (f, v, m) {
				return (
					v.underline &&
						((f = m.converter._dispatch(
							"underline.before",
							f,
							v,
							m
						)),
						v.literalMidWordUnderscores
							? ((f = f.replace(
									/\b___(\S[\s\S]*?)___\b/g,
									function (x, k) {
										return "<u>" + k + "</u>";
									}
							  )),
							  (f = f.replace(
									/\b__(\S[\s\S]*?)__\b/g,
									function (x, k) {
										return "<u>" + k + "</u>";
									}
							  )))
							: ((f = f.replace(
									/___(\S[\s\S]*?)___/g,
									function (x, k) {
										return /\S$/.test(k)
											? "<u>" + k + "</u>"
											: x;
									}
							  )),
							  (f = f.replace(
									/__(\S[\s\S]*?)__/g,
									function (x, k) {
										return /\S$/.test(k)
											? "<u>" + k + "</u>"
											: x;
									}
							  ))),
						(f = f.replace(
							/(_)/g,
							r.helper.escapeCharactersCallback
						)),
						(f = m.converter._dispatch(
							"underline.after",
							f,
							v,
							m
						))),
					f
				);
			}),
			r.subParser("unescapeSpecialChars", function (f, v, m) {
				return (
					(f = m.converter._dispatch(
						"unescapeSpecialChars.before",
						f,
						v,
						m
					)),
					(f = f.replace(/E(\d+)E/g, function (x, k) {
						var C = parseInt(k);
						return String.fromCharCode(C);
					})),
					(f = m.converter._dispatch(
						"unescapeSpecialChars.after",
						f,
						v,
						m
					)),
					f
				);
			}),
			r.subParser("makeMarkdown.blockquote", function (f, v) {
				var m = "";
				if (f.hasChildNodes())
					for (
						var x = f.childNodes, k = x.length, C = 0;
						C < k;
						++C
					) {
						var _ = r.subParser("makeMarkdown.node")(x[C], v);
						_ !== "" && (m += _);
					}
				return (
					(m = m.trim()),
					(m =
						"> " +
						m.split(`
`).join(`
> `)),
					m
				);
			}),
			r.subParser("makeMarkdown.codeBlock", function (f, v) {
				var m = f.getAttribute("language"),
					x = f.getAttribute("precodenum");
				return (
					"```" +
					m +
					`
` +
					v.preList[x] +
					"\n```"
				);
			}),
			r.subParser("makeMarkdown.codeSpan", function (f) {
				return "`" + f.innerHTML + "`";
			}),
			r.subParser("makeMarkdown.emphasis", function (f, v) {
				var m = "";
				if (f.hasChildNodes()) {
					m += "*";
					for (var x = f.childNodes, k = x.length, C = 0; C < k; ++C)
						m += r.subParser("makeMarkdown.node")(x[C], v);
					m += "*";
				}
				return m;
			}),
			r.subParser("makeMarkdown.header", function (f, v, m) {
				var x = new Array(m + 1).join("#"),
					k = "";
				if (f.hasChildNodes()) {
					k = x + " ";
					for (var C = f.childNodes, _ = C.length, T = 0; T < _; ++T)
						k += r.subParser("makeMarkdown.node")(C[T], v);
				}
				return k;
			}),
			r.subParser("makeMarkdown.hr", function () {
				return "---";
			}),
			r.subParser("makeMarkdown.image", function (f) {
				var v = "";
				return (
					f.hasAttribute("src") &&
						((v += "![" + f.getAttribute("alt") + "]("),
						(v += "<" + f.getAttribute("src") + ">"),
						f.hasAttribute("width") &&
							f.hasAttribute("height") &&
							(v +=
								" =" +
								f.getAttribute("width") +
								"x" +
								f.getAttribute("height")),
						f.hasAttribute("title") &&
							(v += ' "' + f.getAttribute("title") + '"'),
						(v += ")")),
					v
				);
			}),
			r.subParser("makeMarkdown.links", function (f, v) {
				var m = "";
				if (f.hasChildNodes() && f.hasAttribute("href")) {
					var x = f.childNodes,
						k = x.length;
					m = "[";
					for (var C = 0; C < k; ++C)
						m += r.subParser("makeMarkdown.node")(x[C], v);
					(m += "]("),
						(m += "<" + f.getAttribute("href") + ">"),
						f.hasAttribute("title") &&
							(m += ' "' + f.getAttribute("title") + '"'),
						(m += ")");
				}
				return m;
			}),
			r.subParser("makeMarkdown.list", function (f, v, m) {
				var x = "";
				if (!f.hasChildNodes()) return "";
				for (
					var k = f.childNodes,
						C = k.length,
						_ = f.getAttribute("start") || 1,
						T = 0;
					T < C;
					++T
				)
					if (
						!(
							typeof k[T].tagName == "undefined" ||
							k[T].tagName.toLowerCase() !== "li"
						)
					) {
						var R = "";
						m === "ol" ? (R = _.toString() + ". ") : (R = "- "),
							(x +=
								R +
								r.subParser("makeMarkdown.listItem")(k[T], v)),
							++_;
					}
				return (
					(x += `
<!-- -->
`),
					x.trim()
				);
			}),
			r.subParser("makeMarkdown.listItem", function (f, v) {
				for (
					var m = "", x = f.childNodes, k = x.length, C = 0;
					C < k;
					++C
				)
					m += r.subParser("makeMarkdown.node")(x[C], v);
				return (
					/\n$/.test(m)
						? (m = m
								.split(
									`
`
								)
								.join(
									`
    `
								)
								.replace(/^ {4}$/gm, "")
								.replace(
									/\n\n+/g,
									`

`
								))
						: (m += `
`),
					m
				);
			}),
			r.subParser("makeMarkdown.node", function (f, v, m) {
				m = m || !1;
				var x = "";
				if (f.nodeType === 3)
					return r.subParser("makeMarkdown.txt")(f, v);
				if (f.nodeType === 8)
					return (
						"<!--" +
						f.data +
						`-->

`
					);
				if (f.nodeType !== 1) return "";
				var k = f.tagName.toLowerCase();
				switch (k) {
					case "h1":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 1) +
								`

`);
						break;
					case "h2":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 2) +
								`

`);
						break;
					case "h3":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 3) +
								`

`);
						break;
					case "h4":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 4) +
								`

`);
						break;
					case "h5":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 5) +
								`

`);
						break;
					case "h6":
						m ||
							(x =
								r.subParser("makeMarkdown.header")(f, v, 6) +
								`

`);
						break;
					case "p":
						m ||
							(x =
								r.subParser("makeMarkdown.paragraph")(f, v) +
								`

`);
						break;
					case "blockquote":
						m ||
							(x =
								r.subParser("makeMarkdown.blockquote")(f, v) +
								`

`);
						break;
					case "hr":
						m ||
							(x =
								r.subParser("makeMarkdown.hr")(f, v) +
								`

`);
						break;
					case "ol":
						m ||
							(x =
								r.subParser("makeMarkdown.list")(f, v, "ol") +
								`

`);
						break;
					case "ul":
						m ||
							(x =
								r.subParser("makeMarkdown.list")(f, v, "ul") +
								`

`);
						break;
					case "precode":
						m ||
							(x =
								r.subParser("makeMarkdown.codeBlock")(f, v) +
								`

`);
						break;
					case "pre":
						m ||
							(x =
								r.subParser("makeMarkdown.pre")(f, v) +
								`

`);
						break;
					case "table":
						m ||
							(x =
								r.subParser("makeMarkdown.table")(f, v) +
								`

`);
						break;
					case "code":
						x = r.subParser("makeMarkdown.codeSpan")(f, v);
						break;
					case "em":
					case "i":
						x = r.subParser("makeMarkdown.emphasis")(f, v);
						break;
					case "strong":
					case "b":
						x = r.subParser("makeMarkdown.strong")(f, v);
						break;
					case "del":
						x = r.subParser("makeMarkdown.strikethrough")(f, v);
						break;
					case "a":
						x = r.subParser("makeMarkdown.links")(f, v);
						break;
					case "img":
						x = r.subParser("makeMarkdown.image")(f, v);
						break;
					default:
						x =
							f.outerHTML +
							`

`;
				}
				return x;
			}),
			r.subParser("makeMarkdown.paragraph", function (f, v) {
				var m = "";
				if (f.hasChildNodes())
					for (var x = f.childNodes, k = x.length, C = 0; C < k; ++C)
						m += r.subParser("makeMarkdown.node")(x[C], v);
				return (m = m.trim()), m;
			}),
			r.subParser("makeMarkdown.pre", function (f, v) {
				var m = f.getAttribute("prenum");
				return "<pre>" + v.preList[m] + "</pre>";
			}),
			r.subParser("makeMarkdown.strikethrough", function (f, v) {
				var m = "";
				if (f.hasChildNodes()) {
					m += "~~";
					for (var x = f.childNodes, k = x.length, C = 0; C < k; ++C)
						m += r.subParser("makeMarkdown.node")(x[C], v);
					m += "~~";
				}
				return m;
			}),
			r.subParser("makeMarkdown.strong", function (f, v) {
				var m = "";
				if (f.hasChildNodes()) {
					m += "**";
					for (var x = f.childNodes, k = x.length, C = 0; C < k; ++C)
						m += r.subParser("makeMarkdown.node")(x[C], v);
					m += "**";
				}
				return m;
			}),
			r.subParser("makeMarkdown.table", function (f, v) {
				var m = "",
					x = [[], []],
					k = f.querySelectorAll("thead>tr>th"),
					C = f.querySelectorAll("tbody>tr"),
					_,
					T;
				for (_ = 0; _ < k.length; ++_) {
					var R = r.subParser("makeMarkdown.tableCell")(k[_], v),
						P = "---";
					if (k[_].hasAttribute("style")) {
						var N = k[_].getAttribute("style")
							.toLowerCase()
							.replace(/\s/g, "");
						switch (N) {
							case "text-align:left;":
								P = ":---";
								break;
							case "text-align:right;":
								P = "---:";
								break;
							case "text-align:center;":
								P = ":---:";
								break;
						}
					}
					(x[0][_] = R.trim()), (x[1][_] = P);
				}
				for (_ = 0; _ < C.length; ++_) {
					var D = x.push([]) - 1,
						M = C[_].getElementsByTagName("td");
					for (T = 0; T < k.length; ++T) {
						var I = " ";
						typeof M[T] != "undefined" &&
							(I = r.subParser("makeMarkdown.tableCell")(
								M[T],
								v
							)),
							x[D].push(I);
					}
				}
				var $ = 3;
				for (_ = 0; _ < x.length; ++_)
					for (T = 0; T < x[_].length; ++T) {
						var V = x[_][T].length;
						V > $ && ($ = V);
					}
				for (_ = 0; _ < x.length; ++_) {
					for (T = 0; T < x[_].length; ++T)
						_ === 1
							? x[_][T].slice(-1) === ":"
								? (x[_][T] =
										r.helper.padEnd(
											x[_][T].slice(-1),
											$ - 1,
											"-"
										) + ":")
								: (x[_][T] = r.helper.padEnd(x[_][T], $, "-"))
							: (x[_][T] = r.helper.padEnd(x[_][T], $));
					m +=
						"| " +
						x[_].join(" | ") +
						` |
`;
				}
				return m.trim();
			}),
			r.subParser("makeMarkdown.tableCell", function (f, v) {
				var m = "";
				if (!f.hasChildNodes()) return "";
				for (var x = f.childNodes, k = x.length, C = 0; C < k; ++C)
					m += r.subParser("makeMarkdown.node")(x[C], v, !0);
				return m.trim();
			}),
			r.subParser("makeMarkdown.txt", function (f) {
				var v = f.nodeValue;
				return (
					(v = v.replace(/ +/g, " ")),
					(v = v.replace(/NBSP;/g, " ")),
					(v = r.helper.unescapeHTMLEntities(v)),
					(v = v.replace(/([*_~|`])/g, "\\$1")),
					(v = v.replace(/^(\s*)>/g, "\\$1>")),
					(v = v.replace(/^#/gm, "\\#")),
					(v = v.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3")),
					(v = v.replace(/^( {0,3}\d+)\./gm, "$1\\.")),
					(v = v.replace(/^( {0,3})([+-])/gm, "$1\\$2")),
					(v = v.replace(/]([\s]*)\(/g, "\\]$1\\(")),
					(v = v.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:")),
					v
				);
			});
		var E = this;
		t.exports ? (t.exports = r) : (E.showdown = r);
	}.call(Ry));
})(j2);
var NN = j2.exports;
const DN = Py(NN);
function jN(t) {
	return new DN.Converter().makeHtml(t);
}
function LN(t) {
	return (
		t
			.split(
				`
`
			)
			.filter(
				(r) =>
					r.startsWith("![") ||
					r.startsWith("#") ||
					r.startsWith("> ") ||
					r.startsWith("*") ||
					r.startsWith("- ") ||
					r.startsWith("1. ") ||
					r.startsWith("```") ||
					r.startsWith("`") ||
					r.startsWith("[") ||
					r.startsWith("---")
			).length > 0
	);
}
const $N = {
	name: "TextEditor",
	inheritAttrs: !1,
	components: {
		EditorContent: E4,
		TextEditorFixedMenu: CN,
		TextEditorBubbleMenu: TN,
		TextEditorFloatingMenu: IN,
	},
	props: {
		content: { type: String, default: null },
		placeholder: { type: [String, Function], default: "" },
		editorClass: { type: [String, Array, Object], default: "" },
		editable: { type: Boolean, default: !0 },
		bubbleMenu: { type: [Boolean, Array], default: !1 },
		bubbleMenuOptions: { type: Object, default: () => ({}) },
		fixedMenu: { type: [Boolean, Array], default: !1 },
		floatingMenu: { type: [Boolean, Array], default: !1 },
		extensions: { type: Array, default: () => [] },
		starterkitOptions: { type: Object, default: () => ({}) },
		mentions: { type: Array, default: () => [] },
	},
	emits: ["change", "focus", "blur"],
	expose: ["editor"],
	provide() {
		return { editor: H1(() => this.editor) };
	},
	data() {
		return { editor: null };
	},
	watch: {
		content(t) {
			this.editor.getHTML() !== t && this.editor.commands.setContent(t);
		},
		editable(t) {
			this.editor.setEditable(t);
		},
		editorProps: {
			deep: !0,
			handler(t) {
				this.editor && this.editor.setOptions({ editorProps: t });
			},
		},
	},
	mounted() {
		this.editor = new M4({
			content: this.content || null,
			editorProps: this.editorProps,
			editable: this.editable,
			extensions: [
				TO.configure(z({}, this.starterkitOptions)),
				I5.configure({ resizable: !0 }),
				j5,
				D5,
				N5,
				P6,
				OO.configure({ types: ["heading", "paragraph"] }),
				I6,
				L6,
				j6.configure({ multicolor: !0 }),
				$5,
				z5,
				u6.configure({ openOnClick: !1 }),
				AO.configure({
					showOnlyWhenEditable: !1,
					placeholder:
						typeof this.placeholder == "function"
							? this.placeholder
							: () => this.placeholder,
				}),
				J6(this.mentions),
				...(this.extensions || []),
			],
			onUpdate: ({ editor: t }) => {
				this.$emit("change", t.getHTML());
			},
			onFocus: ({ editor: t, event: e }) => {
				this.$emit("focus", e);
			},
			onBlur: ({ editor: t, event: e }) => {
				this.$emit("blur", e);
			},
		});
	},
	beforeUnmount() {
		this.editor.destroy(), (this.editor = null);
	},
	computed: {
		editorProps() {
			return {
				attributes: {
					class: we([
						"prose prose-table:table-fixed prose-td:p-2 prose-th:p-2 prose-td:border prose-th:border prose-td:border-gray-300 prose-th:border-gray-300 prose-td:relative prose-th:relative prose-th:bg-gray-100",
						this.editorClass,
					]),
				},
				clipboardTextParser: (t, e) => {
					if (
						!LN(t) ||
						!confirm(
							"Do you want to convert markdown content to HTML before pasting?"
						)
					)
						return;
					let n = document.createElement("div");
					return (
						(n.innerHTML = jN(t)),
						(
							this.editor.view.someProp("clipboardParser") ||
							this.editor.view.someProp("domParser") ||
							Iu.fromSchema(this.editor.schema)
						).parseSlice(n, { preserveWhitespace: !0, context: e })
					);
				},
			};
		},
	},
};
function BN(t, e, n, r, o, i) {
	const s = nt("TextEditorBubbleMenu"),
		l = nt("TextEditorFixedMenu"),
		a = nt("TextEditorFloatingMenu"),
		u = nt("editor-content");
	return o.editor
		? (j(),
		  q(
				"div",
				{ key: 0, class: we(["relative w-full", t.$attrs.class]) },
				[
					be(
						s,
						{ buttons: n.bubbleMenu, options: n.bubbleMenuOptions },
						null,
						8,
						["buttons", "options"]
					),
					be(
						l,
						{
							class: "w-full overflow-x-auto rounded-t-lg border border-gray-200",
							buttons: n.fixedMenu,
						},
						null,
						8,
						["buttons"]
					),
					be(a, { buttons: n.floatingMenu }, null, 8, ["buttons"]),
					De(t.$slots, "top"),
					De(t.$slots, "editor", { editor: o.editor }, () => [
						be(u, { editor: o.editor }, null, 8, ["editor"]),
					]),
					De(t.$slots, "bottom"),
				],
				2
		  ))
		: Ve("", !0);
}
const aL = je($N, [["render", BN]]);
function L2(t, e = !0) {
	let n = e ? "14px " : "",
		r = t
			.map((o) => {
				let i = o.width || 1;
				return typeof i == "number" ? i + "fr" : i;
			})
			.join(" ");
	return n + r;
}
const jh = {
		left: "justify-start",
		start: "justify-start",
		center: "justify-center",
		middle: "justify-center",
		right: "justify-end",
		end: "justify-end",
	},
	zN = {
		__name: "ListHeaderItem",
		props: { item: { type: Object, required: !0 } },
		setup(t) {
			return (e, n) => (
				j(),
				q(
					"div",
					{
						class: we([
							"flex items-center space-x-2 text-base text-gray-600",
							ue(jh)[t.item.align],
						]),
					},
					[
						De(e.$slots, "prefix", Ut(en({ item: t.item }))),
						U("div", null, Qe(t.item.label), 1),
						De(e.$slots, "suffix", Ut(en({ item: t.item }))),
					],
					2
				)
			);
		},
	},
	HN = {
		__name: "ListHeader",
		setup(t) {
			const e = qe("list");
			return (n, r) => (
				j(),
				q(
					"div",
					{
						class: "mb-2 grid items-center space-x-4 rounded bg-gray-100 p-2",
						style: ao({
							gridTemplateColumns: ue(L2)(
								ue(e).columns,
								ue(e).options.selectable
							),
						}),
					},
					[
						ue(e).options.selectable
							? (j(),
							  Fe(
									th,
									{
										key: 0,
										class: "cursor-pointer duration-300",
										modelValue: ue(e).allRowsSelected,
										onClick: R0(ue(e).toggleAllRows, [
											"stop",
										]),
									},
									null,
									8,
									["modelValue", "onClick"]
							  ))
							: Ve("", !0),
						De(n.$slots, "default", {}, () => [
							(j(!0),
							q(
								Ne,
								null,
								Pt(
									ue(e).columns,
									(o) => (
										j(),
										Fe(
											zN,
											{ key: o.key, item: o },
											null,
											8,
											["item"]
										)
									)
								),
								128
							)),
						]),
					],
					4
				)
			);
		},
	},
	FN = {
		name: "Tooltip",
		components: { Popover: Ru },
		props: {
			hoverDelay: { default: 0.5 },
			placement: { default: "top" },
			text: { type: String, default: null },
		},
	},
	VN = {
		key: 0,
		class: "rounded bg-gray-900 px-2 py-1 text-xs text-white shadow-xl",
	},
	WN = { class: "py-px" };
function UN(t, e, n, r, o, i) {
	const s = nt("Popover");
	return (
		j(),
		Fe(
			s,
			{
				trigger: "hover",
				hoverDelay: n.hoverDelay,
				placement: n.placement,
			},
			{
				target: He(() => [De(t.$slots, "default")]),
				body: He(() => [
					De(t.$slots, "body", {}, () => [
						n.text
							? (j(), q("div", VN, [U("div", WN, Qe(n.text), 1)]))
							: Ve("", !0),
					]),
				]),
				_: 3,
			},
			8,
			["hoverDelay", "placement"]
		)
	);
}
const KN = je(FN, [["render", UN]]),
	qN = { class: "truncate text-base" },
	JN = {
		__name: "ListRowItem",
		props: {
			item: { type: [String, Number, Object], default: "" },
			align: { type: String, default: "left" },
		},
		setup(t) {
			const e = t,
				n = H(() => r(e.item).label || "");
			function r(i) {
				return i && typeof i == "object" ? i : { label: i };
			}
			const o = qe("list");
			return (i, s) => (
				j(),
				Fe(
					zn(ue(o).options.showTooltip ? KN : "div"),
					Ht(ue(o).options.showTooltip ? { text: n.value } : {}, {
						class: ["flex items-center space-x-2", ue(jh)[t.align]],
					}),
					{
						default: He(() => [
							De(i.$slots, "prefix"),
							De(
								i.$slots,
								"default",
								Ut(en({ label: n.value })),
								() => [U("div", qN, Qe(n.value), 1)]
							),
							De(i.$slots, "suffix"),
						]),
						_: 3,
					},
					16,
					["class"]
				)
			);
		},
	},
	GN = { key: 0, class: "mx-2 h-px border-t border-gray-200" },
	YN = {
		__name: "ListRow",
		props: { row: { type: Object, required: !0 } },
		setup(t) {
			const e = t,
				n = qe("list"),
				r = H(() => {
					var o;
					return (o = n.value.rows) != null && o.length
						? n.value.rows[n.value.rows.length - 1][
								n.value.rowKey
						  ] === e.row[n.value.rowKey]
						: !1;
				});
			return (o, i) => (
				j(),
				Fe(
					zn(ue(n).options.getRowRoute ? "router-link" : "div"),
					Ht(
						{
							class: "flex cursor-pointer flex-col transition-all duration-300 ease-in-out",
						},
						ue(n).options.getRowRoute
							? { to: ue(n).options.getRowRoute(t.row) }
							: { onClick: () => ue(n).options.onRowClick(t.row) }
					),
					{
						default: He(() => [
							(j(),
							Fe(
								zn(
									ue(n).options.getRowRoute
										? "template"
										: "button"
								),
								{ class: "[all:unset] hover:[all:unset]" },
								{
									default: He(() => [
										U(
											"div",
											{
												class: we([
													"grid items-center space-x-4 rounded px-2 py-2.5",
													ue(n).selections.has(
														t.row[ue(n).rowKey]
													)
														? "bg-gray-100 hover:bg-gray-200"
														: "hover:bg-gray-50",
												]),
												style: ao({
													gridTemplateColumns: ue(L2)(
														ue(n).columns,
														ue(n).options.selectable
													),
												}),
											},
											[
												ue(n).options.selectable
													? (j(),
													  Fe(
															th,
															{
																key: 0,
																modelValue: ue(
																	n
																).selections.has(
																	t.row[
																		ue(n)
																			.rowKey
																	]
																),
																onClick:
																	i[0] ||
																	(i[0] = R0(
																		(s) =>
																			ue(
																				n
																			).toggleRow(
																				t
																					.row[
																					ue(
																						n
																					)
																						.rowKey
																				]
																			),
																		["stop"]
																	)),
																class: "cursor-pointer duration-300",
															},
															null,
															8,
															["modelValue"]
													  ))
													: Ve("", !0),
												(j(!0),
												q(
													Ne,
													null,
													Pt(
														ue(n).columns,
														(s) => (
															j(),
															q(
																"div",
																{
																	key: s.key,
																	class: we(
																		ue(jh)[
																			s
																				.align
																		]
																	),
																},
																[
																	De(
																		o.$slots,
																		"default",
																		Ut(
																			en({
																				column: s,
																				item: t
																					.row[
																					s
																						.key
																				],
																			})
																		),
																		() => [
																			be(
																				JN,
																				{
																					item: t
																						.row[
																						s
																							.key
																					],
																					align: s.align,
																				},
																				null,
																				8,
																				[
																					"item",
																					"align",
																				]
																			),
																		]
																	),
																],
																2
															)
														)
													),
													128
												)),
											],
											6
										),
										r.value
											? Ve("", !0)
											: (j(), q("div", GN)),
									]),
									_: 3,
								}
							)),
						]),
						_: 3,
					},
					16
				)
			);
		},
	},
	QN = { class: "h-full overflow-y-auto" },
	XN = {
		__name: "ListRows",
		setup(t) {
			const e = qe("list");
			return (n, r) => (
				j(),
				q("div", QN, [
					De(n.$slots, "default", {}, () => [
						(j(!0),
						q(
							Ne,
							null,
							Pt(
								ue(e).rows,
								(o) => (
									j(),
									Fe(
										YN,
										{ key: o[ue(e).rowKey], row: o },
										null,
										8,
										["row"]
									)
								)
							),
							128
						)),
					]),
				])
			);
		},
	},
	ZN = {
		key: 0,
		class: "absolute inset-x-0 bottom-6 mx-auto w-max text-base",
	},
	eD = {
		class: "flex flex-1 justify-between border-r border-gray-300 text-gray-900",
	},
	tD = { class: "flex items-center space-x-3" },
	nD = { class: "mr-3" },
	rD = { class: "flex items-center space-x-1" },
	oD = Object.assign(
		{ inheritAttrs: !1 },
		{
			__name: "ListSelectBanner",
			setup(t) {
				const e = qe("list");
				let n = H(() => {
					let r = e.value.selections.size === 1 ? "Row" : "Rows";
					return `${e.value.selections.size} ${r} selected`;
				});
				return (r, o) => (
					j(),
					Fe(
						Su,
						{
							"enter-active-class": "duration-300 ease-out",
							"enter-from-class": "transform opacity-0",
							"enter-to-class": "opacity-100",
							"leave-active-class": "duration-300 ease-in",
							"leave-from-class": "opacity-100",
							"leave-to-class": "transform opacity-0",
						},
						{
							default: He(() => [
								ue(e).selections.size
									? (j(),
									  q("div", ZN, [
											U(
												"div",
												{
													class: we([
														"flex min-w-[596px] items-center space-x-3 rounded-lg bg-white px-4 py-2 shadow-2xl",
														r.$attrs.class,
													]),
												},
												[
													De(
														r.$slots,
														"default",
														Ut(
															en({
																selections:
																	ue(e)
																		.selections,
																allRowsSelected:
																	ue(e)
																		.allRowsSelected,
																selectAll: () =>
																	ue(
																		e
																	).toggleAllRows(
																		!0
																	),
																unselectAll:
																	() =>
																		ue(
																			e
																		).toggleAllRows(
																			!1
																		),
															})
														),
														() => [
															U("div", eD, [
																U("div", tD, [
																	be(th, {
																		modelValue:
																			!0,
																		disabled:
																			!0,
																		class: "text-gray-900",
																	}),
																	U(
																		"div",
																		null,
																		Qe(
																			ue(
																				n
																			)
																		),
																		1
																	),
																]),
																U("div", nD, [
																	De(
																		r.$slots,
																		"actions",
																		Ut(
																			en({
																				selections:
																					ue(
																						e
																					)
																						.selections,
																				allRowsSelected:
																					ue(
																						e
																					)
																						.allRowsSelected,
																				selectAll:
																					() =>
																						ue(
																							e
																						).toggleAllRows(
																							!0
																						),
																				unselectAll:
																					() =>
																						ue(
																							e
																						).toggleAllRows(
																							!1
																						),
																			})
																		)
																	),
																]),
															]),
															U("div", rD, [
																be(
																	Os,
																	{
																		class: we(
																			[
																				"w- text-gray-700",
																				ue(
																					e
																				)
																					.allRowsSelected
																					? "cursor-not-allowed"
																					: "",
																			]
																		),
																		disabled:
																			ue(
																				e
																			)
																				.allRowsSelected,
																		variant:
																			"ghost",
																		onClick:
																			o[0] ||
																			(o[0] =
																				(
																					i
																				) =>
																					ue(
																						e
																					).toggleAllRows(
																						!0
																					)),
																	},
																	{
																		default:
																			He(
																				() => [
																					_r(
																						" Select all "
																					),
																				]
																			),
																		_: 1,
																	},
																	8,
																	[
																		"disabled",
																		"class",
																	]
																),
																be(Os, {
																	icon: "x",
																	variant:
																		"ghost",
																	onClick:
																		o[1] ||
																		(o[1] =
																			(
																				i
																			) =>
																				ue(
																					e
																				).toggleAllRows(
																					!1
																				)),
																}),
															]),
														]
													),
												],
												2
											),
									  ]))
									: Ve("", !0),
							]),
							_: 3,
						}
					)
				);
			},
		}
	),
	iD = { class: "relative flex w-full flex-1 flex-col overflow-x-auto" },
	uL = Object.assign(
		{ inheritAttrs: !1 },
		{
			__name: "ListView",
			props: {
				columns: { type: Array, default: [] },
				rows: { type: Array, default: [] },
				rowKey: { type: String, required: !0 },
				options: {
					type: Object,
					default: {
						getRowRoute: null,
						onRowClick: null,
						showTooltip: !0,
						selectable: !0,
					},
				},
			},
			emits: ["update:selections"],
			setup(t, { emit: e }) {
				const n = t;
				let r = Gt(new Set());
				const o = e;
				it(r, (u) => {
					o("update:selections", u);
				});
				let i = H(() => {
					function u(c) {
						return c === void 0 ? !0 : c;
					}
					return {
						getRowRoute: n.options.getRowRoute || null,
						onRowClick: n.options.onRowClick || null,
						showTooltip: u(n.options.showTooltip),
						selectable: u(n.options.selectable),
					};
				});
				const s = H(() =>
					n.rows.length ? r.size === n.rows.length : !1
				);
				function l(u) {
					r.delete(u) || r.add(u);
				}
				function a(u) {
					if (!u || s.value) {
						r.clear();
						return;
					}
					n.rows.forEach((c) => r.add(c[n.rowKey]));
				}
				return (
					vt(
						"list",
						H(() => ({
							rowKey: n.rowKey,
							rows: n.rows,
							columns: n.columns,
							options: i.value,
							selections: r,
							allRowsSelected: s.value,
							toggleRow: l,
							toggleAllRows: a,
						}))
					),
					(u, c) => (
						j(),
						q("div", iD, [
							U(
								"div",
								{
									class: we([
										"flex w-max min-w-full flex-col overflow-y-hidden",
										u.$attrs.class,
									]),
								},
								[
									De(u.$slots, "default", {}, () => [
										be(HN),
										be(XN),
										ue(i).selectable
											? (j(), Fe(oD, { key: 0 }))
											: Ve("", !0),
									]),
								],
								2
							),
						])
					)
				);
			},
		}
	),
	sD = {
		name: "Toast",
		props: {
			position: { type: String, default: "top-center" },
			icon: { type: String },
			iconClasses: { type: String },
			title: { type: String },
			text: { type: String },
			timeout: { type: Number, default: 5 },
		},
		emits: ["close"],
		components: { FeatherIcon: eo },
		mounted() {
			this.timeout > 0 &&
				setTimeout(() => {
					this.$emit("close");
				}, this.timeout * 1e3);
		},
	},
	lD = {
		class: "my-2 min-w-[15rem] max-w-[40rem] rounded-lg border bg-white p-4 shadow-md",
	},
	aD = { class: "flex items-start" },
	uD = { key: 0, class: "mr-3 grid h-5 w-5 place-items-center" },
	cD = { key: 1, class: "text-base text-gray-600" },
	dD = { class: "ml-auto pl-2" };
function fD(t, e, n, r, o, i) {
	const s = nt("FeatherIcon");
	return (
		j(),
		q("div", lD, [
			U("div", aD, [
				n.icon
					? (j(),
					  q("div", uD, [
							be(
								s,
								{
									name: n.icon,
									class: we(["h-5 w-5", n.iconClasses]),
								},
								null,
								8,
								["name", "class"]
							),
					  ]))
					: Ve("", !0),
				U("div", null, [
					De(t.$slots, "default", {}, () => [
						n.title
							? (j(),
							  q(
									"p",
									{
										key: 0,
										class: we([
											"text-base font-medium text-gray-900",
											{ "mb-1": n.text },
										]),
									},
									Qe(n.title),
									3
							  ))
							: Ve("", !0),
						n.text ? (j(), q("p", cD, Qe(n.text), 1)) : Ve("", !0),
					]),
				]),
				U("div", dD, [
					De(t.$slots, "actions", {}, () => [
						U(
							"button",
							{
								class: "grid h-5 w-5 place-items-center rounded hover:bg-gray-100",
								onClick:
									e[0] || (e[0] = (l) => t.$emit("close")),
							},
							[
								be(s, {
									name: "x",
									class: "h-4 w-4 text-gray-700",
								}),
							]
						),
					]),
				]),
			]),
		])
	);
}
const hD = je(sD, [["render", fD]]);
let Ql = X([]),
	cL = {
		name: "Toasts",
		created() {
			if (
				typeof window != "undefined" &&
				!document.getElementById("frappeui-toast-root")
			) {
				const t = document.createElement("div");
				(t.id = "frappeui-toast-root"),
					(t.style.position = "fixed"),
					(t.style.top = "16px"),
					(t.style.right = "16px"),
					(t.style.bottom = "16px"),
					(t.style.left = "16px"),
					(t.style.zIndex = "9999"),
					(t.style.pointerEvents = "none"),
					document.body.appendChild(t);
			}
		},
		render() {
			return Ue(bu, { to: "#frappeui-toast-root" }, [
				Zo("top-left"),
				Zo("top-center"),
				Zo("top-right"),
				Zo("bottom-left"),
				Zo("bottom-center"),
				Zo("bottom-right"),
			]);
		},
	};
function Zo(t) {
	let e = "transition duration-[230ms] ease-[cubic-bezier(.21,1.02,.73,1)]",
		n = ["absolute"];
	return (
		t === "top-left" && n.push("top-0 left-0"),
		t === "top-right" && n.push("top-0 right-0"),
		t === "top-center" && n.push("top-0 left-1/2 -translate-x-1/2"),
		t === "bottom-left" && n.push("bottom-0 left-0"),
		t === "bottom-right" && n.push("bottom-0 right-0"),
		t === "bottom-center" && n.push("bottom-0 left-1/2 -translate-x-1/2"),
		Ue(
			vx,
			{
				tag: "div",
				class: n,
				moveClass: e,
				enterActiveClass: e,
				enterFromClass: "translate-y-1 opacity-0",
				enterToClass: "translate-y-0 opacity-100",
				leaveActiveClass: `${e} absolute`,
				leaveFromClass: "translate-y-0 opacity-100",
				leaveToClass: "translate-y-1 opacity-0",
			},
			() =>
				Ql.value
					.filter((r) => r.position === t)
					.map((r) =>
						Ue(
							"div",
							{ key: r.key, class: "pointer-events-auto flex" },
							Ue(
								hD,
								ye(z({}, r), {
									onClose: () => {
										Ql.value = Ql.value.filter(
											(o) => o !== r
										);
									},
								})
							)
						)
					)
		)
	);
}
function dL(t) {
	let e = `toast-${Math.random().toString(36).slice(2, 9)}`,
		n = Gt(z({ key: e, position: "top-center" }, t));
	return Ql.value.push(n), e;
}
function pD(r, o) {
	return hr(this, arguments, function* (t, e, n = {}) {
		e || (e = {});
		let i = Object.assign(
			{
				Accept: "application/json",
				"Content-Type": "application/json; charset=utf-8",
				"X-Frappe-Site-Name": window.location.hostname,
			},
			n.headers || {}
		);
		window.csrf_token &&
			window.csrf_token !== "{{ csrf_token }}" &&
			(i["X-Frappe-CSRF-Token"] = window.csrf_token);
		let s = t.startsWith("/") ? t : `/api/method/${t}`;
		const l = yield fetch(s, {
			method: "POST",
			headers: i,
			body: JSON.stringify(e),
		});
		if (l.ok) {
			const a = yield l.json();
			if (a.docs || t === "login") return a;
			if (a.exc)
				try {
					console.groupCollapsed(t),
						console.log(`method: ${t}`),
						console.log("params:", e);
					let u = JSON.parse(a.exc);
					for (let c of u) console.log(c);
					console.groupEnd();
				} catch (u) {
					console.warn("Error printing debug messages", u);
				}
			return a.message;
		} else {
			let a = yield l.text(),
				u,
				c;
			try {
				u = JSON.parse(a);
			} catch (p) {}
			let d = [
				[t, u.exc_type, u._error_message].filter(Boolean).join(" "),
			];
			if (u.exc) {
				c = u.exc;
				try {
					(c = JSON.parse(c)[0]), console.log(c);
				} catch (p) {}
			}
			let h = new Error(
				d.join(`
`)
			);
			throw (
				((h.exc_type = u.exc_type),
				(h.exc = c),
				(h.status = l.status),
				(h.messages = u._server_messages
					? JSON.parse(u._server_messages)
					: []),
				(h.messages = h.messages.concat(u.message)),
				(h.messages = h.messages.map((p) => {
					try {
						return JSON.parse(p).message;
					} catch (g) {
						return p;
					}
				})),
				(h.messages = h.messages.filter(Boolean)),
				h.messages.length ||
					(h.messages = u._error_message
						? [u._error_message]
						: ["Internal Server Error"]),
				n.onError &&
					n.onError({ response: l, status: l.status, error: h }),
				h)
			);
		}
	});
}
let Xl = document.querySelector('link[rel="icon"]'),
	mD = Xl.href;
function gD(t) {
	it(
		() => {
			try {
				return t();
			} catch (e) {
				return null;
			}
		},
		(e) => {
			if (e)
				if ((e.title && (document.title = e.title), e.emoji)) {
					let n = `data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>${e.emoji}</text></svg>`;
					Xl.href = n;
				} else e.icon ? (Xl.href = e.icon) : (Xl.href = mD);
		},
		{ immediate: !0, deep: !0 }
	);
}
const fL = {
	install(t) {
		t.mixin(yD());
	},
};
function yD() {
	return {
		created() {
			if (this.$options.pageMeta) {
				let t = this.$options.pageMeta.bind(this);
				gD(t);
			}
		},
	};
}
function $2(t) {
	let e = Object.assign({}, t);
	if (!e.url) throw new Error("[request] options.url is required");
	e.transformRequest && (e = e.transformRequest(t)),
		e.responseType || (e.responseType = "json"),
		e.method || (e.method = "GET");
	let n = e.url,
		r;
	if (e.params)
		if (e.method === "GET") {
			let o = new URLSearchParams();
			for (let i in e.params) o.append(i, e.params[i]);
			n = e.url + "?" + o.toString();
		} else r = JSON.stringify(e.params);
	return fetch(n, {
		method: e.method || "GET",
		headers: e.headers,
		body: r,
	}).then((o) => {
		if (e.transformResponse) return e.transformResponse(o, e);
		if (o.status >= 200 && o.status < 300)
			return e.responseType === "json" ? o.json() : o;
		{
			let i = new Error(o.statusText);
			throw ((i.response = o), i);
		}
	});
}
function Ju(t) {
	return new Promise((e, n) => {
		(t.oncomplete = t.onsuccess = () => e(t.result)),
			(t.onabort = t.onerror = () => n(t.error));
	});
}
function vD(t, e) {
	const n = indexedDB.open(t);
	n.onupgradeneeded = () => n.result.createObjectStore(e);
	const r = Ju(n);
	return (o, i) => r.then((s) => i(s.transaction(e, o).objectStore(e)));
}
let Jc;
function Lh() {
	return Jc || (Jc = vD("keyval-store", "keyval")), Jc;
}
function bD(t, e = Lh()) {
	return e("readonly", (n) => Ju(n.get(t)));
}
function wD(t, e, n = Lh()) {
	return n("readwrite", (r) => (r.put(e, t), Ju(r.transaction)));
}
function xD(t, e = Lh()) {
	return e("readwrite", (n) => (n.delete(t), Ju(n.transaction)));
}
function $h(t, e) {
	return typeof indexedDB == "undefined"
		? Promise.resolve(null)
		: t
		? wD(t, JSON.stringify(e))
		: Promise.resolve();
}
function kD(t) {
	return typeof indexedDB == "undefined"
		? Promise.resolve(null)
		: t
		? xD(t)
		: Promise.resolve();
}
function Bh(t) {
	return typeof indexedDB == "undefined"
		? Promise.resolve(null)
		: bD(t).then((e) => e && JSON.parse(e));
}
let B2 = {};
function hL(t, e) {
	B2[t] = e;
}
function Ln(t) {
	return B2[t] || null;
}
let Zl = {};
function mn(t, e) {
	let n = null;
	if (t.cache) {
		n = Bi(t.cache);
		let d = Zl[n];
		if (d) return d.auto && d.reload(), d;
	}
	typeof t == "string" && (t = { url: t, auto: !0 });
	let r = t.debounce ? nh(i, t.debounce) : i,
		o = Gt({
			method: t.method,
			url: t.url,
			data: t.initialData || null,
			previousData: null,
			loading: !1,
			fetched: !1,
			error: null,
			promise: null,
			auto: t.auto,
			params: null,
			fetch: r,
			reload: r,
			submit: r,
			reset: l,
			update: s,
			setData: u,
		});
	function i(p) {
		return hr(this, arguments, function* (d, h = {}) {
			let g = t.resourceFetcher || Ln("resourceFetcher") || $2;
			d instanceof Event && (d = null),
				(d = d || o.params),
				t.makeParams && (d = t.makeParams.call(e, d)),
				(o.params = d),
				(o.previousData = o.data
					? JSON.parse(JSON.stringify(o.data))
					: null),
				(o.loading = !0),
				(o.error = null),
				t.onFetch && t.onFetch.call(e, o.params);
			let y = [t.beforeSubmit, h.beforeSubmit];
			for (let f of y) f && f.call(e, o.params);
			let b = h.validate || t.validate,
				w = [t.onError, h.onError],
				S = [t.onSuccess, h.onSuccess],
				E = [t.onData, h.onData];
			if (b) {
				let f;
				try {
					if (
						((f = yield b.call(e, o.params)),
						f && typeof f == "string")
					)
						throw new Error(f);
				} catch (v) {
					a(v, w);
					return;
				}
			}
			try {
				o.promise = g(ye(z({}, t), { params: d || t.params }));
				let f = yield o.promise;
				$h(n, f), (o.data = c(f)), (o.fetched = !0);
				for (let v of S) v && v.call(e, f);
				for (let v of E) v && v.call(e, f);
			} catch (f) {
				a(f, w);
			}
			return (o.loading = !1), o.data;
		});
	}
	function s({ method: d, url: h, params: p, auto: g }) {
		d && d !== t.method && (o.method = d),
			h && h !== t.url && (o.url = h),
			p && p !== t.params && (o.params = p),
			g !== void 0 && g !== o.auto && (o.auto = g);
	}
	function l() {
		(o.data = t.initialData || null),
			(o.previousData = null),
			(o.loading = !1),
			(o.fetched = !1),
			(o.error = null),
			(o.params = null),
			(o.auto = t.auto);
	}
	function a(d, h) {
		(o.loading = !1),
			o.previousData && (o.data = o.previousData),
			(o.error = d);
		for (let p of h) p && p.call(e, d);
		if (h.every((p) => p == null)) {
			let p = Ln("fallbackErrorHandler");
			if (p)
				try {
					p(d);
				} catch (g) {
					console.warn("Error in fallbackErrorHandler", g);
				}
		}
		throw d;
	}
	function u(d) {
		typeof d == "function" && (d = d.call(e, o.data)), (o.data = c(d));
	}
	function c(d) {
		if (t.transform) {
			let h = t.transform.call(e, d);
			if (h != null) return h;
		}
		return d;
	}
	return (
		n &&
			!Zl[n] &&
			((Zl[n] = o),
			Bh(n).then((d) => {
				var h;
				(o.loading || !o.fetched) &&
					d &&
					(u(d), (h = t.onData) == null || h.call(e, d));
			})),
		t.auto && o.fetch(),
		o
	);
}
function Bi(t) {
	return t ? (typeof t == "string" && (t = [t]), JSON.stringify(t)) : null;
}
function SD(t) {
	return (t = Bi(t)), Zl[t] || null;
}
function z2(t, e, n) {
	_D(t, e),
		t.on("list_update", (r) => {
			r.doctype == e && n(r.name);
		});
}
let s1 = {};
function _D(t, e) {
	s1[e] || (t.emit("doctype_subscribe", e), (s1[e] = !0));
}
let lf = Gt({}),
	yi = {};
function CD(t, e) {
	var w, S, E, f, v;
	if (!t.doctype) throw new Error("List resource requires doctype");
	let n = Bi(t.cache);
	if (n) {
		let m = lf[n];
		if (m) return m.auto && m.reload(), m;
	}
	let r = Ln("defaultListUrl") || "frappe.client.get_list",
		o = Ln("defaultDocInsertUrl") || "frappe.client.insert",
		i = Ln("defaultDocUpdateUrl") || "frappe.client.set_value",
		s = Ln("defaultDocDeleteUrl") || "frappe.client.delete",
		l = Ln("defaultRunDocMethodUrl") || "run_doc_method",
		a = Gt({
			doctype: t.doctype,
			fields: t.fields,
			filters: t.filters,
			orderBy: t.orderBy,
			start: t.start || 0,
			pageLength: t.pageLength || 20,
			groupBy: t.groupBy,
			parent: t.parent,
			debug: t.debug || 0,
			originalData: null,
			dataMap: {},
			data: null,
			previous: g,
			hasPreviousPage: !1,
			next: y,
			hasNextPage: !0,
			auto: t.auto,
			list: mn(
				{
					url: t.url || r,
					makeParams() {
						return {
							doctype: a.doctype,
							fields: a.fields,
							filters: a.filters,
							order_by: a.orderBy,
							start: a.start,
							limit: a.pageLength,
							limit_start: a.start,
							limit_page_length: a.pageLength,
							group_by: a.groupBy,
							parent: a.parent,
							debug: a.debug,
						};
					},
					onSuccess(m) {
						var k;
						(a.hasPreviousPage = !!a.start),
							m.length < a.pageLength && (a.hasNextPage = !1);
						let x;
						!a.start || a.start == 0
							? (x = m)
							: a.start > 0 && (x = a.originalData.concat(m)),
							$h(n, x),
							p(x),
							(k = t.onSuccess) == null || k.call(e, a.data);
					},
					onError: t.onError,
				},
				e
			),
			fetchOne: mn(
				{
					url: t.url || r,
					makeParams(m) {
						return {
							doctype: a.doctype,
							fields: a.fields || "*",
							filters: { name: m },
						};
					},
					onSuccess(m) {
						var x, k;
						if (m.length > 0 && a.originalData) {
							let C = m[0];
							vs(a.doctype, C);
						}
						(k = (x = t.fetchOne) == null ? void 0 : x.onSuccess) ==
							null || k.call(e, a.data);
					},
					onError: (w = t.fetchOne) == null ? void 0 : w.onError,
				},
				e
			),
			insert: mn(
				{
					url: o,
					makeParams(m) {
						return { doc: z({ doctype: a.doctype }, m) };
					},
					onSuccess(m) {
						var x, k;
						a.list.fetch(),
							(k =
								(x = t.insert) == null
									? void 0
									: x.onSuccess) == null || k.call(e, m);
					},
					onError: (S = t.insert) == null ? void 0 : S.onError,
				},
				e
			),
			setValue: mn(
				{
					url: i,
					makeParams(m) {
						let C = m,
							{ name: x } = C,
							k = et(C, ["name"]);
						return { doctype: a.doctype, name: x, fieldname: k };
					},
					onSuccess(m) {
						var x, k;
						vs(a.doctype, m),
							(k =
								(x = t.setValue) == null
									? void 0
									: x.onSuccess) == null || k.call(e, m);
					},
					onError: (E = t.setValue) == null ? void 0 : E.onError,
				},
				e
			),
			delete: mn(
				{
					url: s,
					makeParams(m) {
						return { doctype: a.doctype, name: m };
					},
					onSuccess(m) {
						var x, k;
						a.list.fetch(),
							(k =
								(x = t.delete) == null
									? void 0
									: x.onSuccess) == null || k.call(e, m);
					},
					onError: (f = t.delete) == null ? void 0 : f.onError,
				},
				e
			),
			runDocMethod: mn(
				{
					url: l,
					makeParams(C) {
						var _ = C,
							{ method: m, name: x } = _,
							k = et(_, ["method", "name"]);
						return {
							dt: a.doctype,
							dn: x,
							method: m,
							args: JSON.stringify(k),
						};
					},
					onSuccess(m) {
						var x, k;
						if (m.docs) for (let C of m.docs) vs(C.doctype, C);
						(k =
							(x = t.runDocMethod) == null
								? void 0
								: x.onSuccess) == null || k.call(e, m);
					},
					onError: (v = t.runDocMethod) == null ? void 0 : v.onError,
				},
				e
			),
			update: u,
			fetch: h,
			reload: d,
			setData: p,
			transform: c,
			getRow: b,
		});
	function u(m) {
		Object.assign(a, m);
	}
	function c(m) {
		if (t.transform) {
			let x = t.transform.call(e, m);
			if (x != null) return x;
		}
		return m;
	}
	function d() {
		let m = a.start,
			x = a.pageLength;
		return (
			a.start > 0 &&
				((a.start = 0), (a.pageLength = a.originalData.length)),
			a.list.fetch().finally(() => {
				(a.start = m), (a.pageLength = x);
			})
		);
	}
	function h() {
		d();
	}
	function p(m) {
		if (
			((a.originalData = m),
			typeof m == "function" && (m = m.call(e, a.data)),
			(a.data = c(m)),
			Array.isArray(a.data))
		) {
			a.dataMap = {};
			for (let x of a.data) {
				if (!x.name) continue;
				let k = x.name.toString();
				a.dataMap[k] = x;
			}
		}
	}
	function g() {
		(a.start = a.start - a.pageLength), a.list.fetch();
	}
	function y() {
		(a.start = a.start + a.pageLength), a.list.fetch();
	}
	function b(m) {
		let x = m.toString();
		return a.dataMap[x];
	}
	return (
		t.realtime &&
			e != null &&
			e.$socket &&
			z2(e.$socket, a.doctype, (m) => {
				var x;
				(x = a.originalData) != null &&
					x.find((k) => k.name === m) &&
					a.fetchOne.submit(m);
			}),
		n &&
			((lf[n] = a),
			Bh(n).then((m) => {
				var x;
				(a.list.loading || !a.list.fetched) &&
					m &&
					(p(m), (x = t.onData) == null || x.call(e, m));
			})),
		t.auto && a.list.fetch(),
		(yi[a.doctype] = yi[a.doctype] || []),
		yi[a.doctype].push(a),
		a
	);
}
function MD(t) {
	return (t = Bi(t)), lf[t] || null;
}
function vs(t, e) {
	if (!e.name) return;
	let n = yi[t] || [];
	for (let r of n)
		if (r.originalData) {
			for (let o of r.originalData)
				if (o.name && o.name == e.name) {
					delete o._previousData;
					let i = JSON.stringify(o);
					for (let s in o) s in e && (o[s] = e[s]);
					o._previousData = i;
				}
			r.data = r.transform(r.originalData);
		}
}
function ED(t, e) {
	let n = yi[t] || [];
	for (let r of n)
		r.originalData &&
			((r.originalData = r.originalData.filter(
				(o) => o.name.toString() !== e.toString()
			)),
			(r.data = r.transform(r.originalData)));
}
function TD(t, e) {
	let n = yi[t] || [];
	for (let r of n)
		if (r.originalData) {
			for (let o of r.originalData)
				if (o.name && o.name == e.name) {
					let i = JSON.parse(o._previousData);
					for (let s in o) o[s] = i[s];
					delete o._previousData;
				}
			r.data = r.transform(r.originalData);
		}
}
let af = Gt({});
function AD(t, e) {
	var g;
	if (!(t.doctype && t.name)) return;
	let n = Bi([t.doctype, t.name]),
		r = af[n];
	if (r) return r.auto && r.reload(), r;
	let o = Ln("defaultDocGetUrl") || "frappe.client.get",
		i = Ln("defaultDocUpdateUrl") || "frappe.client.set_value",
		s = Ln("defaultDocDeleteUrl") || "frappe.client.delete",
		l = Ln("defaultRunDocMethodUrl") || "run_doc_method",
		a = {
			url: i,
			makeParams(b) {
				return { doctype: c.doctype, name: c.name, fieldname: b };
			},
			beforeSubmit(b) {
				(c.previousDoc = JSON.stringify(c.doc)),
					Object.assign(c.doc, b.fieldname || {}),
					vs(c.doctype, c.doc);
			},
			onSuccess(b) {
				var w, S;
				(c.doc = p(b)),
					(c.originalDoc = JSON.parse(JSON.stringify(c.doc))),
					(S = (w = t.setValue) == null ? void 0 : w.onSuccess) ==
						null || S.call(e, b);
			},
			onError(b) {
				var w, S;
				(c.doc = JSON.parse(c.previousDoc)),
					(S = (w = t.setValue) == null ? void 0 : w.onError) ==
						null || S.call(e, b),
					TD(c.doctype, c.doc);
			},
		};
	const u = t.auto !== void 0;
	let c = Gt({
		doctype: t.doctype,
		name: t.name,
		doc: null,
		originalDoc: null,
		isDirty: !1,
		auto: u ? t.auto : !0,
		get: mn(
			{
				url: o,
				makeParams() {
					return { doctype: c.doctype, name: c.name };
				},
				onSuccess(b) {
					var w;
					$h(n, b),
						(c.doc = p(b)),
						(c.originalDoc = JSON.parse(JSON.stringify(c.doc))),
						(w = t.onSuccess) == null || w.call(e, c.doc);
				},
				onError(b) {
					var w;
					kD(n),
						(c.doc = null),
						(c.originalDoc = null),
						(w = t.onError) == null || w.call(e, b);
				},
			},
			e
		),
		setValue: mn(a, e),
		setValueDebounced: mn(ye(z({}, a), { debounce: t.debounce || 500 }), e),
		save: mn(
			ye(z({}, a), {
				makeParams() {
					let b = JSON.parse(JSON.stringify(c.doc));
					return (
						delete b.doctype,
						delete b.name,
						{ doctype: c.doctype, name: c.name, fieldname: b }
					);
				},
			}),
			e
		),
		delete: mn(
			{
				url: s,
				makeParams() {
					return { doctype: c.doctype, name: c.name };
				},
				onSuccess() {
					var b, w;
					(c.doc = null),
						(w = (b = t.delete) == null ? void 0 : b.onSuccess) ==
							null || w.call(e),
						ED(c.doctype, c.name);
				},
				onError: (g = t.delete) == null ? void 0 : g.onError,
			},
			e
		),
		reload: d,
		setDoc: h,
	});
	it(
		() => c.doc,
		() => {
			c.isDirty = JSON.stringify(c.doc) !== JSON.stringify(c.originalDoc);
		},
		{ deep: !0 }
	);
	for (let b in t.whitelistedMethods) {
		let w = t.whitelistedMethods[b];
		typeof w == "string" && (w = { method: w });
		let y = w,
			{ method: S, onSuccess: E, makeParams: f, transform: v } = y,
			m = et(y, ["method", "onSuccess", "makeParams", "transform"]);
		c[b] = mn(
			z(
				{
					url: l,
					makeParams(x) {
						return (
							(x = f ? f.call(e, x) : x),
							{ dt: c.doctype, dn: c.name, method: S, args: x }
						);
					},
					transform(x) {
						if (v) {
							let k = v.call(e, x.message);
							if (k != null) return k;
						}
						return x.message;
					},
					onSuccess(x) {
						if (x.docs) {
							for (let k of x.docs)
								if (
									k.doctype === c.doctype &&
									k.name.toString() === c.name.toString()
								) {
									(c.doc = p(k)), vs(c.doctype, c.doc);
									break;
								}
						}
						E == null || E.call(e, x.message);
					},
				},
				m
			),
			e
		);
	}
	function d() {
		return c.get.fetch();
	}
	function h(b) {
		typeof b == "function" && (b = b.call(e, c.doc)), (c.doc = p(b));
	}
	function p(b) {
		if (t.transform) {
			let w = t.transform.call(e, b);
			if (typeof w == "object") return w;
		}
		return b;
	}
	return (
		t.realtime &&
			e.$socket &&
			z2(e.$socket, c.doctype, (b) => {
				b == c.name && c.get.fetch();
			}),
		(af[n] = c),
		Bh(n).then((b) => {
			(c.get.loading || !c.get.fetched) && b && (c.doc = p(b));
		}),
		c.auto && c.get.fetch(),
		c
	);
}
function OD(t, e) {
	let n = Bi([t, e]);
	return af[n] || null;
}
let RD = (t) => ({
	created() {
		if (this.$options.resources) {
			this._resources = Gt({});
			for (let e in this.$options.resources) {
				let n = this.$options.resources[e];
				if (typeof n == "function")
					it(
						() => {
							try {
								return n.call(this);
							} catch (r) {
								return (
									console.warn(
										`Failed to get resource options

`,
										r
									),
									null
								);
							}
						},
						(r, o) => {
							!r ||
								!(
									!o ||
									JSON.stringify(r) !== JSON.stringify(o)
								) ||
								(this._resources[e] = l1(r, this));
						},
						{ immediate: !0 }
					);
				else {
					let r = l1(n, this);
					this._resources[e] = r;
				}
			}
		}
	},
	methods: {
		$getResource(e) {
			return SD(e);
		},
		$getDocumentResource(e, n) {
			return OD(e, n);
		},
		$getDoc(e, n) {
			let r = this.$getDocumentResource(e, n);
			return r ? r.doc : null;
		},
		$getListResource(e) {
			return MD(e);
		},
		$refetchResource(e) {
			let n = this.$getResource(e);
			n && n.fetch();
		},
	},
	computed: {
		$resources() {
			return this._resources;
		},
	},
});
function l1(t, e) {
	return t.type === "document"
		? AD(t, e)
		: t.type === "list"
		? CD(t, e)
		: mn(t, e);
}
const PD = {
	install(t, e) {
		let n = RD();
		t.mixin(n);
	},
};
function pL(t) {
	return $2(
		ye(z({}, t), {
			transformRequest: (e = {}) => {
				if (!e.url)
					throw new Error("[frappeRequest] options.url is required");
				let n = Object.assign(
					{
						Accept: "application/json",
						"Content-Type": "application/json; charset=utf-8",
						"X-Frappe-Site-Name": window.location.hostname,
					},
					e.headers || {}
				);
				return (
					window.csrf_token &&
						window.csrf_token !== "{{ csrf_token }}" &&
						(n["X-Frappe-CSRF-Token"] = window.csrf_token),
					!e.url.startsWith("/") &&
						!e.url.startsWith("http") &&
						(e.url = "/api/method/" + e.url),
					ye(z({}, e), { method: e.method || "POST", headers: n })
				);
			},
			transformResponse: (e, n) =>
				hr(this, null, function* () {
					let r = n.url;
					if (e.ok) {
						const o = yield e.json();
						if (o.docs || r === "login") return o;
						if (o.exc)
							try {
								console.groupCollapsed(r), console.log(n);
								let i = JSON.parse(o.exc);
								for (let s of i) console.log(s);
								console.groupEnd();
							} catch (i) {
								console.warn(
									"Error printing debug messages",
									i
								);
							}
						return o.message;
					} else {
						let o = yield e.text(),
							i,
							s;
						try {
							i = JSON.parse(o);
						} catch (u) {}
						let l = [
							[n.url, i.exc_type, i._error_message]
								.filter(Boolean)
								.join(" "),
						];
						if (i.exc) {
							s = i.exc;
							try {
								(s = JSON.parse(s)[0]), console.log(s);
							} catch (u) {}
						}
						let a = new Error(
							l.join(`
`)
						);
						throw (
							((a.exc_type = i.exc_type),
							(a.exc = s),
							(a.response = e),
							(a.status = o.status),
							(a.messages = i._server_messages
								? JSON.parse(i._server_messages)
								: []),
							(a.messages = a.messages.concat(i.message)),
							(a.messages = a.messages.map((u) => {
								try {
									return JSON.parse(u).message;
								} catch (c) {
									return u;
								}
							})),
							(a.messages = a.messages.filter(Boolean)),
							a.messages.length ||
								(a.messages = i._error_message
									? [i._error_message]
									: ["Internal Server Error"]),
							n.onError && n.onError(a),
							a)
						);
					}
				}),
		})
	);
}
const cr = Object.create(null);
cr.open = "0";
cr.close = "1";
cr.ping = "2";
cr.pong = "3";
cr.message = "4";
cr.upgrade = "5";
cr.noop = "6";
const ea = Object.create(null);
Object.keys(cr).forEach((t) => {
	ea[cr[t]] = t;
});
const uf = { type: "error", data: "parser error" },
	H2 =
		typeof Blob == "function" ||
		(typeof Blob != "undefined" &&
			Object.prototype.toString.call(Blob) ===
				"[object BlobConstructor]"),
	F2 = typeof ArrayBuffer == "function",
	V2 = (t) =>
		typeof ArrayBuffer.isView == "function"
			? ArrayBuffer.isView(t)
			: t && t.buffer instanceof ArrayBuffer,
	zh = ({ type: t, data: e }, n, r) =>
		H2 && e instanceof Blob
			? n
				? r(e)
				: a1(e, r)
			: F2 && (e instanceof ArrayBuffer || V2(e))
			? n
				? r(e)
				: a1(new Blob([e]), r)
			: r(cr[t] + (e || "")),
	a1 = (t, e) => {
		const n = new FileReader();
		return (
			(n.onload = function () {
				const r = n.result.split(",")[1];
				e("b" + (r || ""));
			}),
			n.readAsDataURL(t)
		);
	};
function u1(t) {
	return t instanceof Uint8Array
		? t
		: t instanceof ArrayBuffer
		? new Uint8Array(t)
		: new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
}
let Gc;
function ID(t, e) {
	if (H2 && t.data instanceof Blob)
		return t.data.arrayBuffer().then(u1).then(e);
	if (F2 && (t.data instanceof ArrayBuffer || V2(t.data)))
		return e(u1(t.data));
	zh(t, !1, (n) => {
		Gc || (Gc = new TextEncoder()), e(Gc.encode(n));
	});
}
const c1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	es = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (let t = 0; t < c1.length; t++) es[c1.charCodeAt(t)] = t;
const ND = (t) => {
		let e = t.length * 0.75,
			n = t.length,
			r,
			o = 0,
			i,
			s,
			l,
			a;
		t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--);
		const u = new ArrayBuffer(e),
			c = new Uint8Array(u);
		for (r = 0; r < n; r += 4)
			(i = es[t.charCodeAt(r)]),
				(s = es[t.charCodeAt(r + 1)]),
				(l = es[t.charCodeAt(r + 2)]),
				(a = es[t.charCodeAt(r + 3)]),
				(c[o++] = (i << 2) | (s >> 4)),
				(c[o++] = ((s & 15) << 4) | (l >> 2)),
				(c[o++] = ((l & 3) << 6) | (a & 63));
		return u;
	},
	DD = typeof ArrayBuffer == "function",
	Hh = (t, e) => {
		if (typeof t != "string") return { type: "message", data: W2(t, e) };
		const n = t.charAt(0);
		return n === "b"
			? { type: "message", data: jD(t.substring(1), e) }
			: ea[n]
			? t.length > 1
				? { type: ea[n], data: t.substring(1) }
				: { type: ea[n] }
			: uf;
	},
	jD = (t, e) => {
		if (DD) {
			const n = ND(t);
			return W2(n, e);
		} else return { base64: !0, data: t };
	},
	W2 = (t, e) => {
		switch (e) {
			case "blob":
				return t instanceof Blob ? t : new Blob([t]);
			case "arraybuffer":
			default:
				return t instanceof ArrayBuffer ? t : t.buffer;
		}
	},
	U2 = "",
	LD = (t, e) => {
		const n = t.length,
			r = new Array(n);
		let o = 0;
		t.forEach((i, s) => {
			zh(i, !1, (l) => {
				(r[s] = l), ++o === n && e(r.join(U2));
			});
		});
	},
	$D = (t, e) => {
		const n = t.split(U2),
			r = [];
		for (let o = 0; o < n.length; o++) {
			const i = Hh(n[o], e);
			if ((r.push(i), i.type === "error")) break;
		}
		return r;
	};
function BD() {
	return new TransformStream({
		transform(t, e) {
			ID(t, (n) => {
				const r = n.length;
				let o;
				if (r < 126)
					(o = new Uint8Array(1)),
						new DataView(o.buffer).setUint8(0, r);
				else if (r < 65536) {
					o = new Uint8Array(3);
					const i = new DataView(o.buffer);
					i.setUint8(0, 126), i.setUint16(1, r);
				} else {
					o = new Uint8Array(9);
					const i = new DataView(o.buffer);
					i.setUint8(0, 127), i.setBigUint64(1, BigInt(r));
				}
				t.data && typeof t.data != "string" && (o[0] |= 128),
					e.enqueue(o),
					e.enqueue(n);
			});
		},
	});
}
let Yc;
function jl(t) {
	return t.reduce((e, n) => e + n.length, 0);
}
function Ll(t, e) {
	if (t[0].length === e) return t.shift();
	const n = new Uint8Array(e);
	let r = 0;
	for (let o = 0; o < e; o++)
		(n[o] = t[0][r++]), r === t[0].length && (t.shift(), (r = 0));
	return t.length && r < t[0].length && (t[0] = t[0].slice(r)), n;
}
function zD(t, e) {
	Yc || (Yc = new TextDecoder());
	const n = [];
	let r = 0,
		o = -1,
		i = !1;
	return new TransformStream({
		transform(s, l) {
			for (n.push(s); ; ) {
				if (r === 0) {
					if (jl(n) < 1) break;
					const a = Ll(n, 1);
					(i = (a[0] & 128) === 128),
						(o = a[0] & 127),
						o < 126 ? (r = 3) : o === 126 ? (r = 1) : (r = 2);
				} else if (r === 1) {
					if (jl(n) < 2) break;
					const a = Ll(n, 2);
					(o = new DataView(
						a.buffer,
						a.byteOffset,
						a.length
					).getUint16(0)),
						(r = 3);
				} else if (r === 2) {
					if (jl(n) < 8) break;
					const a = Ll(n, 8),
						u = new DataView(a.buffer, a.byteOffset, a.length),
						c = u.getUint32(0);
					if (c > Math.pow(2, 21) - 1) {
						l.enqueue(uf);
						break;
					}
					(o = c * Math.pow(2, 32) + u.getUint32(4)), (r = 3);
				} else {
					if (jl(n) < o) break;
					const a = Ll(n, o);
					l.enqueue(Hh(i ? a : Yc.decode(a), e)), (r = 0);
				}
				if (o === 0 || o > t) {
					l.enqueue(uf);
					break;
				}
			}
		},
	});
}
const K2 = 4;
function Et(t) {
	if (t) return HD(t);
}
function HD(t) {
	for (var e in Et.prototype) t[e] = Et.prototype[e];
	return t;
}
Et.prototype.on = Et.prototype.addEventListener = function (t, e) {
	return (
		(this._callbacks = this._callbacks || {}),
		(this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e),
		this
	);
};
Et.prototype.once = function (t, e) {
	function n() {
		this.off(t, n), e.apply(this, arguments);
	}
	return (n.fn = e), this.on(t, n), this;
};
Et.prototype.off =
	Et.prototype.removeListener =
	Et.prototype.removeAllListeners =
	Et.prototype.removeEventListener =
		function (t, e) {
			if (
				((this._callbacks = this._callbacks || {}),
				arguments.length == 0)
			)
				return (this._callbacks = {}), this;
			var n = this._callbacks["$" + t];
			if (!n) return this;
			if (arguments.length == 1)
				return delete this._callbacks["$" + t], this;
			for (var r, o = 0; o < n.length; o++)
				if (((r = n[o]), r === e || r.fn === e)) {
					n.splice(o, 1);
					break;
				}
			return n.length === 0 && delete this._callbacks["$" + t], this;
		};
Et.prototype.emit = function (t) {
	this._callbacks = this._callbacks || {};
	for (
		var e = new Array(arguments.length - 1),
			n = this._callbacks["$" + t],
			r = 1;
		r < arguments.length;
		r++
	)
		e[r - 1] = arguments[r];
	if (n) {
		n = n.slice(0);
		for (var r = 0, o = n.length; r < o; ++r) n[r].apply(this, e);
	}
	return this;
};
Et.prototype.emitReserved = Et.prototype.emit;
Et.prototype.listeners = function (t) {
	return (
		(this._callbacks = this._callbacks || {}),
		this._callbacks["$" + t] || []
	);
};
Et.prototype.hasListeners = function (t) {
	return !!this.listeners(t).length;
};
const _n =
	typeof self != "undefined"
		? self
		: typeof window != "undefined"
		? window
		: Function("return this")();
function q2(t, ...e) {
	return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {});
}
const FD = _n.setTimeout,
	VD = _n.clearTimeout;
function Gu(t, e) {
	e.useNativeTimers
		? ((t.setTimeoutFn = FD.bind(_n)), (t.clearTimeoutFn = VD.bind(_n)))
		: ((t.setTimeoutFn = _n.setTimeout.bind(_n)),
		  (t.clearTimeoutFn = _n.clearTimeout.bind(_n)));
}
const WD = 1.33;
function UD(t) {
	return typeof t == "string"
		? KD(t)
		: Math.ceil((t.byteLength || t.size) * WD);
}
function KD(t) {
	let e = 0,
		n = 0;
	for (let r = 0, o = t.length; r < o; r++)
		(e = t.charCodeAt(r)),
			e < 128
				? (n += 1)
				: e < 2048
				? (n += 2)
				: e < 55296 || e >= 57344
				? (n += 3)
				: (r++, (n += 4));
	return n;
}
function qD(t) {
	let e = "";
	for (let n in t)
		t.hasOwnProperty(n) &&
			(e.length && (e += "&"),
			(e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])));
	return e;
}
function JD(t) {
	let e = {},
		n = t.split("&");
	for (let r = 0, o = n.length; r < o; r++) {
		let i = n[r].split("=");
		e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
	}
	return e;
}
class GD extends Error {
	constructor(e, n, r) {
		super(e),
			(this.description = n),
			(this.context = r),
			(this.type = "TransportError");
	}
}
class Fh extends Et {
	constructor(e) {
		super(),
			(this.writable = !1),
			Gu(this, e),
			(this.opts = e),
			(this.query = e.query),
			(this.socket = e.socket);
	}
	onError(e, n, r) {
		return super.emitReserved("error", new GD(e, n, r)), this;
	}
	open() {
		return (this.readyState = "opening"), this.doOpen(), this;
	}
	close() {
		return (
			(this.readyState === "opening" || this.readyState === "open") &&
				(this.doClose(), this.onClose()),
			this
		);
	}
	send(e) {
		this.readyState === "open" && this.write(e);
	}
	onOpen() {
		(this.readyState = "open"),
			(this.writable = !0),
			super.emitReserved("open");
	}
	onData(e) {
		const n = Hh(e, this.socket.binaryType);
		this.onPacket(n);
	}
	onPacket(e) {
		super.emitReserved("packet", e);
	}
	onClose(e) {
		(this.readyState = "closed"), super.emitReserved("close", e);
	}
	pause(e) {}
	createUri(e, n = {}) {
		return (
			e +
			"://" +
			this._hostname() +
			this._port() +
			this.opts.path +
			this._query(n)
		);
	}
	_hostname() {
		const e = this.opts.hostname;
		return e.indexOf(":") === -1 ? e : "[" + e + "]";
	}
	_port() {
		return this.opts.port &&
			((this.opts.secure && +(this.opts.port !== 443)) ||
				(!this.opts.secure && Number(this.opts.port) !== 80))
			? ":" + this.opts.port
			: "";
	}
	_query(e) {
		const n = qD(e);
		return n.length ? "?" + n : "";
	}
}
const J2 =
		"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
			""
		),
	cf = 64,
	YD = {};
let d1 = 0,
	$l = 0,
	f1;
function h1(t) {
	let e = "";
	do (e = J2[t % cf] + e), (t = Math.floor(t / cf));
	while (t > 0);
	return e;
}
function G2() {
	const t = h1(+new Date());
	return t !== f1 ? ((d1 = 0), (f1 = t)) : t + "." + h1(d1++);
}
for (; $l < cf; $l++) YD[J2[$l]] = $l;
let Y2 = !1;
try {
	Y2 =
		typeof XMLHttpRequest != "undefined" &&
		"withCredentials" in new XMLHttpRequest();
} catch (t) {}
const QD = Y2;
function Q2(t) {
	const e = t.xdomain;
	try {
		if (typeof XMLHttpRequest != "undefined" && (!e || QD))
			return new XMLHttpRequest();
	} catch (n) {}
	if (!e)
		try {
			return new _n[["Active"].concat("Object").join("X")](
				"Microsoft.XMLHTTP"
			);
		} catch (n) {}
}
function XD() {}
const ZD = (function () {
	return new Q2({ xdomain: !1 }).responseType != null;
})();
class ej extends Fh {
	constructor(e) {
		if ((super(e), (this.polling = !1), typeof location != "undefined")) {
			const r = location.protocol === "https:";
			let o = location.port;
			o || (o = r ? "443" : "80"),
				(this.xd =
					(typeof location != "undefined" &&
						e.hostname !== location.hostname) ||
					o !== e.port);
		}
		const n = e && e.forceBase64;
		(this.supportsBinary = ZD && !n),
			this.opts.withCredentials && (this.cookieJar = void 0);
	}
	get name() {
		return "polling";
	}
	doOpen() {
		this.poll();
	}
	pause(e) {
		this.readyState = "pausing";
		const n = () => {
			(this.readyState = "paused"), e();
		};
		if (this.polling || !this.writable) {
			let r = 0;
			this.polling &&
				(r++,
				this.once("pollComplete", function () {
					--r || n();
				})),
				this.writable ||
					(r++,
					this.once("drain", function () {
						--r || n();
					}));
		} else n();
	}
	poll() {
		(this.polling = !0), this.doPoll(), this.emitReserved("poll");
	}
	onData(e) {
		const n = (r) => {
			if (
				(this.readyState === "opening" &&
					r.type === "open" &&
					this.onOpen(),
				r.type === "close")
			)
				return (
					this.onClose({
						description: "transport closed by the server",
					}),
					!1
				);
			this.onPacket(r);
		};
		$D(e, this.socket.binaryType).forEach(n),
			this.readyState !== "closed" &&
				((this.polling = !1),
				this.emitReserved("pollComplete"),
				this.readyState === "open" && this.poll());
	}
	doClose() {
		const e = () => {
			this.write([{ type: "close" }]);
		};
		this.readyState === "open" ? e() : this.once("open", e);
	}
	write(e) {
		(this.writable = !1),
			LD(e, (n) => {
				this.doWrite(n, () => {
					(this.writable = !0), this.emitReserved("drain");
				});
			});
	}
	uri() {
		const e = this.opts.secure ? "https" : "http",
			n = this.query || {};
		return (
			this.opts.timestampRequests !== !1 &&
				(n[this.opts.timestampParam] = G2()),
			!this.supportsBinary && !n.sid && (n.b64 = 1),
			this.createUri(e, n)
		);
	}
	request(e = {}) {
		return (
			Object.assign(
				e,
				{ xd: this.xd, cookieJar: this.cookieJar },
				this.opts
			),
			new or(this.uri(), e)
		);
	}
	doWrite(e, n) {
		const r = this.request({ method: "POST", data: e });
		r.on("success", n),
			r.on("error", (o, i) => {
				this.onError("xhr post error", o, i);
			});
	}
	doPoll() {
		const e = this.request();
		e.on("data", this.onData.bind(this)),
			e.on("error", (n, r) => {
				this.onError("xhr poll error", n, r);
			}),
			(this.pollXhr = e);
	}
}
class or extends Et {
	constructor(e, n) {
		super(),
			Gu(this, n),
			(this.opts = n),
			(this.method = n.method || "GET"),
			(this.uri = e),
			(this.data = n.data !== void 0 ? n.data : null),
			this.create();
	}
	create() {
		var e;
		const n = q2(
			this.opts,
			"agent",
			"pfx",
			"key",
			"passphrase",
			"cert",
			"ca",
			"ciphers",
			"rejectUnauthorized",
			"autoUnref"
		);
		n.xdomain = !!this.opts.xd;
		const r = (this.xhr = new Q2(n));
		try {
			r.open(this.method, this.uri, !0);
			try {
				if (this.opts.extraHeaders) {
					r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
					for (let o in this.opts.extraHeaders)
						this.opts.extraHeaders.hasOwnProperty(o) &&
							r.setRequestHeader(o, this.opts.extraHeaders[o]);
				}
			} catch (o) {}
			if (this.method === "POST")
				try {
					r.setRequestHeader(
						"Content-type",
						"text/plain;charset=UTF-8"
					);
				} catch (o) {}
			try {
				r.setRequestHeader("Accept", "*/*");
			} catch (o) {}
			(e = this.opts.cookieJar) === null ||
				e === void 0 ||
				e.addCookies(r),
				"withCredentials" in r &&
					(r.withCredentials = this.opts.withCredentials),
				this.opts.requestTimeout &&
					(r.timeout = this.opts.requestTimeout),
				(r.onreadystatechange = () => {
					var o;
					r.readyState === 3 &&
						((o = this.opts.cookieJar) === null ||
							o === void 0 ||
							o.parseCookies(r)),
						r.readyState === 4 &&
							(r.status === 200 || r.status === 1223
								? this.onLoad()
								: this.setTimeoutFn(() => {
										this.onError(
											typeof r.status == "number"
												? r.status
												: 0
										);
								  }, 0));
				}),
				r.send(this.data);
		} catch (o) {
			this.setTimeoutFn(() => {
				this.onError(o);
			}, 0);
			return;
		}
		typeof document != "undefined" &&
			((this.index = or.requestsCount++),
			(or.requests[this.index] = this));
	}
	onError(e) {
		this.emitReserved("error", e, this.xhr), this.cleanup(!0);
	}
	cleanup(e) {
		if (!(typeof this.xhr == "undefined" || this.xhr === null)) {
			if (((this.xhr.onreadystatechange = XD), e))
				try {
					this.xhr.abort();
				} catch (n) {}
			typeof document != "undefined" && delete or.requests[this.index],
				(this.xhr = null);
		}
	}
	onLoad() {
		const e = this.xhr.responseText;
		e !== null &&
			(this.emitReserved("data", e),
			this.emitReserved("success"),
			this.cleanup());
	}
	abort() {
		this.cleanup();
	}
}
or.requestsCount = 0;
or.requests = {};
if (typeof document != "undefined") {
	if (typeof attachEvent == "function") attachEvent("onunload", p1);
	else if (typeof addEventListener == "function") {
		const t = "onpagehide" in _n ? "pagehide" : "unload";
		addEventListener(t, p1, !1);
	}
}
function p1() {
	for (let t in or.requests)
		or.requests.hasOwnProperty(t) && or.requests[t].abort();
}
const Vh =
		typeof Promise == "function" && typeof Promise.resolve == "function"
			? (e) => Promise.resolve().then(e)
			: (e, n) => n(e, 0),
	Bl = _n.WebSocket || _n.MozWebSocket,
	m1 = !0,
	tj = "arraybuffer",
	g1 =
		typeof navigator != "undefined" &&
		typeof navigator.product == "string" &&
		navigator.product.toLowerCase() === "reactnative";
class nj extends Fh {
	constructor(e) {
		super(e), (this.supportsBinary = !e.forceBase64);
	}
	get name() {
		return "websocket";
	}
	doOpen() {
		if (!this.check()) return;
		const e = this.uri(),
			n = this.opts.protocols,
			r = g1
				? {}
				: q2(
						this.opts,
						"agent",
						"perMessageDeflate",
						"pfx",
						"key",
						"passphrase",
						"cert",
						"ca",
						"ciphers",
						"rejectUnauthorized",
						"localAddress",
						"protocolVersion",
						"origin",
						"maxPayload",
						"family",
						"checkServerIdentity"
				  );
		this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
		try {
			this.ws =
				m1 && !g1 ? (n ? new Bl(e, n) : new Bl(e)) : new Bl(e, n, r);
		} catch (o) {
			return this.emitReserved("error", o);
		}
		(this.ws.binaryType = this.socket.binaryType), this.addEventListeners();
	}
	addEventListeners() {
		(this.ws.onopen = () => {
			this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
		}),
			(this.ws.onclose = (e) =>
				this.onClose({
					description: "websocket connection closed",
					context: e,
				})),
			(this.ws.onmessage = (e) => this.onData(e.data)),
			(this.ws.onerror = (e) => this.onError("websocket error", e));
	}
	write(e) {
		this.writable = !1;
		for (let n = 0; n < e.length; n++) {
			const r = e[n],
				o = n === e.length - 1;
			zh(r, this.supportsBinary, (i) => {
				const s = {};
				try {
					m1 && this.ws.send(i);
				} catch (l) {}
				o &&
					Vh(() => {
						(this.writable = !0), this.emitReserved("drain");
					}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		typeof this.ws != "undefined" && (this.ws.close(), (this.ws = null));
	}
	uri() {
		const e = this.opts.secure ? "wss" : "ws",
			n = this.query || {};
		return (
			this.opts.timestampRequests && (n[this.opts.timestampParam] = G2()),
			this.supportsBinary || (n.b64 = 1),
			this.createUri(e, n)
		);
	}
	check() {
		return !!Bl;
	}
}
class rj extends Fh {
	get name() {
		return "webtransport";
	}
	doOpen() {
		typeof WebTransport == "function" &&
			((this.transport = new WebTransport(
				this.createUri("https"),
				this.opts.transportOptions[this.name]
			)),
			this.transport.closed
				.then(() => {
					this.onClose();
				})
				.catch((e) => {
					this.onError("webtransport error", e);
				}),
			this.transport.ready.then(() => {
				this.transport.createBidirectionalStream().then((e) => {
					const n = zD(
							Number.MAX_SAFE_INTEGER,
							this.socket.binaryType
						),
						r = e.readable.pipeThrough(n).getReader(),
						o = BD();
					o.readable.pipeTo(e.writable),
						(this.writer = o.writable.getWriter());
					const i = () => {
						r.read()
							.then(({ done: l, value: a }) => {
								l || (this.onPacket(a), i());
							})
							.catch((l) => {});
					};
					i();
					const s = { type: "open" };
					this.query.sid && (s.data = `{"sid":"${this.query.sid}"}`),
						this.writer.write(s).then(() => this.onOpen());
				});
			}));
	}
	write(e) {
		this.writable = !1;
		for (let n = 0; n < e.length; n++) {
			const r = e[n],
				o = n === e.length - 1;
			this.writer.write(r).then(() => {
				o &&
					Vh(() => {
						(this.writable = !0), this.emitReserved("drain");
					}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		var e;
		(e = this.transport) === null || e === void 0 || e.close();
	}
}
const oj = { websocket: nj, webtransport: rj, polling: ej },
	ij =
		/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
	sj = [
		"source",
		"protocol",
		"authority",
		"userInfo",
		"user",
		"password",
		"host",
		"port",
		"relative",
		"path",
		"directory",
		"file",
		"query",
		"anchor",
	];
function df(t) {
	if (t.length > 2e3) throw "URI too long";
	const e = t,
		n = t.indexOf("["),
		r = t.indexOf("]");
	n != -1 &&
		r != -1 &&
		(t =
			t.substring(0, n) +
			t.substring(n, r).replace(/:/g, ";") +
			t.substring(r, t.length));
	let o = ij.exec(t || ""),
		i = {},
		s = 14;
	for (; s--; ) i[sj[s]] = o[s] || "";
	return (
		n != -1 &&
			r != -1 &&
			((i.source = e),
			(i.host = i.host
				.substring(1, i.host.length - 1)
				.replace(/;/g, ":")),
			(i.authority = i.authority
				.replace("[", "")
				.replace("]", "")
				.replace(/;/g, ":")),
			(i.ipv6uri = !0)),
		(i.pathNames = lj(i, i.path)),
		(i.queryKey = aj(i, i.query)),
		i
	);
}
function lj(t, e) {
	const n = /\/{2,9}/g,
		r = e.replace(n, "/").split("/");
	return (
		(e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1),
		e.slice(-1) == "/" && r.splice(r.length - 1, 1),
		r
	);
}
function aj(t, e) {
	const n = {};
	return (
		e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, o, i) {
			o && (n[o] = i);
		}),
		n
	);
}
let X2 = class ii extends Et {
	constructor(e, n = {}) {
		super(),
			(this.binaryType = tj),
			(this.writeBuffer = []),
			e && typeof e == "object" && ((n = e), (e = null)),
			e
				? ((e = df(e)),
				  (n.hostname = e.host),
				  (n.secure = e.protocol === "https" || e.protocol === "wss"),
				  (n.port = e.port),
				  e.query && (n.query = e.query))
				: n.host && (n.hostname = df(n.host).host),
			Gu(this, n),
			(this.secure =
				n.secure != null
					? n.secure
					: typeof location != "undefined" &&
					  location.protocol === "https:"),
			n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
			(this.hostname =
				n.hostname ||
				(typeof location != "undefined"
					? location.hostname
					: "localhost")),
			(this.port =
				n.port ||
				(typeof location != "undefined" && location.port
					? location.port
					: this.secure
					? "443"
					: "80")),
			(this.transports = n.transports || [
				"polling",
				"websocket",
				"webtransport",
			]),
			(this.writeBuffer = []),
			(this.prevBufferLen = 0),
			(this.opts = Object.assign(
				{
					path: "/engine.io",
					agent: !1,
					withCredentials: !1,
					upgrade: !0,
					timestampParam: "t",
					rememberUpgrade: !1,
					addTrailingSlash: !0,
					rejectUnauthorized: !0,
					perMessageDeflate: { threshold: 1024 },
					transportOptions: {},
					closeOnBeforeunload: !1,
				},
				n
			)),
			(this.opts.path =
				this.opts.path.replace(/\/$/, "") +
				(this.opts.addTrailingSlash ? "/" : "")),
			typeof this.opts.query == "string" &&
				(this.opts.query = JD(this.opts.query)),
			(this.id = null),
			(this.upgrades = null),
			(this.pingInterval = null),
			(this.pingTimeout = null),
			(this.pingTimeoutTimer = null),
			typeof addEventListener == "function" &&
				(this.opts.closeOnBeforeunload &&
					((this.beforeunloadEventListener = () => {
						this.transport &&
							(this.transport.removeAllListeners(),
							this.transport.close());
					}),
					addEventListener(
						"beforeunload",
						this.beforeunloadEventListener,
						!1
					)),
				this.hostname !== "localhost" &&
					((this.offlineEventListener = () => {
						this.onClose("transport close", {
							description: "network connection lost",
						});
					}),
					addEventListener(
						"offline",
						this.offlineEventListener,
						!1
					))),
			this.open();
	}
	createTransport(e) {
		const n = Object.assign({}, this.opts.query);
		(n.EIO = K2), (n.transport = e), this.id && (n.sid = this.id);
		const r = Object.assign(
			{},
			this.opts,
			{
				query: n,
				socket: this,
				hostname: this.hostname,
				secure: this.secure,
				port: this.port,
			},
			this.opts.transportOptions[e]
		);
		return new oj[e](r);
	}
	open() {
		let e;
		if (
			this.opts.rememberUpgrade &&
			ii.priorWebsocketSuccess &&
			this.transports.indexOf("websocket") !== -1
		)
			e = "websocket";
		else if (this.transports.length === 0) {
			this.setTimeoutFn(() => {
				this.emitReserved("error", "No transports available");
			}, 0);
			return;
		} else e = this.transports[0];
		this.readyState = "opening";
		try {
			e = this.createTransport(e);
		} catch (n) {
			this.transports.shift(), this.open();
			return;
		}
		e.open(), this.setTransport(e);
	}
	setTransport(e) {
		this.transport && this.transport.removeAllListeners(),
			(this.transport = e),
			e
				.on("drain", this.onDrain.bind(this))
				.on("packet", this.onPacket.bind(this))
				.on("error", this.onError.bind(this))
				.on("close", (n) => this.onClose("transport close", n));
	}
	probe(e) {
		let n = this.createTransport(e),
			r = !1;
		ii.priorWebsocketSuccess = !1;
		const o = () => {
			r ||
				(n.send([{ type: "ping", data: "probe" }]),
				n.once("packet", (d) => {
					if (!r)
						if (d.type === "pong" && d.data === "probe") {
							if (
								((this.upgrading = !0),
								this.emitReserved("upgrading", n),
								!n)
							)
								return;
							(ii.priorWebsocketSuccess = n.name === "websocket"),
								this.transport.pause(() => {
									r ||
										(this.readyState !== "closed" &&
											(c(),
											this.setTransport(n),
											n.send([{ type: "upgrade" }]),
											this.emitReserved("upgrade", n),
											(n = null),
											(this.upgrading = !1),
											this.flush()));
								});
						} else {
							const h = new Error("probe error");
							(h.transport = n.name),
								this.emitReserved("upgradeError", h);
						}
				}));
		};
		function i() {
			r || ((r = !0), c(), n.close(), (n = null));
		}
		const s = (d) => {
			const h = new Error("probe error: " + d);
			(h.transport = n.name), i(), this.emitReserved("upgradeError", h);
		};
		function l() {
			s("transport closed");
		}
		function a() {
			s("socket closed");
		}
		function u(d) {
			n && d.name !== n.name && i();
		}
		const c = () => {
			n.removeListener("open", o),
				n.removeListener("error", s),
				n.removeListener("close", l),
				this.off("close", a),
				this.off("upgrading", u);
		};
		n.once("open", o),
			n.once("error", s),
			n.once("close", l),
			this.once("close", a),
			this.once("upgrading", u),
			this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport"
				? this.setTimeoutFn(() => {
						r || n.open();
				  }, 200)
				: n.open();
	}
	onOpen() {
		if (
			((this.readyState = "open"),
			(ii.priorWebsocketSuccess = this.transport.name === "websocket"),
			this.emitReserved("open"),
			this.flush(),
			this.readyState === "open" && this.opts.upgrade)
		) {
			let e = 0;
			const n = this.upgrades.length;
			for (; e < n; e++) this.probe(this.upgrades[e]);
		}
	}
	onPacket(e) {
		if (
			this.readyState === "opening" ||
			this.readyState === "open" ||
			this.readyState === "closing"
		)
			switch (
				(this.emitReserved("packet", e),
				this.emitReserved("heartbeat"),
				this.resetPingTimeout(),
				e.type)
			) {
				case "open":
					this.onHandshake(JSON.parse(e.data));
					break;
				case "ping":
					this.sendPacket("pong"),
						this.emitReserved("ping"),
						this.emitReserved("pong");
					break;
				case "error":
					const n = new Error("server error");
					(n.code = e.data), this.onError(n);
					break;
				case "message":
					this.emitReserved("data", e.data),
						this.emitReserved("message", e.data);
					break;
			}
	}
	onHandshake(e) {
		this.emitReserved("handshake", e),
			(this.id = e.sid),
			(this.transport.query.sid = e.sid),
			(this.upgrades = this.filterUpgrades(e.upgrades)),
			(this.pingInterval = e.pingInterval),
			(this.pingTimeout = e.pingTimeout),
			(this.maxPayload = e.maxPayload),
			this.onOpen(),
			this.readyState !== "closed" && this.resetPingTimeout();
	}
	resetPingTimeout() {
		this.clearTimeoutFn(this.pingTimeoutTimer),
			(this.pingTimeoutTimer = this.setTimeoutFn(() => {
				this.onClose("ping timeout");
			}, this.pingInterval + this.pingTimeout)),
			this.opts.autoUnref && this.pingTimeoutTimer.unref();
	}
	onDrain() {
		this.writeBuffer.splice(0, this.prevBufferLen),
			(this.prevBufferLen = 0),
			this.writeBuffer.length === 0
				? this.emitReserved("drain")
				: this.flush();
	}
	flush() {
		if (
			this.readyState !== "closed" &&
			this.transport.writable &&
			!this.upgrading &&
			this.writeBuffer.length
		) {
			const e = this.getWritablePackets();
			this.transport.send(e),
				(this.prevBufferLen = e.length),
				this.emitReserved("flush");
		}
	}
	getWritablePackets() {
		if (
			!(
				this.maxPayload &&
				this.transport.name === "polling" &&
				this.writeBuffer.length > 1
			)
		)
			return this.writeBuffer;
		let n = 1;
		for (let r = 0; r < this.writeBuffer.length; r++) {
			const o = this.writeBuffer[r].data;
			if ((o && (n += UD(o)), r > 0 && n > this.maxPayload))
				return this.writeBuffer.slice(0, r);
			n += 2;
		}
		return this.writeBuffer;
	}
	write(e, n, r) {
		return this.sendPacket("message", e, n, r), this;
	}
	send(e, n, r) {
		return this.sendPacket("message", e, n, r), this;
	}
	sendPacket(e, n, r, o) {
		if (
			(typeof n == "function" && ((o = n), (n = void 0)),
			typeof r == "function" && ((o = r), (r = null)),
			this.readyState === "closing" || this.readyState === "closed")
		)
			return;
		(r = r || {}), (r.compress = r.compress !== !1);
		const i = { type: e, data: n, options: r };
		this.emitReserved("packetCreate", i),
			this.writeBuffer.push(i),
			o && this.once("flush", o),
			this.flush();
	}
	close() {
		const e = () => {
				this.onClose("forced close"), this.transport.close();
			},
			n = () => {
				this.off("upgrade", n), this.off("upgradeError", n), e();
			},
			r = () => {
				this.once("upgrade", n), this.once("upgradeError", n);
			};
		return (
			(this.readyState === "opening" || this.readyState === "open") &&
				((this.readyState = "closing"),
				this.writeBuffer.length
					? this.once("drain", () => {
							this.upgrading ? r() : e();
					  })
					: this.upgrading
					? r()
					: e()),
			this
		);
	}
	onError(e) {
		(ii.priorWebsocketSuccess = !1),
			this.emitReserved("error", e),
			this.onClose("transport error", e);
	}
	onClose(e, n) {
		(this.readyState === "opening" ||
			this.readyState === "open" ||
			this.readyState === "closing") &&
			(this.clearTimeoutFn(this.pingTimeoutTimer),
			this.transport.removeAllListeners("close"),
			this.transport.close(),
			this.transport.removeAllListeners(),
			typeof removeEventListener == "function" &&
				(removeEventListener(
					"beforeunload",
					this.beforeunloadEventListener,
					!1
				),
				removeEventListener("offline", this.offlineEventListener, !1)),
			(this.readyState = "closed"),
			(this.id = null),
			this.emitReserved("close", e, n),
			(this.writeBuffer = []),
			(this.prevBufferLen = 0));
	}
	filterUpgrades(e) {
		const n = [];
		let r = 0;
		const o = e.length;
		for (; r < o; r++) ~this.transports.indexOf(e[r]) && n.push(e[r]);
		return n;
	}
};
X2.protocol = K2;
function uj(t, e = "", n) {
	let r = t;
	(n = n || (typeof location != "undefined" && location)),
		t == null && (t = n.protocol + "//" + n.host),
		typeof t == "string" &&
			(t.charAt(0) === "/" &&
				(t.charAt(1) === "/" ? (t = n.protocol + t) : (t = n.host + t)),
			/^(https?|wss?):\/\//.test(t) ||
				(typeof n != "undefined"
					? (t = n.protocol + "//" + t)
					: (t = "https://" + t)),
			(r = df(t))),
		r.port ||
			(/^(http|ws)$/.test(r.protocol)
				? (r.port = "80")
				: /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
		(r.path = r.path || "/");
	const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
	return (
		(r.id = r.protocol + "://" + i + ":" + r.port + e),
		(r.href =
			r.protocol +
			"://" +
			i +
			(n && n.port === r.port ? "" : ":" + r.port)),
		r
	);
}
const cj = typeof ArrayBuffer == "function",
	dj = (t) =>
		typeof ArrayBuffer.isView == "function"
			? ArrayBuffer.isView(t)
			: t.buffer instanceof ArrayBuffer,
	Z2 = Object.prototype.toString,
	fj =
		typeof Blob == "function" ||
		(typeof Blob != "undefined" &&
			Z2.call(Blob) === "[object BlobConstructor]"),
	hj =
		typeof File == "function" ||
		(typeof File != "undefined" &&
			Z2.call(File) === "[object FileConstructor]");
function Wh(t) {
	return (
		(cj && (t instanceof ArrayBuffer || dj(t))) ||
		(fj && t instanceof Blob) ||
		(hj && t instanceof File)
	);
}
function ta(t, e) {
	if (!t || typeof t != "object") return !1;
	if (Array.isArray(t)) {
		for (let n = 0, r = t.length; n < r; n++) if (ta(t[n])) return !0;
		return !1;
	}
	if (Wh(t)) return !0;
	if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
		return ta(t.toJSON(), !0);
	for (const n in t)
		if (Object.prototype.hasOwnProperty.call(t, n) && ta(t[n])) return !0;
	return !1;
}
function pj(t) {
	const e = [],
		n = t.data,
		r = t;
	return (
		(r.data = ff(n, e)),
		(r.attachments = e.length),
		{ packet: r, buffers: e }
	);
}
function ff(t, e) {
	if (!t) return t;
	if (Wh(t)) {
		const n = { _placeholder: !0, num: e.length };
		return e.push(t), n;
	} else if (Array.isArray(t)) {
		const n = new Array(t.length);
		for (let r = 0; r < t.length; r++) n[r] = ff(t[r], e);
		return n;
	} else if (typeof t == "object" && !(t instanceof Date)) {
		const n = {};
		for (const r in t)
			Object.prototype.hasOwnProperty.call(t, r) && (n[r] = ff(t[r], e));
		return n;
	}
	return t;
}
function mj(t, e) {
	return (t.data = hf(t.data, e)), delete t.attachments, t;
}
function hf(t, e) {
	if (!t) return t;
	if (t && t._placeholder === !0) {
		if (typeof t.num == "number" && t.num >= 0 && t.num < e.length)
			return e[t.num];
		throw new Error("illegal attachments");
	} else if (Array.isArray(t))
		for (let n = 0; n < t.length; n++) t[n] = hf(t[n], e);
	else if (typeof t == "object")
		for (const n in t)
			Object.prototype.hasOwnProperty.call(t, n) && (t[n] = hf(t[n], e));
	return t;
}
const gj = [
		"connect",
		"connect_error",
		"disconnect",
		"disconnecting",
		"newListener",
		"removeListener",
	],
	yj = 5;
var Ke;
(function (t) {
	(t[(t.CONNECT = 0)] = "CONNECT"),
		(t[(t.DISCONNECT = 1)] = "DISCONNECT"),
		(t[(t.EVENT = 2)] = "EVENT"),
		(t[(t.ACK = 3)] = "ACK"),
		(t[(t.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
		(t[(t.BINARY_EVENT = 5)] = "BINARY_EVENT"),
		(t[(t.BINARY_ACK = 6)] = "BINARY_ACK");
})(Ke || (Ke = {}));
class vj {
	constructor(e) {
		this.replacer = e;
	}
	encode(e) {
		return (e.type === Ke.EVENT || e.type === Ke.ACK) && ta(e)
			? this.encodeAsBinary({
					type: e.type === Ke.EVENT ? Ke.BINARY_EVENT : Ke.BINARY_ACK,
					nsp: e.nsp,
					data: e.data,
					id: e.id,
			  })
			: [this.encodeAsString(e)];
	}
	encodeAsString(e) {
		let n = "" + e.type;
		return (
			(e.type === Ke.BINARY_EVENT || e.type === Ke.BINARY_ACK) &&
				(n += e.attachments + "-"),
			e.nsp && e.nsp !== "/" && (n += e.nsp + ","),
			e.id != null && (n += e.id),
			e.data != null && (n += JSON.stringify(e.data, this.replacer)),
			n
		);
	}
	encodeAsBinary(e) {
		const n = pj(e),
			r = this.encodeAsString(n.packet),
			o = n.buffers;
		return o.unshift(r), o;
	}
}
function y1(t) {
	return Object.prototype.toString.call(t) === "[object Object]";
}
class Uh extends Et {
	constructor(e) {
		super(), (this.reviver = e);
	}
	add(e) {
		let n;
		if (typeof e == "string") {
			if (this.reconstructor)
				throw new Error(
					"got plaintext data when reconstructing a packet"
				);
			n = this.decodeString(e);
			const r = n.type === Ke.BINARY_EVENT;
			r || n.type === Ke.BINARY_ACK
				? ((n.type = r ? Ke.EVENT : Ke.ACK),
				  (this.reconstructor = new bj(n)),
				  n.attachments === 0 && super.emitReserved("decoded", n))
				: super.emitReserved("decoded", n);
		} else if (Wh(e) || e.base64)
			if (this.reconstructor)
				(n = this.reconstructor.takeBinaryData(e)),
					n &&
						((this.reconstructor = null),
						super.emitReserved("decoded", n));
			else
				throw new Error(
					"got binary data when not reconstructing a packet"
				);
		else throw new Error("Unknown type: " + e);
	}
	decodeString(e) {
		let n = 0;
		const r = { type: Number(e.charAt(0)) };
		if (Ke[r.type] === void 0)
			throw new Error("unknown packet type " + r.type);
		if (r.type === Ke.BINARY_EVENT || r.type === Ke.BINARY_ACK) {
			const i = n + 1;
			for (; e.charAt(++n) !== "-" && n != e.length; );
			const s = e.substring(i, n);
			if (s != Number(s) || e.charAt(n) !== "-")
				throw new Error("Illegal attachments");
			r.attachments = Number(s);
		}
		if (e.charAt(n + 1) === "/") {
			const i = n + 1;
			for (; ++n && !(e.charAt(n) === "," || n === e.length); );
			r.nsp = e.substring(i, n);
		} else r.nsp = "/";
		const o = e.charAt(n + 1);
		if (o !== "" && Number(o) == o) {
			const i = n + 1;
			for (; ++n; ) {
				const s = e.charAt(n);
				if (s == null || Number(s) != s) {
					--n;
					break;
				}
				if (n === e.length) break;
			}
			r.id = Number(e.substring(i, n + 1));
		}
		if (e.charAt(++n)) {
			const i = this.tryParse(e.substr(n));
			if (Uh.isPayloadValid(r.type, i)) r.data = i;
			else throw new Error("invalid payload");
		}
		return r;
	}
	tryParse(e) {
		try {
			return JSON.parse(e, this.reviver);
		} catch (n) {
			return !1;
		}
	}
	static isPayloadValid(e, n) {
		switch (e) {
			case Ke.CONNECT:
				return y1(n);
			case Ke.DISCONNECT:
				return n === void 0;
			case Ke.CONNECT_ERROR:
				return typeof n == "string" || y1(n);
			case Ke.EVENT:
			case Ke.BINARY_EVENT:
				return (
					Array.isArray(n) &&
					(typeof n[0] == "number" ||
						(typeof n[0] == "string" && gj.indexOf(n[0]) === -1))
				);
			case Ke.ACK:
			case Ke.BINARY_ACK:
				return Array.isArray(n);
		}
	}
	destroy() {
		this.reconstructor &&
			(this.reconstructor.finishedReconstruction(),
			(this.reconstructor = null));
	}
}
class bj {
	constructor(e) {
		(this.packet = e), (this.buffers = []), (this.reconPack = e);
	}
	takeBinaryData(e) {
		if (
			(this.buffers.push(e),
			this.buffers.length === this.reconPack.attachments)
		) {
			const n = mj(this.reconPack, this.buffers);
			return this.finishedReconstruction(), n;
		}
		return null;
	}
	finishedReconstruction() {
		(this.reconPack = null), (this.buffers = []);
	}
}
const wj = Object.freeze(
	Object.defineProperty(
		{
			__proto__: null,
			Decoder: Uh,
			Encoder: vj,
			get PacketType() {
				return Ke;
			},
			protocol: yj,
		},
		Symbol.toStringTag,
		{ value: "Module" }
	)
);
function In(t, e, n) {
	return (
		t.on(e, n),
		function () {
			t.off(e, n);
		}
	);
}
const xj = Object.freeze({
	connect: 1,
	connect_error: 1,
	disconnect: 1,
	disconnecting: 1,
	newListener: 1,
	removeListener: 1,
});
class eb extends Et {
	constructor(e, n, r) {
		super(),
			(this.connected = !1),
			(this.recovered = !1),
			(this.receiveBuffer = []),
			(this.sendBuffer = []),
			(this._queue = []),
			(this._queueSeq = 0),
			(this.ids = 0),
			(this.acks = {}),
			(this.flags = {}),
			(this.io = e),
			(this.nsp = n),
			r && r.auth && (this.auth = r.auth),
			(this._opts = Object.assign({}, r)),
			this.io._autoConnect && this.open();
	}
	get disconnected() {
		return !this.connected;
	}
	subEvents() {
		if (this.subs) return;
		const e = this.io;
		this.subs = [
			In(e, "open", this.onopen.bind(this)),
			In(e, "packet", this.onpacket.bind(this)),
			In(e, "error", this.onerror.bind(this)),
			In(e, "close", this.onclose.bind(this)),
		];
	}
	get active() {
		return !!this.subs;
	}
	connect() {
		return this.connected
			? this
			: (this.subEvents(),
			  this.io._reconnecting || this.io.open(),
			  this.io._readyState === "open" && this.onopen(),
			  this);
	}
	open() {
		return this.connect();
	}
	send(...e) {
		return e.unshift("message"), this.emit.apply(this, e), this;
	}
	emit(e, ...n) {
		if (xj.hasOwnProperty(e))
			throw new Error('"' + e.toString() + '" is a reserved event name');
		if (
			(n.unshift(e),
			this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
		)
			return this._addToQueue(n), this;
		const r = { type: Ke.EVENT, data: n };
		if (
			((r.options = {}),
			(r.options.compress = this.flags.compress !== !1),
			typeof n[n.length - 1] == "function")
		) {
			const s = this.ids++,
				l = n.pop();
			this._registerAckCallback(s, l), (r.id = s);
		}
		const o =
			this.io.engine &&
			this.io.engine.transport &&
			this.io.engine.transport.writable;
		return (
			(this.flags.volatile && (!o || !this.connected)) ||
				(this.connected
					? (this.notifyOutgoingListeners(r), this.packet(r))
					: this.sendBuffer.push(r)),
			(this.flags = {}),
			this
		);
	}
	_registerAckCallback(e, n) {
		var r;
		const o =
			(r = this.flags.timeout) !== null && r !== void 0
				? r
				: this._opts.ackTimeout;
		if (o === void 0) {
			this.acks[e] = n;
			return;
		}
		const i = this.io.setTimeoutFn(() => {
			delete this.acks[e];
			for (let s = 0; s < this.sendBuffer.length; s++)
				this.sendBuffer[s].id === e && this.sendBuffer.splice(s, 1);
			n.call(this, new Error("operation has timed out"));
		}, o);
		this.acks[e] = (...s) => {
			this.io.clearTimeoutFn(i), n.apply(this, [null, ...s]);
		};
	}
	emitWithAck(e, ...n) {
		const r =
			this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
		return new Promise((o, i) => {
			n.push((s, l) => (r ? (s ? i(s) : o(l)) : o(s))),
				this.emit(e, ...n);
		});
	}
	_addToQueue(e) {
		let n;
		typeof e[e.length - 1] == "function" && (n = e.pop());
		const r = {
			id: this._queueSeq++,
			tryCount: 0,
			pending: !1,
			args: e,
			flags: Object.assign({ fromQueue: !0 }, this.flags),
		};
		e.push((o, ...i) =>
			r !== this._queue[0]
				? void 0
				: (o !== null
						? r.tryCount > this._opts.retries &&
						  (this._queue.shift(), n && n(o))
						: (this._queue.shift(), n && n(null, ...i)),
				  (r.pending = !1),
				  this._drainQueue())
		),
			this._queue.push(r),
			this._drainQueue();
	}
	_drainQueue(e = !1) {
		if (!this.connected || this._queue.length === 0) return;
		const n = this._queue[0];
		(n.pending && !e) ||
			((n.pending = !0),
			n.tryCount++,
			(this.flags = n.flags),
			this.emit.apply(this, n.args));
	}
	packet(e) {
		(e.nsp = this.nsp), this.io._packet(e);
	}
	onopen() {
		typeof this.auth == "function"
			? this.auth((e) => {
					this._sendConnectPacket(e);
			  })
			: this._sendConnectPacket(this.auth);
	}
	_sendConnectPacket(e) {
		this.packet({
			type: Ke.CONNECT,
			data: this._pid
				? Object.assign({ pid: this._pid, offset: this._lastOffset }, e)
				: e,
		});
	}
	onerror(e) {
		this.connected || this.emitReserved("connect_error", e);
	}
	onclose(e, n) {
		(this.connected = !1),
			delete this.id,
			this.emitReserved("disconnect", e, n);
	}
	onpacket(e) {
		if (e.nsp === this.nsp)
			switch (e.type) {
				case Ke.CONNECT:
					e.data && e.data.sid
						? this.onconnect(e.data.sid, e.data.pid)
						: this.emitReserved(
								"connect_error",
								new Error(
									"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
								)
						  );
					break;
				case Ke.EVENT:
				case Ke.BINARY_EVENT:
					this.onevent(e);
					break;
				case Ke.ACK:
				case Ke.BINARY_ACK:
					this.onack(e);
					break;
				case Ke.DISCONNECT:
					this.ondisconnect();
					break;
				case Ke.CONNECT_ERROR:
					this.destroy();
					const r = new Error(e.data.message);
					(r.data = e.data.data),
						this.emitReserved("connect_error", r);
					break;
			}
	}
	onevent(e) {
		const n = e.data || [];
		e.id != null && n.push(this.ack(e.id)),
			this.connected
				? this.emitEvent(n)
				: this.receiveBuffer.push(Object.freeze(n));
	}
	emitEvent(e) {
		if (this._anyListeners && this._anyListeners.length) {
			const n = this._anyListeners.slice();
			for (const r of n) r.apply(this, e);
		}
		super.emit.apply(this, e),
			this._pid &&
				e.length &&
				typeof e[e.length - 1] == "string" &&
				(this._lastOffset = e[e.length - 1]);
	}
	ack(e) {
		const n = this;
		let r = !1;
		return function (...o) {
			r || ((r = !0), n.packet({ type: Ke.ACK, id: e, data: o }));
		};
	}
	onack(e) {
		const n = this.acks[e.id];
		typeof n == "function" &&
			(n.apply(this, e.data), delete this.acks[e.id]);
	}
	onconnect(e, n) {
		(this.id = e),
			(this.recovered = n && this._pid === n),
			(this._pid = n),
			(this.connected = !0),
			this.emitBuffered(),
			this.emitReserved("connect"),
			this._drainQueue(!0);
	}
	emitBuffered() {
		this.receiveBuffer.forEach((e) => this.emitEvent(e)),
			(this.receiveBuffer = []),
			this.sendBuffer.forEach((e) => {
				this.notifyOutgoingListeners(e), this.packet(e);
			}),
			(this.sendBuffer = []);
	}
	ondisconnect() {
		this.destroy(), this.onclose("io server disconnect");
	}
	destroy() {
		this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
			this.io._destroy(this);
	}
	disconnect() {
		return (
			this.connected && this.packet({ type: Ke.DISCONNECT }),
			this.destroy(),
			this.connected && this.onclose("io client disconnect"),
			this
		);
	}
	close() {
		return this.disconnect();
	}
	compress(e) {
		return (this.flags.compress = e), this;
	}
	get volatile() {
		return (this.flags.volatile = !0), this;
	}
	timeout(e) {
		return (this.flags.timeout = e), this;
	}
	onAny(e) {
		return (
			(this._anyListeners = this._anyListeners || []),
			this._anyListeners.push(e),
			this
		);
	}
	prependAny(e) {
		return (
			(this._anyListeners = this._anyListeners || []),
			this._anyListeners.unshift(e),
			this
		);
	}
	offAny(e) {
		if (!this._anyListeners) return this;
		if (e) {
			const n = this._anyListeners;
			for (let r = 0; r < n.length; r++)
				if (e === n[r]) return n.splice(r, 1), this;
		} else this._anyListeners = [];
		return this;
	}
	listenersAny() {
		return this._anyListeners || [];
	}
	onAnyOutgoing(e) {
		return (
			(this._anyOutgoingListeners = this._anyOutgoingListeners || []),
			this._anyOutgoingListeners.push(e),
			this
		);
	}
	prependAnyOutgoing(e) {
		return (
			(this._anyOutgoingListeners = this._anyOutgoingListeners || []),
			this._anyOutgoingListeners.unshift(e),
			this
		);
	}
	offAnyOutgoing(e) {
		if (!this._anyOutgoingListeners) return this;
		if (e) {
			const n = this._anyOutgoingListeners;
			for (let r = 0; r < n.length; r++)
				if (e === n[r]) return n.splice(r, 1), this;
		} else this._anyOutgoingListeners = [];
		return this;
	}
	listenersAnyOutgoing() {
		return this._anyOutgoingListeners || [];
	}
	notifyOutgoingListeners(e) {
		if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
			const n = this._anyOutgoingListeners.slice();
			for (const r of n) r.apply(this, e.data);
		}
	}
}
function zi(t) {
	(t = t || {}),
		(this.ms = t.min || 100),
		(this.max = t.max || 1e4),
		(this.factor = t.factor || 2),
		(this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
		(this.attempts = 0);
}
zi.prototype.duration = function () {
	var t = this.ms * Math.pow(this.factor, this.attempts++);
	if (this.jitter) {
		var e = Math.random(),
			n = Math.floor(e * this.jitter * t);
		t = Math.floor(e * 10) & 1 ? t + n : t - n;
	}
	return Math.min(t, this.max) | 0;
};
zi.prototype.reset = function () {
	this.attempts = 0;
};
zi.prototype.setMin = function (t) {
	this.ms = t;
};
zi.prototype.setMax = function (t) {
	this.max = t;
};
zi.prototype.setJitter = function (t) {
	this.jitter = t;
};
class pf extends Et {
	constructor(e, n) {
		var r;
		super(),
			(this.nsps = {}),
			(this.subs = []),
			e && typeof e == "object" && ((n = e), (e = void 0)),
			(n = n || {}),
			(n.path = n.path || "/socket.io"),
			(this.opts = n),
			Gu(this, n),
			this.reconnection(n.reconnection !== !1),
			this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
			this.reconnectionDelay(n.reconnectionDelay || 1e3),
			this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
			this.randomizationFactor(
				(r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5
			),
			(this.backoff = new zi({
				min: this.reconnectionDelay(),
				max: this.reconnectionDelayMax(),
				jitter: this.randomizationFactor(),
			})),
			this.timeout(n.timeout == null ? 2e4 : n.timeout),
			(this._readyState = "closed"),
			(this.uri = e);
		const o = n.parser || wj;
		(this.encoder = new o.Encoder()),
			(this.decoder = new o.Decoder()),
			(this._autoConnect = n.autoConnect !== !1),
			this._autoConnect && this.open();
	}
	reconnection(e) {
		return arguments.length
			? ((this._reconnection = !!e), this)
			: this._reconnection;
	}
	reconnectionAttempts(e) {
		return e === void 0
			? this._reconnectionAttempts
			: ((this._reconnectionAttempts = e), this);
	}
	reconnectionDelay(e) {
		var n;
		return e === void 0
			? this._reconnectionDelay
			: ((this._reconnectionDelay = e),
			  (n = this.backoff) === null || n === void 0 || n.setMin(e),
			  this);
	}
	randomizationFactor(e) {
		var n;
		return e === void 0
			? this._randomizationFactor
			: ((this._randomizationFactor = e),
			  (n = this.backoff) === null || n === void 0 || n.setJitter(e),
			  this);
	}
	reconnectionDelayMax(e) {
		var n;
		return e === void 0
			? this._reconnectionDelayMax
			: ((this._reconnectionDelayMax = e),
			  (n = this.backoff) === null || n === void 0 || n.setMax(e),
			  this);
	}
	timeout(e) {
		return arguments.length ? ((this._timeout = e), this) : this._timeout;
	}
	maybeReconnectOnOpen() {
		!this._reconnecting &&
			this._reconnection &&
			this.backoff.attempts === 0 &&
			this.reconnect();
	}
	open(e) {
		if (~this._readyState.indexOf("open")) return this;
		this.engine = new X2(this.uri, this.opts);
		const n = this.engine,
			r = this;
		(this._readyState = "opening"), (this.skipReconnect = !1);
		const o = In(n, "open", function () {
				r.onopen(), e && e();
			}),
			i = (l) => {
				this.cleanup(),
					(this._readyState = "closed"),
					this.emitReserved("error", l),
					e ? e(l) : this.maybeReconnectOnOpen();
			},
			s = In(n, "error", i);
		if (this._timeout !== !1) {
			const l = this._timeout,
				a = this.setTimeoutFn(() => {
					o(), i(new Error("timeout")), n.close();
				}, l);
			this.opts.autoUnref && a.unref(),
				this.subs.push(() => {
					this.clearTimeoutFn(a);
				});
		}
		return this.subs.push(o), this.subs.push(s), this;
	}
	connect(e) {
		return this.open(e);
	}
	onopen() {
		this.cleanup(), (this._readyState = "open"), this.emitReserved("open");
		const e = this.engine;
		this.subs.push(
			In(e, "ping", this.onping.bind(this)),
			In(e, "data", this.ondata.bind(this)),
			In(e, "error", this.onerror.bind(this)),
			In(e, "close", this.onclose.bind(this)),
			In(this.decoder, "decoded", this.ondecoded.bind(this))
		);
	}
	onping() {
		this.emitReserved("ping");
	}
	ondata(e) {
		try {
			this.decoder.add(e);
		} catch (n) {
			this.onclose("parse error", n);
		}
	}
	ondecoded(e) {
		Vh(() => {
			this.emitReserved("packet", e);
		}, this.setTimeoutFn);
	}
	onerror(e) {
		this.emitReserved("error", e);
	}
	socket(e, n) {
		let r = this.nsps[e];
		return (
			r
				? this._autoConnect && !r.active && r.connect()
				: ((r = new eb(this, e, n)), (this.nsps[e] = r)),
			r
		);
	}
	_destroy(e) {
		const n = Object.keys(this.nsps);
		for (const r of n) if (this.nsps[r].active) return;
		this._close();
	}
	_packet(e) {
		const n = this.encoder.encode(e);
		for (let r = 0; r < n.length; r++) this.engine.write(n[r], e.options);
	}
	cleanup() {
		this.subs.forEach((e) => e()),
			(this.subs.length = 0),
			this.decoder.destroy();
	}
	_close() {
		(this.skipReconnect = !0),
			(this._reconnecting = !1),
			this.onclose("forced close"),
			this.engine && this.engine.close();
	}
	disconnect() {
		return this._close();
	}
	onclose(e, n) {
		this.cleanup(),
			this.backoff.reset(),
			(this._readyState = "closed"),
			this.emitReserved("close", e, n),
			this._reconnection && !this.skipReconnect && this.reconnect();
	}
	reconnect() {
		if (this._reconnecting || this.skipReconnect) return this;
		const e = this;
		if (this.backoff.attempts >= this._reconnectionAttempts)
			this.backoff.reset(),
				this.emitReserved("reconnect_failed"),
				(this._reconnecting = !1);
		else {
			const n = this.backoff.duration();
			this._reconnecting = !0;
			const r = this.setTimeoutFn(() => {
				e.skipReconnect ||
					(this.emitReserved("reconnect_attempt", e.backoff.attempts),
					!e.skipReconnect &&
						e.open((o) => {
							o
								? ((e._reconnecting = !1),
								  e.reconnect(),
								  this.emitReserved("reconnect_error", o))
								: e.onreconnect();
						}));
			}, n);
			this.opts.autoUnref && r.unref(),
				this.subs.push(() => {
					this.clearTimeoutFn(r);
				});
		}
	}
	onreconnect() {
		const e = this.backoff.attempts;
		(this._reconnecting = !1),
			this.backoff.reset(),
			this.emitReserved("reconnect", e);
	}
}
const Ji = {};
function na(t, e) {
	typeof t == "object" && ((e = t), (t = void 0)), (e = e || {});
	const n = uj(t, e.path || "/socket.io"),
		r = n.source,
		o = n.id,
		i = n.path,
		s = Ji[o] && i in Ji[o].nsps,
		l = e.forceNew || e["force new connection"] || e.multiplex === !1 || s;
	let a;
	return (
		l ? (a = new pf(r, e)) : (Ji[o] || (Ji[o] = new pf(r, e)), (a = Ji[o])),
		n.query && !e.query && (e.query = n.queryKey),
		a.socket(n.path, e)
	);
}
Object.assign(na, { Manager: pf, Socket: eb, io: na, connect: na });
function kj(t = {}) {
	let e = window.location.hostname,
		n = t.port || 9e3,
		r = window.location.port ? `:${n}` : "",
		i = `${r ? "http" : "https"}://${e}${r}`;
	return na(i, { withCredentials: !0 });
}
let Sj = { resources: !0, call: !0, socketio: !0 };
const mL = {
	install(t, e = {}) {
		if (
			((e = Object.assign({}, Sj, e)),
			e.resources && t.use(PD, e.resources),
			e.call)
		) {
			let n = typeof e.call == "function" ? e.call : pD;
			t.config.globalProperties.$call = n;
		}
		e.socketio && (t.config.globalProperties.$socket = kj(e.socketio));
	},
};
export {
	MD as $,
	Fe as A,
	He as B,
	we as C,
	eL as D,
	tL as E,
	be as F,
	ue as G,
	Qe as H,
	Ve as I,
	U as J,
	o_ as K,
	F0 as L,
	zn as M,
	De as N,
	dL as O,
	Qj as P,
	Ne as Q,
	Pt as R,
	Yj as S,
	KN as T,
	_r as U,
	ao as V,
	nt as W,
	cL as X,
	na as Y,
	SD as Z,
	gl as _,
	qe as a,
	Ij as a0,
	mL as a1,
	fL as a2,
	hL as a3,
	pL as a4,
	CD as a5,
	Xj as a6,
	Os as a7,
	Jj as a8,
	iL as a9,
	l0 as aA,
	Ru as aB,
	en as aC,
	Ut as aD,
	zj as aE,
	Hj as aF,
	Fj as aG,
	E0 as aH,
	e0 as aI,
	Bj as aJ,
	Gj as aK,
	Ej as aL,
	Pj as aM,
	Yg as aN,
	nL as aO,
	Tj as aa,
	Rj as ab,
	oL as ac,
	AD as ad,
	uL as ae,
	dw as af,
	jj as ag,
	Wj as ah,
	Uj as ai,
	Vj as aj,
	rL as ak,
	Zj as al,
	S_ as am,
	HN as an,
	zN as ao,
	XN as ap,
	YN as aq,
	JN as ar,
	qj as as,
	oD as at,
	aL as au,
	Ht as av,
	Ry as aw,
	Kj as ax,
	Py as ay,
	Rf as az,
	Gt as b,
	qt as c,
	di as d,
	Cj as e,
	Mj as f,
	C1 as g,
	Aj as h,
	Lj as i,
	H as j,
	mn as k,
	Dj as l,
	hu as m,
	zt as n,
	M1 as o,
	Nj as p,
	Ue as q,
	X as r,
	Xe as s,
	Oe as t,
	Dt as u,
	je as v,
	it as w,
	j as x,
	q as y,
	Oj as z,
};
function __vite__mapDeps(indexes) {
	if (!__vite__mapDeps.viteFileDeps) {
		__vite__mapDeps.viteFileDeps = [];
	}
	return indexes.map((i) => __vite__mapDeps.viteFileDeps[i]);
}
//# sourceMappingURL=frappe-ui-iPT8hMkb.js.map
