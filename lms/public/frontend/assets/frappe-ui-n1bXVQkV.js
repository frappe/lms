var mb = Object.defineProperty,
	gb = Object.defineProperties;
var yb = Object.getOwnPropertyDescriptors;
var ul = Object.getOwnPropertySymbols;
var tp = Object.prototype.hasOwnProperty,
	np = Object.prototype.propertyIsEnumerable;
var ic = (t, e, n) =>
		e in t
			? mb(t, e, {
					enumerable: !0,
					configurable: !0,
					writable: !0,
					value: n,
			  })
			: (t[e] = n),
	B = (t, e) => {
		for (var n in e || (e = {})) tp.call(e, n) && ic(t, n, e[n]);
		if (ul) for (var n of ul(e)) np.call(e, n) && ic(t, n, e[n]);
		return t;
	},
	ge = (t, e) => gb(t, yb(e));
var tt = (t, e) => {
	var n = {};
	for (var r in t) tp.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
	if (t != null && ul)
		for (var r of ul(t)) e.indexOf(r) < 0 && np.call(t, r) && (n[r] = t[r]);
	return n;
};
var sc = (t, e, n) => (ic(t, typeof e != "symbol" ? e + "" : e, n), n);
var pr = (t, e, n) =>
	new Promise((r, o) => {
		var i = (a) => {
				try {
					l(n.next(a));
				} catch (u) {
					o(u);
				}
			},
			s = (a) => {
				try {
					l(n.throw(a));
				} catch (u) {
					o(u);
				}
			},
			l = (a) =>
				a.done ? r(a.value) : Promise.resolve(a.value).then(i, s);
		l((n = n.apply(t, e)).next());
	});
/**
 * @vue/shared v3.4.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Cf(t, e) {
	const n = new Set(t.split(","));
	return e ? (r) => n.has(r.toLowerCase()) : (r) => n.has(r);
}
const lt = {},
	ci = [],
	Mn = () => {},
	vb = () => !1,
	fu = (t) =>
		t.charCodeAt(0) === 111 &&
		t.charCodeAt(1) === 110 &&
		(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97),
	Mf = (t) => t.startsWith("onUpdate:"),
	_t = Object.assign,
	Ef = (t, e) => {
		const n = t.indexOf(e);
		n > -1 && t.splice(n, 1);
	},
	bb = Object.prototype.hasOwnProperty,
	Xe = (t, e) => bb.call(t, e),
	ke = Array.isArray,
	di = (t) => hu(t) === "[object Map]",
	M1 = (t) => hu(t) === "[object Set]",
	Ie = (t) => typeof t == "function",
	gt = (t) => typeof t == "string",
	Li = (t) => typeof t == "symbol",
	dt = (t) => t !== null && typeof t == "object",
	E1 = (t) => (dt(t) || Ie(t)) && Ie(t.then) && Ie(t.catch),
	T1 = Object.prototype.toString,
	hu = (t) => T1.call(t),
	wb = (t) => hu(t).slice(8, -1),
	A1 = (t) => hu(t) === "[object Object]",
	Tf = (t) =>
		gt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
	Vl = Cf(
		",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
	),
	pu = (t) => {
		const e = Object.create(null);
		return (n) => e[n] || (e[n] = t(n));
	},
	xb = /-(\w)/g,
	Hn = pu((t) => t.replace(xb, (e, n) => (n ? n.toUpperCase() : ""))),
	kb = /\B([A-Z])/g,
	lo = pu((t) => t.replace(kb, "-$1").toLowerCase()),
	mu = pu((t) => t.charAt(0).toUpperCase() + t.slice(1)),
	lc = pu((t) => (t ? `on${mu(t)}` : "")),
	ir = (t, e) => !Object.is(t, e),
	ac = (t, e) => {
		for (let n = 0; n < t.length; n++) t[n](e);
	},
	sa = (t, e, n) => {
		Object.defineProperty(t, e, {
			configurable: !0,
			enumerable: !1,
			value: n,
		});
	},
	Sb = (t) => {
		const e = parseFloat(t);
		return isNaN(e) ? t : e;
	},
	_b = (t) => {
		const e = gt(t) ? Number(t) : NaN;
		return isNaN(e) ? t : e;
	};
let rp;
const O1 = () =>
	rp ||
	(rp =
		typeof globalThis != "undefined"
			? globalThis
			: typeof self != "undefined"
			? self
			: typeof window != "undefined"
			? window
			: typeof global != "undefined"
			? global
			: {});
function ao(t) {
	if (ke(t)) {
		const e = {};
		for (let n = 0; n < t.length; n++) {
			const r = t[n],
				o = gt(r) ? Tb(r) : ao(r);
			if (o) for (const i in o) e[i] = o[i];
		}
		return e;
	} else if (gt(t) || dt(t)) return t;
}
const Cb = /;(?![^(]*\))/g,
	Mb = /:([^]+)/,
	Eb = /\/\*[^]*?\*\//g;
function Tb(t) {
	const e = {};
	return (
		t
			.replace(Eb, "")
			.split(Cb)
			.forEach((n) => {
				if (n) {
					const r = n.split(Mb);
					r.length > 1 && (e[r[0].trim()] = r[1].trim());
				}
			}),
		e
	);
}
function be(t) {
	let e = "";
	if (gt(t)) e = t;
	else if (ke(t))
		for (let n = 0; n < t.length; n++) {
			const r = be(t[n]);
			r && (e += r + " ");
		}
	else if (dt(t)) for (const n in t) t[n] && (e += n + " ");
	return e.trim();
}
function Et(t) {
	if (!t) return null;
	let { class: e, style: n } = t;
	return e && !gt(e) && (t.class = be(e)), n && (t.style = ao(n)), t;
}
const Ab =
		"itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
	Ob = Cf(Ab);
function R1(t) {
	return !!t || t === "";
}
const We = (t) =>
		gt(t)
			? t
			: t == null
			? ""
			: ke(t) || (dt(t) && (t.toString === T1 || !Ie(t.toString)))
			? JSON.stringify(t, P1, 2)
			: String(t),
	P1 = (t, e) =>
		e && e.__v_isRef
			? P1(t, e.value)
			: di(e)
			? {
					[`Map(${e.size})`]: [...e.entries()].reduce(
						(n, [r, o], i) => ((n[uc(r, i) + " =>"] = o), n),
						{}
					),
			  }
			: M1(e)
			? { [`Set(${e.size})`]: [...e.values()].map((n) => uc(n)) }
			: Li(e)
			? uc(e)
			: dt(e) && !ke(e) && !A1(e)
			? String(e)
			: e,
	uc = (t, e = "") => {
		var n;
		return Li(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t;
	};
/**
 * @vue/reactivity v3.4.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let pn;
class I1 {
	constructor(e = !1) {
		(this.detached = e),
			(this._active = !0),
			(this.effects = []),
			(this.cleanups = []),
			(this.parent = pn),
			!e &&
				pn &&
				(this.index = (pn.scopes || (pn.scopes = [])).push(this) - 1);
	}
	get active() {
		return this._active;
	}
	run(e) {
		if (this._active) {
			const n = pn;
			try {
				return (pn = this), e();
			} finally {
				pn = n;
			}
		}
	}
	on() {
		pn = this;
	}
	off() {
		pn = this.parent;
	}
	stop(e) {
		if (this._active) {
			let n, r;
			for (n = 0, r = this.effects.length; n < r; n++)
				this.effects[n].stop();
			for (n = 0, r = this.cleanups.length; n < r; n++)
				this.cleanups[n]();
			if (this.scopes)
				for (n = 0, r = this.scopes.length; n < r; n++)
					this.scopes[n].stop(!0);
			if (!this.detached && this.parent && !e) {
				const o = this.parent.scopes.pop();
				o &&
					o !== this &&
					((this.parent.scopes[this.index] = o),
					(o.index = this.index));
			}
			(this.parent = void 0), (this._active = !1);
		}
	}
}
function fL(t) {
	return new I1(t);
}
function Rb(t, e = pn) {
	e && e.active && e.effects.push(t);
}
function N1() {
	return pn;
}
function D1(t) {
	pn && pn.cleanups.push(t);
}
let Oo;
class Af {
	constructor(e, n, r, o) {
		(this.fn = e),
			(this.trigger = n),
			(this.scheduler = r),
			(this.active = !0),
			(this.deps = []),
			(this._dirtyLevel = 2),
			(this._trackId = 0),
			(this._runnings = 0),
			(this._shouldSchedule = !1),
			(this._depsLength = 0),
			Rb(this, o);
	}
	get dirty() {
		if (this._dirtyLevel === 1) {
			Uo();
			for (let e = 0; e < this._depsLength; e++) {
				const n = this.deps[e];
				if (n.computed && (Pb(n.computed), this._dirtyLevel >= 2))
					break;
			}
			this._dirtyLevel < 2 && (this._dirtyLevel = 0), Ko();
		}
		return this._dirtyLevel >= 2;
	}
	set dirty(e) {
		this._dirtyLevel = e ? 2 : 0;
	}
	run() {
		if (((this._dirtyLevel = 0), !this.active)) return this.fn();
		let e = Xr,
			n = Oo;
		try {
			return (
				(Xr = !0), (Oo = this), this._runnings++, op(this), this.fn()
			);
		} finally {
			ip(this), this._runnings--, (Oo = n), (Xr = e);
		}
	}
	stop() {
		var e;
		this.active &&
			(op(this),
			ip(this),
			(e = this.onStop) == null || e.call(this),
			(this.active = !1));
	}
}
function Pb(t) {
	return t.value;
}
function op(t) {
	t._trackId++, (t._depsLength = 0);
}
function ip(t) {
	if (t.deps && t.deps.length > t._depsLength) {
		for (let e = t._depsLength; e < t.deps.length; e++) j1(t.deps[e], t);
		t.deps.length = t._depsLength;
	}
}
function j1(t, e) {
	const n = t.get(e);
	n !== void 0 &&
		e._trackId !== n &&
		(t.delete(e), t.size === 0 && t.cleanup());
}
let Xr = !0,
	ld = 0;
const L1 = [];
function Uo() {
	L1.push(Xr), (Xr = !1);
}
function Ko() {
	const t = L1.pop();
	Xr = t === void 0 ? !0 : t;
}
function Of() {
	ld++;
}
function Rf() {
	for (ld--; !ld && ad.length; ) ad.shift()();
}
function $1(t, e, n) {
	if (e.get(t) !== t._trackId) {
		e.set(t, t._trackId);
		const r = t.deps[t._depsLength];
		r !== e
			? (r && j1(r, t), (t.deps[t._depsLength++] = e))
			: t._depsLength++;
	}
}
const ad = [];
function B1(t, e, n) {
	Of();
	for (const r of t.keys())
		if (r._dirtyLevel < e && t.get(r) === r._trackId) {
			const o = r._dirtyLevel;
			(r._dirtyLevel = e),
				o === 0 && ((r._shouldSchedule = !0), r.trigger());
		}
	z1(t), Rf();
}
function z1(t) {
	for (const e of t.keys())
		e.scheduler &&
			e._shouldSchedule &&
			(!e._runnings || e.allowRecurse) &&
			t.get(e) === e._trackId &&
			((e._shouldSchedule = !1), ad.push(e.scheduler));
}
const H1 = (t, e) => {
		const n = new Map();
		return (n.cleanup = t), (n.computed = e), n;
	},
	la = new WeakMap(),
	Ro = Symbol(""),
	ud = Symbol("");
function dn(t, e, n) {
	if (Xr && Oo) {
		let r = la.get(t);
		r || la.set(t, (r = new Map()));
		let o = r.get(n);
		o || r.set(n, (o = H1(() => r.delete(n)))), $1(Oo, o);
	}
}
function Sr(t, e, n, r, o, i) {
	const s = la.get(t);
	if (!s) return;
	let l = [];
	if (e === "clear") l = [...s.values()];
	else if (n === "length" && ke(t)) {
		const a = Number(r);
		s.forEach((u, c) => {
			(c === "length" || (!Li(c) && c >= a)) && l.push(u);
		});
	} else
		switch ((n !== void 0 && l.push(s.get(n)), e)) {
			case "add":
				ke(t)
					? Tf(n) && l.push(s.get("length"))
					: (l.push(s.get(Ro)), di(t) && l.push(s.get(ud)));
				break;
			case "delete":
				ke(t) || (l.push(s.get(Ro)), di(t) && l.push(s.get(ud)));
				break;
			case "set":
				di(t) && l.push(s.get(Ro));
				break;
		}
	Of();
	for (const a of l) a && B1(a, 2);
	Rf();
}
function Ib(t, e) {
	var n;
	return (n = la.get(t)) == null ? void 0 : n.get(e);
}
const Nb = Cf("__proto__,__v_isRef,__isVue"),
	F1 = new Set(
		Object.getOwnPropertyNames(Symbol)
			.filter((t) => t !== "arguments" && t !== "caller")
			.map((t) => Symbol[t])
			.filter(Li)
	),
	sp = Db();
function Db() {
	const t = {};
	return (
		["includes", "indexOf", "lastIndexOf"].forEach((e) => {
			t[e] = function (...n) {
				const r = je(this);
				for (let i = 0, s = this.length; i < s; i++)
					dn(r, "get", i + "");
				const o = r[e](...n);
				return o === -1 || o === !1 ? r[e](...n.map(je)) : o;
			};
		}),
		["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
			t[e] = function (...n) {
				Uo(), Of();
				const r = je(this)[e].apply(this, n);
				return Rf(), Ko(), r;
			};
		}),
		t
	);
}
function jb(t) {
	const e = je(this);
	return dn(e, "has", t), e.hasOwnProperty(t);
}
class V1 {
	constructor(e = !1, n = !1) {
		(this._isReadonly = e), (this._shallow = n);
	}
	get(e, n, r) {
		const o = this._isReadonly,
			i = this._shallow;
		if (n === "__v_isReactive") return !o;
		if (n === "__v_isReadonly") return o;
		if (n === "__v_isShallow") return i;
		if (n === "__v_raw")
			return r === (o ? (i ? Gb : q1) : i ? K1 : U1).get(e) ||
				Object.getPrototypeOf(e) === Object.getPrototypeOf(r)
				? e
				: void 0;
		const s = ke(e);
		if (!o) {
			if (s && Xe(sp, n)) return Reflect.get(sp, n, r);
			if (n === "hasOwnProperty") return jb;
		}
		const l = Reflect.get(e, n, r);
		return (Li(n) ? F1.has(n) : Nb(n)) || (o || dn(e, "get", n), i)
			? l
			: Jt(l)
			? s && Tf(n)
				? l
				: l.value
			: dt(l)
			? o
				? yu(l)
				: Yt(l)
			: l;
	}
}
class W1 extends V1 {
	constructor(e = !1) {
		super(!1, e);
	}
	set(e, n, r, o) {
		let i = e[n];
		if (!this._shallow) {
			const a = wi(i);
			if (
				(!aa(r) && !wi(r) && ((i = je(i)), (r = je(r))),
				!ke(e) && Jt(i) && !Jt(r))
			)
				return a ? !1 : ((i.value = r), !0);
		}
		const s = ke(e) && Tf(n) ? Number(n) < e.length : Xe(e, n),
			l = Reflect.set(e, n, r, o);
		return (
			e === je(o) &&
				(s ? ir(r, i) && Sr(e, "set", n, r) : Sr(e, "add", n, r)),
			l
		);
	}
	deleteProperty(e, n) {
		const r = Xe(e, n);
		e[n];
		const o = Reflect.deleteProperty(e, n);
		return o && r && Sr(e, "delete", n, void 0), o;
	}
	has(e, n) {
		const r = Reflect.has(e, n);
		return (!Li(n) || !F1.has(n)) && dn(e, "has", n), r;
	}
	ownKeys(e) {
		return dn(e, "iterate", ke(e) ? "length" : Ro), Reflect.ownKeys(e);
	}
}
class Lb extends V1 {
	constructor(e = !1) {
		super(!0, e);
	}
	set(e, n) {
		return !0;
	}
	deleteProperty(e, n) {
		return !0;
	}
}
const $b = new W1(),
	Bb = new Lb(),
	zb = new W1(!0),
	Pf = (t) => t,
	gu = (t) => Reflect.getPrototypeOf(t);
function cl(t, e, n = !1, r = !1) {
	t = t.__v_raw;
	const o = je(t),
		i = je(e);
	n || (ir(e, i) && dn(o, "get", e), dn(o, "get", i));
	const { has: s } = gu(o),
		l = r ? Pf : n ? Df : Ss;
	if (s.call(o, e)) return l(t.get(e));
	if (s.call(o, i)) return l(t.get(i));
	t !== o && t.get(e);
}
function dl(t, e = !1) {
	const n = this.__v_raw,
		r = je(n),
		o = je(t);
	return (
		e || (ir(t, o) && dn(r, "has", t), dn(r, "has", o)),
		t === o ? n.has(t) : n.has(t) || n.has(o)
	);
}
function fl(t, e = !1) {
	return (
		(t = t.__v_raw),
		!e && dn(je(t), "iterate", Ro),
		Reflect.get(t, "size", t)
	);
}
function lp(t) {
	t = je(t);
	const e = je(this);
	return gu(e).has.call(e, t) || (e.add(t), Sr(e, "add", t, t)), this;
}
function ap(t, e) {
	e = je(e);
	const n = je(this),
		{ has: r, get: o } = gu(n);
	let i = r.call(n, t);
	i || ((t = je(t)), (i = r.call(n, t)));
	const s = o.call(n, t);
	return (
		n.set(t, e),
		i ? ir(e, s) && Sr(n, "set", t, e) : Sr(n, "add", t, e),
		this
	);
}
function up(t) {
	const e = je(this),
		{ has: n, get: r } = gu(e);
	let o = n.call(e, t);
	o || ((t = je(t)), (o = n.call(e, t))), r && r.call(e, t);
	const i = e.delete(t);
	return o && Sr(e, "delete", t, void 0), i;
}
function cp() {
	const t = je(this),
		e = t.size !== 0,
		n = t.clear();
	return e && Sr(t, "clear", void 0, void 0), n;
}
function hl(t, e) {
	return function (r, o) {
		const i = this,
			s = i.__v_raw,
			l = je(s),
			a = e ? Pf : t ? Df : Ss;
		return (
			!t && dn(l, "iterate", Ro),
			s.forEach((u, c) => r.call(o, a(u), a(c), i))
		);
	};
}
function pl(t, e, n) {
	return function (...r) {
		const o = this.__v_raw,
			i = je(o),
			s = di(i),
			l = t === "entries" || (t === Symbol.iterator && s),
			a = t === "keys" && s,
			u = o[t](...r),
			c = n ? Pf : e ? Df : Ss;
		return (
			!e && dn(i, "iterate", a ? ud : Ro),
			{
				next() {
					const { value: d, done: f } = u.next();
					return f
						? { value: d, done: f }
						: { value: l ? [c(d[0]), c(d[1])] : c(d), done: f };
				},
				[Symbol.iterator]() {
					return this;
				},
			}
		);
	};
}
function Or(t) {
	return function (...e) {
		return t === "delete" ? !1 : t === "clear" ? void 0 : this;
	};
}
function Hb() {
	const t = {
			get(i) {
				return cl(this, i);
			},
			get size() {
				return fl(this);
			},
			has: dl,
			add: lp,
			set: ap,
			delete: up,
			clear: cp,
			forEach: hl(!1, !1),
		},
		e = {
			get(i) {
				return cl(this, i, !1, !0);
			},
			get size() {
				return fl(this);
			},
			has: dl,
			add: lp,
			set: ap,
			delete: up,
			clear: cp,
			forEach: hl(!1, !0),
		},
		n = {
			get(i) {
				return cl(this, i, !0);
			},
			get size() {
				return fl(this, !0);
			},
			has(i) {
				return dl.call(this, i, !0);
			},
			add: Or("add"),
			set: Or("set"),
			delete: Or("delete"),
			clear: Or("clear"),
			forEach: hl(!0, !1),
		},
		r = {
			get(i) {
				return cl(this, i, !0, !0);
			},
			get size() {
				return fl(this, !0);
			},
			has(i) {
				return dl.call(this, i, !0);
			},
			add: Or("add"),
			set: Or("set"),
			delete: Or("delete"),
			clear: Or("clear"),
			forEach: hl(!0, !0),
		};
	return (
		["keys", "values", "entries", Symbol.iterator].forEach((i) => {
			(t[i] = pl(i, !1, !1)),
				(n[i] = pl(i, !0, !1)),
				(e[i] = pl(i, !1, !0)),
				(r[i] = pl(i, !0, !0));
		}),
		[t, n, e, r]
	);
}
const [Fb, Vb, Wb, Ub] = Hb();
function If(t, e) {
	const n = e ? (t ? Ub : Wb) : t ? Vb : Fb;
	return (r, o, i) =>
		o === "__v_isReactive"
			? !t
			: o === "__v_isReadonly"
			? t
			: o === "__v_raw"
			? r
			: Reflect.get(Xe(n, o) && o in r ? n : r, o, i);
}
const Kb = { get: If(!1, !1) },
	qb = { get: If(!1, !0) },
	Jb = { get: If(!0, !1) },
	U1 = new WeakMap(),
	K1 = new WeakMap(),
	q1 = new WeakMap(),
	Gb = new WeakMap();
function Yb(t) {
	switch (t) {
		case "Object":
		case "Array":
			return 1;
		case "Map":
		case "Set":
		case "WeakMap":
		case "WeakSet":
			return 2;
		default:
			return 0;
	}
}
function Qb(t) {
	return t.__v_skip || !Object.isExtensible(t) ? 0 : Yb(wb(t));
}
function Yt(t) {
	return wi(t) ? t : Nf(t, !1, $b, Kb, U1);
}
function J1(t) {
	return Nf(t, !1, zb, qb, K1);
}
function yu(t) {
	return Nf(t, !0, Bb, Jb, q1);
}
function Nf(t, e, n, r, o) {
	if (!dt(t) || (t.__v_raw && !(e && t.__v_isReactive))) return t;
	const i = o.get(t);
	if (i) return i;
	const s = Qb(t);
	if (s === 0) return t;
	const l = new Proxy(t, s === 2 ? r : n);
	return o.set(t, l), l;
}
function fi(t) {
	return wi(t) ? fi(t.__v_raw) : !!(t && t.__v_isReactive);
}
function wi(t) {
	return !!(t && t.__v_isReadonly);
}
function aa(t) {
	return !!(t && t.__v_isShallow);
}
function G1(t) {
	return fi(t) || wi(t);
}
function je(t) {
	const e = t && t.__v_raw;
	return e ? je(e) : t;
}
function vu(t) {
	return sa(t, "__v_skip", !0), t;
}
const Ss = (t) => (dt(t) ? Yt(t) : t),
	Df = (t) => (dt(t) ? yu(t) : t);
class Y1 {
	constructor(e, n, r, o) {
		(this._setter = n),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this.__v_isReadonly = !1),
			(this.effect = new Af(
				() => e(this._value),
				() => hi(this, 1),
				() => this.dep && z1(this.dep)
			)),
			(this.effect.computed = this),
			(this.effect.active = this._cacheable = !o),
			(this.__v_isReadonly = r);
	}
	get value() {
		const e = je(this);
		return (
			(!e._cacheable || e.effect.dirty) &&
				ir(e._value, (e._value = e.effect.run())) &&
				hi(e, 2),
			jf(e),
			e.effect._dirtyLevel >= 1 && hi(e, 1),
			e._value
		);
	}
	set value(e) {
		this._setter(e);
	}
	get _dirty() {
		return this.effect.dirty;
	}
	set _dirty(e) {
		this.effect.dirty = e;
	}
}
function Q1(t, e, n = !1) {
	let r, o;
	const i = Ie(t);
	return (
		i ? ((r = t), (o = Mn)) : ((r = t.get), (o = t.set)),
		new Y1(r, o, i || !o, n)
	);
}
function jf(t) {
	Xr &&
		Oo &&
		((t = je(t)),
		$1(
			Oo,
			t.dep ||
				(t.dep = H1(
					() => (t.dep = void 0),
					t instanceof Y1 ? t : void 0
				))
		));
}
function hi(t, e = 2, n) {
	t = je(t);
	const r = t.dep;
	r && B1(r, e);
}
function Jt(t) {
	return !!(t && t.__v_isRef === !0);
}
function Q(t) {
	return X1(t, !1);
}
function bu(t) {
	return X1(t, !0);
}
function X1(t, e) {
	return Jt(t) ? t : new Xb(t, e);
}
class Xb {
	constructor(e, n) {
		(this.__v_isShallow = n),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this._rawValue = n ? e : je(e)),
			(this._value = n ? e : Ss(e));
	}
	get value() {
		return jf(this), this._value;
	}
	set value(e) {
		const n = this.__v_isShallow || aa(e) || wi(e);
		(e = n ? e : je(e)),
			ir(e, this._rawValue) &&
				((this._rawValue = e),
				(this._value = n ? e : Ss(e)),
				hi(this, 2));
	}
}
function dp(t) {
	hi(t, 2);
}
function ne(t) {
	return Jt(t) ? t.value : t;
}
const Zb = {
	get: (t, e, n) => ne(Reflect.get(t, e, n)),
	set: (t, e, n, r) => {
		const o = t[e];
		return Jt(o) && !Jt(n) ? ((o.value = n), !0) : Reflect.set(t, e, n, r);
	},
};
function Z1(t) {
	return fi(t) ? t : new Proxy(t, Zb);
}
class ew {
	constructor(e) {
		(this.dep = void 0), (this.__v_isRef = !0);
		const { get: n, set: r } = e(
			() => jf(this),
			() => hi(this)
		);
		(this._get = n), (this._set = r);
	}
	get value() {
		return this._get();
	}
	set value(e) {
		this._set(e);
	}
}
function e0(t) {
	return new ew(t);
}
function hL(t) {
	const e = ke(t) ? new Array(t.length) : {};
	for (const n in t) e[n] = nw(t, n);
	return e;
}
class tw {
	constructor(e, n, r) {
		(this._object = e),
			(this._key = n),
			(this._defaultValue = r),
			(this.__v_isRef = !0);
	}
	get value() {
		const e = this._object[this._key];
		return e === void 0 ? this._defaultValue : e;
	}
	set value(e) {
		this._object[this._key] = e;
	}
	get dep() {
		return Ib(je(this._object), this._key);
	}
}
function nw(t, e, n) {
	const r = t[e];
	return Jt(r) ? r : new tw(t, e, n);
}
/**
 * @vue/runtime-core v3.4.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Zr(t, e, n, r) {
	let o;
	try {
		o = r ? t(...r) : t();
	} catch (i) {
		Us(i, e, n);
	}
	return o;
}
function En(t, e, n, r) {
	if (Ie(t)) {
		const i = Zr(t, e, n, r);
		return (
			i &&
				E1(i) &&
				i.catch((s) => {
					Us(s, e, n);
				}),
			i
		);
	}
	const o = [];
	for (let i = 0; i < t.length; i++) o.push(En(t[i], e, n, r));
	return o;
}
function Us(t, e, n, r = !0) {
	const o = e ? e.vnode : null;
	if (e) {
		let i = e.parent;
		const s = e.proxy,
			l = `https://vuejs.org/error-reference/#runtime-${n}`;
		for (; i; ) {
			const u = i.ec;
			if (u) {
				for (let c = 0; c < u.length; c++)
					if (u[c](t, s, l) === !1) return;
			}
			i = i.parent;
		}
		const a = e.appContext.config.errorHandler;
		if (a) {
			Zr(a, null, 10, [t, s, l]);
			return;
		}
	}
	rw(t, n, o, r);
}
function rw(t, e, n, r = !0) {
	console.error(t);
}
let _s = !1,
	cd = !1;
const Ut = [];
let Xn = 0;
const pi = [];
let jr = null,
	xo = 0;
const t0 = Promise.resolve();
let Lf = null;
function bt(t) {
	const e = Lf || t0;
	return t ? e.then(this ? t.bind(this) : t) : e;
}
function ow(t) {
	let e = Xn + 1,
		n = Ut.length;
	for (; e < n; ) {
		const r = (e + n) >>> 1,
			o = Ut[r],
			i = Cs(o);
		i < t || (i === t && o.pre) ? (e = r + 1) : (n = r);
	}
	return e;
}
function wu(t) {
	(!Ut.length || !Ut.includes(t, _s && t.allowRecurse ? Xn + 1 : Xn)) &&
		(t.id == null ? Ut.push(t) : Ut.splice(ow(t.id), 0, t), n0());
}
function n0() {
	!_s && !cd && ((cd = !0), (Lf = t0.then(o0)));
}
function iw(t) {
	const e = Ut.indexOf(t);
	e > Xn && Ut.splice(e, 1);
}
function sw(t) {
	ke(t)
		? pi.push(...t)
		: (!jr || !jr.includes(t, t.allowRecurse ? xo + 1 : xo)) && pi.push(t),
		n0();
}
function fp(t, e, n = _s ? Xn + 1 : 0) {
	for (; n < Ut.length; n++) {
		const r = Ut[n];
		if (r && r.pre) {
			if (t && r.id !== t.uid) continue;
			Ut.splice(n, 1), n--, r();
		}
	}
}
function r0(t) {
	if (pi.length) {
		const e = [...new Set(pi)].sort((n, r) => Cs(n) - Cs(r));
		if (((pi.length = 0), jr)) {
			jr.push(...e);
			return;
		}
		for (jr = e, xo = 0; xo < jr.length; xo++) jr[xo]();
		(jr = null), (xo = 0);
	}
}
const Cs = (t) => (t.id == null ? 1 / 0 : t.id),
	lw = (t, e) => {
		const n = Cs(t) - Cs(e);
		if (n === 0) {
			if (t.pre && !e.pre) return -1;
			if (e.pre && !t.pre) return 1;
		}
		return n;
	};
function o0(t) {
	(cd = !1), (_s = !0), Ut.sort(lw);
	try {
		for (Xn = 0; Xn < Ut.length; Xn++) {
			const e = Ut[Xn];
			e && e.active !== !1 && Zr(e, null, 14);
		}
	} finally {
		(Xn = 0),
			(Ut.length = 0),
			r0(),
			(_s = !1),
			(Lf = null),
			(Ut.length || pi.length) && o0();
	}
}
function aw(t, e, ...n) {
	if (t.isUnmounted) return;
	const r = t.vnode.props || lt;
	let o = n;
	const i = e.startsWith("update:"),
		s = i && e.slice(7);
	if (s && s in r) {
		const c = `${s === "modelValue" ? "model" : s}Modifiers`,
			{ number: d, trim: f } = r[c] || lt;
		f && (o = n.map((p) => (gt(p) ? p.trim() : p))), d && (o = n.map(Sb));
	}
	let l,
		a = r[(l = lc(e))] || r[(l = lc(Hn(e)))];
	!a && i && (a = r[(l = lc(lo(e)))]), a && En(a, t, 6, o);
	const u = r[l + "Once"];
	if (u) {
		if (!t.emitted) t.emitted = {};
		else if (t.emitted[l]) return;
		(t.emitted[l] = !0), En(u, t, 6, o);
	}
}
function i0(t, e, n = !1) {
	const r = e.emitsCache,
		o = r.get(t);
	if (o !== void 0) return o;
	const i = t.emits;
	let s = {},
		l = !1;
	if (!Ie(t)) {
		const a = (u) => {
			const c = i0(u, e, !0);
			c && ((l = !0), _t(s, c));
		};
		!n && e.mixins.length && e.mixins.forEach(a),
			t.extends && a(t.extends),
			t.mixins && t.mixins.forEach(a);
	}
	return !i && !l
		? (dt(t) && r.set(t, null), null)
		: (ke(i) ? i.forEach((a) => (s[a] = null)) : _t(s, i),
		  dt(t) && r.set(t, s),
		  s);
}
function xu(t, e) {
	return !t || !fu(e)
		? !1
		: ((e = e.slice(2).replace(/Once$/, "")),
		  Xe(t, e[0].toLowerCase() + e.slice(1)) || Xe(t, lo(e)) || Xe(t, e));
}
let Tt = null,
	s0 = null;
function ua(t) {
	const e = Tt;
	return (Tt = t), (s0 = (t && t.type.__scopeId) || null), e;
}
function Ce(t, e = Tt, n) {
	if (!e || t._n) return t;
	const r = (...o) => {
		r._d && Cp(-1);
		const i = ua(e);
		let s;
		try {
			s = t(...o);
		} finally {
			ua(i), r._d && Cp(1);
		}
		return s;
	};
	return (r._n = !0), (r._c = !0), (r._d = !0), r;
}
function cc(t) {
	const {
		type: e,
		vnode: n,
		proxy: r,
		withProxy: o,
		props: i,
		propsOptions: [s],
		slots: l,
		attrs: a,
		emit: u,
		render: c,
		renderCache: d,
		data: f,
		setupState: p,
		ctx: m,
		inheritAttrs: y,
	} = t;
	let v, w;
	const S = ua(t);
	try {
		if (n.shapeFlag & 4) {
			const h = o || r,
				b = h;
			(v = Yn(c.call(b, h, d, i, p, f, m))), (w = a);
		} else {
			const h = e;
			(v = Yn(
				h.length > 1
					? h(i, { attrs: a, slots: l, emit: u })
					: h(i, null)
			)),
				(w = e.props ? a : uw(a));
		}
	} catch (h) {
		(us.length = 0), Us(h, t, 1), (v = ve(Tn));
	}
	let E = v;
	if (w && y !== !1) {
		const h = Object.keys(w),
			{ shapeFlag: b } = E;
		h.length &&
			b & 7 &&
			(s && h.some(Mf) && (w = cw(w, s)), (E = sr(E, w)));
	}
	return (
		n.dirs &&
			((E = sr(E)), (E.dirs = E.dirs ? E.dirs.concat(n.dirs) : n.dirs)),
		n.transition && (E.transition = n.transition),
		(v = E),
		ua(S),
		v
	);
}
const uw = (t) => {
		let e;
		for (const n in t)
			(n === "class" || n === "style" || fu(n)) &&
				((e || (e = {}))[n] = t[n]);
		return e;
	},
	cw = (t, e) => {
		const n = {};
		for (const r in t) (!Mf(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
		return n;
	};
function dw(t, e, n) {
	const { props: r, children: o, component: i } = t,
		{ props: s, children: l, patchFlag: a } = e,
		u = i.emitsOptions;
	if (e.dirs || e.transition) return !0;
	if (n && a >= 0) {
		if (a & 1024) return !0;
		if (a & 16) return r ? hp(r, s, u) : !!s;
		if (a & 8) {
			const c = e.dynamicProps;
			for (let d = 0; d < c.length; d++) {
				const f = c[d];
				if (s[f] !== r[f] && !xu(u, f)) return !0;
			}
		}
	} else
		return (o || l) && (!l || !l.$stable)
			? !0
			: r === s
			? !1
			: r
			? s
				? hp(r, s, u)
				: !0
			: !!s;
	return !1;
}
function hp(t, e, n) {
	const r = Object.keys(e);
	if (r.length !== Object.keys(t).length) return !0;
	for (let o = 0; o < r.length; o++) {
		const i = r[o];
		if (e[i] !== t[i] && !xu(n, i)) return !0;
	}
	return !1;
}
function fw({ vnode: t, parent: e }, n) {
	for (; e; ) {
		const r = e.subTree;
		if (
			(r.suspense && r.suspense.activeBranch === t && (r.el = t.el),
			r === t)
		)
			((t = e.vnode).el = n), (e = e.parent);
		else break;
	}
}
const $f = "components";
function Je(t, e) {
	return a0($f, t, !0, e) || t;
}
const l0 = Symbol.for("v-ndc");
function Bn(t) {
	return gt(t) ? a0($f, t, !1) || t : t || l0;
}
function a0(t, e, n = !0, r = !1) {
	const o = Tt || It;
	if (o) {
		const i = o.type;
		if (t === $f) {
			const l = ox(i, !1);
			if (l && (l === e || l === Hn(e) || l === mu(Hn(e)))) return i;
		}
		const s = pp(o[t] || i[t], e) || pp(o.appContext[t], e);
		return !s && r ? i : s;
	}
}
function pp(t, e) {
	return t && (t[e] || t[Hn(e)] || t[mu(Hn(e))]);
}
const hw = (t) => t.__isSuspense;
function pw(t, e) {
	e && e.pendingBranch
		? ke(t)
			? e.effects.push(...t)
			: e.effects.push(t)
		: sw(t);
}
const mw = Symbol.for("v-scx"),
	gw = () => Ge(mw);
function xt(t, e) {
	return ku(t, null, e);
}
function yw(t, e) {
	return ku(t, null, { flush: "sync" });
}
const ml = {};
function at(t, e, n) {
	return ku(t, e, n);
}
function ku(
	t,
	e,
	{ immediate: n, deep: r, flush: o, once: i, onTrack: s, onTrigger: l } = lt
) {
	if (e && i) {
		const g = e;
		e = (...x) => {
			g(...x), b();
		};
	}
	const a = It,
		u = (g) => (r === !0 ? g : Co(g, r === !1 ? 1 : void 0));
	let c,
		d = !1,
		f = !1;
	if (
		(Jt(t)
			? ((c = () => t.value), (d = aa(t)))
			: fi(t)
			? ((c = () => u(t)), (d = !0))
			: ke(t)
			? ((f = !0),
			  (d = t.some((g) => fi(g) || aa(g))),
			  (c = () =>
					t.map((g) => {
						if (Jt(g)) return g.value;
						if (fi(g)) return u(g);
						if (Ie(g)) return Zr(g, a, 2);
					})))
			: Ie(t)
			? e
				? (c = () => Zr(t, a, 2))
				: (c = () => (p && p(), En(t, a, 3, [m])))
			: (c = Mn),
		e && r)
	) {
		const g = c;
		c = () => Co(g());
	}
	let p,
		m = (g) => {
			p = E.onStop = () => {
				Zr(g, a, 4), (p = E.onStop = void 0);
			};
		},
		y;
	if (Ys)
		if (
			((m = Mn),
			e ? n && En(e, a, 3, [c(), f ? [] : void 0, m]) : c(),
			o === "sync")
		) {
			const g = gw();
			y = g.__watcherHandles || (g.__watcherHandles = []);
		} else return Mn;
	let v = f ? new Array(t.length).fill(ml) : ml;
	const w = () => {
		if (!(!E.active || !E.dirty))
			if (e) {
				const g = E.run();
				(r || d || (f ? g.some((x, k) => ir(x, v[k])) : ir(g, v))) &&
					(p && p(),
					En(e, a, 3, [
						g,
						v === ml ? void 0 : f && v[0] === ml ? [] : v,
						m,
					]),
					(v = g));
			} else E.run();
	};
	w.allowRecurse = !!e;
	let S;
	o === "sync"
		? (S = w)
		: o === "post"
		? (S = () => sn(w, a && a.suspense))
		: ((w.pre = !0), a && (w.id = a.uid), (S = () => wu(w)));
	const E = new Af(c, Mn, S),
		h = N1(),
		b = () => {
			E.stop(), h && Ef(h.effects, E);
		};
	return (
		e
			? n
				? w()
				: (v = E.run())
			: o === "post"
			? sn(E.run.bind(E), a && a.suspense)
			: E.run(),
		y && y.push(b),
		b
	);
}
function vw(t, e, n) {
	const r = this.proxy,
		o = gt(t) ? (t.includes(".") ? u0(r, t) : () => r[t]) : t.bind(r, r);
	let i;
	Ie(e) ? (i = e) : ((i = e.handler), (n = e));
	const s = Gs(this),
		l = ku(o, i.bind(r), n);
	return s(), l;
}
function u0(t, e) {
	const n = e.split(".");
	return () => {
		let r = t;
		for (let o = 0; o < n.length && r; o++) r = r[n[o]];
		return r;
	};
}
function Co(t, e, n = 0, r) {
	if (!dt(t) || t.__v_skip) return t;
	if (e && e > 0) {
		if (n >= e) return t;
		n++;
	}
	if (((r = r || new Set()), r.has(t))) return t;
	if ((r.add(t), Jt(t))) Co(t.value, e, n, r);
	else if (ke(t)) for (let o = 0; o < t.length; o++) Co(t[o], e, n, r);
	else if (M1(t) || di(t))
		t.forEach((o) => {
			Co(o, e, n, r);
		});
	else if (A1(t)) for (const o in t) Co(t[o], e, n, r);
	return t;
}
function ca(t, e) {
	if (Tt === null) return t;
	const n = Eu(Tt) || Tt.proxy,
		r = t.dirs || (t.dirs = []);
	for (let o = 0; o < e.length; o++) {
		let [i, s, l, a = lt] = e[o];
		i &&
			(Ie(i) && (i = { mounted: i, updated: i }),
			i.deep && Co(s),
			r.push({
				dir: i,
				instance: n,
				value: s,
				oldValue: void 0,
				arg: l,
				modifiers: a,
			}));
	}
	return t;
}
function go(t, e, n, r) {
	const o = t.dirs,
		i = e && e.dirs;
	for (let s = 0; s < o.length; s++) {
		const l = o[s];
		i && (l.oldValue = i[s].value);
		let a = l.dir[r];
		a && (Uo(), En(a, n, 8, [t.el, l, t, e]), Ko());
	}
}
const Lr = Symbol("_leaveCb"),
	gl = Symbol("_enterCb");
function c0() {
	const t = {
		isMounted: !1,
		isLeaving: !1,
		isUnmounting: !1,
		leavingVNodes: new Map(),
	};
	return (
		Ze(() => {
			t.isMounted = !0;
		}),
		qs(() => {
			t.isUnmounting = !0;
		}),
		t
	);
}
const wn = [Function, Array],
	d0 = {
		mode: String,
		appear: Boolean,
		persisted: Boolean,
		onBeforeEnter: wn,
		onEnter: wn,
		onAfterEnter: wn,
		onEnterCancelled: wn,
		onBeforeLeave: wn,
		onLeave: wn,
		onAfterLeave: wn,
		onLeaveCancelled: wn,
		onBeforeAppear: wn,
		onAppear: wn,
		onAfterAppear: wn,
		onAppearCancelled: wn,
	},
	bw = {
		name: "BaseTransition",
		props: d0,
		setup(t, { slots: e }) {
			const n = uo(),
				r = c0();
			let o;
			return () => {
				const i = e.default && Bf(e.default(), !0);
				if (!i || !i.length) return;
				let s = i[0];
				if (i.length > 1) {
					for (const y of i)
						if (y.type !== Tn) {
							s = y;
							break;
						}
				}
				const l = je(t),
					{ mode: a } = l;
				if (r.isLeaving) return dc(s);
				const u = mp(s);
				if (!u) return dc(s);
				const c = Ms(u, l, r, n);
				Es(u, c);
				const d = n.subTree,
					f = d && mp(d);
				let p = !1;
				const { getTransitionKey: m } = u.type;
				if (m) {
					const y = m();
					o === void 0 ? (o = y) : y !== o && ((o = y), (p = !0));
				}
				if (f && f.type !== Tn && (!ko(u, f) || p)) {
					const y = Ms(f, l, r, n);
					if ((Es(f, y), a === "out-in"))
						return (
							(r.isLeaving = !0),
							(y.afterLeave = () => {
								(r.isLeaving = !1),
									n.update.active !== !1 &&
										((n.effect.dirty = !0), n.update());
							}),
							dc(s)
						);
					a === "in-out" &&
						u.type !== Tn &&
						(y.delayLeave = (v, w, S) => {
							const E = f0(r, f);
							(E[String(f.key)] = f),
								(v[Lr] = () => {
									w(),
										(v[Lr] = void 0),
										delete c.delayedLeave;
								}),
								(c.delayedLeave = S);
						});
				}
				return s;
			};
		},
	},
	ww = bw;
function f0(t, e) {
	const { leavingVNodes: n } = t;
	let r = n.get(e.type);
	return r || ((r = Object.create(null)), n.set(e.type, r)), r;
}
function Ms(t, e, n, r) {
	const {
			appear: o,
			mode: i,
			persisted: s = !1,
			onBeforeEnter: l,
			onEnter: a,
			onAfterEnter: u,
			onEnterCancelled: c,
			onBeforeLeave: d,
			onLeave: f,
			onAfterLeave: p,
			onLeaveCancelled: m,
			onBeforeAppear: y,
			onAppear: v,
			onAfterAppear: w,
			onAppearCancelled: S,
		} = e,
		E = String(t.key),
		h = f0(n, t),
		b = (k, C) => {
			k && En(k, r, 9, C);
		},
		g = (k, C) => {
			const _ = C[1];
			b(k, C),
				ke(k)
					? k.every((T) => T.length <= 1) && _()
					: k.length <= 1 && _();
		},
		x = {
			mode: i,
			persisted: s,
			beforeEnter(k) {
				let C = l;
				if (!n.isMounted)
					if (o) C = y || l;
					else return;
				k[Lr] && k[Lr](!0);
				const _ = h[E];
				_ && ko(t, _) && _.el[Lr] && _.el[Lr](), b(C, [k]);
			},
			enter(k) {
				let C = a,
					_ = u,
					T = c;
				if (!n.isMounted)
					if (o) (C = v || a), (_ = w || u), (T = S || c);
					else return;
				let R = !1;
				const P = (k[gl] = (D) => {
					R ||
						((R = !0),
						D ? b(T, [k]) : b(_, [k]),
						x.delayedLeave && x.delayedLeave(),
						(k[gl] = void 0));
				});
				C ? g(C, [k, P]) : P();
			},
			leave(k, C) {
				const _ = String(t.key);
				if ((k[gl] && k[gl](!0), n.isUnmounting)) return C();
				b(d, [k]);
				let T = !1;
				const R = (k[Lr] = (P) => {
					T ||
						((T = !0),
						C(),
						P ? b(m, [k]) : b(p, [k]),
						(k[Lr] = void 0),
						h[_] === t && delete h[_]);
				});
				(h[_] = t), f ? g(f, [k, R]) : R();
			},
			clone(k) {
				return Ms(k, e, n, r);
			},
		};
	return x;
}
function dc(t) {
	if (Ks(t)) return (t = sr(t)), (t.children = null), t;
}
function mp(t) {
	return Ks(t) ? (t.children ? t.children[0] : void 0) : t;
}
function Es(t, e) {
	t.shapeFlag & 6 && t.component
		? Es(t.component.subTree, e)
		: t.shapeFlag & 128
		? ((t.ssContent.transition = e.clone(t.ssContent)),
		  (t.ssFallback.transition = e.clone(t.ssFallback)))
		: (t.transition = e);
}
function Bf(t, e = !1, n) {
	let r = [],
		o = 0;
	for (let i = 0; i < t.length; i++) {
		let s = t[i];
		const l =
			n == null ? s.key : String(n) + String(s.key != null ? s.key : i);
		s.type === Ne
			? (s.patchFlag & 128 && o++, (r = r.concat(Bf(s.children, e, l))))
			: (e || s.type !== Tn) && r.push(l != null ? sr(s, { key: l }) : s);
	}
	if (o > 1) for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
	return r;
}
/*! #__NO_SIDE_EFFECTS__ */ function Oe(t, e) {
	return Ie(t) ? _t({ name: t.name }, e, { setup: t }) : t;
}
const ss = (t) => !!t.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */ function yl(t) {
	Ie(t) && (t = { loader: t });
	const {
		loader: e,
		loadingComponent: n,
		errorComponent: r,
		delay: o = 200,
		timeout: i,
		suspensible: s = !0,
		onError: l,
	} = t;
	let a = null,
		u,
		c = 0;
	const d = () => (c++, (a = null), f()),
		f = () => {
			let p;
			return (
				a ||
				(p = a =
					e()
						.catch((m) => {
							if (
								((m =
									m instanceof Error
										? m
										: new Error(String(m))),
								l)
							)
								return new Promise((y, v) => {
									l(
										m,
										() => y(d()),
										() => v(m),
										c + 1
									);
								});
							throw m;
						})
						.then((m) =>
							p !== a && a
								? a
								: (m &&
										(m.__esModule ||
											m[Symbol.toStringTag] ===
												"Module") &&
										(m = m.default),
								  (u = m),
								  m)
						))
			);
		};
	return Oe({
		name: "AsyncComponentWrapper",
		__asyncLoader: f,
		get __asyncResolved() {
			return u;
		},
		setup() {
			const p = It;
			if (u) return () => fc(u, p);
			const m = (S) => {
				(a = null), Us(S, p, 13, !r);
			};
			if ((s && p.suspense) || Ys)
				return f()
					.then((S) => () => fc(S, p))
					.catch(
						(S) => (m(S), () => (r ? ve(r, { error: S }) : null))
					);
			const y = Q(!1),
				v = Q(),
				w = Q(!!o);
			return (
				o &&
					setTimeout(() => {
						w.value = !1;
					}, o),
				i != null &&
					setTimeout(() => {
						if (!y.value && !v.value) {
							const S = new Error(
								`Async component timed out after ${i}ms.`
							);
							m(S), (v.value = S);
						}
					}, i),
				f()
					.then(() => {
						(y.value = !0),
							p.parent &&
								Ks(p.parent.vnode) &&
								((p.parent.effect.dirty = !0),
								wu(p.parent.update));
					})
					.catch((S) => {
						m(S), (v.value = S);
					}),
				() => {
					if (y.value && u) return fc(u, p);
					if (v.value && r) return ve(r, { error: v.value });
					if (n && !w.value) return ve(n);
				}
			);
		},
	});
}
function fc(t, e) {
	const { ref: n, props: r, children: o, ce: i } = e.vnode,
		s = ve(t, r, o);
	return (s.ref = n), (s.ce = i), delete e.vnode.ce, s;
}
const Ks = (t) => t.type.__isKeepAlive;
function xw(t, e) {
	h0(t, "a", e);
}
function kw(t, e) {
	h0(t, "da", e);
}
function h0(t, e, n = It) {
	const r =
		t.__wdc ||
		(t.__wdc = () => {
			let o = n;
			for (; o; ) {
				if (o.isDeactivated) return;
				o = o.parent;
			}
			return t();
		});
	if ((Su(e, r, n), n)) {
		let o = n.parent;
		for (; o && o.parent; )
			Ks(o.parent.vnode) && Sw(r, e, n, o), (o = o.parent);
	}
}
function Sw(t, e, n, r) {
	const o = Su(e, t, r, !0);
	zt(() => {
		Ef(r[e], o);
	}, n);
}
function Su(t, e, n = It, r = !1) {
	if (n) {
		const o = n[t] || (n[t] = []),
			i =
				e.__weh ||
				(e.__weh = (...s) => {
					if (n.isUnmounted) return;
					Uo();
					const l = Gs(n),
						a = En(e, n, t, s);
					return l(), Ko(), a;
				});
		return r ? o.unshift(i) : o.push(i), i;
	}
}
const Tr =
		(t) =>
		(e, n = It) =>
			(!Ys || t === "sp") && Su(t, (...r) => e(...r), n),
	_w = Tr("bm"),
	Ze = Tr("m"),
	Cw = Tr("bu"),
	p0 = Tr("u"),
	qs = Tr("bum"),
	zt = Tr("um"),
	Mw = Tr("sp"),
	Ew = Tr("rtg"),
	Tw = Tr("rtc");
function Aw(t, e = It) {
	Su("ec", t, e);
}
function Rt(t, e, n, r) {
	let o;
	const i = n && n[r];
	if (ke(t) || gt(t)) {
		o = new Array(t.length);
		for (let s = 0, l = t.length; s < l; s++)
			o[s] = e(t[s], s, void 0, i && i[s]);
	} else if (typeof t == "number") {
		o = new Array(t);
		for (let s = 0; s < t; s++) o[s] = e(s + 1, s, void 0, i && i[s]);
	} else if (dt(t))
		if (t[Symbol.iterator])
			o = Array.from(t, (s, l) => e(s, l, void 0, i && i[l]));
		else {
			const s = Object.keys(t);
			o = new Array(s.length);
			for (let l = 0, a = s.length; l < a; l++) {
				const u = s[l];
				o[l] = e(t[u], u, l, i && i[l]);
			}
		}
	else o = [];
	return n && (n[r] = o), o;
}
function hc(t, e) {
	for (let n = 0; n < e.length; n++) {
		const r = e[n];
		if (ke(r)) for (let o = 0; o < r.length; o++) t[r[o].name] = r[o].fn;
		else
			r &&
				(t[r.name] = r.key
					? (...o) => {
							const i = r.fn(...o);
							return i && (i.key = r.key), i;
					  }
					: r.fn);
	}
	return t;
}
function xe(t, e, n = {}, r, o) {
	if (Tt.isCE || (Tt.parent && ss(Tt.parent) && Tt.parent.isCE))
		return e !== "default" && (n.name = e), ve("slot", n, r && r());
	let i = t[e];
	i && i._c && (i._d = !1), N();
	const s = i && m0(i(n)),
		l = Te(
			Ne,
			{ key: n.key || (s && s.key) || `_${e}` },
			s || (r ? r() : []),
			s && t._ === 1 ? 64 : -2
		);
	return (
		!o && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]),
		i && i._c && (i._d = !0),
		l
	);
}
function m0(t) {
	return t.some((e) =>
		ha(e) ? !(e.type === Tn || (e.type === Ne && !m0(e.children))) : !0
	)
		? t
		: null;
}
const dd = (t) => (t ? (T0(t) ? Eu(t) || t.proxy : dd(t.parent)) : null),
	ls = _t(Object.create(null), {
		$: (t) => t,
		$el: (t) => t.vnode.el,
		$data: (t) => t.data,
		$props: (t) => t.props,
		$attrs: (t) => t.attrs,
		$slots: (t) => t.slots,
		$refs: (t) => t.refs,
		$parent: (t) => dd(t.parent),
		$root: (t) => dd(t.root),
		$emit: (t) => t.emit,
		$options: (t) => Hf(t),
		$forceUpdate: (t) =>
			t.f ||
			(t.f = () => {
				(t.effect.dirty = !0), wu(t.update);
			}),
		$nextTick: (t) => t.n || (t.n = bt.bind(t.proxy)),
		$watch: (t) => vw.bind(t),
	}),
	pc = (t, e) => t !== lt && !t.__isScriptSetup && Xe(t, e),
	Ow = {
		get({ _: t }, e) {
			const {
				ctx: n,
				setupState: r,
				data: o,
				props: i,
				accessCache: s,
				type: l,
				appContext: a,
			} = t;
			let u;
			if (e[0] !== "$") {
				const p = s[e];
				if (p !== void 0)
					switch (p) {
						case 1:
							return r[e];
						case 2:
							return o[e];
						case 4:
							return n[e];
						case 3:
							return i[e];
					}
				else {
					if (pc(r, e)) return (s[e] = 1), r[e];
					if (o !== lt && Xe(o, e)) return (s[e] = 2), o[e];
					if ((u = t.propsOptions[0]) && Xe(u, e))
						return (s[e] = 3), i[e];
					if (n !== lt && Xe(n, e)) return (s[e] = 4), n[e];
					fd && (s[e] = 0);
				}
			}
			const c = ls[e];
			let d, f;
			if (c) return e === "$attrs" && dn(t, "get", e), c(t);
			if ((d = l.__cssModules) && (d = d[e])) return d;
			if (n !== lt && Xe(n, e)) return (s[e] = 4), n[e];
			if (((f = a.config.globalProperties), Xe(f, e))) return f[e];
		},
		set({ _: t }, e, n) {
			const { data: r, setupState: o, ctx: i } = t;
			return pc(o, e)
				? ((o[e] = n), !0)
				: r !== lt && Xe(r, e)
				? ((r[e] = n), !0)
				: Xe(t.props, e) || (e[0] === "$" && e.slice(1) in t)
				? !1
				: ((i[e] = n), !0);
		},
		has(
			{
				_: {
					data: t,
					setupState: e,
					accessCache: n,
					ctx: r,
					appContext: o,
					propsOptions: i,
				},
			},
			s
		) {
			let l;
			return (
				!!n[s] ||
				(t !== lt && Xe(t, s)) ||
				pc(e, s) ||
				((l = i[0]) && Xe(l, s)) ||
				Xe(r, s) ||
				Xe(ls, s) ||
				Xe(o.config.globalProperties, s)
			);
		},
		defineProperty(t, e, n) {
			return (
				n.get != null
					? (t._.accessCache[e] = 0)
					: Xe(n, "value") && this.set(t, e, n.value, null),
				Reflect.defineProperty(t, e, n)
			);
		},
	};
function zf() {
	return g0().slots;
}
function Js() {
	return g0().attrs;
}
function g0() {
	const t = uo();
	return t.setupContext || (t.setupContext = O0(t));
}
function da(t) {
	return ke(t) ? t.reduce((e, n) => ((e[n] = null), e), {}) : t;
}
function pL(t, e) {
	return !t || !e
		? t || e
		: ke(t) && ke(e)
		? t.concat(e)
		: _t({}, da(t), da(e));
}
let fd = !0;
function Rw(t) {
	const e = Hf(t),
		n = t.proxy,
		r = t.ctx;
	(fd = !1), e.beforeCreate && gp(e.beforeCreate, t, "bc");
	const {
		data: o,
		computed: i,
		methods: s,
		watch: l,
		provide: a,
		inject: u,
		created: c,
		beforeMount: d,
		mounted: f,
		beforeUpdate: p,
		updated: m,
		activated: y,
		deactivated: v,
		beforeDestroy: w,
		beforeUnmount: S,
		destroyed: E,
		unmounted: h,
		render: b,
		renderTracked: g,
		renderTriggered: x,
		errorCaptured: k,
		serverPrefetch: C,
		expose: _,
		inheritAttrs: T,
		components: R,
		directives: P,
		filters: D,
	} = e;
	if ((u && Pw(u, r, null), s))
		for (const I in s) {
			const $ = s[I];
			Ie($) && (r[I] = $.bind(n));
		}
	if (o) {
		const I = o.call(n, n);
		dt(I) && (t.data = Yt(I));
	}
	if (((fd = !0), i))
		for (const I in i) {
			const $ = i[I],
				K = Ie($) ? $.bind(n, n) : Ie($.get) ? $.get.bind(n, n) : Mn,
				ie = !Ie($) && Ie($.set) ? $.set.bind(n) : Mn,
				X = z({ get: K, set: ie });
			Object.defineProperty(r, I, {
				enumerable: !0,
				configurable: !0,
				get: () => X.value,
				set: (de) => (X.value = de),
			});
		}
	if (l) for (const I in l) y0(l[I], r, n, I);
	if (a) {
		const I = Ie(a) ? a.call(n) : a;
		Reflect.ownKeys(I).forEach(($) => {
			wt($, I[$]);
		});
	}
	c && gp(c, t, "c");
	function M(I, $) {
		ke($) ? $.forEach((K) => I(K.bind(n))) : $ && I($.bind(n));
	}
	if (
		(M(_w, d),
		M(Ze, f),
		M(Cw, p),
		M(p0, m),
		M(xw, y),
		M(kw, v),
		M(Aw, k),
		M(Tw, g),
		M(Ew, x),
		M(qs, S),
		M(zt, h),
		M(Mw, C),
		ke(_))
	)
		if (_.length) {
			const I = t.exposed || (t.exposed = {});
			_.forEach(($) => {
				Object.defineProperty(I, $, {
					get: () => n[$],
					set: (K) => (n[$] = K),
				});
			});
		} else t.exposed || (t.exposed = {});
	b && t.render === Mn && (t.render = b),
		T != null && (t.inheritAttrs = T),
		R && (t.components = R),
		P && (t.directives = P);
}
function Pw(t, e, n = Mn) {
	ke(t) && (t = hd(t));
	for (const r in t) {
		const o = t[r];
		let i;
		dt(o)
			? "default" in o
				? (i = Ge(o.from || r, o.default, !0))
				: (i = Ge(o.from || r))
			: (i = Ge(o)),
			Jt(i)
				? Object.defineProperty(e, r, {
						enumerable: !0,
						configurable: !0,
						get: () => i.value,
						set: (s) => (i.value = s),
				  })
				: (e[r] = i);
	}
}
function gp(t, e, n) {
	En(ke(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy), e, n);
}
function y0(t, e, n, r) {
	const o = r.includes(".") ? u0(n, r) : () => n[r];
	if (gt(t)) {
		const i = e[t];
		Ie(i) && at(o, i);
	} else if (Ie(t)) at(o, t.bind(n));
	else if (dt(t))
		if (ke(t)) t.forEach((i) => y0(i, e, n, r));
		else {
			const i = Ie(t.handler) ? t.handler.bind(n) : e[t.handler];
			Ie(i) && at(o, i, t);
		}
}
function Hf(t) {
	const e = t.type,
		{ mixins: n, extends: r } = e,
		{
			mixins: o,
			optionsCache: i,
			config: { optionMergeStrategies: s },
		} = t.appContext,
		l = i.get(e);
	let a;
	return (
		l
			? (a = l)
			: !o.length && !n && !r
			? (a = e)
			: ((a = {}),
			  o.length && o.forEach((u) => fa(a, u, s, !0)),
			  fa(a, e, s)),
		dt(e) && i.set(e, a),
		a
	);
}
function fa(t, e, n, r = !1) {
	const { mixins: o, extends: i } = e;
	i && fa(t, i, n, !0), o && o.forEach((s) => fa(t, s, n, !0));
	for (const s in e)
		if (!(r && s === "expose")) {
			const l = Iw[s] || (n && n[s]);
			t[s] = l ? l(t[s], e[s]) : e[s];
		}
	return t;
}
const Iw = {
	data: yp,
	props: vp,
	emits: vp,
	methods: Zi,
	computed: Zi,
	beforeCreate: Zt,
	created: Zt,
	beforeMount: Zt,
	mounted: Zt,
	beforeUpdate: Zt,
	updated: Zt,
	beforeDestroy: Zt,
	beforeUnmount: Zt,
	destroyed: Zt,
	unmounted: Zt,
	activated: Zt,
	deactivated: Zt,
	errorCaptured: Zt,
	serverPrefetch: Zt,
	components: Zi,
	directives: Zi,
	watch: Dw,
	provide: yp,
	inject: Nw,
};
function yp(t, e) {
	return e
		? t
			? function () {
					return _t(
						Ie(t) ? t.call(this, this) : t,
						Ie(e) ? e.call(this, this) : e
					);
			  }
			: e
		: t;
}
function Nw(t, e) {
	return Zi(hd(t), hd(e));
}
function hd(t) {
	if (ke(t)) {
		const e = {};
		for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
		return e;
	}
	return t;
}
function Zt(t, e) {
	return t ? [...new Set([].concat(t, e))] : e;
}
function Zi(t, e) {
	return t ? _t(Object.create(null), t, e) : e;
}
function vp(t, e) {
	return t
		? ke(t) && ke(e)
			? [...new Set([...t, ...e])]
			: _t(Object.create(null), da(t), da(e != null ? e : {}))
		: e;
}
function Dw(t, e) {
	if (!t) return e;
	if (!e) return t;
	const n = _t(Object.create(null), t);
	for (const r in e) n[r] = Zt(t[r], e[r]);
	return n;
}
function v0() {
	return {
		app: null,
		config: {
			isNativeTag: vb,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {},
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap(),
		propsCache: new WeakMap(),
		emitsCache: new WeakMap(),
	};
}
let jw = 0;
function Lw(t, e) {
	return function (r, o = null) {
		Ie(r) || (r = _t({}, r)), o != null && !dt(o) && (o = null);
		const i = v0(),
			s = new WeakSet();
		let l = !1;
		const a = (i.app = {
			_uid: jw++,
			_component: r,
			_props: o,
			_container: null,
			_context: i,
			_instance: null,
			version: sx,
			get config() {
				return i.config;
			},
			set config(u) {},
			use(u, ...c) {
				return (
					s.has(u) ||
						(u && Ie(u.install)
							? (s.add(u), u.install(a, ...c))
							: Ie(u) && (s.add(u), u(a, ...c))),
					a
				);
			},
			mixin(u) {
				return i.mixins.includes(u) || i.mixins.push(u), a;
			},
			component(u, c) {
				return c ? ((i.components[u] = c), a) : i.components[u];
			},
			directive(u, c) {
				return c ? ((i.directives[u] = c), a) : i.directives[u];
			},
			mount(u, c, d) {
				if (!l) {
					const f = ve(r, o);
					return (
						(f.appContext = i),
						d === !0 ? (d = "svg") : d === !1 && (d = void 0),
						c && e ? e(f, u) : t(f, u, d),
						(l = !0),
						(a._container = u),
						(u.__vue_app__ = a),
						Eu(f.component) || f.component.proxy
					);
				}
			},
			unmount() {
				l && (t(null, a._container), delete a._container.__vue_app__);
			},
			provide(u, c) {
				return (i.provides[u] = c), a;
			},
			runWithContext(u) {
				Ts = a;
				try {
					return u();
				} finally {
					Ts = null;
				}
			},
		});
		return a;
	};
}
let Ts = null;
function wt(t, e) {
	if (It) {
		let n = It.provides;
		const r = It.parent && It.parent.provides;
		r === n && (n = It.provides = Object.create(r)), (n[t] = e);
	}
}
function Ge(t, e, n = !1) {
	const r = It || Tt;
	if (r || Ts) {
		const o = r
			? r.parent == null
				? r.vnode.appContext && r.vnode.appContext.provides
				: r.parent.provides
			: Ts._context.provides;
		if (o && t in o) return o[t];
		if (arguments.length > 1) return n && Ie(e) ? e.call(r && r.proxy) : e;
	}
}
function mL() {
	return !!(It || Tt || Ts);
}
function $w(t, e, n, r = !1) {
	const o = {},
		i = {};
	sa(i, Mu, 1), (t.propsDefaults = Object.create(null)), b0(t, e, o, i);
	for (const s in t.propsOptions[0]) s in o || (o[s] = void 0);
	n
		? (t.props = r ? o : J1(o))
		: t.type.props
		? (t.props = o)
		: (t.props = i),
		(t.attrs = i);
}
function Bw(t, e, n, r) {
	const {
			props: o,
			attrs: i,
			vnode: { patchFlag: s },
		} = t,
		l = je(o),
		[a] = t.propsOptions;
	let u = !1;
	if ((r || s > 0) && !(s & 16)) {
		if (s & 8) {
			const c = t.vnode.dynamicProps;
			for (let d = 0; d < c.length; d++) {
				let f = c[d];
				if (xu(t.emitsOptions, f)) continue;
				const p = e[f];
				if (a)
					if (Xe(i, f)) p !== i[f] && ((i[f] = p), (u = !0));
					else {
						const m = Hn(f);
						o[m] = pd(a, l, m, p, t, !1);
					}
				else p !== i[f] && ((i[f] = p), (u = !0));
			}
		}
	} else {
		b0(t, e, o, i) && (u = !0);
		let c;
		for (const d in l)
			(!e || (!Xe(e, d) && ((c = lo(d)) === d || !Xe(e, c)))) &&
				(a
					? n &&
					  (n[d] !== void 0 || n[c] !== void 0) &&
					  (o[d] = pd(a, l, d, void 0, t, !0))
					: delete o[d]);
		if (i !== l)
			for (const d in i) (!e || !Xe(e, d)) && (delete i[d], (u = !0));
	}
	u && Sr(t, "set", "$attrs");
}
function b0(t, e, n, r) {
	const [o, i] = t.propsOptions;
	let s = !1,
		l;
	if (e)
		for (let a in e) {
			if (Vl(a)) continue;
			const u = e[a];
			let c;
			o && Xe(o, (c = Hn(a)))
				? !i || !i.includes(c)
					? (n[c] = u)
					: ((l || (l = {}))[c] = u)
				: xu(t.emitsOptions, a) ||
				  ((!(a in r) || u !== r[a]) && ((r[a] = u), (s = !0)));
		}
	if (i) {
		const a = je(n),
			u = l || lt;
		for (let c = 0; c < i.length; c++) {
			const d = i[c];
			n[d] = pd(o, a, d, u[d], t, !Xe(u, d));
		}
	}
	return s;
}
function pd(t, e, n, r, o, i) {
	const s = t[n];
	if (s != null) {
		const l = Xe(s, "default");
		if (l && r === void 0) {
			const a = s.default;
			if (s.type !== Function && !s.skipFactory && Ie(a)) {
				const { propsDefaults: u } = o;
				if (n in u) r = u[n];
				else {
					const c = Gs(o);
					(r = u[n] = a.call(null, e)), c();
				}
			} else r = a;
		}
		s[0] &&
			(i && !l
				? (r = !1)
				: s[1] && (r === "" || r === lo(n)) && (r = !0));
	}
	return r;
}
function w0(t, e, n = !1) {
	const r = e.propsCache,
		o = r.get(t);
	if (o) return o;
	const i = t.props,
		s = {},
		l = [];
	let a = !1;
	if (!Ie(t)) {
		const c = (d) => {
			a = !0;
			const [f, p] = w0(d, e, !0);
			_t(s, f), p && l.push(...p);
		};
		!n && e.mixins.length && e.mixins.forEach(c),
			t.extends && c(t.extends),
			t.mixins && t.mixins.forEach(c);
	}
	if (!i && !a) return dt(t) && r.set(t, ci), ci;
	if (ke(i))
		for (let c = 0; c < i.length; c++) {
			const d = Hn(i[c]);
			bp(d) && (s[d] = lt);
		}
	else if (i)
		for (const c in i) {
			const d = Hn(c);
			if (bp(d)) {
				const f = i[c],
					p = (s[d] = ke(f) || Ie(f) ? { type: f } : _t({}, f));
				if (p) {
					const m = kp(Boolean, p.type),
						y = kp(String, p.type);
					(p[0] = m > -1),
						(p[1] = y < 0 || m < y),
						(m > -1 || Xe(p, "default")) && l.push(d);
				}
			}
		}
	const u = [s, l];
	return dt(t) && r.set(t, u), u;
}
function bp(t) {
	return t[0] !== "$";
}
function wp(t) {
	const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
	return e ? e[2] : t === null ? "null" : "";
}
function xp(t, e) {
	return wp(t) === wp(e);
}
function kp(t, e) {
	return ke(e) ? e.findIndex((n) => xp(n, t)) : Ie(e) && xp(e, t) ? 0 : -1;
}
const x0 = (t) => t[0] === "_" || t === "$stable",
	Ff = (t) => (ke(t) ? t.map(Yn) : [Yn(t)]),
	zw = (t, e, n) => {
		if (e._n) return e;
		const r = Ce((...o) => Ff(e(...o)), n);
		return (r._c = !1), r;
	},
	k0 = (t, e, n) => {
		const r = t._ctx;
		for (const o in t) {
			if (x0(o)) continue;
			const i = t[o];
			if (Ie(i)) e[o] = zw(o, i, r);
			else if (i != null) {
				const s = Ff(i);
				e[o] = () => s;
			}
		}
	},
	S0 = (t, e) => {
		const n = Ff(e);
		t.slots.default = () => n;
	},
	Hw = (t, e) => {
		if (t.vnode.shapeFlag & 32) {
			const n = e._;
			n ? ((t.slots = je(e)), sa(e, "_", n)) : k0(e, (t.slots = {}));
		} else (t.slots = {}), e && S0(t, e);
		sa(t.slots, Mu, 1);
	},
	Fw = (t, e, n) => {
		const { vnode: r, slots: o } = t;
		let i = !0,
			s = lt;
		if (r.shapeFlag & 32) {
			const l = e._;
			l
				? n && l === 1
					? (i = !1)
					: (_t(o, e), !n && l === 1 && delete o._)
				: ((i = !e.$stable), k0(e, o)),
				(s = e);
		} else e && (S0(t, e), (s = { default: 1 }));
		if (i) for (const l in o) !x0(l) && s[l] == null && delete o[l];
	};
function md(t, e, n, r, o = !1) {
	if (ke(t)) {
		t.forEach((f, p) => md(f, e && (ke(e) ? e[p] : e), n, r, o));
		return;
	}
	if (ss(r) && !o) return;
	const i = r.shapeFlag & 4 ? Eu(r.component) || r.component.proxy : r.el,
		s = o ? null : i,
		{ i: l, r: a } = t,
		u = e && e.r,
		c = l.refs === lt ? (l.refs = {}) : l.refs,
		d = l.setupState;
	if (
		(u != null &&
			u !== a &&
			(gt(u)
				? ((c[u] = null), Xe(d, u) && (d[u] = null))
				: Jt(u) && (u.value = null)),
		Ie(a))
	)
		Zr(a, l, 12, [s, c]);
	else {
		const f = gt(a),
			p = Jt(a),
			m = t.f;
		if (f || p) {
			const y = () => {
				if (m) {
					const v = f ? (Xe(d, a) ? d[a] : c[a]) : a.value;
					o
						? ke(v) && Ef(v, i)
						: ke(v)
						? v.includes(i) || v.push(i)
						: f
						? ((c[a] = [i]), Xe(d, a) && (d[a] = c[a]))
						: ((a.value = [i]), t.k && (c[t.k] = a.value));
				} else
					f
						? ((c[a] = s), Xe(d, a) && (d[a] = s))
						: p && ((a.value = s), t.k && (c[t.k] = s));
			};
			o || m ? y() : ((y.id = -1), sn(y, n));
		}
	}
}
const sn = pw;
function Vw(t) {
	return Ww(t);
}
function Ww(t, e) {
	const n = O1();
	n.__VUE__ = !0;
	const {
			insert: r,
			remove: o,
			patchProp: i,
			createElement: s,
			createText: l,
			createComment: a,
			setText: u,
			setElementText: c,
			parentNode: d,
			nextSibling: f,
			setScopeId: p = Mn,
			insertStaticContent: m,
		} = t,
		y = (
			A,
			O,
			L,
			q = null,
			U = null,
			ee = null,
			ae = void 0,
			Y = null,
			te = !!O.dynamicChildren
		) => {
			if (A === O) return;
			A && !ko(A, O) && ((q = H(A)), de(A, U, ee, !0), (A = null)),
				O.patchFlag === -2 && ((te = !1), (O.dynamicChildren = null));
			const { type: G, ref: ue, shapeFlag: ye } = O;
			switch (G) {
				case Cu:
					v(A, O, L, q);
					break;
				case Tn:
					w(A, O, L, q);
					break;
				case Wl:
					A == null && S(O, L, q, ae);
					break;
				case Ne:
					R(A, O, L, q, U, ee, ae, Y, te);
					break;
				default:
					ye & 1
						? b(A, O, L, q, U, ee, ae, Y, te)
						: ye & 6
						? P(A, O, L, q, U, ee, ae, Y, te)
						: (ye & 64 || ye & 128) &&
						  G.process(A, O, L, q, U, ee, ae, Y, te, ce);
			}
			ue != null && U && md(ue, A && A.ref, ee, O || A, !O);
		},
		v = (A, O, L, q) => {
			if (A == null) r((O.el = l(O.children)), L, q);
			else {
				const U = (O.el = A.el);
				O.children !== A.children && u(U, O.children);
			}
		},
		w = (A, O, L, q) => {
			A == null ? r((O.el = a(O.children || "")), L, q) : (O.el = A.el);
		},
		S = (A, O, L, q) => {
			[A.el, A.anchor] = m(A.children, O, L, q, A.el, A.anchor);
		},
		E = ({ el: A, anchor: O }, L, q) => {
			let U;
			for (; A && A !== O; ) (U = f(A)), r(A, L, q), (A = U);
			r(O, L, q);
		},
		h = ({ el: A, anchor: O }) => {
			let L;
			for (; A && A !== O; ) (L = f(A)), o(A), (A = L);
			o(O);
		},
		b = (A, O, L, q, U, ee, ae, Y, te) => {
			O.type === "svg"
				? (ae = "svg")
				: O.type === "math" && (ae = "mathml"),
				A == null
					? g(O, L, q, U, ee, ae, Y, te)
					: C(A, O, U, ee, ae, Y, te);
		},
		g = (A, O, L, q, U, ee, ae, Y) => {
			let te, G;
			const { props: ue, shapeFlag: ye, transition: me, dirs: _e } = A;
			if (
				((te = A.el = s(A.type, ee, ue && ue.is, ue)),
				ye & 8
					? c(te, A.children)
					: ye & 16 &&
					  k(A.children, te, null, q, U, mc(A, ee), ae, Y),
				_e && go(A, null, q, "created"),
				x(te, A, A.scopeId, ae, q),
				ue)
			) {
				for (const Qe in ue)
					Qe !== "value" &&
						!Vl(Qe) &&
						i(te, Qe, null, ue[Qe], ee, A.children, q, U, De);
				"value" in ue && i(te, "value", null, ue.value, ee),
					(G = ue.onVnodeBeforeMount) && Un(G, q, A);
			}
			_e && go(A, null, q, "beforeMount");
			const $e = Uw(U, me);
			$e && me.beforeEnter(te),
				r(te, O, L),
				((G = ue && ue.onVnodeMounted) || $e || _e) &&
					sn(() => {
						G && Un(G, q, A),
							$e && me.enter(te),
							_e && go(A, null, q, "mounted");
					}, U);
		},
		x = (A, O, L, q, U) => {
			if ((L && p(A, L), q))
				for (let ee = 0; ee < q.length; ee++) p(A, q[ee]);
			if (U) {
				let ee = U.subTree;
				if (O === ee) {
					const ae = U.vnode;
					x(A, ae, ae.scopeId, ae.slotScopeIds, U.parent);
				}
			}
		},
		k = (A, O, L, q, U, ee, ae, Y, te = 0) => {
			for (let G = te; G < A.length; G++) {
				const ue = (A[G] = Y ? $r(A[G]) : Yn(A[G]));
				y(null, ue, O, L, q, U, ee, ae, Y);
			}
		},
		C = (A, O, L, q, U, ee, ae) => {
			const Y = (O.el = A.el);
			let { patchFlag: te, dynamicChildren: G, dirs: ue } = O;
			te |= A.patchFlag & 16;
			const ye = A.props || lt,
				me = O.props || lt;
			let _e;
			if (
				(L && yo(L, !1),
				(_e = me.onVnodeBeforeUpdate) && Un(_e, L, O, A),
				ue && go(O, A, L, "beforeUpdate"),
				L && yo(L, !0),
				G
					? _(A.dynamicChildren, G, Y, L, q, mc(O, U), ee)
					: ae || $(A, O, Y, null, L, q, mc(O, U), ee, !1),
				te > 0)
			) {
				if (te & 16) T(Y, O, ye, me, L, q, U);
				else if (
					(te & 2 &&
						ye.class !== me.class &&
						i(Y, "class", null, me.class, U),
					te & 4 && i(Y, "style", ye.style, me.style, U),
					te & 8)
				) {
					const $e = O.dynamicProps;
					for (let Qe = 0; Qe < $e.length; Qe++) {
						const st = $e[Qe],
							Ct = ye[st],
							hn = me[st];
						(hn !== Ct || st === "value") &&
							i(Y, st, Ct, hn, U, A.children, L, q, De);
					}
				}
				te & 1 && A.children !== O.children && c(Y, O.children);
			} else !ae && G == null && T(Y, O, ye, me, L, q, U);
			((_e = me.onVnodeUpdated) || ue) &&
				sn(() => {
					_e && Un(_e, L, O, A), ue && go(O, A, L, "updated");
				}, q);
		},
		_ = (A, O, L, q, U, ee, ae) => {
			for (let Y = 0; Y < O.length; Y++) {
				const te = A[Y],
					G = O[Y],
					ue =
						te.el &&
						(te.type === Ne || !ko(te, G) || te.shapeFlag & 70)
							? d(te.el)
							: L;
				y(te, G, ue, null, q, U, ee, ae, !0);
			}
		},
		T = (A, O, L, q, U, ee, ae) => {
			if (L !== q) {
				if (L !== lt)
					for (const Y in L)
						!Vl(Y) &&
							!(Y in q) &&
							i(A, Y, L[Y], null, ae, O.children, U, ee, De);
				for (const Y in q) {
					if (Vl(Y)) continue;
					const te = q[Y],
						G = L[Y];
					te !== G &&
						Y !== "value" &&
						i(A, Y, G, te, ae, O.children, U, ee, De);
				}
				"value" in q && i(A, "value", L.value, q.value, ae);
			}
		},
		R = (A, O, L, q, U, ee, ae, Y, te) => {
			const G = (O.el = A ? A.el : l("")),
				ue = (O.anchor = A ? A.anchor : l(""));
			let { patchFlag: ye, dynamicChildren: me, slotScopeIds: _e } = O;
			_e && (Y = Y ? Y.concat(_e) : _e),
				A == null
					? (r(G, L, q),
					  r(ue, L, q),
					  k(O.children || [], L, ue, U, ee, ae, Y, te))
					: ye > 0 && ye & 64 && me && A.dynamicChildren
					? (_(A.dynamicChildren, me, L, U, ee, ae, Y),
					  (O.key != null || (U && O === U.subTree)) && Vf(A, O, !0))
					: $(A, O, L, ue, U, ee, ae, Y, te);
		},
		P = (A, O, L, q, U, ee, ae, Y, te) => {
			(O.slotScopeIds = Y),
				A == null
					? O.shapeFlag & 512
						? U.ctx.activate(O, L, q, ae, te)
						: D(O, L, q, U, ee, ae, te)
					: j(A, O, te);
		},
		D = (A, O, L, q, U, ee, ae) => {
			const Y = (A.component = ex(A, q, U));
			if ((Ks(A) && (Y.ctx.renderer = ce), tx(Y), Y.asyncDep)) {
				if ((U && U.registerDep(Y, M), !A.el)) {
					const te = (Y.subTree = ve(Tn));
					w(null, te, O, L);
				}
			} else M(Y, A, O, L, U, ee, ae);
		},
		j = (A, O, L) => {
			const q = (O.component = A.component);
			if (dw(A, O, L))
				if (q.asyncDep && !q.asyncResolved) {
					I(q, O, L);
					return;
				} else
					(q.next = O),
						iw(q.update),
						(q.effect.dirty = !0),
						q.update();
			else (O.el = A.el), (q.vnode = O);
		},
		M = (A, O, L, q, U, ee, ae) => {
			const Y = () => {
					if (A.isMounted) {
						let {
							next: ue,
							bu: ye,
							u: me,
							parent: _e,
							vnode: $e,
						} = A;
						{
							const Ar = _0(A);
							if (Ar) {
								ue && ((ue.el = $e.el), I(A, ue, ae)),
									Ar.asyncDep.then(() => {
										A.isUnmounted || Y();
									});
								return;
							}
						}
						let Qe = ue,
							st;
						yo(A, !1),
							ue ? ((ue.el = $e.el), I(A, ue, ae)) : (ue = $e),
							ye && ac(ye),
							(st = ue.props && ue.props.onVnodeBeforeUpdate) &&
								Un(st, _e, ue, $e),
							yo(A, !0);
						const Ct = cc(A),
							hn = A.subTree;
						(A.subTree = Ct),
							y(hn, Ct, d(hn.el), H(hn), A, U, ee),
							(ue.el = Ct.el),
							Qe === null && fw(A, Ct.el),
							me && sn(me, U),
							(st = ue.props && ue.props.onVnodeUpdated) &&
								sn(() => Un(st, _e, ue, $e), U);
					} else {
						let ue;
						const { el: ye, props: me } = O,
							{ bm: _e, m: $e, parent: Qe } = A,
							st = ss(O);
						if (
							(yo(A, !1),
							_e && ac(_e),
							!st &&
								(ue = me && me.onVnodeBeforeMount) &&
								Un(ue, Qe, O),
							yo(A, !0),
							ye && Ye)
						) {
							const Ct = () => {
								(A.subTree = cc(A)),
									Ye(ye, A.subTree, A, U, null);
							};
							st
								? O.type
										.__asyncLoader()
										.then(() => !A.isUnmounted && Ct())
								: Ct();
						} else {
							const Ct = (A.subTree = cc(A));
							y(null, Ct, L, q, A, U, ee), (O.el = Ct.el);
						}
						if (
							($e && sn($e, U),
							!st && (ue = me && me.onVnodeMounted))
						) {
							const Ct = O;
							sn(() => Un(ue, Qe, Ct), U);
						}
						(O.shapeFlag & 256 ||
							(Qe && ss(Qe.vnode) && Qe.vnode.shapeFlag & 256)) &&
							A.a &&
							sn(A.a, U),
							(A.isMounted = !0),
							(O = L = q = null);
					}
				},
				te = (A.effect = new Af(Y, Mn, () => wu(G), A.scope)),
				G = (A.update = () => {
					te.dirty && te.run();
				});
			(G.id = A.uid), yo(A, !0), G();
		},
		I = (A, O, L) => {
			O.component = A;
			const q = A.vnode.props;
			(A.vnode = O),
				(A.next = null),
				Bw(A, O.props, q, L),
				Fw(A, O.children, L),
				Uo(),
				fp(A),
				Ko();
		},
		$ = (A, O, L, q, U, ee, ae, Y, te = !1) => {
			const G = A && A.children,
				ue = A ? A.shapeFlag : 0,
				ye = O.children,
				{ patchFlag: me, shapeFlag: _e } = O;
			if (me > 0) {
				if (me & 128) {
					ie(G, ye, L, q, U, ee, ae, Y, te);
					return;
				} else if (me & 256) {
					K(G, ye, L, q, U, ee, ae, Y, te);
					return;
				}
			}
			_e & 8
				? (ue & 16 && De(G, U, ee), ye !== G && c(L, ye))
				: ue & 16
				? _e & 16
					? ie(G, ye, L, q, U, ee, ae, Y, te)
					: De(G, U, ee, !0)
				: (ue & 8 && c(L, ""),
				  _e & 16 && k(ye, L, q, U, ee, ae, Y, te));
		},
		K = (A, O, L, q, U, ee, ae, Y, te) => {
			(A = A || ci), (O = O || ci);
			const G = A.length,
				ue = O.length,
				ye = Math.min(G, ue);
			let me;
			for (me = 0; me < ye; me++) {
				const _e = (O[me] = te ? $r(O[me]) : Yn(O[me]));
				y(A[me], _e, L, null, U, ee, ae, Y, te);
			}
			G > ue
				? De(A, U, ee, !0, !1, ye)
				: k(O, L, q, U, ee, ae, Y, te, ye);
		},
		ie = (A, O, L, q, U, ee, ae, Y, te) => {
			let G = 0;
			const ue = O.length;
			let ye = A.length - 1,
				me = ue - 1;
			for (; G <= ye && G <= me; ) {
				const _e = A[G],
					$e = (O[G] = te ? $r(O[G]) : Yn(O[G]));
				if (ko(_e, $e)) y(_e, $e, L, null, U, ee, ae, Y, te);
				else break;
				G++;
			}
			for (; G <= ye && G <= me; ) {
				const _e = A[ye],
					$e = (O[me] = te ? $r(O[me]) : Yn(O[me]));
				if (ko(_e, $e)) y(_e, $e, L, null, U, ee, ae, Y, te);
				else break;
				ye--, me--;
			}
			if (G > ye) {
				if (G <= me) {
					const _e = me + 1,
						$e = _e < ue ? O[_e].el : q;
					for (; G <= me; )
						y(
							null,
							(O[G] = te ? $r(O[G]) : Yn(O[G])),
							L,
							$e,
							U,
							ee,
							ae,
							Y,
							te
						),
							G++;
				}
			} else if (G > me) for (; G <= ye; ) de(A[G], U, ee, !0), G++;
			else {
				const _e = G,
					$e = G,
					Qe = new Map();
				for (G = $e; G <= me; G++) {
					const pe = (O[G] = te ? $r(O[G]) : Yn(O[G]));
					pe.key != null && Qe.set(pe.key, G);
				}
				let st,
					Ct = 0;
				const hn = me - $e + 1;
				let Ar = !1,
					sl = 0;
				const F = new Array(hn);
				for (G = 0; G < hn; G++) F[G] = 0;
				for (G = _e; G <= ye; G++) {
					const pe = A[G];
					if (Ct >= hn) {
						de(pe, U, ee, !0);
						continue;
					}
					let Fe;
					if (pe.key != null) Fe = Qe.get(pe.key);
					else
						for (st = $e; st <= me; st++)
							if (F[st - $e] === 0 && ko(pe, O[st])) {
								Fe = st;
								break;
							}
					Fe === void 0
						? de(pe, U, ee, !0)
						: ((F[Fe - $e] = G + 1),
						  Fe >= sl ? (sl = Fe) : (Ar = !0),
						  y(pe, O[Fe], L, null, U, ee, ae, Y, te),
						  Ct++);
				}
				const he = Ar ? Kw(F) : ci;
				for (st = he.length - 1, G = hn - 1; G >= 0; G--) {
					const pe = $e + G,
						Fe = O[pe],
						Ue = pe + 1 < ue ? O[pe + 1].el : q;
					F[G] === 0
						? y(null, Fe, L, Ue, U, ee, ae, Y, te)
						: Ar &&
						  (st < 0 || G !== he[st] ? X(Fe, L, Ue, 2) : st--);
				}
			}
		},
		X = (A, O, L, q, U = null) => {
			const {
				el: ee,
				type: ae,
				transition: Y,
				children: te,
				shapeFlag: G,
			} = A;
			if (G & 6) {
				X(A.component.subTree, O, L, q);
				return;
			}
			if (G & 128) {
				A.suspense.move(O, L, q);
				return;
			}
			if (G & 64) {
				ae.move(A, O, L, ce);
				return;
			}
			if (ae === Ne) {
				r(ee, O, L);
				for (let ye = 0; ye < te.length; ye++) X(te[ye], O, L, q);
				r(A.anchor, O, L);
				return;
			}
			if (ae === Wl) {
				E(A, O, L);
				return;
			}
			if (q !== 2 && G & 1 && Y)
				if (q === 0)
					Y.beforeEnter(ee), r(ee, O, L), sn(() => Y.enter(ee), U);
				else {
					const { leave: ye, delayLeave: me, afterLeave: _e } = Y,
						$e = () => r(ee, O, L),
						Qe = () => {
							ye(ee, () => {
								$e(), _e && _e();
							});
						};
					me ? me(ee, $e, Qe) : Qe();
				}
			else r(ee, O, L);
		},
		de = (A, O, L, q = !1, U = !1) => {
			const {
				type: ee,
				props: ae,
				ref: Y,
				children: te,
				dynamicChildren: G,
				shapeFlag: ue,
				patchFlag: ye,
				dirs: me,
			} = A;
			if ((Y != null && md(Y, null, L, A, !0), ue & 256)) {
				O.ctx.deactivate(A);
				return;
			}
			const _e = ue & 1 && me,
				$e = !ss(A);
			let Qe;
			if (
				($e && (Qe = ae && ae.onVnodeBeforeUnmount) && Un(Qe, O, A),
				ue & 6)
			)
				Pe(A.component, L, q);
			else {
				if (ue & 128) {
					A.suspense.unmount(L, q);
					return;
				}
				_e && go(A, null, O, "beforeUnmount"),
					ue & 64
						? A.type.remove(A, O, L, U, ce, q)
						: G && (ee !== Ne || (ye > 0 && ye & 64))
						? De(G, O, L, !1, !0)
						: ((ee === Ne && ye & 384) || (!U && ue & 16)) &&
						  De(te, O, L),
					q && ze(A);
			}
			(($e && (Qe = ae && ae.onVnodeUnmounted)) || _e) &&
				sn(() => {
					Qe && Un(Qe, O, A), _e && go(A, null, O, "unmounted");
				}, L);
		},
		ze = (A) => {
			const { type: O, el: L, anchor: q, transition: U } = A;
			if (O === Ne) {
				Ee(L, q);
				return;
			}
			if (O === Wl) {
				h(A);
				return;
			}
			const ee = () => {
				o(L), U && !U.persisted && U.afterLeave && U.afterLeave();
			};
			if (A.shapeFlag & 1 && U && !U.persisted) {
				const { leave: ae, delayLeave: Y } = U,
					te = () => ae(L, ee);
				Y ? Y(A.el, ee, te) : te();
			} else ee();
		},
		Ee = (A, O) => {
			let L;
			for (; A !== O; ) (L = f(A)), o(A), (A = L);
			o(O);
		},
		Pe = (A, O, L) => {
			const { bum: q, scope: U, update: ee, subTree: ae, um: Y } = A;
			q && ac(q),
				U.stop(),
				ee && ((ee.active = !1), de(ae, A, O, L)),
				Y && sn(Y, O),
				sn(() => {
					A.isUnmounted = !0;
				}, O),
				O &&
					O.pendingBranch &&
					!O.isUnmounted &&
					A.asyncDep &&
					!A.asyncResolved &&
					A.suspenseId === O.pendingId &&
					(O.deps--, O.deps === 0 && O.resolve());
		},
		De = (A, O, L, q = !1, U = !1, ee = 0) => {
			for (let ae = ee; ae < A.length; ae++) de(A[ae], O, L, q, U);
		},
		H = (A) =>
			A.shapeFlag & 6
				? H(A.component.subTree)
				: A.shapeFlag & 128
				? A.suspense.next()
				: f(A.anchor || A.el);
	let Z = !1;
	const oe = (A, O, L) => {
			A == null
				? O._vnode && de(O._vnode, null, null, !0)
				: y(O._vnode || null, A, O, null, null, null, L),
				Z || ((Z = !0), fp(), r0(), (Z = !1)),
				(O._vnode = A);
		},
		ce = {
			p: y,
			um: de,
			m: X,
			r: ze,
			mt: D,
			mc: k,
			pc: $,
			pbc: _,
			n: H,
			o: t,
		};
	let He, Ye;
	return (
		e && ([He, Ye] = e(ce)),
		{ render: oe, hydrate: He, createApp: Lw(oe, He) }
	);
}
function mc({ type: t, props: e }, n) {
	return (n === "svg" && t === "foreignObject") ||
		(n === "mathml" &&
			t === "annotation-xml" &&
			e &&
			e.encoding &&
			e.encoding.includes("html"))
		? void 0
		: n;
}
function yo({ effect: t, update: e }, n) {
	t.allowRecurse = e.allowRecurse = n;
}
function Uw(t, e) {
	return (!t || (t && !t.pendingBranch)) && e && !e.persisted;
}
function Vf(t, e, n = !1) {
	const r = t.children,
		o = e.children;
	if (ke(r) && ke(o))
		for (let i = 0; i < r.length; i++) {
			const s = r[i];
			let l = o[i];
			l.shapeFlag & 1 &&
				!l.dynamicChildren &&
				((l.patchFlag <= 0 || l.patchFlag === 32) &&
					((l = o[i] = $r(o[i])), (l.el = s.el)),
				n || Vf(s, l)),
				l.type === Cu && (l.el = s.el);
		}
}
function Kw(t) {
	const e = t.slice(),
		n = [0];
	let r, o, i, s, l;
	const a = t.length;
	for (r = 0; r < a; r++) {
		const u = t[r];
		if (u !== 0) {
			if (((o = n[n.length - 1]), t[o] < u)) {
				(e[r] = o), n.push(r);
				continue;
			}
			for (i = 0, s = n.length - 1; i < s; )
				(l = (i + s) >> 1), t[n[l]] < u ? (i = l + 1) : (s = l);
			u < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), (n[i] = r));
		}
	}
	for (i = n.length, s = n[i - 1]; i-- > 0; ) (n[i] = s), (s = e[s]);
	return n;
}
function _0(t) {
	const e = t.subTree.component;
	if (e) return e.asyncDep && !e.asyncResolved ? e : _0(e);
}
const qw = (t) => t.__isTeleport,
	as = (t) => t && (t.disabled || t.disabled === ""),
	Sp = (t) => typeof SVGElement != "undefined" && t instanceof SVGElement,
	_p = (t) =>
		typeof MathMLElement == "function" && t instanceof MathMLElement,
	gd = (t, e) => {
		const n = t && t.to;
		return gt(n) ? (e ? e(n) : null) : n;
	},
	Jw = {
		name: "Teleport",
		__isTeleport: !0,
		process(t, e, n, r, o, i, s, l, a, u) {
			const {
					mc: c,
					pc: d,
					pbc: f,
					o: {
						insert: p,
						querySelector: m,
						createText: y,
						createComment: v,
					},
				} = u,
				w = as(e.props);
			let { shapeFlag: S, children: E, dynamicChildren: h } = e;
			if (t == null) {
				const b = (e.el = y("")),
					g = (e.anchor = y(""));
				p(b, n, r), p(g, n, r);
				const x = (e.target = gd(e.props, m)),
					k = (e.targetAnchor = y(""));
				x &&
					(p(k, x),
					s === "svg" || Sp(x)
						? (s = "svg")
						: (s === "mathml" || _p(x)) && (s = "mathml"));
				const C = (_, T) => {
					S & 16 && c(E, _, T, o, i, s, l, a);
				};
				w ? C(n, g) : x && C(x, k);
			} else {
				e.el = t.el;
				const b = (e.anchor = t.anchor),
					g = (e.target = t.target),
					x = (e.targetAnchor = t.targetAnchor),
					k = as(t.props),
					C = k ? n : g,
					_ = k ? b : x;
				if (
					(s === "svg" || Sp(g)
						? (s = "svg")
						: (s === "mathml" || _p(g)) && (s = "mathml"),
					h
						? (f(t.dynamicChildren, h, C, o, i, s, l), Vf(t, e, !0))
						: a || d(t, e, C, _, o, i, s, l, !1),
					w)
				)
					k
						? e.props &&
						  t.props &&
						  e.props.to !== t.props.to &&
						  (e.props.to = t.props.to)
						: vl(e, n, b, u, 1);
				else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
					const T = (e.target = gd(e.props, m));
					T && vl(e, T, null, u, 0);
				} else k && vl(e, g, x, u, 1);
			}
			C0(e);
		},
		remove(t, e, n, r, { um: o, o: { remove: i } }, s) {
			const {
				shapeFlag: l,
				children: a,
				anchor: u,
				targetAnchor: c,
				target: d,
				props: f,
			} = t;
			if ((d && i(c), s && i(u), l & 16)) {
				const p = s || !as(f);
				for (let m = 0; m < a.length; m++) {
					const y = a[m];
					o(y, e, n, p, !!y.dynamicChildren);
				}
			}
		},
		move: vl,
		hydrate: Gw,
	};
function vl(t, e, n, { o: { insert: r }, m: o }, i = 2) {
	i === 0 && r(t.targetAnchor, e, n);
	const { el: s, anchor: l, shapeFlag: a, children: u, props: c } = t,
		d = i === 2;
	if ((d && r(s, e, n), (!d || as(c)) && a & 16))
		for (let f = 0; f < u.length; f++) o(u[f], e, n, 2);
	d && r(l, e, n);
}
function Gw(
	t,
	e,
	n,
	r,
	o,
	i,
	{ o: { nextSibling: s, parentNode: l, querySelector: a } },
	u
) {
	const c = (e.target = gd(e.props, a));
	if (c) {
		const d = c._lpa || c.firstChild;
		if (e.shapeFlag & 16)
			if (as(e.props))
				(e.anchor = u(s(t), e, l(t), n, r, o, i)), (e.targetAnchor = d);
			else {
				e.anchor = s(t);
				let f = d;
				for (; f; )
					if (
						((f = s(f)),
						f && f.nodeType === 8 && f.data === "teleport anchor")
					) {
						(e.targetAnchor = f),
							(c._lpa = e.targetAnchor && s(e.targetAnchor));
						break;
					}
				u(d, e, c, n, r, o, i);
			}
		C0(e);
	}
	return e.anchor && s(e.anchor);
}
const _u = Jw;
function C0(t) {
	const e = t.ctx;
	if (e && e.ut) {
		let n = t.children[0].el;
		for (; n && n !== t.targetAnchor; )
			n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid),
				(n = n.nextSibling);
		e.ut();
	}
}
const Ne = Symbol.for("v-fgt"),
	Cu = Symbol.for("v-txt"),
	Tn = Symbol.for("v-cmt"),
	Wl = Symbol.for("v-stc"),
	us = [];
let Ln = null;
function N(t = !1) {
	us.push((Ln = t ? null : []));
}
function Yw() {
	us.pop(), (Ln = us[us.length - 1] || null);
}
let As = 1;
function Cp(t) {
	As += t;
}
function M0(t) {
	return (
		(t.dynamicChildren = As > 0 ? Ln || ci : null),
		Yw(),
		As > 0 && Ln && Ln.push(t),
		t
	);
}
function W(t, e, n, r, o, i) {
	return M0(V(t, e, n, r, o, i, !0));
}
function Te(t, e, n, r, o) {
	return M0(ve(t, e, n, r, o, !0));
}
function ha(t) {
	return t ? t.__v_isVNode === !0 : !1;
}
function ko(t, e) {
	return t.type === e.type && t.key === e.key;
}
const Mu = "__vInternal",
	E0 = ({ key: t }) => (t != null ? t : null),
	Ul = ({ ref: t, ref_key: e, ref_for: n }) => (
		typeof t == "number" && (t = "" + t),
		t != null
			? gt(t) || Jt(t) || Ie(t)
				? { i: Tt, r: t, k: e, f: !!n }
				: t
			: null
	);
function V(
	t,
	e = null,
	n = null,
	r = 0,
	o = null,
	i = t === Ne ? 0 : 1,
	s = !1,
	l = !1
) {
	const a = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: t,
		props: e,
		key: e && E0(e),
		ref: e && Ul(e),
		scopeId: s0,
		slotScopeIds: null,
		children: n,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: i,
		patchFlag: r,
		dynamicProps: o,
		dynamicChildren: null,
		appContext: null,
		ctx: Tt,
	};
	return (
		l
			? (Wf(a, n), i & 128 && t.normalize(a))
			: n && (a.shapeFlag |= gt(n) ? 8 : 16),
		As > 0 &&
			!s &&
			Ln &&
			(a.patchFlag > 0 || i & 6) &&
			a.patchFlag !== 32 &&
			Ln.push(a),
		a
	);
}
const ve = Qw;
function Qw(t, e = null, n = null, r = 0, o = null, i = !1) {
	if (((!t || t === l0) && (t = Tn), ha(t))) {
		const l = sr(t, e, !0);
		return (
			n && Wf(l, n),
			As > 0 &&
				!i &&
				Ln &&
				(l.shapeFlag & 6 ? (Ln[Ln.indexOf(t)] = l) : Ln.push(l)),
			(l.patchFlag |= -2),
			l
		);
	}
	if ((ix(t) && (t = t.__vccOpts), e)) {
		e = Lt(e);
		let { class: l, style: a } = e;
		l && !gt(l) && (e.class = be(l)),
			dt(a) && (G1(a) && !ke(a) && (a = _t({}, a)), (e.style = ao(a)));
	}
	const s = gt(t) ? 1 : hw(t) ? 128 : qw(t) ? 64 : dt(t) ? 4 : Ie(t) ? 2 : 0;
	return V(t, e, n, r, o, s, i, !0);
}
function Lt(t) {
	return t ? (G1(t) || Mu in t ? _t({}, t) : t) : null;
}
function sr(t, e, n = !1) {
	const { props: r, ref: o, patchFlag: i, children: s } = t,
		l = e ? pt(r || {}, e) : r;
	return {
		__v_isVNode: !0,
		__v_skip: !0,
		type: t.type,
		props: l,
		key: l && E0(l),
		ref:
			e && e.ref
				? n && o
					? ke(o)
						? o.concat(Ul(e))
						: [o, Ul(e)]
					: Ul(e)
				: o,
		scopeId: t.scopeId,
		slotScopeIds: t.slotScopeIds,
		children: s,
		target: t.target,
		targetAnchor: t.targetAnchor,
		staticCount: t.staticCount,
		shapeFlag: t.shapeFlag,
		patchFlag: e && t.type !== Ne ? (i === -1 ? 16 : i | 16) : i,
		dynamicProps: t.dynamicProps,
		dynamicChildren: t.dynamicChildren,
		appContext: t.appContext,
		dirs: t.dirs,
		transition: t.transition,
		component: t.component,
		suspense: t.suspense,
		ssContent: t.ssContent && sr(t.ssContent),
		ssFallback: t.ssFallback && sr(t.ssFallback),
		el: t.el,
		anchor: t.anchor,
		ctx: t.ctx,
		ce: t.ce,
	};
}
function lr(t = " ", e = 0) {
	return ve(Cu, null, t, e);
}
function gL(t, e) {
	const n = ve(Wl, null, t);
	return (n.staticCount = e), n;
}
function Re(t = "", e = !1) {
	return e ? (N(), Te(Tn, null, t)) : ve(Tn, null, t);
}
function Yn(t) {
	return t == null || typeof t == "boolean"
		? ve(Tn)
		: ke(t)
		? ve(Ne, null, t.slice())
		: typeof t == "object"
		? $r(t)
		: ve(Cu, null, String(t));
}
function $r(t) {
	return (t.el === null && t.patchFlag !== -1) || t.memo ? t : sr(t);
}
function Wf(t, e) {
	let n = 0;
	const { shapeFlag: r } = t;
	if (e == null) e = null;
	else if (ke(e)) n = 16;
	else if (typeof e == "object")
		if (r & 65) {
			const o = e.default;
			o && (o._c && (o._d = !1), Wf(t, o()), o._c && (o._d = !0));
			return;
		} else {
			n = 32;
			const o = e._;
			!o && !(Mu in e)
				? (e._ctx = Tt)
				: o === 3 &&
				  Tt &&
				  (Tt.slots._ === 1
						? (e._ = 1)
						: ((e._ = 2), (t.patchFlag |= 1024)));
		}
	else
		Ie(e)
			? ((e = { default: e, _ctx: Tt }), (n = 32))
			: ((e = String(e)), r & 64 ? ((n = 16), (e = [lr(e)])) : (n = 8));
	(t.children = e), (t.shapeFlag |= n);
}
function pt(...t) {
	const e = {};
	for (let n = 0; n < t.length; n++) {
		const r = t[n];
		for (const o in r)
			if (o === "class")
				e.class !== r.class && (e.class = be([e.class, r.class]));
			else if (o === "style") e.style = ao([e.style, r.style]);
			else if (fu(o)) {
				const i = e[o],
					s = r[o];
				s &&
					i !== s &&
					!(ke(i) && i.includes(s)) &&
					(e[o] = i ? [].concat(i, s) : s);
			} else o !== "" && (e[o] = r[o]);
	}
	return e;
}
function Un(t, e, n, r = null) {
	En(t, e, 7, [n, r]);
}
const Xw = v0();
let Zw = 0;
function ex(t, e, n) {
	const r = t.type,
		o = (e ? e.appContext : t.appContext) || Xw,
		i = {
			uid: Zw++,
			vnode: t,
			type: r,
			parent: e,
			appContext: o,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			scope: new I1(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: e ? e.provides : Object.create(o.provides),
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: w0(r, o),
			emitsOptions: i0(r, o),
			emit: null,
			emitted: null,
			propsDefaults: lt,
			inheritAttrs: r.inheritAttrs,
			ctx: lt,
			data: lt,
			props: lt,
			attrs: lt,
			slots: lt,
			refs: lt,
			setupState: lt,
			setupContext: null,
			attrsProxy: null,
			slotsProxy: null,
			suspense: n,
			suspenseId: n ? n.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null,
		};
	return (
		(i.ctx = { _: i }),
		(i.root = e ? e.root : i),
		(i.emit = aw.bind(null, i)),
		t.ce && t.ce(i),
		i
	);
}
let It = null;
const uo = () => It || Tt;
let pa, yd;
{
	const t = O1(),
		e = (n, r) => {
			let o;
			return (
				(o = t[n]) || (o = t[n] = []),
				o.push(r),
				(i) => {
					o.length > 1 ? o.forEach((s) => s(i)) : o[0](i);
				}
			);
		};
	(pa = e("__VUE_INSTANCE_SETTERS__", (n) => (It = n))),
		(yd = e("__VUE_SSR_SETTERS__", (n) => (Ys = n)));
}
const Gs = (t) => {
		const e = It;
		return (
			pa(t),
			t.scope.on(),
			() => {
				t.scope.off(), pa(e);
			}
		);
	},
	Mp = () => {
		It && It.scope.off(), pa(null);
	};
function T0(t) {
	return t.vnode.shapeFlag & 4;
}
let Ys = !1;
function tx(t, e = !1) {
	e && yd(e);
	const { props: n, children: r } = t.vnode,
		o = T0(t);
	$w(t, n, o, e), Hw(t, r);
	const i = o ? nx(t, e) : void 0;
	return e && yd(!1), i;
}
function nx(t, e) {
	const n = t.type;
	(t.accessCache = Object.create(null)), (t.proxy = vu(new Proxy(t.ctx, Ow)));
	const { setup: r } = n;
	if (r) {
		const o = (t.setupContext = r.length > 1 ? O0(t) : null),
			i = Gs(t);
		Uo();
		const s = Zr(r, t, 0, [t.props, o]);
		if ((Ko(), i(), E1(s))) {
			if ((s.then(Mp, Mp), e))
				return s
					.then((l) => {
						Ep(t, l, e);
					})
					.catch((l) => {
						Us(l, t, 0);
					});
			t.asyncDep = s;
		} else Ep(t, s, e);
	} else A0(t, e);
}
function Ep(t, e, n) {
	Ie(e)
		? t.type.__ssrInlineRender
			? (t.ssrRender = e)
			: (t.render = e)
		: dt(e) && (t.setupState = Z1(e)),
		A0(t, n);
}
let Tp;
function A0(t, e, n) {
	const r = t.type;
	if (!t.render) {
		if (!e && Tp && !r.render) {
			const o = r.template || Hf(t).template;
			if (o) {
				const { isCustomElement: i, compilerOptions: s } =
						t.appContext.config,
					{ delimiters: l, compilerOptions: a } = r,
					u = _t(_t({ isCustomElement: i, delimiters: l }, s), a);
				r.render = Tp(o, u);
			}
		}
		t.render = r.render || Mn;
	}
	{
		const o = Gs(t);
		Uo();
		try {
			Rw(t);
		} finally {
			Ko(), o();
		}
	}
}
function rx(t) {
	return (
		t.attrsProxy ||
		(t.attrsProxy = new Proxy(t.attrs, {
			get(e, n) {
				return dn(t, "get", "$attrs"), e[n];
			},
		}))
	);
}
function O0(t) {
	const e = (n) => {
		t.exposed = n || {};
	};
	return {
		get attrs() {
			return rx(t);
		},
		slots: t.slots,
		emit: t.emit,
		expose: e,
	};
}
function Eu(t) {
	if (t.exposed)
		return (
			t.exposeProxy ||
			(t.exposeProxy = new Proxy(Z1(vu(t.exposed)), {
				get(e, n) {
					if (n in e) return e[n];
					if (n in ls) return ls[n](t);
				},
				has(e, n) {
					return n in e || n in ls;
				},
			}))
		);
}
function ox(t, e = !0) {
	return Ie(t) ? t.displayName || t.name : t.name || (e && t.__name);
}
function ix(t) {
	return Ie(t) && "__vccOpts" in t;
}
const z = (t, e) => Q1(t, e, Ys);
function yL(t, e, n = lt) {
	const r = uo(),
		o = Hn(e),
		i = lo(e),
		s = e0((a, u) => {
			let c;
			return (
				yw(() => {
					const d = t[e];
					ir(c, d) && ((c = d), u());
				}),
				{
					get() {
						return a(), n.get ? n.get(c) : c;
					},
					set(d) {
						const f = r.vnode.props;
						!(
							f &&
							(e in f || o in f || i in f) &&
							(`onUpdate:${e}` in f ||
								`onUpdate:${o}` in f ||
								`onUpdate:${i}` in f)
						) &&
							ir(d, c) &&
							((c = d), u()),
							r.emit(`update:${e}`, n.set ? n.set(d) : d);
					},
				}
			);
		}),
		l = e === "modelValue" ? "modelModifiers" : `${e}Modifiers`;
	return (
		(s[Symbol.iterator] = () => {
			let a = 0;
			return {
				next() {
					return a < 2
						? { value: a++ ? t[l] || {} : s, done: !1 }
						: { done: !0 };
				},
			};
		}),
		s
	);
}
function Ke(t, e, n) {
	const r = arguments.length;
	return r === 2
		? dt(e) && !ke(e)
			? ha(e)
				? ve(t, null, [e])
				: ve(t, e)
			: ve(t, null, e)
		: (r > 3
				? (n = Array.prototype.slice.call(arguments, 2))
				: r === 3 && ha(n) && (n = [n]),
		  ve(t, e, n));
}
const sx = "3.4.15";
/**
 * @vue/runtime-dom v3.4.15
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const lx = "http://www.w3.org/2000/svg",
	ax = "http://www.w3.org/1998/Math/MathML",
	Br = typeof document != "undefined" ? document : null,
	Ap = Br && Br.createElement("template"),
	ux = {
		insert: (t, e, n) => {
			e.insertBefore(t, n || null);
		},
		remove: (t) => {
			const e = t.parentNode;
			e && e.removeChild(t);
		},
		createElement: (t, e, n, r) => {
			const o =
				e === "svg"
					? Br.createElementNS(lx, t)
					: e === "mathml"
					? Br.createElementNS(ax, t)
					: Br.createElement(t, n ? { is: n } : void 0);
			return (
				t === "select" &&
					r &&
					r.multiple != null &&
					o.setAttribute("multiple", r.multiple),
				o
			);
		},
		createText: (t) => Br.createTextNode(t),
		createComment: (t) => Br.createComment(t),
		setText: (t, e) => {
			t.nodeValue = e;
		},
		setElementText: (t, e) => {
			t.textContent = e;
		},
		parentNode: (t) => t.parentNode,
		nextSibling: (t) => t.nextSibling,
		querySelector: (t) => Br.querySelector(t),
		setScopeId(t, e) {
			t.setAttribute(e, "");
		},
		insertStaticContent(t, e, n, r, o, i) {
			const s = n ? n.previousSibling : e.lastChild;
			if (o && (o === i || o.nextSibling))
				for (
					;
					e.insertBefore(o.cloneNode(!0), n),
						!(o === i || !(o = o.nextSibling));

				);
			else {
				Ap.innerHTML =
					r === "svg"
						? `<svg>${t}</svg>`
						: r === "mathml"
						? `<math>${t}</math>`
						: t;
				const l = Ap.content;
				if (r === "svg" || r === "mathml") {
					const a = l.firstChild;
					for (; a.firstChild; ) l.appendChild(a.firstChild);
					l.removeChild(a);
				}
				e.insertBefore(l, n);
			}
			return [
				s ? s.nextSibling : e.firstChild,
				n ? n.previousSibling : e.lastChild,
			];
		},
	},
	Rr = "transition",
	Ui = "animation",
	xi = Symbol("_vtc"),
	Tu = (t, { slots: e }) => Ke(ww, P0(t), e);
Tu.displayName = "Transition";
const R0 = {
		name: String,
		type: String,
		css: { type: Boolean, default: !0 },
		duration: [String, Number, Object],
		enterFromClass: String,
		enterActiveClass: String,
		enterToClass: String,
		appearFromClass: String,
		appearActiveClass: String,
		appearToClass: String,
		leaveFromClass: String,
		leaveActiveClass: String,
		leaveToClass: String,
	},
	cx = (Tu.props = _t({}, d0, R0)),
	vo = (t, e = []) => {
		ke(t) ? t.forEach((n) => n(...e)) : t && t(...e);
	},
	Op = (t) => (t ? (ke(t) ? t.some((e) => e.length > 1) : t.length > 1) : !1);
function P0(t) {
	const e = {};
	for (const R in t) R in R0 || (e[R] = t[R]);
	if (t.css === !1) return e;
	const {
			name: n = "v",
			type: r,
			duration: o,
			enterFromClass: i = `${n}-enter-from`,
			enterActiveClass: s = `${n}-enter-active`,
			enterToClass: l = `${n}-enter-to`,
			appearFromClass: a = i,
			appearActiveClass: u = s,
			appearToClass: c = l,
			leaveFromClass: d = `${n}-leave-from`,
			leaveActiveClass: f = `${n}-leave-active`,
			leaveToClass: p = `${n}-leave-to`,
		} = t,
		m = dx(o),
		y = m && m[0],
		v = m && m[1],
		{
			onBeforeEnter: w,
			onEnter: S,
			onEnterCancelled: E,
			onLeave: h,
			onLeaveCancelled: b,
			onBeforeAppear: g = w,
			onAppear: x = S,
			onAppearCancelled: k = E,
		} = e,
		C = (R, P, D) => {
			Nr(R, P ? c : l), Nr(R, P ? u : s), D && D();
		},
		_ = (R, P) => {
			(R._isLeaving = !1), Nr(R, d), Nr(R, p), Nr(R, f), P && P();
		},
		T = (R) => (P, D) => {
			const j = R ? x : S,
				M = () => C(P, R, D);
			vo(j, [P, M]),
				Rp(() => {
					Nr(P, R ? a : i), yr(P, R ? c : l), Op(j) || Pp(P, r, y, M);
				});
		};
	return _t(e, {
		onBeforeEnter(R) {
			vo(w, [R]), yr(R, i), yr(R, s);
		},
		onBeforeAppear(R) {
			vo(g, [R]), yr(R, a), yr(R, u);
		},
		onEnter: T(!1),
		onAppear: T(!0),
		onLeave(R, P) {
			R._isLeaving = !0;
			const D = () => _(R, P);
			yr(R, d),
				N0(),
				yr(R, f),
				Rp(() => {
					R._isLeaving &&
						(Nr(R, d), yr(R, p), Op(h) || Pp(R, r, v, D));
				}),
				vo(h, [R, D]);
		},
		onEnterCancelled(R) {
			C(R, !1), vo(E, [R]);
		},
		onAppearCancelled(R) {
			C(R, !0), vo(k, [R]);
		},
		onLeaveCancelled(R) {
			_(R), vo(b, [R]);
		},
	});
}
function dx(t) {
	if (t == null) return null;
	if (dt(t)) return [gc(t.enter), gc(t.leave)];
	{
		const e = gc(t);
		return [e, e];
	}
}
function gc(t) {
	return _b(t);
}
function yr(t, e) {
	e.split(/\s+/).forEach((n) => n && t.classList.add(n)),
		(t[xi] || (t[xi] = new Set())).add(e);
}
function Nr(t, e) {
	e.split(/\s+/).forEach((r) => r && t.classList.remove(r));
	const n = t[xi];
	n && (n.delete(e), n.size || (t[xi] = void 0));
}
function Rp(t) {
	requestAnimationFrame(() => {
		requestAnimationFrame(t);
	});
}
let fx = 0;
function Pp(t, e, n, r) {
	const o = (t._endId = ++fx),
		i = () => {
			o === t._endId && r();
		};
	if (n) return setTimeout(i, n);
	const { type: s, timeout: l, propCount: a } = I0(t, e);
	if (!s) return r();
	const u = s + "end";
	let c = 0;
	const d = () => {
			t.removeEventListener(u, f), i();
		},
		f = (p) => {
			p.target === t && ++c >= a && d();
		};
	setTimeout(() => {
		c < a && d();
	}, l + 1),
		t.addEventListener(u, f);
}
function I0(t, e) {
	const n = window.getComputedStyle(t),
		r = (m) => (n[m] || "").split(", "),
		o = r(`${Rr}Delay`),
		i = r(`${Rr}Duration`),
		s = Ip(o, i),
		l = r(`${Ui}Delay`),
		a = r(`${Ui}Duration`),
		u = Ip(l, a);
	let c = null,
		d = 0,
		f = 0;
	e === Rr
		? s > 0 && ((c = Rr), (d = s), (f = i.length))
		: e === Ui
		? u > 0 && ((c = Ui), (d = u), (f = a.length))
		: ((d = Math.max(s, u)),
		  (c = d > 0 ? (s > u ? Rr : Ui) : null),
		  (f = c ? (c === Rr ? i.length : a.length) : 0));
	const p =
		c === Rr &&
		/\b(transform|all)(,|$)/.test(r(`${Rr}Property`).toString());
	return { type: c, timeout: d, propCount: f, hasTransform: p };
}
function Ip(t, e) {
	for (; t.length < e.length; ) t = t.concat(t);
	return Math.max(...e.map((n, r) => Np(n) + Np(t[r])));
}
function Np(t) {
	return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
}
function N0() {
	return document.body.offsetHeight;
}
function hx(t, e, n) {
	const r = t[xi];
	r && (e = (e ? [e, ...r] : [...r]).join(" ")),
		e == null
			? t.removeAttribute("class")
			: n
			? t.setAttribute("class", e)
			: (t.className = e);
}
const Uf = Symbol("_vod"),
	ma = {
		beforeMount(t, { value: e }, { transition: n }) {
			(t[Uf] = t.style.display === "none" ? "" : t.style.display),
				n && e ? n.beforeEnter(t) : Ki(t, e);
		},
		mounted(t, { value: e }, { transition: n }) {
			n && e && n.enter(t);
		},
		updated(t, { value: e, oldValue: n }, { transition: r }) {
			!e != !n &&
				(r
					? e
						? (r.beforeEnter(t), Ki(t, !0), r.enter(t))
						: r.leave(t, () => {
								Ki(t, !1);
						  })
					: Ki(t, e));
		},
		beforeUnmount(t, { value: e }) {
			Ki(t, e);
		},
	};
function Ki(t, e) {
	t.style.display = e ? t[Uf] : "none";
}
const px = Symbol("");
function mx(t, e, n) {
	const r = t.style,
		o = r.display,
		i = gt(n);
	if (n && !i) {
		if (e && !gt(e)) for (const s in e) n[s] == null && vd(r, s, "");
		for (const s in n) vd(r, s, n[s]);
	} else if (i) {
		if (e !== n) {
			const s = r[px];
			s && (n += ";" + s), (r.cssText = n);
		}
	} else e && t.removeAttribute("style");
	Uf in t && (r.display = o);
}
const Dp = /\s*!important$/;
function vd(t, e, n) {
	if (ke(n)) n.forEach((r) => vd(t, e, r));
	else if ((n == null && (n = ""), e.startsWith("--"))) t.setProperty(e, n);
	else {
		const r = gx(t, e);
		Dp.test(n)
			? t.setProperty(lo(r), n.replace(Dp, ""), "important")
			: (t[r] = n);
	}
}
const jp = ["Webkit", "Moz", "ms"],
	yc = {};
function gx(t, e) {
	const n = yc[e];
	if (n) return n;
	let r = Hn(e);
	if (r !== "filter" && r in t) return (yc[e] = r);
	r = mu(r);
	for (let o = 0; o < jp.length; o++) {
		const i = jp[o] + r;
		if (i in t) return (yc[e] = i);
	}
	return e;
}
const Lp = "http://www.w3.org/1999/xlink";
function yx(t, e, n, r, o) {
	if (r && e.startsWith("xlink:"))
		n == null
			? t.removeAttributeNS(Lp, e.slice(6, e.length))
			: t.setAttributeNS(Lp, e, n);
	else {
		const i = Ob(e);
		n == null || (i && !R1(n))
			? t.removeAttribute(e)
			: t.setAttribute(e, i ? "" : n);
	}
}
function vx(t, e, n, r, o, i, s) {
	if (e === "innerHTML" || e === "textContent") {
		r && s(r, o, i), (t[e] = n == null ? "" : n);
		return;
	}
	const l = t.tagName;
	if (e === "value" && l !== "PROGRESS" && !l.includes("-")) {
		t._value = n;
		const u = l === "OPTION" ? t.getAttribute("value") : t.value,
			c = n == null ? "" : n;
		u !== c && (t.value = c), n == null && t.removeAttribute(e);
		return;
	}
	let a = !1;
	if (n === "" || n == null) {
		const u = typeof t[e];
		u === "boolean"
			? (n = R1(n))
			: n == null && u === "string"
			? ((n = ""), (a = !0))
			: u === "number" && ((n = 0), (a = !0));
	}
	try {
		t[e] = n;
	} catch (u) {}
	a && t.removeAttribute(e);
}
function bx(t, e, n, r) {
	t.addEventListener(e, n, r);
}
function wx(t, e, n, r) {
	t.removeEventListener(e, n, r);
}
const $p = Symbol("_vei");
function xx(t, e, n, r, o = null) {
	const i = t[$p] || (t[$p] = {}),
		s = i[e];
	if (r && s) s.value = r;
	else {
		const [l, a] = kx(e);
		if (r) {
			const u = (i[e] = Cx(r, o));
			bx(t, l, u, a);
		} else s && (wx(t, l, s, a), (i[e] = void 0));
	}
}
const Bp = /(?:Once|Passive|Capture)$/;
function kx(t) {
	let e;
	if (Bp.test(t)) {
		e = {};
		let r;
		for (; (r = t.match(Bp)); )
			(t = t.slice(0, t.length - r[0].length)),
				(e[r[0].toLowerCase()] = !0);
	}
	return [t[2] === ":" ? t.slice(3) : lo(t.slice(2)), e];
}
let vc = 0;
const Sx = Promise.resolve(),
	_x = () => vc || (Sx.then(() => (vc = 0)), (vc = Date.now()));
function Cx(t, e) {
	const n = (r) => {
		if (!r._vts) r._vts = Date.now();
		else if (r._vts <= n.attached) return;
		En(Mx(r, n.value), e, 5, [r]);
	};
	return (n.value = t), (n.attached = _x()), n;
}
function Mx(t, e) {
	if (ke(e)) {
		const n = t.stopImmediatePropagation;
		return (
			(t.stopImmediatePropagation = () => {
				n.call(t), (t._stopped = !0);
			}),
			e.map((r) => (o) => !o._stopped && r && r(o))
		);
	} else return e;
}
const zp = (t) =>
		t.charCodeAt(0) === 111 &&
		t.charCodeAt(1) === 110 &&
		t.charCodeAt(2) > 96 &&
		t.charCodeAt(2) < 123,
	Ex = (t, e, n, r, o, i, s, l, a) => {
		const u = o === "svg";
		e === "class"
			? hx(t, r, u)
			: e === "style"
			? mx(t, n, r)
			: fu(e)
			? Mf(e) || xx(t, e, n, r, s)
			: (
					e[0] === "."
						? ((e = e.slice(1)), !0)
						: e[0] === "^"
						? ((e = e.slice(1)), !1)
						: Tx(t, e, r, u)
			  )
			? vx(t, e, r, i, s, l, a)
			: (e === "true-value"
					? (t._trueValue = r)
					: e === "false-value" && (t._falseValue = r),
			  yx(t, e, r, u));
	};
function Tx(t, e, n, r) {
	if (r)
		return !!(
			e === "innerHTML" ||
			e === "textContent" ||
			(e in t && zp(e) && Ie(n))
		);
	if (
		e === "spellcheck" ||
		e === "draggable" ||
		e === "translate" ||
		e === "form" ||
		(e === "list" && t.tagName === "INPUT") ||
		(e === "type" && t.tagName === "TEXTAREA")
	)
		return !1;
	if (e === "width" || e === "height") {
		const o = t.tagName;
		if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE")
			return !1;
	}
	return zp(e) && gt(n) ? !1 : e in t;
}
const D0 = new WeakMap(),
	j0 = new WeakMap(),
	ga = Symbol("_moveCb"),
	Hp = Symbol("_enterCb"),
	L0 = {
		name: "TransitionGroup",
		props: _t({}, cx, { tag: String, moveClass: String }),
		setup(t, { slots: e }) {
			const n = uo(),
				r = c0();
			let o, i;
			return (
				p0(() => {
					if (!o.length) return;
					const s = t.moveClass || `${t.name || "v"}-move`;
					if (!Nx(o[0].el, n.vnode.el, s)) return;
					o.forEach(Rx), o.forEach(Px);
					const l = o.filter(Ix);
					N0(),
						l.forEach((a) => {
							const u = a.el,
								c = u.style;
							yr(u, s),
								(c.transform =
									c.webkitTransform =
									c.transitionDuration =
										"");
							const d = (u[ga] = (f) => {
								(f && f.target !== u) ||
									((!f ||
										/transform$/.test(f.propertyName)) &&
										(u.removeEventListener(
											"transitionend",
											d
										),
										(u[ga] = null),
										Nr(u, s)));
							});
							u.addEventListener("transitionend", d);
						});
				}),
				() => {
					const s = je(t),
						l = P0(s);
					let a = s.tag || Ne;
					(o = i), (i = e.default ? Bf(e.default()) : []);
					for (let u = 0; u < i.length; u++) {
						const c = i[u];
						c.key != null && Es(c, Ms(c, l, r, n));
					}
					if (o)
						for (let u = 0; u < o.length; u++) {
							const c = o[u];
							Es(c, Ms(c, l, r, n)),
								D0.set(c, c.el.getBoundingClientRect());
						}
					return ve(a, null, i);
				}
			);
		},
	},
	Ax = (t) => delete t.mode;
L0.props;
const Ox = L0;
function Rx(t) {
	const e = t.el;
	e[ga] && e[ga](), e[Hp] && e[Hp]();
}
function Px(t) {
	j0.set(t, t.el.getBoundingClientRect());
}
function Ix(t) {
	const e = D0.get(t),
		n = j0.get(t),
		r = e.left - n.left,
		o = e.top - n.top;
	if (r || o) {
		const i = t.el.style;
		return (
			(i.transform = i.webkitTransform = `translate(${r}px,${o}px)`),
			(i.transitionDuration = "0s"),
			t
		);
	}
}
function Nx(t, e, n) {
	const r = t.cloneNode(),
		o = t[xi];
	o &&
		o.forEach((l) => {
			l.split(/\s+/).forEach((a) => a && r.classList.remove(a));
		}),
		n.split(/\s+/).forEach((l) => l && r.classList.add(l)),
		(r.style.display = "none");
	const i = e.nodeType === 1 ? e : e.parentNode;
	i.appendChild(r);
	const { hasTransform: s } = I0(r);
	return i.removeChild(r), s;
}
const Dx = ["ctrl", "shift", "alt", "meta"],
	jx = {
		stop: (t) => t.stopPropagation(),
		prevent: (t) => t.preventDefault(),
		self: (t) => t.target !== t.currentTarget,
		ctrl: (t) => !t.ctrlKey,
		shift: (t) => !t.shiftKey,
		alt: (t) => !t.altKey,
		meta: (t) => !t.metaKey,
		left: (t) => "button" in t && t.button !== 0,
		middle: (t) => "button" in t && t.button !== 1,
		right: (t) => "button" in t && t.button !== 2,
		exact: (t, e) => Dx.some((n) => t[`${n}Key`] && !e.includes(n)),
	},
	$0 = (t, e) => {
		const n = t._withMods || (t._withMods = {}),
			r = e.join(".");
		return (
			n[r] ||
			(n[r] = (o, ...i) => {
				for (let s = 0; s < e.length; s++) {
					const l = jx[e[s]];
					if (l && l(o, e)) return;
				}
				return t(o, ...i);
			})
		);
	},
	Lx = {
		esc: "escape",
		space: " ",
		up: "arrow-up",
		left: "arrow-left",
		right: "arrow-right",
		down: "arrow-down",
		delete: "backspace",
	},
	vL = (t, e) => {
		const n = t._withKeys || (t._withKeys = {}),
			r = e.join(".");
		return (
			n[r] ||
			(n[r] = (o) => {
				if (!("key" in o)) return;
				const i = lo(o.key);
				if (e.some((s) => s === i || Lx[s] === i)) return t(o);
			})
		);
	},
	$x = _t({ patchProp: Ex }, ux);
let Fp;
function Bx() {
	return Fp || (Fp = Vw($x));
}
const bL = (...t) => {
	const e = Bx().createApp(...t),
		{ mount: n } = e;
	return (
		(e.mount = (r) => {
			const o = Hx(r);
			if (!o) return;
			const i = e._component;
			!Ie(i) && !i.render && !i.template && (i.template = o.innerHTML),
				(o.innerHTML = "");
			const s = n(o, !1, zx(o));
			return (
				o instanceof Element &&
					(o.removeAttribute("v-cloak"),
					o.setAttribute("data-v-app", "")),
				s
			);
		}),
		e
	);
};
function zx(t) {
	if (t instanceof SVGElement) return "svg";
	if (typeof MathMLElement == "function" && t instanceof MathMLElement)
		return "mathml";
}
function Hx(t) {
	return gt(t) ? document.querySelector(t) : t;
}
const Fx = "modulepreload",
	Vx = function (t) {
		return "/" + t;
	},
	Vp = {},
	bl = function (e, n, r) {
		let o = Promise.resolve();
		if (n && n.length > 0) {
			const i = document.getElementsByTagName("link");
			o = Promise.all(
				n.map((s) => {
					if (((s = Vx(s)), s in Vp)) return;
					Vp[s] = !0;
					const l = s.endsWith(".css"),
						a = l ? '[rel="stylesheet"]' : "";
					if (!!r)
						for (let d = i.length - 1; d >= 0; d--) {
							const f = i[d];
							if (f.href === s && (!l || f.rel === "stylesheet"))
								return;
						}
					else if (document.querySelector(`link[href="${s}"]${a}`))
						return;
					const c = document.createElement("link");
					if (
						((c.rel = l ? "stylesheet" : Fx),
						l || ((c.as = "script"), (c.crossOrigin = "")),
						(c.href = s),
						document.head.appendChild(c),
						l)
					)
						return new Promise((d, f) => {
							c.addEventListener("load", d),
								c.addEventListener("error", () =>
									f(
										new Error(
											`Unable to preload CSS for ${s}`
										)
									)
								);
						});
				})
			);
		}
		return o
			.then(() => e())
			.catch((i) => {
				const s = new Event("vite:preloadError", { cancelable: !0 });
				if (
					((s.payload = i),
					window.dispatchEvent(s),
					!s.defaultPrevented)
				)
					throw i;
			});
	};
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */ const ti = typeof window != "undefined";
function Wx(t) {
	return t.__esModule || t[Symbol.toStringTag] === "Module";
}
const nt = Object.assign;
function bc(t, e) {
	const n = {};
	for (const r in e) {
		const o = e[r];
		n[r] = Fn(o) ? o.map(t) : t(o);
	}
	return n;
}
const cs = () => {},
	Fn = Array.isArray,
	Ux = /\/$/,
	Kx = (t) => t.replace(Ux, "");
function wc(t, e, n = "/") {
	let r,
		o = {},
		i = "",
		s = "";
	const l = e.indexOf("#");
	let a = e.indexOf("?");
	return (
		l < a && l >= 0 && (a = -1),
		a > -1 &&
			((r = e.slice(0, a)),
			(i = e.slice(a + 1, l > -1 ? l : e.length)),
			(o = t(i))),
		l > -1 && ((r = r || e.slice(0, l)), (s = e.slice(l, e.length))),
		(r = Yx(r != null ? r : e, n)),
		{ fullPath: r + (i && "?") + i + s, path: r, query: o, hash: s }
	);
}
function qx(t, e) {
	const n = e.query ? t(e.query) : "";
	return e.path + (n && "?") + n + (e.hash || "");
}
function Wp(t, e) {
	return !e || !t.toLowerCase().startsWith(e.toLowerCase())
		? t
		: t.slice(e.length) || "/";
}
function Jx(t, e, n) {
	const r = e.matched.length - 1,
		o = n.matched.length - 1;
	return (
		r > -1 &&
		r === o &&
		ki(e.matched[r], n.matched[o]) &&
		B0(e.params, n.params) &&
		t(e.query) === t(n.query) &&
		e.hash === n.hash
	);
}
function ki(t, e) {
	return (t.aliasOf || t) === (e.aliasOf || e);
}
function B0(t, e) {
	if (Object.keys(t).length !== Object.keys(e).length) return !1;
	for (const n in t) if (!Gx(t[n], e[n])) return !1;
	return !0;
}
function Gx(t, e) {
	return Fn(t) ? Up(t, e) : Fn(e) ? Up(e, t) : t === e;
}
function Up(t, e) {
	return Fn(e)
		? t.length === e.length && t.every((n, r) => n === e[r])
		: t.length === 1 && t[0] === e;
}
function Yx(t, e) {
	if (t.startsWith("/")) return t;
	if (!t) return e;
	const n = e.split("/"),
		r = t.split("/"),
		o = r[r.length - 1];
	(o === ".." || o === ".") && r.push("");
	let i = n.length - 1,
		s,
		l;
	for (s = 0; s < r.length; s++)
		if (((l = r[s]), l !== "."))
			if (l === "..") i > 1 && i--;
			else break;
	return (
		n.slice(0, i).join("/") +
		"/" +
		r.slice(s - (s === r.length ? 1 : 0)).join("/")
	);
}
var Os;
(function (t) {
	(t.pop = "pop"), (t.push = "push");
})(Os || (Os = {}));
var ds;
(function (t) {
	(t.back = "back"), (t.forward = "forward"), (t.unknown = "");
})(ds || (ds = {}));
function Qx(t) {
	if (!t)
		if (ti) {
			const e = document.querySelector("base");
			(t = (e && e.getAttribute("href")) || "/"),
				(t = t.replace(/^\w+:\/\/[^\/]+/, ""));
		} else t = "/";
	return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), Kx(t);
}
const Xx = /^[^#]+#/;
function Zx(t, e) {
	return t.replace(Xx, "#") + e;
}
function e3(t, e) {
	const n = document.documentElement.getBoundingClientRect(),
		r = t.getBoundingClientRect();
	return {
		behavior: e.behavior,
		left: r.left - n.left - (e.left || 0),
		top: r.top - n.top - (e.top || 0),
	};
}
const Au = () => ({ left: window.pageXOffset, top: window.pageYOffset });
function t3(t) {
	let e;
	if ("el" in t) {
		const n = t.el,
			r = typeof n == "string" && n.startsWith("#"),
			o =
				typeof n == "string"
					? r
						? document.getElementById(n.slice(1))
						: document.querySelector(n)
					: n;
		if (!o) return;
		e = e3(o, t);
	} else e = t;
	"scrollBehavior" in document.documentElement.style
		? window.scrollTo(e)
		: window.scrollTo(
				e.left != null ? e.left : window.pageXOffset,
				e.top != null ? e.top : window.pageYOffset
		  );
}
function Kp(t, e) {
	return (history.state ? history.state.position - e : -1) + t;
}
const bd = new Map();
function n3(t, e) {
	bd.set(t, e);
}
function r3(t) {
	const e = bd.get(t);
	return bd.delete(t), e;
}
let o3 = () => location.protocol + "//" + location.host;
function z0(t, e) {
	const { pathname: n, search: r, hash: o } = e,
		i = t.indexOf("#");
	if (i > -1) {
		let l = o.includes(t.slice(i)) ? t.slice(i).length : 1,
			a = o.slice(l);
		return a[0] !== "/" && (a = "/" + a), Wp(a, "");
	}
	return Wp(n, t) + r + o;
}
function i3(t, e, n, r) {
	let o = [],
		i = [],
		s = null;
	const l = ({ state: f }) => {
		const p = z0(t, location),
			m = n.value,
			y = e.value;
		let v = 0;
		if (f) {
			if (((n.value = p), (e.value = f), s && s === m)) {
				s = null;
				return;
			}
			v = y ? f.position - y.position : 0;
		} else r(p);
		o.forEach((w) => {
			w(n.value, m, {
				delta: v,
				type: Os.pop,
				direction: v ? (v > 0 ? ds.forward : ds.back) : ds.unknown,
			});
		});
	};
	function a() {
		s = n.value;
	}
	function u(f) {
		o.push(f);
		const p = () => {
			const m = o.indexOf(f);
			m > -1 && o.splice(m, 1);
		};
		return i.push(p), p;
	}
	function c() {
		const { history: f } = window;
		f.state && f.replaceState(nt({}, f.state, { scroll: Au() }), "");
	}
	function d() {
		for (const f of i) f();
		(i = []),
			window.removeEventListener("popstate", l),
			window.removeEventListener("beforeunload", c);
	}
	return (
		window.addEventListener("popstate", l),
		window.addEventListener("beforeunload", c, { passive: !0 }),
		{ pauseListeners: a, listen: u, destroy: d }
	);
}
function qp(t, e, n, r = !1, o = !1) {
	return {
		back: t,
		current: e,
		forward: n,
		replaced: r,
		position: window.history.length,
		scroll: o ? Au() : null,
	};
}
function s3(t) {
	const { history: e, location: n } = window,
		r = { value: z0(t, n) },
		o = { value: e.state };
	o.value ||
		i(
			r.value,
			{
				back: null,
				current: r.value,
				forward: null,
				position: e.length - 1,
				replaced: !0,
				scroll: null,
			},
			!0
		);
	function i(a, u, c) {
		const d = t.indexOf("#"),
			f =
				d > -1
					? (n.host && document.querySelector("base")
							? t
							: t.slice(d)) + a
					: o3() + t + a;
		try {
			e[c ? "replaceState" : "pushState"](u, "", f), (o.value = u);
		} catch (p) {
			console.error(p), n[c ? "replace" : "assign"](f);
		}
	}
	function s(a, u) {
		const c = nt({}, e.state, qp(o.value.back, a, o.value.forward, !0), u, {
			position: o.value.position,
		});
		i(a, c, !0), (r.value = a);
	}
	function l(a, u) {
		const c = nt({}, o.value, e.state, { forward: a, scroll: Au() });
		i(c.current, c, !0);
		const d = nt({}, qp(r.value, a, null), { position: c.position + 1 }, u);
		i(a, d, !1), (r.value = a);
	}
	return { location: r, state: o, push: l, replace: s };
}
function wL(t) {
	t = Qx(t);
	const e = s3(t),
		n = i3(t, e.state, e.location, e.replace);
	function r(i, s = !0) {
		s || n.pauseListeners(), history.go(i);
	}
	const o = nt(
		{ location: "", base: t, go: r, createHref: Zx.bind(null, t) },
		e,
		n
	);
	return (
		Object.defineProperty(o, "location", {
			enumerable: !0,
			get: () => e.location.value,
		}),
		Object.defineProperty(o, "state", {
			enumerable: !0,
			get: () => e.state.value,
		}),
		o
	);
}
function l3(t) {
	return typeof t == "string" || (t && typeof t == "object");
}
function H0(t) {
	return typeof t == "string" || typeof t == "symbol";
}
const Pr = {
		path: "/",
		name: void 0,
		params: {},
		query: {},
		hash: "",
		fullPath: "/",
		matched: [],
		meta: {},
		redirectedFrom: void 0,
	},
	F0 = Symbol("");
var Jp;
(function (t) {
	(t[(t.aborted = 4)] = "aborted"),
		(t[(t.cancelled = 8)] = "cancelled"),
		(t[(t.duplicated = 16)] = "duplicated");
})(Jp || (Jp = {}));
function Si(t, e) {
	return nt(new Error(), { type: t, [F0]: !0 }, e);
}
function mr(t, e) {
	return t instanceof Error && F0 in t && (e == null || !!(t.type & e));
}
const Gp = "[^/]+?",
	a3 = { sensitive: !1, strict: !1, start: !0, end: !0 },
	u3 = /[.+*?^${}()[\]/\\]/g;
function c3(t, e) {
	const n = nt({}, a3, e),
		r = [];
	let o = n.start ? "^" : "";
	const i = [];
	for (const u of t) {
		const c = u.length ? [] : [90];
		n.strict && !u.length && (o += "/");
		for (let d = 0; d < u.length; d++) {
			const f = u[d];
			let p = 40 + (n.sensitive ? 0.25 : 0);
			if (f.type === 0)
				d || (o += "/"), (o += f.value.replace(u3, "\\$&")), (p += 40);
			else if (f.type === 1) {
				const { value: m, repeatable: y, optional: v, regexp: w } = f;
				i.push({ name: m, repeatable: y, optional: v });
				const S = w || Gp;
				if (S !== Gp) {
					p += 10;
					try {
						new RegExp(`(${S})`);
					} catch (h) {
						throw new Error(
							`Invalid custom RegExp for param "${m}" (${S}): ` +
								h.message
						);
					}
				}
				let E = y ? `((?:${S})(?:/(?:${S}))*)` : `(${S})`;
				d || (E = v && u.length < 2 ? `(?:/${E})` : "/" + E),
					v && (E += "?"),
					(o += E),
					(p += 20),
					v && (p += -8),
					y && (p += -20),
					S === ".*" && (p += -50);
			}
			c.push(p);
		}
		r.push(c);
	}
	if (n.strict && n.end) {
		const u = r.length - 1;
		r[u][r[u].length - 1] += 0.7000000000000001;
	}
	n.strict || (o += "/?"), n.end ? (o += "$") : n.strict && (o += "(?:/|$)");
	const s = new RegExp(o, n.sensitive ? "" : "i");
	function l(u) {
		const c = u.match(s),
			d = {};
		if (!c) return null;
		for (let f = 1; f < c.length; f++) {
			const p = c[f] || "",
				m = i[f - 1];
			d[m.name] = p && m.repeatable ? p.split("/") : p;
		}
		return d;
	}
	function a(u) {
		let c = "",
			d = !1;
		for (const f of t) {
			(!d || !c.endsWith("/")) && (c += "/"), (d = !1);
			for (const p of f)
				if (p.type === 0) c += p.value;
				else if (p.type === 1) {
					const { value: m, repeatable: y, optional: v } = p,
						w = m in u ? u[m] : "";
					if (Fn(w) && !y)
						throw new Error(
							`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`
						);
					const S = Fn(w) ? w.join("/") : w;
					if (!S)
						if (v)
							f.length < 2 &&
								(c.endsWith("/")
									? (c = c.slice(0, -1))
									: (d = !0));
						else throw new Error(`Missing required param "${m}"`);
					c += S;
				}
		}
		return c || "/";
	}
	return { re: s, score: r, keys: i, parse: l, stringify: a };
}
function d3(t, e) {
	let n = 0;
	for (; n < t.length && n < e.length; ) {
		const r = e[n] - t[n];
		if (r) return r;
		n++;
	}
	return t.length < e.length
		? t.length === 1 && t[0] === 80
			? -1
			: 1
		: t.length > e.length
		? e.length === 1 && e[0] === 80
			? 1
			: -1
		: 0;
}
function f3(t, e) {
	let n = 0;
	const r = t.score,
		o = e.score;
	for (; n < r.length && n < o.length; ) {
		const i = d3(r[n], o[n]);
		if (i) return i;
		n++;
	}
	if (Math.abs(o.length - r.length) === 1) {
		if (Yp(r)) return 1;
		if (Yp(o)) return -1;
	}
	return o.length - r.length;
}
function Yp(t) {
	const e = t[t.length - 1];
	return t.length > 0 && e[e.length - 1] < 0;
}
const h3 = { type: 0, value: "" },
	p3 = /[a-zA-Z0-9_]/;
function m3(t) {
	if (!t) return [[]];
	if (t === "/") return [[h3]];
	if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`);
	function e(p) {
		throw new Error(`ERR (${n})/"${u}": ${p}`);
	}
	let n = 0,
		r = n;
	const o = [];
	let i;
	function s() {
		i && o.push(i), (i = []);
	}
	let l = 0,
		a,
		u = "",
		c = "";
	function d() {
		u &&
			(n === 0
				? i.push({ type: 0, value: u })
				: n === 1 || n === 2 || n === 3
				? (i.length > 1 &&
						(a === "*" || a === "+") &&
						e(
							`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`
						),
				  i.push({
						type: 1,
						value: u,
						regexp: c,
						repeatable: a === "*" || a === "+",
						optional: a === "*" || a === "?",
				  }))
				: e("Invalid state to consume buffer"),
			(u = ""));
	}
	function f() {
		u += a;
	}
	for (; l < t.length; ) {
		if (((a = t[l++]), a === "\\" && n !== 2)) {
			(r = n), (n = 4);
			continue;
		}
		switch (n) {
			case 0:
				a === "/" ? (u && d(), s()) : a === ":" ? (d(), (n = 1)) : f();
				break;
			case 4:
				f(), (n = r);
				break;
			case 1:
				a === "("
					? (n = 2)
					: p3.test(a)
					? f()
					: (d(),
					  (n = 0),
					  a !== "*" && a !== "?" && a !== "+" && l--);
				break;
			case 2:
				a === ")"
					? c[c.length - 1] == "\\"
						? (c = c.slice(0, -1) + a)
						: (n = 3)
					: (c += a);
				break;
			case 3:
				d(),
					(n = 0),
					a !== "*" && a !== "?" && a !== "+" && l--,
					(c = "");
				break;
			default:
				e("Unknown state");
				break;
		}
	}
	return (
		n === 2 && e(`Unfinished custom RegExp for param "${u}"`), d(), s(), o
	);
}
function g3(t, e, n) {
	const r = c3(m3(t.path), n),
		o = nt(r, { record: t, parent: e, children: [], alias: [] });
	return e && !o.record.aliasOf == !e.record.aliasOf && e.children.push(o), o;
}
function y3(t, e) {
	const n = [],
		r = new Map();
	e = Zp({ strict: !1, end: !0, sensitive: !1 }, e);
	function o(c) {
		return r.get(c);
	}
	function i(c, d, f) {
		const p = !f,
			m = v3(c);
		m.aliasOf = f && f.record;
		const y = Zp(e, c),
			v = [m];
		if ("alias" in c) {
			const E = typeof c.alias == "string" ? [c.alias] : c.alias;
			for (const h of E)
				v.push(
					nt({}, m, {
						components: f ? f.record.components : m.components,
						path: h,
						aliasOf: f ? f.record : m,
					})
				);
		}
		let w, S;
		for (const E of v) {
			const { path: h } = E;
			if (d && h[0] !== "/") {
				const b = d.record.path,
					g = b[b.length - 1] === "/" ? "" : "/";
				E.path = d.record.path + (h && g + h);
			}
			if (
				((w = g3(E, d, y)),
				f
					? f.alias.push(w)
					: ((S = S || w),
					  S !== w && S.alias.push(w),
					  p && c.name && !Xp(w) && s(c.name)),
				m.children)
			) {
				const b = m.children;
				for (let g = 0; g < b.length; g++)
					i(b[g], w, f && f.children[g]);
			}
			(f = f || w),
				((w.record.components &&
					Object.keys(w.record.components).length) ||
					w.record.name ||
					w.record.redirect) &&
					a(w);
		}
		return S
			? () => {
					s(S);
			  }
			: cs;
	}
	function s(c) {
		if (H0(c)) {
			const d = r.get(c);
			d &&
				(r.delete(c),
				n.splice(n.indexOf(d), 1),
				d.children.forEach(s),
				d.alias.forEach(s));
		} else {
			const d = n.indexOf(c);
			d > -1 &&
				(n.splice(d, 1),
				c.record.name && r.delete(c.record.name),
				c.children.forEach(s),
				c.alias.forEach(s));
		}
	}
	function l() {
		return n;
	}
	function a(c) {
		let d = 0;
		for (
			;
			d < n.length &&
			f3(c, n[d]) >= 0 &&
			(c.record.path !== n[d].record.path || !V0(c, n[d]));

		)
			d++;
		n.splice(d, 0, c), c.record.name && !Xp(c) && r.set(c.record.name, c);
	}
	function u(c, d) {
		let f,
			p = {},
			m,
			y;
		if ("name" in c && c.name) {
			if (((f = r.get(c.name)), !f)) throw Si(1, { location: c });
			(y = f.record.name),
				(p = nt(
					Qp(
						d.params,
						f.keys.filter((S) => !S.optional).map((S) => S.name)
					),
					c.params &&
						Qp(
							c.params,
							f.keys.map((S) => S.name)
						)
				)),
				(m = f.stringify(p));
		} else if ("path" in c)
			(m = c.path),
				(f = n.find((S) => S.re.test(m))),
				f && ((p = f.parse(m)), (y = f.record.name));
		else {
			if (
				((f = d.name
					? r.get(d.name)
					: n.find((S) => S.re.test(d.path))),
				!f)
			)
				throw Si(1, { location: c, currentLocation: d });
			(y = f.record.name),
				(p = nt({}, d.params, c.params)),
				(m = f.stringify(p));
		}
		const v = [];
		let w = f;
		for (; w; ) v.unshift(w.record), (w = w.parent);
		return { name: y, path: m, params: p, matched: v, meta: w3(v) };
	}
	return (
		t.forEach((c) => i(c)),
		{
			addRoute: i,
			resolve: u,
			removeRoute: s,
			getRoutes: l,
			getRecordMatcher: o,
		}
	);
}
function Qp(t, e) {
	const n = {};
	for (const r of e) r in t && (n[r] = t[r]);
	return n;
}
function v3(t) {
	return {
		path: t.path,
		redirect: t.redirect,
		name: t.name,
		meta: t.meta || {},
		aliasOf: void 0,
		beforeEnter: t.beforeEnter,
		props: b3(t),
		children: t.children || [],
		instances: {},
		leaveGuards: new Set(),
		updateGuards: new Set(),
		enterCallbacks: {},
		components:
			"components" in t
				? t.components || null
				: t.component && { default: t.component },
	};
}
function b3(t) {
	const e = {},
		n = t.props || !1;
	if ("component" in t) e.default = n;
	else for (const r in t.components) e[r] = typeof n == "object" ? n[r] : n;
	return e;
}
function Xp(t) {
	for (; t; ) {
		if (t.record.aliasOf) return !0;
		t = t.parent;
	}
	return !1;
}
function w3(t) {
	return t.reduce((e, n) => nt(e, n.meta), {});
}
function Zp(t, e) {
	const n = {};
	for (const r in t) n[r] = r in e ? e[r] : t[r];
	return n;
}
function V0(t, e) {
	return e.children.some((n) => n === t || V0(t, n));
}
const W0 = /#/g,
	x3 = /&/g,
	k3 = /\//g,
	S3 = /=/g,
	_3 = /\?/g,
	U0 = /\+/g,
	C3 = /%5B/g,
	M3 = /%5D/g,
	K0 = /%5E/g,
	E3 = /%60/g,
	q0 = /%7B/g,
	T3 = /%7C/g,
	J0 = /%7D/g,
	A3 = /%20/g;
function Kf(t) {
	return encodeURI("" + t)
		.replace(T3, "|")
		.replace(C3, "[")
		.replace(M3, "]");
}
function O3(t) {
	return Kf(t).replace(q0, "{").replace(J0, "}").replace(K0, "^");
}
function wd(t) {
	return Kf(t)
		.replace(U0, "%2B")
		.replace(A3, "+")
		.replace(W0, "%23")
		.replace(x3, "%26")
		.replace(E3, "`")
		.replace(q0, "{")
		.replace(J0, "}")
		.replace(K0, "^");
}
function R3(t) {
	return wd(t).replace(S3, "%3D");
}
function P3(t) {
	return Kf(t).replace(W0, "%23").replace(_3, "%3F");
}
function I3(t) {
	return t == null ? "" : P3(t).replace(k3, "%2F");
}
function ya(t) {
	try {
		return decodeURIComponent("" + t);
	} catch (e) {}
	return "" + t;
}
function N3(t) {
	const e = {};
	if (t === "" || t === "?") return e;
	const r = (t[0] === "?" ? t.slice(1) : t).split("&");
	for (let o = 0; o < r.length; ++o) {
		const i = r[o].replace(U0, " "),
			s = i.indexOf("="),
			l = ya(s < 0 ? i : i.slice(0, s)),
			a = s < 0 ? null : ya(i.slice(s + 1));
		if (l in e) {
			let u = e[l];
			Fn(u) || (u = e[l] = [u]), u.push(a);
		} else e[l] = a;
	}
	return e;
}
function em(t) {
	let e = "";
	for (let n in t) {
		const r = t[n];
		if (((n = R3(n)), r == null)) {
			r !== void 0 && (e += (e.length ? "&" : "") + n);
			continue;
		}
		(Fn(r) ? r.map((i) => i && wd(i)) : [r && wd(r)]).forEach((i) => {
			i !== void 0 &&
				((e += (e.length ? "&" : "") + n), i != null && (e += "=" + i));
		});
	}
	return e;
}
function D3(t) {
	const e = {};
	for (const n in t) {
		const r = t[n];
		r !== void 0 &&
			(e[n] = Fn(r)
				? r.map((o) => (o == null ? null : "" + o))
				: r == null
				? r
				: "" + r);
	}
	return e;
}
const j3 = Symbol(""),
	tm = Symbol(""),
	Ou = Symbol(""),
	qf = Symbol(""),
	xd = Symbol("");
function qi() {
	let t = [];
	function e(r) {
		return (
			t.push(r),
			() => {
				const o = t.indexOf(r);
				o > -1 && t.splice(o, 1);
			}
		);
	}
	function n() {
		t = [];
	}
	return { add: e, list: () => t.slice(), reset: n };
}
function zr(t, e, n, r, o) {
	const i = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
	return () =>
		new Promise((s, l) => {
			const a = (d) => {
					d === !1
						? l(Si(4, { from: n, to: e }))
						: d instanceof Error
						? l(d)
						: l3(d)
						? l(Si(2, { from: e, to: d }))
						: (i &&
								r.enterCallbacks[o] === i &&
								typeof d == "function" &&
								i.push(d),
						  s());
				},
				u = t.call(r && r.instances[o], e, n, a);
			let c = Promise.resolve(u);
			t.length < 3 && (c = c.then(a)), c.catch((d) => l(d));
		});
}
function xc(t, e, n, r) {
	const o = [];
	for (const i of t)
		for (const s in i.components) {
			let l = i.components[s];
			if (!(e !== "beforeRouteEnter" && !i.instances[s]))
				if (L3(l)) {
					const u = (l.__vccOpts || l)[e];
					u && o.push(zr(u, n, r, i, s));
				} else {
					let a = l();
					o.push(() =>
						a.then((u) => {
							if (!u)
								return Promise.reject(
									new Error(
										`Couldn't resolve component "${s}" at "${i.path}"`
									)
								);
							const c = Wx(u) ? u.default : u;
							i.components[s] = c;
							const f = (c.__vccOpts || c)[e];
							return f && zr(f, n, r, i, s)();
						})
					);
				}
		}
	return o;
}
function L3(t) {
	return (
		typeof t == "object" ||
		"displayName" in t ||
		"props" in t ||
		"__vccOpts" in t
	);
}
function nm(t) {
	const e = Ge(Ou),
		n = Ge(qf),
		r = z(() => e.resolve(ne(t.to))),
		o = z(() => {
			const { matched: a } = r.value,
				{ length: u } = a,
				c = a[u - 1],
				d = n.matched;
			if (!c || !d.length) return -1;
			const f = d.findIndex(ki.bind(null, c));
			if (f > -1) return f;
			const p = rm(a[u - 2]);
			return u > 1 && rm(c) === p && d[d.length - 1].path !== p
				? d.findIndex(ki.bind(null, a[u - 2]))
				: f;
		}),
		i = z(() => o.value > -1 && H3(n.params, r.value.params)),
		s = z(
			() =>
				o.value > -1 &&
				o.value === n.matched.length - 1 &&
				B0(n.params, r.value.params)
		);
	function l(a = {}) {
		return z3(a)
			? e[ne(t.replace) ? "replace" : "push"](ne(t.to)).catch(cs)
			: Promise.resolve();
	}
	return {
		route: r,
		href: z(() => r.value.href),
		isActive: i,
		isExactActive: s,
		navigate: l,
	};
}
const $3 = Oe({
		name: "RouterLink",
		compatConfig: { MODE: 3 },
		props: {
			to: { type: [String, Object], required: !0 },
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: { type: String, default: "page" },
		},
		useLink: nm,
		setup(t, { slots: e }) {
			const n = Yt(nm(t)),
				{ options: r } = Ge(Ou),
				o = z(() => ({
					[om(
						t.activeClass,
						r.linkActiveClass,
						"router-link-active"
					)]: n.isActive,
					[om(
						t.exactActiveClass,
						r.linkExactActiveClass,
						"router-link-exact-active"
					)]: n.isExactActive,
				}));
			return () => {
				const i = e.default && e.default(n);
				return t.custom
					? i
					: Ke(
							"a",
							{
								"aria-current": n.isExactActive
									? t.ariaCurrentValue
									: null,
								href: n.href,
								onClick: n.navigate,
								class: o.value,
							},
							i
					  );
			};
		},
	}),
	B3 = $3;
function z3(t) {
	if (
		!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) &&
		!t.defaultPrevented &&
		!(t.button !== void 0 && t.button !== 0)
	) {
		if (t.currentTarget && t.currentTarget.getAttribute) {
			const e = t.currentTarget.getAttribute("target");
			if (/\b_blank\b/i.test(e)) return;
		}
		return t.preventDefault && t.preventDefault(), !0;
	}
}
function H3(t, e) {
	for (const n in e) {
		const r = e[n],
			o = t[n];
		if (typeof r == "string") {
			if (r !== o) return !1;
		} else if (
			!Fn(o) ||
			o.length !== r.length ||
			r.some((i, s) => i !== o[s])
		)
			return !1;
	}
	return !0;
}
function rm(t) {
	return t ? (t.aliasOf ? t.aliasOf.path : t.path) : "";
}
const om = (t, e, n) => (t != null ? t : e != null ? e : n),
	F3 = Oe({
		name: "RouterView",
		inheritAttrs: !1,
		props: { name: { type: String, default: "default" }, route: Object },
		compatConfig: { MODE: 3 },
		setup(t, { attrs: e, slots: n }) {
			const r = Ge(xd),
				o = z(() => t.route || r.value),
				i = Ge(tm, 0),
				s = z(() => {
					let u = ne(i);
					const { matched: c } = o.value;
					let d;
					for (; (d = c[u]) && !d.components; ) u++;
					return u;
				}),
				l = z(() => o.value.matched[s.value]);
			wt(
				tm,
				z(() => s.value + 1)
			),
				wt(j3, l),
				wt(xd, o);
			const a = Q();
			return (
				at(
					() => [a.value, l.value, t.name],
					([u, c, d], [f, p, m]) => {
						c &&
							((c.instances[d] = u),
							p &&
								p !== c &&
								u &&
								u === f &&
								(c.leaveGuards.size ||
									(c.leaveGuards = p.leaveGuards),
								c.updateGuards.size ||
									(c.updateGuards = p.updateGuards))),
							u &&
								c &&
								(!p || !ki(c, p) || !f) &&
								(c.enterCallbacks[d] || []).forEach((y) =>
									y(u)
								);
					},
					{ flush: "post" }
				),
				() => {
					const u = o.value,
						c = t.name,
						d = l.value,
						f = d && d.components[c];
					if (!f) return im(n.default, { Component: f, route: u });
					const p = d.props[c],
						m = p
							? p === !0
								? u.params
								: typeof p == "function"
								? p(u)
								: p
							: null,
						v = Ke(
							f,
							nt({}, m, e, {
								onVnodeUnmounted: (w) => {
									w.component.isUnmounted &&
										(d.instances[c] = null);
								},
								ref: a,
							})
						);
					return im(n.default, { Component: v, route: u }) || v;
				}
			);
		},
	});
function im(t, e) {
	if (!t) return null;
	const n = t(e);
	return n.length === 1 ? n[0] : n;
}
const V3 = F3;
function xL(t) {
	const e = y3(t.routes, t),
		n = t.parseQuery || N3,
		r = t.stringifyQuery || em,
		o = t.history,
		i = qi(),
		s = qi(),
		l = qi(),
		a = bu(Pr);
	let u = Pr;
	ti &&
		t.scrollBehavior &&
		"scrollRestoration" in history &&
		(history.scrollRestoration = "manual");
	const c = bc.bind(null, (H) => "" + H),
		d = bc.bind(null, I3),
		f = bc.bind(null, ya);
	function p(H, Z) {
		let oe, ce;
		return (
			H0(H) ? ((oe = e.getRecordMatcher(H)), (ce = Z)) : (ce = H),
			e.addRoute(ce, oe)
		);
	}
	function m(H) {
		const Z = e.getRecordMatcher(H);
		Z && e.removeRoute(Z);
	}
	function y() {
		return e.getRoutes().map((H) => H.record);
	}
	function v(H) {
		return !!e.getRecordMatcher(H);
	}
	function w(H, Z) {
		if (((Z = nt({}, Z || a.value)), typeof H == "string")) {
			const O = wc(n, H, Z.path),
				L = e.resolve({ path: O.path }, Z),
				q = o.createHref(O.fullPath);
			return nt(O, L, {
				params: f(L.params),
				hash: ya(O.hash),
				redirectedFrom: void 0,
				href: q,
			});
		}
		let oe;
		if ("path" in H) oe = nt({}, H, { path: wc(n, H.path, Z.path).path });
		else {
			const O = nt({}, H.params);
			for (const L in O) O[L] == null && delete O[L];
			(oe = nt({}, H, { params: d(O) })), (Z.params = d(Z.params));
		}
		const ce = e.resolve(oe, Z),
			He = H.hash || "";
		ce.params = c(f(ce.params));
		const Ye = qx(r, nt({}, H, { hash: O3(He), path: ce.path })),
			A = o.createHref(Ye);
		return nt(
			{
				fullPath: Ye,
				hash: He,
				query: r === em ? D3(H.query) : H.query || {},
			},
			ce,
			{ redirectedFrom: void 0, href: A }
		);
	}
	function S(H) {
		return typeof H == "string" ? wc(n, H, a.value.path) : nt({}, H);
	}
	function E(H, Z) {
		if (u !== H) return Si(8, { from: Z, to: H });
	}
	function h(H) {
		return x(H);
	}
	function b(H) {
		return h(nt(S(H), { replace: !0 }));
	}
	function g(H) {
		const Z = H.matched[H.matched.length - 1];
		if (Z && Z.redirect) {
			const { redirect: oe } = Z;
			let ce = typeof oe == "function" ? oe(H) : oe;
			return (
				typeof ce == "string" &&
					((ce =
						ce.includes("?") || ce.includes("#")
							? (ce = S(ce))
							: { path: ce }),
					(ce.params = {})),
				nt(
					{
						query: H.query,
						hash: H.hash,
						params: "path" in ce ? {} : H.params,
					},
					ce
				)
			);
		}
	}
	function x(H, Z) {
		const oe = (u = w(H)),
			ce = a.value,
			He = H.state,
			Ye = H.force,
			A = H.replace === !0,
			O = g(oe);
		if (O)
			return x(
				nt(S(O), {
					state: typeof O == "object" ? nt({}, He, O.state) : He,
					force: Ye,
					replace: A,
				}),
				Z || oe
			);
		const L = oe;
		L.redirectedFrom = Z;
		let q;
		return (
			!Ye &&
				Jx(r, ce, oe) &&
				((q = Si(16, { to: L, from: ce })), X(ce, ce, !0, !1)),
			(q ? Promise.resolve(q) : _(L, ce))
				.catch((U) => (mr(U) ? (mr(U, 2) ? U : ie(U)) : $(U, L, ce)))
				.then((U) => {
					if (U) {
						if (mr(U, 2))
							return x(
								nt({ replace: A }, S(U.to), {
									state:
										typeof U.to == "object"
											? nt({}, He, U.to.state)
											: He,
									force: Ye,
								}),
								Z || L
							);
					} else U = R(L, ce, !0, A, He);
					return T(L, ce, U), U;
				})
		);
	}
	function k(H, Z) {
		const oe = E(H, Z);
		return oe ? Promise.reject(oe) : Promise.resolve();
	}
	function C(H) {
		const Z = Ee.values().next().value;
		return Z && typeof Z.runWithContext == "function"
			? Z.runWithContext(H)
			: H();
	}
	function _(H, Z) {
		let oe;
		const [ce, He, Ye] = W3(H, Z);
		oe = xc(ce.reverse(), "beforeRouteLeave", H, Z);
		for (const O of ce)
			O.leaveGuards.forEach((L) => {
				oe.push(zr(L, H, Z));
			});
		const A = k.bind(null, H, Z);
		return (
			oe.push(A),
			De(oe)
				.then(() => {
					oe = [];
					for (const O of i.list()) oe.push(zr(O, H, Z));
					return oe.push(A), De(oe);
				})
				.then(() => {
					oe = xc(He, "beforeRouteUpdate", H, Z);
					for (const O of He)
						O.updateGuards.forEach((L) => {
							oe.push(zr(L, H, Z));
						});
					return oe.push(A), De(oe);
				})
				.then(() => {
					oe = [];
					for (const O of Ye)
						if (O.beforeEnter)
							if (Fn(O.beforeEnter))
								for (const L of O.beforeEnter)
									oe.push(zr(L, H, Z));
							else oe.push(zr(O.beforeEnter, H, Z));
					return oe.push(A), De(oe);
				})
				.then(
					() => (
						H.matched.forEach((O) => (O.enterCallbacks = {})),
						(oe = xc(Ye, "beforeRouteEnter", H, Z)),
						oe.push(A),
						De(oe)
					)
				)
				.then(() => {
					oe = [];
					for (const O of s.list()) oe.push(zr(O, H, Z));
					return oe.push(A), De(oe);
				})
				.catch((O) => (mr(O, 8) ? O : Promise.reject(O)))
		);
	}
	function T(H, Z, oe) {
		l.list().forEach((ce) => C(() => ce(H, Z, oe)));
	}
	function R(H, Z, oe, ce, He) {
		const Ye = E(H, Z);
		if (Ye) return Ye;
		const A = Z === Pr,
			O = ti ? history.state : {};
		oe &&
			(ce || A
				? o.replace(H.fullPath, nt({ scroll: A && O && O.scroll }, He))
				: o.push(H.fullPath, He)),
			(a.value = H),
			X(H, Z, oe, A),
			ie();
	}
	let P;
	function D() {
		P ||
			(P = o.listen((H, Z, oe) => {
				if (!Pe.listening) return;
				const ce = w(H),
					He = g(ce);
				if (He) {
					x(nt(He, { replace: !0 }), ce).catch(cs);
					return;
				}
				u = ce;
				const Ye = a.value;
				ti && n3(Kp(Ye.fullPath, oe.delta), Au()),
					_(ce, Ye)
						.catch((A) =>
							mr(A, 12)
								? A
								: mr(A, 2)
								? (x(A.to, ce)
										.then((O) => {
											mr(O, 20) &&
												!oe.delta &&
												oe.type === Os.pop &&
												o.go(-1, !1);
										})
										.catch(cs),
								  Promise.reject())
								: (oe.delta && o.go(-oe.delta, !1),
								  $(A, ce, Ye))
						)
						.then((A) => {
							(A = A || R(ce, Ye, !1)),
								A &&
									(oe.delta && !mr(A, 8)
										? o.go(-oe.delta, !1)
										: oe.type === Os.pop &&
										  mr(A, 20) &&
										  o.go(-1, !1)),
								T(ce, Ye, A);
						})
						.catch(cs);
			}));
	}
	let j = qi(),
		M = qi(),
		I;
	function $(H, Z, oe) {
		ie(H);
		const ce = M.list();
		return (
			ce.length ? ce.forEach((He) => He(H, Z, oe)) : console.error(H),
			Promise.reject(H)
		);
	}
	function K() {
		return I && a.value !== Pr
			? Promise.resolve()
			: new Promise((H, Z) => {
					j.add([H, Z]);
			  });
	}
	function ie(H) {
		return (
			I ||
				((I = !H),
				D(),
				j.list().forEach(([Z, oe]) => (H ? oe(H) : Z())),
				j.reset()),
			H
		);
	}
	function X(H, Z, oe, ce) {
		const { scrollBehavior: He } = t;
		if (!ti || !He) return Promise.resolve();
		const Ye =
			(!oe && r3(Kp(H.fullPath, 0))) ||
			((ce || !oe) && history.state && history.state.scroll) ||
			null;
		return bt()
			.then(() => He(H, Z, Ye))
			.then((A) => A && t3(A))
			.catch((A) => $(A, H, Z));
	}
	const de = (H) => o.go(H);
	let ze;
	const Ee = new Set(),
		Pe = {
			currentRoute: a,
			listening: !0,
			addRoute: p,
			removeRoute: m,
			hasRoute: v,
			getRoutes: y,
			resolve: w,
			options: t,
			push: h,
			replace: b,
			go: de,
			back: () => de(-1),
			forward: () => de(1),
			beforeEach: i.add,
			beforeResolve: s.add,
			afterEach: l.add,
			onError: M.add,
			isReady: K,
			install(H) {
				const Z = this;
				H.component("RouterLink", B3),
					H.component("RouterView", V3),
					(H.config.globalProperties.$router = Z),
					Object.defineProperty(H.config.globalProperties, "$route", {
						enumerable: !0,
						get: () => ne(a),
					}),
					ti &&
						!ze &&
						a.value === Pr &&
						((ze = !0), h(o.location).catch((He) => {}));
				const oe = {};
				for (const He in Pr)
					Object.defineProperty(oe, He, {
						get: () => a.value[He],
						enumerable: !0,
					});
				H.provide(Ou, Z), H.provide(qf, J1(oe)), H.provide(xd, a);
				const ce = H.unmount;
				Ee.add(H),
					(H.unmount = function () {
						Ee.delete(H),
							Ee.size < 1 &&
								((u = Pr),
								P && P(),
								(P = null),
								(a.value = Pr),
								(ze = !1),
								(I = !1)),
							ce();
					});
			},
		};
	function De(H) {
		return H.reduce((Z, oe) => Z.then(() => C(oe)), Promise.resolve());
	}
	return Pe;
}
function W3(t, e) {
	const n = [],
		r = [],
		o = [],
		i = Math.max(e.matched.length, t.matched.length);
	for (let s = 0; s < i; s++) {
		const l = e.matched[s];
		l && (t.matched.find((u) => ki(u, l)) ? r.push(l) : n.push(l));
		const a = t.matched[s];
		a && (e.matched.find((u) => ki(u, a)) || o.push(a));
	}
	return [n, r, o];
}
function G0() {
	return Ge(Ou);
}
function kL() {
	return Ge(qf);
}
var SL = !1;
const Le = (t, e) => {
	const n = t.__vccOpts || t;
	for (const [r, o] of e) n[r] = o;
	return n;
};
/**
 * vue-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function va() {
	return (
		(va = Object.assign
			? Object.assign.bind()
			: function (t) {
					for (var e = 1; e < arguments.length; e++) {
						var n = arguments[e];
						for (var r in n)
							Object.prototype.hasOwnProperty.call(n, r) &&
								(t[r] = n[r]);
					}
					return t;
			  }),
		va.apply(this, arguments)
	);
}
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function ba() {
	return (
		(ba = Object.assign
			? Object.assign.bind()
			: function (t) {
					for (var e = 1; e < arguments.length; e++) {
						var n = arguments[e];
						for (var r in n)
							Object.prototype.hasOwnProperty.call(n, r) &&
								(t[r] = n[r]);
					}
					return t;
			  }),
		ba.apply(this, arguments)
	);
}
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Yo(t, e, n) {
	var r,
		o = (r = n.initialDeps) != null ? r : [],
		i;
	return function () {
		var s;
		n.key && n.debug != null && n.debug() && (s = Date.now());
		var l = t(),
			a =
				l.length !== o.length ||
				l.some(function (m, y) {
					return o[y] !== m;
				});
		if (!a) return i;
		o = l;
		var u;
		if (
			(n.key && n.debug != null && n.debug() && (u = Date.now()),
			(i = e.apply(void 0, l)),
			n.key && n.debug != null && n.debug())
		) {
			var c = Math.round((Date.now() - s) * 100) / 100,
				d = Math.round((Date.now() - u) * 100) / 100,
				f = d / 16,
				p = function (y, v) {
					for (y = String(y); y.length < v; ) y = " " + y;
					return y;
				};
			console.info(
				"%c " + p(d, 5) + " /" + p(c, 5) + " ms",
				`
            font-size: .6rem;
            font-weight: bold;
            color: hsl(` +
					Math.max(0, Math.min(120 - 120 * f, 120)) +
					"deg 100% 31%);",
				n == null ? void 0 : n.key
			);
		}
		return n == null || n.onChange == null || n.onChange(i), i;
	};
}
function kc(t, e) {
	if (t === void 0)
		throw new Error("Unexpected undefined" + (e ? ": " + e : ""));
	return t;
}
var U3 = function (e, n) {
	return Math.abs(e - n) < 1;
};
/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ var K3 = function (e) {
		return e;
	},
	q3 = function (e) {
		for (
			var n = Math.max(e.startIndex - e.overscan, 0),
				r = Math.min(e.endIndex + e.overscan, e.count - 1),
				o = [],
				i = n;
			i <= r;
			i++
		)
			o.push(i);
		return o;
	},
	J3 = function (e, n) {
		var r = e.scrollElement;
		if (r) {
			var o = function (l) {
				var a = l.width,
					u = l.height;
				n({ width: Math.round(a), height: Math.round(u) });
			};
			o(r.getBoundingClientRect());
			var i = new ResizeObserver(function (s) {
				var l = s[0];
				if (l != null && l.borderBoxSize) {
					var a = l.borderBoxSize[0];
					if (a) {
						o({ width: a.inlineSize, height: a.blockSize });
						return;
					}
				}
				o(r.getBoundingClientRect());
			});
			return (
				i.observe(r, { box: "border-box" }),
				function () {
					i.unobserve(r);
				}
			);
		}
	},
	G3 = function (e, n) {
		var r = e.scrollElement;
		if (r) {
			var o = function () {
				n(r[e.options.horizontal ? "scrollLeft" : "scrollTop"]);
			};
			return (
				o(),
				r.addEventListener("scroll", o, { passive: !0 }),
				function () {
					r.removeEventListener("scroll", o);
				}
			);
		}
	},
	Y3 = function (e, n, r) {
		if (n != null && n.borderBoxSize) {
			var o = n.borderBoxSize[0];
			if (o) {
				var i = Math.round(
					o[r.options.horizontal ? "inlineSize" : "blockSize"]
				);
				return i;
			}
		}
		return Math.round(
			e.getBoundingClientRect()[r.options.horizontal ? "width" : "height"]
		);
	},
	Q3 = function (e, n, r) {
		var o,
			i,
			s = n.adjustments,
			l = s === void 0 ? 0 : s,
			a = n.behavior,
			u = e + l;
		(o = r.scrollElement) == null ||
			o.scrollTo == null ||
			o.scrollTo(
				((i = {}),
				(i[r.options.horizontal ? "left" : "top"] = u),
				(i.behavior = a),
				i)
			);
	},
	X3 = function (e) {
		var n = this;
		(this.unsubs = []),
			(this.scrollElement = null),
			(this.isScrolling = !1),
			(this.isScrollingTimeoutId = null),
			(this.scrollToIndexTimeoutId = null),
			(this.measurementsCache = []),
			(this.itemSizeCache = new Map()),
			(this.pendingMeasuredCacheIndexes = []),
			(this.scrollDirection = null),
			(this.scrollAdjustments = 0),
			(this.measureElementCache = new Map()),
			(this.observer = (function () {
				var r = null,
					o = function () {
						return (
							r ||
							(typeof ResizeObserver != "undefined"
								? (r = new ResizeObserver(function (s) {
										s.forEach(function (l) {
											n._measureElement(l.target, l);
										});
								  }))
								: null)
						);
					};
				return {
					disconnect: function () {
						var s;
						return (s = o()) == null ? void 0 : s.disconnect();
					},
					observe: function (s) {
						var l;
						return (l = o()) == null
							? void 0
							: l.observe(s, { box: "border-box" });
					},
					unobserve: function (s) {
						var l;
						return (l = o()) == null ? void 0 : l.unobserve(s);
					},
				};
			})()),
			(this.range = null),
			(this.setOptions = function (r) {
				Object.entries(r).forEach(function (o) {
					var i = o[0],
						s = o[1];
					typeof s == "undefined" && delete r[i];
				}),
					(n.options = ba(
						{
							debug: !1,
							initialOffset: 0,
							overscan: 1,
							paddingStart: 0,
							paddingEnd: 0,
							scrollPaddingStart: 0,
							scrollPaddingEnd: 0,
							horizontal: !1,
							getItemKey: K3,
							rangeExtractor: q3,
							onChange: function () {},
							measureElement: Y3,
							initialRect: { width: 0, height: 0 },
							scrollMargin: 0,
							scrollingDelay: 150,
							indexAttribute: "data-index",
							initialMeasurementsCache: [],
							lanes: 1,
						},
						r
					));
			}),
			(this.notify = function (r) {
				n.options.onChange == null || n.options.onChange(n, r);
			}),
			(this.maybeNotify = Yo(
				function () {
					return (
						n.calculateRange(),
						[
							n.isScrolling,
							n.range ? n.range.startIndex : null,
							n.range ? n.range.endIndex : null,
						]
					);
				},
				function (r) {
					n.notify(r);
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
					initialDeps: [
						this.isScrolling,
						this.range ? this.range.startIndex : null,
						this.range ? this.range.endIndex : null,
					],
				}
			)),
			(this.cleanup = function () {
				n.unsubs.filter(Boolean).forEach(function (r) {
					return r();
				}),
					(n.unsubs = []),
					(n.scrollElement = null);
			}),
			(this._didMount = function () {
				return (
					n.measureElementCache.forEach(n.observer.observe),
					function () {
						n.observer.disconnect(), n.cleanup();
					}
				);
			}),
			(this._willUpdate = function () {
				var r = n.options.getScrollElement();
				n.scrollElement !== r &&
					(n.cleanup(),
					(n.scrollElement = r),
					n._scrollToOffset(n.scrollOffset, {
						adjustments: void 0,
						behavior: void 0,
					}),
					n.unsubs.push(
						n.options.observeElementRect(n, function (o) {
							(n.scrollRect = o), n.maybeNotify();
						})
					),
					n.unsubs.push(
						n.options.observeElementOffset(n, function (o) {
							(n.scrollAdjustments = 0),
								n.scrollOffset !== o &&
									(n.isScrollingTimeoutId !== null &&
										(clearTimeout(n.isScrollingTimeoutId),
										(n.isScrollingTimeoutId = null)),
									(n.isScrolling = !0),
									(n.scrollDirection =
										n.scrollOffset < o
											? "forward"
											: "backward"),
									(n.scrollOffset = o),
									n.maybeNotify(),
									(n.isScrollingTimeoutId = setTimeout(
										function () {
											(n.isScrollingTimeoutId = null),
												(n.isScrolling = !1),
												(n.scrollDirection = null),
												n.maybeNotify();
										},
										n.options.scrollingDelay
									)));
						})
					));
			}),
			(this.getSize = function () {
				return n.scrollRect[n.options.horizontal ? "width" : "height"];
			}),
			(this.memoOptions = Yo(
				function () {
					return [
						n.options.count,
						n.options.paddingStart,
						n.options.scrollMargin,
						n.options.getItemKey,
					];
				},
				function (r, o, i, s) {
					return (
						(n.pendingMeasuredCacheIndexes = []),
						{
							count: r,
							paddingStart: o,
							scrollMargin: i,
							getItemKey: s,
						}
					);
				},
				{ key: !1 }
			)),
			(this.getFurthestMeasurement = function (r, o) {
				for (var i = new Map(), s = new Map(), l = o - 1; l >= 0; l--) {
					var a = r[l];
					if (!i.has(a.lane)) {
						var u = s.get(a.lane);
						if (
							(u == null || a.end > u.end
								? s.set(a.lane, a)
								: a.end < u.end && i.set(a.lane, !0),
							i.size === n.options.lanes)
						)
							break;
					}
				}
				return s.size === n.options.lanes
					? Array.from(s.values()).sort(function (c, d) {
							return c.end - d.end;
					  })[0]
					: void 0;
			}),
			(this.getMeasurements = Yo(
				function () {
					return [n.memoOptions(), n.itemSizeCache];
				},
				function (r, o) {
					var i = r.count,
						s = r.paddingStart,
						l = r.scrollMargin,
						a = r.getItemKey,
						u =
							n.pendingMeasuredCacheIndexes.length > 0
								? Math.min.apply(
										Math,
										n.pendingMeasuredCacheIndexes
								  )
								: 0;
					n.pendingMeasuredCacheIndexes = [];
					for (
						var c = n.measurementsCache.slice(0, u), d = u;
						d < i;
						d++
					) {
						var f = a(d),
							p =
								n.options.lanes === 1
									? c[d - 1]
									: n.getFurthestMeasurement(c, d),
							m = p ? p.end : s + l,
							y = o.get(f),
							v =
								typeof y == "number"
									? y
									: n.options.estimateSize(d),
							w = m + v,
							S = p ? p.lane : d % n.options.lanes;
						c[d] = {
							index: d,
							start: m,
							size: v,
							end: w,
							key: f,
							lane: S,
						};
					}
					return (n.measurementsCache = c), c;
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.calculateRange = Yo(
				function () {
					return [n.getMeasurements(), n.getSize(), n.scrollOffset];
				},
				function (r, o, i) {
					return (n.range =
						r.length > 0 && o > 0
							? Z3({
									measurements: r,
									outerSize: o,
									scrollOffset: i,
							  })
							: null);
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.getIndexes = Yo(
				function () {
					return [
						n.options.rangeExtractor,
						n.calculateRange(),
						n.options.overscan,
						n.options.count,
					];
				},
				function (r, o, i, s) {
					return o === null
						? []
						: r(ba({}, o, { overscan: i, count: s }));
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.indexFromElement = function (r) {
				var o = n.options.indexAttribute,
					i = r.getAttribute(o);
				return i
					? parseInt(i, 10)
					: (console.warn(
							"Missing attribute name '" +
								o +
								"={index}' on measured element."
					  ),
					  -1);
			}),
			(this._measureElement = function (r, o) {
				var i = n.measurementsCache[n.indexFromElement(r)];
				if (!i || !r.isConnected) {
					n.measureElementCache.forEach(function (a, u) {
						a === r &&
							(n.observer.unobserve(r),
							n.measureElementCache.delete(u));
					});
					return;
				}
				var s = n.measureElementCache.get(i.key);
				s !== r &&
					(s && n.observer.unobserve(s),
					n.observer.observe(r),
					n.measureElementCache.set(i.key, r));
				var l = n.options.measureElement(r, o, n);
				n.resizeItem(i, l);
			}),
			(this.resizeItem = function (r, o) {
				var i,
					s = (i = n.itemSizeCache.get(r.key)) != null ? i : r.size,
					l = o - s;
				l !== 0 &&
					(r.start < n.scrollOffset &&
						n._scrollToOffset(n.scrollOffset, {
							adjustments: (n.scrollAdjustments += l),
							behavior: void 0,
						}),
					n.pendingMeasuredCacheIndexes.push(r.index),
					(n.itemSizeCache = new Map(n.itemSizeCache.set(r.key, o))),
					n.notify(!1));
			}),
			(this.measureElement = function (r) {
				r && n._measureElement(r, void 0);
			}),
			(this.getVirtualItems = Yo(
				function () {
					return [n.getIndexes(), n.getMeasurements()];
				},
				function (r, o) {
					for (var i = [], s = 0, l = r.length; s < l; s++) {
						var a = r[s],
							u = o[a];
						i.push(u);
					}
					return i;
				},
				{
					key: !1,
					debug: function () {
						return n.options.debug;
					},
				}
			)),
			(this.getVirtualItemForOffset = function (r) {
				var o = n.getMeasurements();
				return kc(
					o[
						Y0(
							0,
							o.length - 1,
							function (i) {
								return kc(o[i]).start;
							},
							r
						)
					]
				);
			}),
			(this.getOffsetForAlignment = function (r, o) {
				var i = n.getSize();
				o === "auto" &&
					(r <= n.scrollOffset
						? (o = "start")
						: r >= n.scrollOffset + i
						? (o = "end")
						: (o = "start")),
					o === "start"
						? (r = r)
						: o === "end"
						? (r = r - i)
						: o === "center" && (r = r - i / 2);
				var s = n.options.horizontal ? "scrollWidth" : "scrollHeight",
					l = n.scrollElement
						? "document" in n.scrollElement
							? n.scrollElement.document.documentElement[s]
							: n.scrollElement[s]
						: 0,
					a = l - n.getSize();
				return Math.max(Math.min(a, r), 0);
			}),
			(this.getOffsetForIndex = function (r, o) {
				o === void 0 && (o = "auto"),
					(r = Math.max(0, Math.min(r, n.options.count - 1)));
				var i = kc(n.getMeasurements()[r]);
				if (o === "auto")
					if (
						i.end >=
						n.scrollOffset +
							n.getSize() -
							n.options.scrollPaddingEnd
					)
						o = "end";
					else if (
						i.start <=
						n.scrollOffset + n.options.scrollPaddingStart
					)
						o = "start";
					else return [n.scrollOffset, o];
				var s =
					o === "end"
						? i.end + n.options.scrollPaddingEnd
						: i.start - n.options.scrollPaddingStart;
				return [n.getOffsetForAlignment(s, o), o];
			}),
			(this.isDynamicMode = function () {
				return n.measureElementCache.size > 0;
			}),
			(this.cancelScrollToIndex = function () {
				n.scrollToIndexTimeoutId !== null &&
					(clearTimeout(n.scrollToIndexTimeoutId),
					(n.scrollToIndexTimeoutId = null));
			}),
			(this.scrollToOffset = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.align,
					l = s === void 0 ? "start" : s,
					a = i.behavior;
				n.cancelScrollToIndex(),
					a === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						),
					n._scrollToOffset(n.getOffsetForAlignment(r, l), {
						adjustments: void 0,
						behavior: a,
					});
			}),
			(this.scrollToIndex = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.align,
					l = s === void 0 ? "auto" : s,
					a = i.behavior;
				(r = Math.max(0, Math.min(r, n.options.count - 1))),
					n.cancelScrollToIndex(),
					a === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						);
				var u = n.getOffsetForIndex(r, l),
					c = u[0],
					d = u[1];
				n._scrollToOffset(c, { adjustments: void 0, behavior: a }),
					a !== "smooth" &&
						n.isDynamicMode() &&
						(n.scrollToIndexTimeoutId = setTimeout(function () {
							n.scrollToIndexTimeoutId = null;
							var f = n.measureElementCache.has(
								n.options.getItemKey(r)
							);
							if (f) {
								var p = n.getOffsetForIndex(r, d),
									m = p[0];
								U3(m, n.scrollOffset) ||
									n.scrollToIndex(r, {
										align: d,
										behavior: a,
									});
							} else n.scrollToIndex(r, { align: d, behavior: a });
						}));
			}),
			(this.scrollBy = function (r, o) {
				var i = o === void 0 ? {} : o,
					s = i.behavior;
				n.cancelScrollToIndex(),
					s === "smooth" &&
						n.isDynamicMode() &&
						console.warn(
							"The `smooth` scroll behavior is not fully supported with dynamic size."
						),
					n._scrollToOffset(n.scrollOffset + r, {
						adjustments: void 0,
						behavior: s,
					});
			}),
			(this.getTotalSize = function () {
				var r;
				return (
					(((r = n.getMeasurements()[n.options.count - 1]) == null
						? void 0
						: r.end) || n.options.paddingStart) -
					n.options.scrollMargin +
					n.options.paddingEnd
				);
			}),
			(this._scrollToOffset = function (r, o) {
				var i = o.adjustments,
					s = o.behavior;
				n.options.scrollToFn(r, { behavior: s, adjustments: i }, n);
			}),
			(this.measure = function () {
				(n.itemSizeCache = new Map()), n.notify(!1);
			}),
			this.setOptions(e),
			(this.scrollRect = this.options.initialRect),
			(this.scrollOffset = this.options.initialOffset),
			(this.measurementsCache = this.options.initialMeasurementsCache),
			this.measurementsCache.forEach(function (r) {
				n.itemSizeCache.set(r.key, r.size);
			}),
			this.maybeNotify();
	},
	Y0 = function (e, n, r, o) {
		for (; e <= n; ) {
			var i = ((e + n) / 2) | 0,
				s = r(i);
			if (s < o) e = i + 1;
			else if (s > o) n = i - 1;
			else return i;
		}
		return e > 0 ? e - 1 : 0;
	};
function Z3(t) {
	for (
		var e = t.measurements,
			n = t.outerSize,
			r = t.scrollOffset,
			o = e.length - 1,
			i = function (u) {
				return e[u].start;
			},
			s = Y0(0, o, i, r),
			l = s;
		l < o && e[l].end < r + n;

	)
		l++;
	return { startIndex: s, endIndex: l };
}
/**
 * vue-virtual
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function ek(t) {
	var e = new X3(ne(t)),
		n = bu(e),
		r = e._didMount();
	return (
		at(
			function () {
				return ne(t).getScrollElement();
			},
			function (o) {
				o && e._willUpdate();
			},
			{ immediate: !0 }
		),
		at(
			function () {
				return ne(t);
			},
			function (o) {
				e.setOptions(
					va({}, o, {
						onChange: function (s, l) {
							dp(n), o.onChange == null || o.onChange(s, l);
						},
					})
				),
					e._willUpdate(),
					dp(n);
			},
			{ immediate: !0 }
		),
		D1(r),
		n
	);
}
function tk(t) {
	return ek(
		z(function () {
			return va(
				{
					observeElementRect: J3,
					observeElementOffset: G3,
					scrollToFn: Q3,
				},
				ne(t)
			);
		})
	);
}
function nk(t, e, n) {
	let r = Q(n == null ? void 0 : n.value),
		o = z(() => t.value !== void 0);
	return [
		z(() => (o.value ? t.value : r.value)),
		function (i) {
			return o.value || (r.value = i), e == null ? void 0 : e(i);
		},
	];
}
let rk = 0;
function ok() {
	return ++rk;
}
function tn() {
	return ok();
}
function re(t) {
	var e;
	if (t == null || t.value == null) return null;
	let n = (e = t.value.$el) != null ? e : t.value;
	return n instanceof Node ? n : null;
}
function mt(t, e, ...n) {
	if (t in e) {
		let o = e[t];
		return typeof o == "function" ? o(...n) : o;
	}
	let r = new Error(
		`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(
			e
		)
			.map((o) => `"${o}"`)
			.join(", ")}.`
	);
	throw (Error.captureStackTrace && Error.captureStackTrace(r, mt), r);
}
var ik = Object.defineProperty,
	sk = (t, e, n) =>
		e in t
			? ik(t, e, {
					enumerable: !0,
					configurable: !0,
					writable: !0,
					value: n,
			  })
			: (t[e] = n),
	sm = (t, e, n) => (sk(t, typeof e != "symbol" ? e + "" : e, n), n);
let lk = class {
		constructor() {
			sm(this, "current", this.detect()), sm(this, "currentId", 0);
		}
		set(e) {
			this.current !== e && ((this.currentId = 0), (this.current = e));
		}
		reset() {
			this.set(this.detect());
		}
		nextId() {
			return ++this.currentId;
		}
		get isServer() {
			return this.current === "server";
		}
		get isClient() {
			return this.current === "client";
		}
		detect() {
			return typeof window == "undefined" ||
				typeof document == "undefined"
				? "server"
				: "client";
		}
	},
	Qs = new lk();
function fr(t) {
	if (Qs.isServer) return null;
	if (t instanceof Node) return t.ownerDocument;
	if (t != null && t.hasOwnProperty("value")) {
		let e = re(t);
		if (e) return e.ownerDocument;
	}
	return document;
}
let kd = [
	"[contentEditable=true]",
	"[tabindex]",
	"a[href]",
	"area[href]",
	"button:not([disabled])",
	"iframe",
	"input:not([disabled])",
	"select:not([disabled])",
	"textarea:not([disabled])",
]
	.map((t) => `${t}:not([tabindex='-1'])`)
	.join(",");
var Mt = ((t) => (
		(t[(t.First = 1)] = "First"),
		(t[(t.Previous = 2)] = "Previous"),
		(t[(t.Next = 4)] = "Next"),
		(t[(t.Last = 8)] = "Last"),
		(t[(t.WrapAround = 16)] = "WrapAround"),
		(t[(t.NoScroll = 32)] = "NoScroll"),
		t
	))(Mt || {}),
	li = ((t) => (
		(t[(t.Error = 0)] = "Error"),
		(t[(t.Overflow = 1)] = "Overflow"),
		(t[(t.Success = 2)] = "Success"),
		(t[(t.Underflow = 3)] = "Underflow"),
		t
	))(li || {}),
	ak = ((t) => (
		(t[(t.Previous = -1)] = "Previous"), (t[(t.Next = 1)] = "Next"), t
	))(ak || {});
function Q0(t = document.body) {
	return t == null
		? []
		: Array.from(t.querySelectorAll(kd)).sort((e, n) =>
				Math.sign(
					(e.tabIndex || Number.MAX_SAFE_INTEGER) -
						(n.tabIndex || Number.MAX_SAFE_INTEGER)
				)
		  );
}
var Jf = ((t) => (
	(t[(t.Strict = 0)] = "Strict"), (t[(t.Loose = 1)] = "Loose"), t
))(Jf || {});
function Gf(t, e = 0) {
	var n;
	return t === ((n = fr(t)) == null ? void 0 : n.body)
		? !1
		: mt(e, {
				0() {
					return t.matches(kd);
				},
				1() {
					let r = t;
					for (; r !== null; ) {
						if (r.matches(kd)) return !0;
						r = r.parentElement;
					}
					return !1;
				},
		  });
}
function X0(t) {
	let e = fr(t);
	bt(() => {
		e && !Gf(e.activeElement, 0) && eo(t);
	});
}
var uk = ((t) => (
	(t[(t.Keyboard = 0)] = "Keyboard"), (t[(t.Mouse = 1)] = "Mouse"), t
))(uk || {});
typeof window != "undefined" &&
	typeof document != "undefined" &&
	(document.addEventListener(
		"keydown",
		(t) => {
			t.metaKey ||
				t.altKey ||
				t.ctrlKey ||
				(document.documentElement.dataset.headlessuiFocusVisible = "");
		},
		!0
	),
	document.addEventListener(
		"click",
		(t) => {
			t.detail === 1
				? delete document.documentElement.dataset.headlessuiFocusVisible
				: t.detail === 0 &&
				  (document.documentElement.dataset.headlessuiFocusVisible =
						"");
		},
		!0
	));
function eo(t) {
	t == null || t.focus({ preventScroll: !0 });
}
let ck = ["textarea", "input"].join(",");
function dk(t) {
	var e, n;
	return (n =
		(e = t == null ? void 0 : t.matches) == null
			? void 0
			: e.call(t, ck)) != null
		? n
		: !1;
}
function Wr(t, e = (n) => n) {
	return t.slice().sort((n, r) => {
		let o = e(n),
			i = e(r);
		if (o === null || i === null) return 0;
		let s = o.compareDocumentPosition(i);
		return s & Node.DOCUMENT_POSITION_FOLLOWING
			? -1
			: s & Node.DOCUMENT_POSITION_PRECEDING
			? 1
			: 0;
	});
}
function fk(t, e) {
	return Nn(Q0(), e, { relativeTo: t });
}
function Nn(
	t,
	e,
	{ sorted: n = !0, relativeTo: r = null, skipElements: o = [] } = {}
) {
	var i;
	let s =
			(i = Array.isArray(t)
				? t.length > 0
					? t[0].ownerDocument
					: document
				: t == null
				? void 0
				: t.ownerDocument) != null
				? i
				: document,
		l = Array.isArray(t) ? (n ? Wr(t) : t) : Q0(t);
	o.length > 0 && l.length > 1 && (l = l.filter((m) => !o.includes(m))),
		(r = r != null ? r : s.activeElement);
	let a = (() => {
			if (e & 5) return 1;
			if (e & 10) return -1;
			throw new Error(
				"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
			);
		})(),
		u = (() => {
			if (e & 1) return 0;
			if (e & 2) return Math.max(0, l.indexOf(r)) - 1;
			if (e & 4) return Math.max(0, l.indexOf(r)) + 1;
			if (e & 8) return l.length - 1;
			throw new Error(
				"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
			);
		})(),
		c = e & 32 ? { preventScroll: !0 } : {},
		d = 0,
		f = l.length,
		p;
	do {
		if (d >= f || d + f <= 0) return 0;
		let m = u + d;
		if (e & 16) m = (m + f) % f;
		else {
			if (m < 0) return 3;
			if (m >= f) return 1;
		}
		(p = l[m]), p == null || p.focus(c), (d += a);
	} while (p !== s.activeElement);
	return e & 6 && dk(p) && p.select(), 2;
}
function Z0() {
	return (
		/iPhone/gi.test(window.navigator.platform) ||
		(/Mac/gi.test(window.navigator.platform) &&
			window.navigator.maxTouchPoints > 0)
	);
}
function hk() {
	return /Android/gi.test(window.navigator.userAgent);
}
function ey() {
	return Z0() || hk();
}
function wl(t, e, n) {
	Qs.isServer ||
		xt((r) => {
			document.addEventListener(t, e, n),
				r(() => document.removeEventListener(t, e, n));
		});
}
function ty(t, e, n) {
	Qs.isServer ||
		xt((r) => {
			window.addEventListener(t, e, n),
				r(() => window.removeEventListener(t, e, n));
		});
}
function Yf(t, e, n = z(() => !0)) {
	function r(i, s) {
		if (!n.value || i.defaultPrevented) return;
		let l = s(i);
		if (l === null || !l.getRootNode().contains(l)) return;
		let a = (function u(c) {
			return typeof c == "function"
				? u(c())
				: Array.isArray(c) || c instanceof Set
				? c
				: [c];
		})(t);
		for (let u of a) {
			if (u === null) continue;
			let c = u instanceof HTMLElement ? u : re(u);
			if (
				(c != null && c.contains(l)) ||
				(i.composed && i.composedPath().includes(c))
			)
				return;
		}
		return (
			!Gf(l, Jf.Loose) && l.tabIndex !== -1 && i.preventDefault(), e(i, l)
		);
	}
	let o = Q(null);
	wl(
		"pointerdown",
		(i) => {
			var s, l;
			n.value &&
				(o.value =
					((l = (s = i.composedPath) == null ? void 0 : s.call(i)) ==
					null
						? void 0
						: l[0]) || i.target);
		},
		!0
	),
		wl(
			"mousedown",
			(i) => {
				var s, l;
				n.value &&
					(o.value =
						((l =
							(s = i.composedPath) == null
								? void 0
								: s.call(i)) == null
							? void 0
							: l[0]) || i.target);
			},
			!0
		),
		wl(
			"click",
			(i) => {
				ey() || (o.value && (r(i, () => o.value), (o.value = null)));
			},
			!0
		),
		wl(
			"touchend",
			(i) =>
				r(i, () => (i.target instanceof HTMLElement ? i.target : null)),
			!0
		),
		ty(
			"blur",
			(i) =>
				r(i, () =>
					window.document.activeElement instanceof HTMLIFrameElement
						? window.document.activeElement
						: null
				),
			!0
		);
}
function lm(t, e) {
	if (t) return t;
	let n = e != null ? e : "button";
	if (typeof n == "string" && n.toLowerCase() === "button") return "button";
}
function Ru(t, e) {
	let n = Q(lm(t.value.type, t.value.as));
	return (
		Ze(() => {
			n.value = lm(t.value.type, t.value.as);
		}),
		xt(() => {
			var r;
			n.value ||
				(re(e) &&
					re(e) instanceof HTMLButtonElement &&
					!((r = re(e)) != null && r.hasAttribute("type")) &&
					(n.value = "button"));
		}),
		n
	);
}
function am(t) {
	return [t.screenX, t.screenY];
}
function ny() {
	let t = Q([-1, -1]);
	return {
		wasMoved(e) {
			let n = am(e);
			return t.value[0] === n[0] && t.value[1] === n[1]
				? !1
				: ((t.value = n), !0);
		},
		update(e) {
			t.value = am(e);
		},
	};
}
function ry({ container: t, accept: e, walk: n, enabled: r }) {
	xt(() => {
		let o = t.value;
		if (!o || (r !== void 0 && !r.value)) return;
		let i = fr(t);
		if (!i) return;
		let s = Object.assign((a) => e(a), { acceptNode: e }),
			l = i.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, s, !1);
		for (; l.nextNode(); ) n(l.currentNode);
	});
}
var fn = ((t) => (
		(t[(t.None = 0)] = "None"),
		(t[(t.RenderStrategy = 1)] = "RenderStrategy"),
		(t[(t.Static = 2)] = "Static"),
		t
	))(fn || {}),
	Jr = ((t) => (
		(t[(t.Unmount = 0)] = "Unmount"), (t[(t.Hidden = 1)] = "Hidden"), t
	))(Jr || {});
function it(i) {
	var s = i,
		{ visible: t = !0, features: e = 0, ourProps: n, theirProps: r } = s,
		o = tt(s, ["visible", "features", "ourProps", "theirProps"]);
	var l;
	let a = iy(r, n),
		u = Object.assign(o, { props: a });
	if (t || (e & 2 && a.static)) return Sc(u);
	if (e & 1) {
		let c = (l = a.unmount) == null || l ? 0 : 1;
		return mt(c, {
			0() {
				return null;
			},
			1() {
				return Sc(
					ge(B({}, o), {
						props: ge(B({}, a), {
							hidden: !0,
							style: { display: "none" },
						}),
					})
				);
			},
		});
	}
	return Sc(u);
}
function Sc({ props: t, attrs: e, slots: n, slot: r, name: o }) {
	var i, s;
	let d = $i(t, ["unmount", "static"]),
		{ as: l } = d,
		a = tt(d, ["as"]),
		u = (i = n.default) == null ? void 0 : i.call(n, r),
		c = {};
	if (r) {
		let f = !1,
			p = [];
		for (let [m, y] of Object.entries(r))
			typeof y == "boolean" && (f = !0), y === !0 && p.push(m);
		f && (c["data-headlessui-state"] = p.join(" "));
	}
	if (l === "template") {
		if (
			((u = oy(u != null ? u : [])),
			Object.keys(a).length > 0 || Object.keys(e).length > 0)
		) {
			let [f, ...p] = u != null ? u : [];
			if (!mk(f) || p.length > 0)
				throw new Error(
					[
						'Passing props on "template"!',
						"",
						`The current component <${o} /> is rendering a "template".`,
						"However we need to passthrough the following props:",
						Object.keys(a)
							.concat(Object.keys(e))
							.map((v) => v.trim())
							.filter((v, w, S) => S.indexOf(v) === w)
							.sort((v, w) => v.localeCompare(w))
							.map((v) => `  - ${v}`).join(`
`),
						"",
						"You can apply a few solutions:",
						[
							'Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".',
							"Render a single element as the child so that we can forward the props onto that element.",
						].map((v) => `  - ${v}`).join(`
`),
					].join(`
`)
				);
			let m = iy((s = f.props) != null ? s : {}, a, c),
				y = sr(f, m, !0);
			for (let v in m)
				v.startsWith("on") &&
					(y.props || (y.props = {}), (y.props[v] = m[v]));
			return y;
		}
		return Array.isArray(u) && u.length === 1 ? u[0] : u;
	}
	return Ke(l, Object.assign({}, a, c), { default: () => u });
}
function oy(t) {
	return t.flatMap((e) => (e.type === Ne ? oy(e.children) : [e]));
}
function iy(...t) {
	if (t.length === 0) return {};
	if (t.length === 1) return t[0];
	let e = {},
		n = {};
	for (let r of t)
		for (let o in r)
			o.startsWith("on") && typeof r[o] == "function"
				? (n[o] != null || (n[o] = []), n[o].push(r[o]))
				: (e[o] = r[o]);
	if (e.disabled || e["aria-disabled"])
		return Object.assign(
			e,
			Object.fromEntries(Object.keys(n).map((r) => [r, void 0]))
		);
	for (let r in n)
		Object.assign(e, {
			[r](o, ...i) {
				let s = n[r];
				for (let l of s) {
					if (o instanceof Event && o.defaultPrevented) return;
					l(o, ...i);
				}
			},
		});
	return e;
}
function pk(t) {
	let e = Object.assign({}, t);
	for (let n in e) e[n] === void 0 && delete e[n];
	return e;
}
function $i(t, e = []) {
	let n = Object.assign({}, t);
	for (let r of e) r in n && delete n[r];
	return n;
}
function mk(t) {
	return t == null
		? !1
		: typeof t.type == "string" ||
				typeof t.type == "object" ||
				typeof t.type == "function";
}
var _i = ((t) => (
	(t[(t.None = 1)] = "None"),
	(t[(t.Focusable = 2)] = "Focusable"),
	(t[(t.Hidden = 4)] = "Hidden"),
	t
))(_i || {});
let Ci = Oe({
		name: "Hidden",
		props: {
			as: { type: [Object, String], default: "div" },
			features: { type: Number, default: 1 },
		},
		setup(t, { slots: e, attrs: n }) {
			return () => {
				var r;
				let l = t,
					{ features: o } = l,
					i = tt(l, ["features"]),
					s = {
						"aria-hidden":
							(o & 2) === 2
								? !0
								: (r = i["aria-hidden"]) != null
								? r
								: void 0,
						style: B(
							{
								position: "fixed",
								top: 1,
								left: 1,
								width: 1,
								height: 0,
								padding: 0,
								margin: -1,
								overflow: "hidden",
								clip: "rect(0, 0, 0, 0)",
								whiteSpace: "nowrap",
								borderWidth: "0",
							},
							(o & 4) === 4 &&
								(o & 2) !== 2 && { display: "none" }
						),
					};
				return it({
					ourProps: s,
					theirProps: i,
					slot: {},
					attrs: n,
					slots: e,
					name: "Hidden",
				});
			};
		},
	}),
	sy = Symbol("Context");
var ct = ((t) => (
	(t[(t.Open = 1)] = "Open"),
	(t[(t.Closed = 2)] = "Closed"),
	(t[(t.Closing = 4)] = "Closing"),
	(t[(t.Opening = 8)] = "Opening"),
	t
))(ct || {});
function gk() {
	return Bi() !== null;
}
function Bi() {
	return Ge(sy, null);
}
function Pu(t) {
	wt(sy, t);
}
var Ae = ((t) => (
	(t.Space = " "),
	(t.Enter = "Enter"),
	(t.Escape = "Escape"),
	(t.Backspace = "Backspace"),
	(t.Delete = "Delete"),
	(t.ArrowLeft = "ArrowLeft"),
	(t.ArrowUp = "ArrowUp"),
	(t.ArrowRight = "ArrowRight"),
	(t.ArrowDown = "ArrowDown"),
	(t.Home = "Home"),
	(t.End = "End"),
	(t.PageUp = "PageUp"),
	(t.PageDown = "PageDown"),
	(t.Tab = "Tab"),
	t
))(Ae || {});
function yk(t) {
	function e() {
		document.readyState !== "loading" &&
			(t(), document.removeEventListener("DOMContentLoaded", e));
	}
	typeof window != "undefined" &&
		typeof document != "undefined" &&
		(document.addEventListener("DOMContentLoaded", e), e());
}
let xr = [];
yk(() => {
	function t(e) {
		e.target instanceof HTMLElement &&
			e.target !== document.body &&
			xr[0] !== e.target &&
			(xr.unshift(e.target),
			(xr = xr.filter((n) => n != null && n.isConnected)),
			xr.splice(10));
	}
	window.addEventListener("click", t, { capture: !0 }),
		window.addEventListener("mousedown", t, { capture: !0 }),
		window.addEventListener("focus", t, { capture: !0 }),
		document.body.addEventListener("click", t, { capture: !0 }),
		document.body.addEventListener("mousedown", t, { capture: !0 }),
		document.body.addEventListener("focus", t, { capture: !0 });
});
function vk(t) {
	throw new Error("Unexpected object: " + t);
}
var rt = ((t) => (
	(t[(t.First = 0)] = "First"),
	(t[(t.Previous = 1)] = "Previous"),
	(t[(t.Next = 2)] = "Next"),
	(t[(t.Last = 3)] = "Last"),
	(t[(t.Specific = 4)] = "Specific"),
	(t[(t.Nothing = 5)] = "Nothing"),
	t
))(rt || {});
function Sd(t, e) {
	let n = e.resolveItems();
	if (n.length <= 0) return null;
	let r = e.resolveActiveIndex(),
		o = r != null ? r : -1;
	switch (t.focus) {
		case 0: {
			for (let i = 0; i < n.length; ++i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 1: {
			o === -1 && (o = n.length);
			for (let i = o - 1; i >= 0; --i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 2: {
			for (let i = o + 1; i < n.length; ++i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 3: {
			for (let i = n.length - 1; i >= 0; --i)
				if (!e.resolveDisabled(n[i], i, n)) return i;
			return r;
		}
		case 4: {
			for (let i = 0; i < n.length; ++i)
				if (e.resolveId(n[i], i, n) === t.id) return i;
			return r;
		}
		case 5:
			return null;
		default:
			vk(t);
	}
}
function Iu(t) {
	typeof queueMicrotask == "function"
		? queueMicrotask(t)
		: Promise.resolve()
				.then(t)
				.catch((e) =>
					setTimeout(() => {
						throw e;
					})
				);
}
function $o() {
	let t = [],
		e = {
			addEventListener(n, r, o, i) {
				return (
					n.addEventListener(r, o, i),
					e.add(() => n.removeEventListener(r, o, i))
				);
			},
			requestAnimationFrame(...n) {
				let r = requestAnimationFrame(...n);
				e.add(() => cancelAnimationFrame(r));
			},
			nextFrame(...n) {
				e.requestAnimationFrame(() => {
					e.requestAnimationFrame(...n);
				});
			},
			setTimeout(...n) {
				let r = setTimeout(...n);
				e.add(() => clearTimeout(r));
			},
			microTask(...n) {
				let r = { current: !0 };
				return (
					Iu(() => {
						r.current && n[0]();
					}),
					e.add(() => {
						r.current = !1;
					})
				);
			},
			style(n, r, o) {
				let i = n.style.getPropertyValue(r);
				return (
					Object.assign(n.style, { [r]: o }),
					this.add(() => {
						Object.assign(n.style, { [r]: i });
					})
				);
			},
			group(n) {
				let r = $o();
				return n(r), this.add(() => r.dispose());
			},
			add(n) {
				return (
					t.push(n),
					() => {
						let r = t.indexOf(n);
						if (r >= 0) for (let o of t.splice(r, 1)) o();
					}
				);
			},
			dispose() {
				for (let n of t.splice(0)) n();
			},
		};
	return e;
}
function ly(t = {}, e = null, n = []) {
	for (let [r, o] of Object.entries(t)) uy(n, ay(e, r), o);
	return n;
}
function ay(t, e) {
	return t ? t + "[" + e + "]" : e;
}
function uy(t, e, n) {
	if (Array.isArray(n))
		for (let [r, o] of n.entries()) uy(t, ay(e, r.toString()), o);
	else
		n instanceof Date
			? t.push([e, n.toISOString()])
			: typeof n == "boolean"
			? t.push([e, n ? "1" : "0"])
			: typeof n == "string"
			? t.push([e, n])
			: typeof n == "number"
			? t.push([e, `${n}`])
			: n == null
			? t.push([e, ""])
			: ly(n, e, t);
}
var bk = {};
function wk(t, e) {
	return t === e;
}
var xk = ((t) => (
		(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
	))(xk || {}),
	kk = ((t) => (
		(t[(t.Single = 0)] = "Single"), (t[(t.Multi = 1)] = "Multi"), t
	))(kk || {}),
	Sk = ((t) => (
		(t[(t.Pointer = 0)] = "Pointer"),
		(t[(t.Focus = 1)] = "Focus"),
		(t[(t.Other = 2)] = "Other"),
		t
	))(Sk || {});
let cy = Symbol("ComboboxContext");
function zi(t) {
	let e = Ge(cy, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <Combobox /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, zi), n);
	}
	return e;
}
let dy = Symbol("VirtualContext"),
	_k = Oe({
		name: "VirtualProvider",
		setup(t, { slots: e }) {
			let n = zi("VirtualProvider"),
				r = z(() => {
					let l = re(n.optionsRef);
					if (!l) return { start: 0, end: 0 };
					let a = window.getComputedStyle(l);
					return {
						start: parseFloat(a.paddingBlockStart || a.paddingTop),
						end: parseFloat(a.paddingBlockEnd || a.paddingBottom),
					};
				}),
				o = tk(
					z(() => ({
						scrollPaddingStart: r.value.start,
						scrollPaddingEnd: r.value.end,
						count: n.virtual.value.options.length,
						estimateSize() {
							return 40;
						},
						getScrollElement() {
							return re(n.optionsRef);
						},
						overscan: 12,
					}))
				),
				i = z(() => {
					var l;
					return (l = n.virtual.value) == null ? void 0 : l.options;
				}),
				s = Q(0);
			return (
				at([i], () => {
					s.value += 1;
				}),
				wt(dy, n.virtual.value ? o : null),
				() => [
					Ke(
						"div",
						{
							style: {
								position: "relative",
								width: "100%",
								height: `${o.value.getTotalSize()}px`,
							},
							ref: (l) => {
								if (l) {
									if (
										(typeof process != "undefined" &&
											bk.JEST_WORKER_ID !== void 0) ||
										n.activationTrigger.value === 0
									)
										return;
									n.activeOptionIndex.value !== null &&
										n.virtual.value.options.length >
											n.activeOptionIndex.value &&
										o.value.scrollToIndex(
											n.activeOptionIndex.value
										);
								}
							},
						},
						o.value.getVirtualItems().map((l) =>
							sr(
								e.default({
									option: n.virtual.value.options[l.index],
									open: n.comboboxState.value === 0,
								})[0],
								{
									key: `${s.value}-${l.index}`,
									"data-index": l.index,
									"aria-setsize":
										n.virtual.value.options.length,
									"aria-posinset": l.index + 1,
									style: {
										position: "absolute",
										top: 0,
										left: 0,
										transform: `translateY(${l.start}px)`,
										overflowAnchor: "none",
									},
								}
							)
						)
					),
				]
			);
		},
	}),
	Ck = Oe({
		name: "Combobox",
		emits: { "update:modelValue": (t) => !0 },
		props: {
			as: { type: [Object, String], default: "template" },
			disabled: { type: [Boolean], default: !1 },
			by: { type: [String, Function], nullable: !0, default: null },
			modelValue: {
				type: [Object, String, Number, Boolean],
				default: void 0,
			},
			defaultValue: {
				type: [Object, String, Number, Boolean],
				default: void 0,
			},
			form: { type: String, optional: !0 },
			name: { type: String, optional: !0 },
			nullable: { type: Boolean, default: !1 },
			multiple: { type: [Boolean], default: !1 },
			immediate: { type: [Boolean], default: !1 },
			virtual: { type: Object, default: null },
		},
		inheritAttrs: !1,
		setup(t, { slots: e, attrs: n, emit: r }) {
			let o = Q(1),
				i = Q(null),
				s = Q(null),
				l = Q(null),
				a = Q(null),
				u = Q({ static: !1, hold: !1 }),
				c = Q([]),
				d = Q(null),
				f = Q(2),
				p = Q(!1);
			function m(_ = (T) => T) {
				let T = d.value !== null ? c.value[d.value] : null,
					R = _(c.value.slice()),
					P =
						R.length > 0 && R[0].dataRef.order.value !== null
							? R.sort(
									(j, M) =>
										j.dataRef.order.value -
										M.dataRef.order.value
							  )
							: Wr(R, (j) => re(j.dataRef.domRef)),
					D = T ? P.indexOf(T) : null;
				return (
					D === -1 && (D = null), { options: P, activeOptionIndex: D }
				);
			}
			let y = z(() => (t.multiple ? 1 : 0)),
				v = z(() => t.nullable),
				[w, S] = nk(
					z(() => t.modelValue),
					(_) => r("update:modelValue", _),
					z(() => t.defaultValue)
				),
				E = z(() =>
					w.value === void 0
						? mt(y.value, { 1: [], 0: void 0 })
						: w.value
				),
				h = null,
				b = null;
			function g(_) {
				return mt(y.value, {
					0() {
						return S == null ? void 0 : S(_);
					},
					1: () => {
						let T = je(k.value.value).slice(),
							R = je(_),
							P = T.findIndex((D) => k.compare(R, je(D)));
						return (
							P === -1 ? T.push(R) : T.splice(P, 1),
							S == null ? void 0 : S(T)
						);
					},
				});
			}
			let x = z(() => {});
			at([x], ([_], [T]) => {
				if (k.virtual.value && _ && T && d.value !== null) {
					let R = _.indexOf(T[d.value]);
					R !== -1 ? (d.value = R) : (d.value = null);
				}
			});
			let k = {
				comboboxState: o,
				value: E,
				mode: y,
				compare(_, T) {
					if (typeof t.by == "string") {
						let R = t.by;
						return (
							(_ == null ? void 0 : _[R]) ===
							(T == null ? void 0 : T[R])
						);
					}
					return t.by === null ? wk(_, T) : t.by(_, T);
				},
				calculateIndex(_) {
					return k.virtual.value
						? t.by === null
							? k.virtual.value.options.indexOf(_)
							: k.virtual.value.options.findIndex((T) =>
									k.compare(T, _)
							  )
						: c.value.findIndex((T) =>
								k.compare(T.dataRef.value, _)
						  );
				},
				defaultValue: z(() => t.defaultValue),
				nullable: v,
				immediate: z(() => !1),
				virtual: z(() => null),
				inputRef: s,
				labelRef: i,
				buttonRef: l,
				optionsRef: a,
				disabled: z(() => t.disabled),
				options: c,
				change(_) {
					S(_);
				},
				activeOptionIndex: z(() => {
					if (
						p.value &&
						d.value === null &&
						(k.virtual.value
							? k.virtual.value.options.length > 0
							: c.value.length > 0)
					) {
						if (k.virtual.value) {
							let T = k.virtual.value.options.findIndex((R) => {
								var P;
								return !(
									(P = k.virtual.value) != null &&
									P.disabled(R)
								);
							});
							if (T !== -1) return T;
						}
						let _ = c.value.findIndex((T) => !T.dataRef.disabled);
						if (_ !== -1) return _;
					}
					return d.value;
				}),
				activationTrigger: f,
				optionsPropsRef: u,
				closeCombobox() {
					(p.value = !1),
						!t.disabled &&
							o.value !== 1 &&
							((o.value = 1), (d.value = null));
				},
				openCombobox() {
					if (((p.value = !0), !t.disabled && o.value !== 0)) {
						if (k.value.value) {
							let _ = k.calculateIndex(k.value.value);
							_ !== -1 && (d.value = _);
						}
						o.value = 0;
					}
				},
				setActivationTrigger(_) {
					f.value = _;
				},
				goToOption(_, T, R) {
					(p.value = !1),
						h !== null && cancelAnimationFrame(h),
						(h = requestAnimationFrame(() => {
							if (
								t.disabled ||
								(a.value && !u.value.static && o.value === 1)
							)
								return;
							if (k.virtual.value) {
								(d.value =
									_ === rt.Specific
										? T
										: Sd(
												{ focus: _ },
												{
													resolveItems: () =>
														k.virtual.value.options,
													resolveActiveIndex: () => {
														var j, M;
														return (M =
															(j =
																k
																	.activeOptionIndex
																	.value) !=
															null
																? j
																: k.virtual.value.options.findIndex(
																		(I) => {
																			var $;
																			return !(
																				($ =
																					k
																						.virtual
																						.value) !=
																					null &&
																				$.disabled(
																					I
																				)
																			);
																		}
																  )) != null
															? M
															: null;
													},
													resolveDisabled: (j) =>
														k.virtual.value.disabled(
															j
														),
													resolveId() {
														throw new Error(
															"Function not implemented."
														);
													},
												}
										  )),
									(f.value = R != null ? R : 2);
								return;
							}
							let P = m();
							if (P.activeOptionIndex === null) {
								let j = P.options.findIndex(
									(M) => !M.dataRef.disabled
								);
								j !== -1 && (P.activeOptionIndex = j);
							}
							let D =
								_ === rt.Specific
									? T
									: Sd(
											{ focus: _ },
											{
												resolveItems: () => P.options,
												resolveActiveIndex: () =>
													P.activeOptionIndex,
												resolveId: (j) => j.id,
												resolveDisabled: (j) =>
													j.dataRef.disabled,
											}
									  );
							(d.value = D),
								(f.value = R != null ? R : 2),
								(c.value = P.options);
						}));
				},
				selectOption(_) {
					let T = c.value.find((P) => P.id === _);
					if (!T) return;
					let { dataRef: R } = T;
					g(R.value);
				},
				selectActiveOption() {
					if (k.activeOptionIndex.value !== null) {
						if (k.virtual.value)
							g(
								k.virtual.value.options[
									k.activeOptionIndex.value
								]
							);
						else {
							let { dataRef: _ } =
								c.value[k.activeOptionIndex.value];
							g(_.value);
						}
						k.goToOption(rt.Specific, k.activeOptionIndex.value);
					}
				},
				registerOption(_, T) {
					let R = Yt({ id: _, dataRef: T });
					if (k.virtual.value) {
						c.value.push(R);
						return;
					}
					b && cancelAnimationFrame(b);
					let P = m((D) => (D.push(R), D));
					d.value === null &&
						k.isSelected(T.value.value) &&
						(P.activeOptionIndex = P.options.indexOf(R)),
						(c.value = P.options),
						(d.value = P.activeOptionIndex),
						(f.value = 2),
						P.options.some((D) => !re(D.dataRef.domRef)) &&
							(b = requestAnimationFrame(() => {
								let D = m();
								(c.value = D.options),
									(d.value = D.activeOptionIndex);
							}));
				},
				unregisterOption(_, T) {
					if (
						(h !== null && cancelAnimationFrame(h),
						T && (p.value = !0),
						k.virtual.value)
					) {
						c.value = c.value.filter((P) => P.id !== _);
						return;
					}
					let R = m((P) => {
						let D = P.findIndex((j) => j.id === _);
						return D !== -1 && P.splice(D, 1), P;
					});
					(c.value = R.options),
						(d.value = R.activeOptionIndex),
						(f.value = 2);
				},
				isSelected(_) {
					return mt(y.value, {
						0: () => k.compare(je(k.value.value), je(_)),
						1: () =>
							je(k.value.value).some((T) =>
								k.compare(je(T), je(_))
							),
					});
				},
				isActive(_) {
					return d.value === k.calculateIndex(_);
				},
			};
			Yf(
				[s, l, a],
				() => k.closeCombobox(),
				z(() => o.value === 0)
			),
				wt(cy, k),
				Pu(z(() => mt(o.value, { 0: ct.Open, 1: ct.Closed })));
			let C = z(() => {
				var _;
				return (_ = re(s)) == null ? void 0 : _.closest("form");
			});
			return (
				Ze(() => {
					at(
						[C],
						() => {
							if (!C.value || t.defaultValue === void 0) return;
							function _() {
								k.change(t.defaultValue);
							}
							return (
								C.value.addEventListener("reset", _),
								() => {
									var T;
									(T = C.value) == null ||
										T.removeEventListener("reset", _);
								}
							);
						},
						{ immediate: !0 }
					);
				}),
				() => {
					var _, T, R;
					let $ = t,
						{ name: P, disabled: D, form: j } = $,
						M = tt($, ["name", "disabled", "form"]),
						I = {
							open: o.value === 0,
							disabled: D,
							activeIndex: k.activeOptionIndex.value,
							activeOption:
								k.activeOptionIndex.value === null
									? null
									: k.virtual.value
									? k.virtual.value.options[
											(_ = k.activeOptionIndex.value) !=
											null
												? _
												: 0
									  ]
									: (R =
											(T =
												k.options.value[
													k.activeOptionIndex.value
												]) == null
												? void 0
												: T.dataRef.value.value) != null
									? R
									: null,
							value: E.value,
						};
					return Ke(Ne, [
						...(P != null && E.value != null
							? ly({ [P]: E.value }).map(([K, ie]) =>
									Ke(
										Ci,
										pk({
											features: _i.Hidden,
											key: K,
											as: "input",
											type: "hidden",
											hidden: !0,
											readOnly: !0,
											form: j,
											name: K,
											value: ie,
										})
									)
							  )
							: []),
						it({
							theirProps: B(
								B({}, n),
								$i(M, [
									"by",
									"defaultValue",
									"immediate",
									"modelValue",
									"multiple",
									"nullable",
									"onUpdate:modelValue",
									"virtual",
								])
							),
							ourProps: {},
							slot: I,
							slots: e,
							attrs: n,
							name: "Combobox",
						}),
					]);
				}
			);
		},
	}),
	Mk = Oe({
		name: "ComboboxButton",
		props: {
			as: { type: [Object, String], default: "button" },
			id: {
				type: String,
				default: () => `headlessui-combobox-button-${tn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = zi("ComboboxButton");
			r({ el: o.buttonRef, $el: o.buttonRef });
			function i(a) {
				o.disabled.value ||
					(o.comboboxState.value === 0
						? o.closeCombobox()
						: (a.preventDefault(), o.openCombobox()),
					bt(() => {
						var u;
						return (u = re(o.inputRef)) == null
							? void 0
							: u.focus({ preventScroll: !0 });
					}));
			}
			function s(a) {
				switch (a.key) {
					case Ae.ArrowDown:
						a.preventDefault(),
							a.stopPropagation(),
							o.comboboxState.value === 1 && o.openCombobox(),
							bt(() => {
								var u;
								return (u = o.inputRef.value) == null
									? void 0
									: u.focus({ preventScroll: !0 });
							});
						return;
					case Ae.ArrowUp:
						a.preventDefault(),
							a.stopPropagation(),
							o.comboboxState.value === 1 &&
								(o.openCombobox(),
								bt(() => {
									o.value.value || o.goToOption(rt.Last);
								})),
							bt(() => {
								var u;
								return (u = o.inputRef.value) == null
									? void 0
									: u.focus({ preventScroll: !0 });
							});
						return;
					case Ae.Escape:
						if (o.comboboxState.value !== 0) return;
						a.preventDefault(),
							o.optionsRef.value &&
								!o.optionsPropsRef.value.static &&
								a.stopPropagation(),
							o.closeCombobox(),
							bt(() => {
								var u;
								return (u = o.inputRef.value) == null
									? void 0
									: u.focus({ preventScroll: !0 });
							});
						return;
				}
			}
			let l = Ru(
				z(() => ({ as: t.as, type: e.type })),
				o.buttonRef
			);
			return () => {
				var a, u;
				let c = {
						open: o.comboboxState.value === 0,
						disabled: o.disabled.value,
						value: o.value.value,
					},
					m = t,
					{ id: d } = m,
					f = tt(m, ["id"]),
					p = {
						ref: o.buttonRef,
						id: d,
						type: l.value,
						tabindex: "-1",
						"aria-haspopup": "listbox",
						"aria-controls":
							(a = re(o.optionsRef)) == null ? void 0 : a.id,
						"aria-expanded": o.comboboxState.value === 0,
						"aria-labelledby": o.labelRef.value
							? [
									(u = re(o.labelRef)) == null
										? void 0
										: u.id,
									d,
							  ].join(" ")
							: void 0,
						disabled: o.disabled.value === !0 ? !0 : void 0,
						onKeydown: s,
						onClick: i,
					};
				return it({
					ourProps: p,
					theirProps: f,
					slot: c,
					attrs: e,
					slots: n,
					name: "ComboboxButton",
				});
			};
		},
	}),
	Ek = Oe({
		name: "ComboboxInput",
		props: {
			as: { type: [Object, String], default: "input" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			displayValue: { type: Function },
			defaultValue: { type: String, default: void 0 },
			id: {
				type: String,
				default: () => `headlessui-combobox-input-${tn()}`,
			},
		},
		emits: { change: (t) => !0 },
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			let i = zi("ComboboxInput"),
				s = z(() => fr(re(i.inputRef))),
				l = { value: !1 };
			o({ el: i.inputRef, $el: i.inputRef });
			function a() {
				i.change(null);
				let S = re(i.optionsRef);
				S && (S.scrollTop = 0), i.goToOption(rt.Nothing);
			}
			let u = z(() => {
				var S;
				let E = i.value.value;
				return re(i.inputRef)
					? typeof t.displayValue != "undefined" && E !== void 0
						? (S = t.displayValue(E)) != null
							? S
							: ""
						: typeof E == "string"
						? E
						: ""
					: "";
			});
			Ze(() => {
				at(
					[u, i.comboboxState, s],
					([S, E], [h, b]) => {
						if (l.value) return;
						let g = re(i.inputRef);
						g &&
							(((b === 0 && E === 1) || S !== h) && (g.value = S),
							requestAnimationFrame(() => {
								var x;
								if (
									l.value ||
									!g ||
									((x = s.value) == null
										? void 0
										: x.activeElement) !== g
								)
									return;
								let { selectionStart: k, selectionEnd: C } = g;
								Math.abs(
									(C != null ? C : 0) - (k != null ? k : 0)
								) === 0 &&
									k === 0 &&
									g.setSelectionRange(
										g.value.length,
										g.value.length
									);
							}));
					},
					{ immediate: !0 }
				),
					at([i.comboboxState], ([S], [E]) => {
						if (S === 0 && E === 1) {
							if (l.value) return;
							let h = re(i.inputRef);
							if (!h) return;
							let b = h.value,
								{
									selectionStart: g,
									selectionEnd: x,
									selectionDirection: k,
								} = h;
							(h.value = ""),
								(h.value = b),
								k !== null
									? h.setSelectionRange(g, x, k)
									: h.setSelectionRange(g, x);
						}
					});
			});
			let c = Q(!1);
			function d() {
				c.value = !0;
			}
			function f() {
				$o().nextFrame(() => {
					c.value = !1;
				});
			}
			function p(S) {
				switch (((l.value = !0), S.key)) {
					case Ae.Enter:
						if (
							((l.value = !1),
							i.comboboxState.value !== 0 || c.value)
						)
							return;
						if (
							(S.preventDefault(),
							S.stopPropagation(),
							i.activeOptionIndex.value === null)
						) {
							i.closeCombobox();
							return;
						}
						i.selectActiveOption(),
							i.mode.value === 0 && i.closeCombobox();
						break;
					case Ae.ArrowDown:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							mt(i.comboboxState.value, {
								0: () => i.goToOption(rt.Next),
								1: () => i.openCombobox(),
							})
						);
					case Ae.ArrowUp:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							mt(i.comboboxState.value, {
								0: () => i.goToOption(rt.Previous),
								1: () => {
									i.openCombobox(),
										bt(() => {
											i.value.value ||
												i.goToOption(rt.Last);
										});
								},
							})
						);
					case Ae.Home:
						if (S.shiftKey) break;
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.First)
						);
					case Ae.PageUp:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.First)
						);
					case Ae.End:
						if (S.shiftKey) break;
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.Last)
						);
					case Ae.PageDown:
						return (
							(l.value = !1),
							S.preventDefault(),
							S.stopPropagation(),
							i.goToOption(rt.Last)
						);
					case Ae.Escape:
						if (((l.value = !1), i.comboboxState.value !== 0))
							return;
						S.preventDefault(),
							i.optionsRef.value &&
								!i.optionsPropsRef.value.static &&
								S.stopPropagation(),
							i.nullable.value &&
								i.mode.value === 0 &&
								i.value.value === null &&
								a(),
							i.closeCombobox();
						break;
					case Ae.Tab:
						if (((l.value = !1), i.comboboxState.value !== 0))
							return;
						i.mode.value === 0 &&
							i.activationTrigger.value !== 1 &&
							i.selectActiveOption(),
							i.closeCombobox();
						break;
				}
			}
			function m(S) {
				e("change", S),
					i.nullable.value &&
						i.mode.value === 0 &&
						S.target.value === "" &&
						a(),
					i.openCombobox();
			}
			function y(S) {
				var E, h, b;
				let g =
					(E = S.relatedTarget) != null
						? E
						: xr.find((x) => x !== S.currentTarget);
				if (
					((l.value = !1),
					!((h = re(i.optionsRef)) != null && h.contains(g)) &&
						!((b = re(i.buttonRef)) != null && b.contains(g)) &&
						i.comboboxState.value === 0)
				)
					return (
						S.preventDefault(),
						i.mode.value === 0 &&
							(i.nullable.value && i.value.value === null
								? a()
								: i.activationTrigger.value !== 1 &&
								  i.selectActiveOption()),
						i.closeCombobox()
					);
			}
			function v(S) {
				var E, h, b;
				let g =
					(E = S.relatedTarget) != null
						? E
						: xr.find((x) => x !== S.currentTarget);
				((h = re(i.buttonRef)) != null && h.contains(g)) ||
					((b = re(i.optionsRef)) != null && b.contains(g)) ||
					i.disabled.value ||
					(i.immediate.value &&
						i.comboboxState.value !== 0 &&
						(i.openCombobox(),
						$o().nextFrame(() => {
							i.setActivationTrigger(1);
						})));
			}
			let w = z(() => {
				var S, E, h, b;
				return (b =
					(h =
						(E = t.defaultValue) != null
							? E
							: i.defaultValue.value !== void 0
							? (S = t.displayValue) == null
								? void 0
								: S.call(t, i.defaultValue.value)
							: null) != null
						? h
						: i.defaultValue.value) != null
					? b
					: "";
			});
			return () => {
				var S, E, h, b, g, x, k;
				let C = { open: i.comboboxState.value === 0 },
					j = t,
					{ id: _, displayValue: T, onChange: R } = j,
					P = tt(j, ["id", "displayValue", "onChange"]),
					D = {
						"aria-controls":
							(S = i.optionsRef.value) == null ? void 0 : S.id,
						"aria-expanded": i.comboboxState.value === 0,
						"aria-activedescendant":
							i.activeOptionIndex.value === null
								? void 0
								: i.virtual.value
								? (E = i.options.value.find(
										(M) =>
											!i.virtual.value.disabled(
												M.dataRef.value
											) &&
											i.compare(
												M.dataRef.value,
												i.virtual.value.options[
													i.activeOptionIndex.value
												]
											)
								  )) == null
									? void 0
									: E.id
								: (h =
										i.options.value[
											i.activeOptionIndex.value
										]) == null
								? void 0
								: h.id,
						"aria-labelledby":
							(x =
								(b = re(i.labelRef)) == null ? void 0 : b.id) !=
							null
								? x
								: (g = re(i.buttonRef)) == null
								? void 0
								: g.id,
						"aria-autocomplete": "list",
						id: _,
						onCompositionstart: d,
						onCompositionend: f,
						onKeydown: p,
						onInput: m,
						onFocus: v,
						onBlur: y,
						role: "combobox",
						type: (k = n.type) != null ? k : "text",
						tabIndex: 0,
						ref: i.inputRef,
						defaultValue: w.value,
						disabled: i.disabled.value === !0 ? !0 : void 0,
					};
				return it({
					ourProps: D,
					theirProps: P,
					slot: C,
					attrs: n,
					slots: r,
					features: fn.RenderStrategy | fn.Static,
					name: "ComboboxInput",
				});
			};
		},
	}),
	Tk = Oe({
		name: "ComboboxOptions",
		props: {
			as: { type: [Object, String], default: "ul" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			hold: { type: [Boolean], default: !1 },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = zi("ComboboxOptions"),
				i = `headlessui-combobox-options-${tn()}`;
			r({ el: o.optionsRef, $el: o.optionsRef }),
				xt(() => {
					o.optionsPropsRef.value.static = t.static;
				}),
				xt(() => {
					o.optionsPropsRef.value.hold = t.hold;
				});
			let s = Bi(),
				l = z(() =>
					s !== null
						? (s.value & ct.Open) === ct.Open
						: o.comboboxState.value === 0
				);
			return (
				ry({
					container: z(() => re(o.optionsRef)),
					enabled: z(() => o.comboboxState.value === 0),
					accept(a) {
						return a.getAttribute("role") === "option"
							? NodeFilter.FILTER_REJECT
							: a.hasAttribute("role")
							? NodeFilter.FILTER_SKIP
							: NodeFilter.FILTER_ACCEPT;
					},
					walk(a) {
						a.setAttribute("role", "none");
					},
				}),
				() => {
					var a, u, c;
					let d = { open: o.comboboxState.value === 0 },
						f = {
							"aria-labelledby":
								(c =
									(a = re(o.labelRef)) == null
										? void 0
										: a.id) != null
									? c
									: (u = re(o.buttonRef)) == null
									? void 0
									: u.id,
							id: i,
							ref: o.optionsRef,
							role: "listbox",
							"aria-multiselectable":
								o.mode.value === 1 ? !0 : void 0,
						},
						p = $i(t, ["hold"]);
					return it({
						ourProps: f,
						theirProps: p,
						slot: d,
						attrs: e,
						slots:
							o.virtual.value && o.comboboxState.value === 0
								? ge(B({}, n), {
										default: () => [Ke(_k, {}, n.default)],
								  })
								: n,
						features: fn.RenderStrategy | fn.Static,
						visible: l.value,
						name: "ComboboxOptions",
					});
				}
			);
		},
	}),
	Ak = Oe({
		name: "ComboboxOption",
		props: {
			as: { type: [Object, String], default: "li" },
			value: { type: [Object, String, Number, Boolean] },
			disabled: { type: Boolean, default: !1 },
			order: { type: [Number], default: null },
		},
		setup(t, { slots: e, attrs: n, expose: r }) {
			let o = zi("ComboboxOption"),
				i = `headlessui-combobox-option-${tn()}`,
				s = Q(null);
			r({ el: s, $el: s });
			let l = z(() => {
					var w;
					return o.virtual.value
						? o.activeOptionIndex.value ===
								o.calculateIndex(t.value)
						: o.activeOptionIndex.value === null
						? !1
						: ((w = o.options.value[o.activeOptionIndex.value]) ==
						  null
								? void 0
								: w.id) === i;
				}),
				a = z(() => o.isSelected(t.value)),
				u = Ge(dy, null),
				c = z(() => ({
					disabled: t.disabled,
					value: t.value,
					domRef: s,
					order: z(() => t.order),
				}));
			Ze(() => o.registerOption(i, c)),
				zt(() => o.unregisterOption(i, l.value)),
				xt(() => {
					let w = re(s);
					w && (u == null || u.value.measureElement(w));
				}),
				xt(() => {
					o.comboboxState.value === 0 &&
						l.value &&
						(o.virtual.value ||
							(o.activationTrigger.value !== 0 &&
								bt(() => {
									var w, S;
									return (S =
										(w = re(s)) == null
											? void 0
											: w.scrollIntoView) == null
										? void 0
										: S.call(w, { block: "nearest" });
								})));
				});
			function d(w) {
				var S;
				if (
					t.disabled ||
					((S = o.virtual.value) != null && S.disabled(t.value))
				)
					return w.preventDefault();
				o.selectOption(i),
					ey() ||
						requestAnimationFrame(() => {
							var E;
							return (E = re(o.inputRef)) == null
								? void 0
								: E.focus({ preventScroll: !0 });
						}),
					o.mode.value === 0 &&
						requestAnimationFrame(() => o.closeCombobox());
			}
			function f() {
				var w;
				if (
					t.disabled ||
					((w = o.virtual.value) != null && w.disabled(t.value))
				)
					return o.goToOption(rt.Nothing);
				let S = o.calculateIndex(t.value);
				o.goToOption(rt.Specific, S);
			}
			let p = ny();
			function m(w) {
				p.update(w);
			}
			function y(w) {
				var S;
				if (
					!p.wasMoved(w) ||
					t.disabled ||
					((S = o.virtual.value) != null && S.disabled(t.value)) ||
					l.value
				)
					return;
				let E = o.calculateIndex(t.value);
				o.goToOption(rt.Specific, E, 0);
			}
			function v(w) {
				var S;
				p.wasMoved(w) &&
					(t.disabled ||
						((S = o.virtual.value) != null &&
							S.disabled(t.value)) ||
						(l.value &&
							(o.optionsPropsRef.value.hold ||
								o.goToOption(rt.Nothing))));
			}
			return () => {
				let { disabled: w } = t,
					S = { active: l.value, selected: a.value, disabled: w },
					E = {
						id: i,
						ref: s,
						role: "option",
						tabIndex: w === !0 ? void 0 : -1,
						"aria-disabled": w === !0 ? !0 : void 0,
						"aria-selected": a.value,
						disabled: void 0,
						onClick: d,
						onFocus: f,
						onPointerenter: m,
						onMouseenter: m,
						onPointermove: y,
						onMousemove: y,
						onPointerleave: v,
						onMouseleave: v,
					},
					h = $i(t, ["order", "value"]);
				return it({
					ourProps: E,
					theirProps: h,
					slot: S,
					attrs: n,
					slots: e,
					name: "ComboboxOption",
				});
			};
		},
	});
function fy(t, e, n, r) {
	Qs.isServer ||
		xt((o) => {
			(t = t != null ? t : window),
				t.addEventListener(e, n, r),
				o(() => t.removeEventListener(e, n, r));
		});
}
var es = ((t) => (
	(t[(t.Forwards = 0)] = "Forwards"), (t[(t.Backwards = 1)] = "Backwards"), t
))(es || {});
function Ok() {
	let t = Q(0);
	return (
		ty("keydown", (e) => {
			e.key === "Tab" && (t.value = e.shiftKey ? 1 : 0);
		}),
		t
	);
}
function hy(t) {
	if (!t) return new Set();
	if (typeof t == "function") return new Set(t());
	let e = new Set();
	for (let n of t.value) {
		let r = re(n);
		r instanceof HTMLElement && e.add(r);
	}
	return e;
}
var py = ((t) => (
	(t[(t.None = 1)] = "None"),
	(t[(t.InitialFocus = 2)] = "InitialFocus"),
	(t[(t.TabLock = 4)] = "TabLock"),
	(t[(t.FocusLock = 8)] = "FocusLock"),
	(t[(t.RestoreFocus = 16)] = "RestoreFocus"),
	(t[(t.All = 30)] = "All"),
	t
))(py || {});
let Ji = Object.assign(
	Oe({
		name: "FocusTrap",
		props: {
			as: { type: [Object, String], default: "div" },
			initialFocus: { type: Object, default: null },
			features: { type: Number, default: 30 },
			containers: { type: [Object, Function], default: Q(new Set()) },
		},
		inheritAttrs: !1,
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Q(null);
			r({ el: o, $el: o });
			let i = z(() => fr(o)),
				s = Q(!1);
			Ze(() => (s.value = !0)),
				zt(() => (s.value = !1)),
				Pk(
					{ ownerDocument: i },
					z(() => s.value && !!(t.features & 16))
				);
			let l = Ik(
				{
					ownerDocument: i,
					container: o,
					initialFocus: z(() => t.initialFocus),
				},
				z(() => s.value && !!(t.features & 2))
			);
			Nk(
				{
					ownerDocument: i,
					container: o,
					containers: t.containers,
					previousActiveElement: l,
				},
				z(() => s.value && !!(t.features & 8))
			);
			let a = Ok();
			function u(p) {
				let m = re(o);
				m &&
					((y) => y())(() => {
						mt(a.value, {
							[es.Forwards]: () => {
								Nn(m, Mt.First, {
									skipElements: [p.relatedTarget],
								});
							},
							[es.Backwards]: () => {
								Nn(m, Mt.Last, {
									skipElements: [p.relatedTarget],
								});
							},
						});
					});
			}
			let c = Q(!1);
			function d(p) {
				p.key === "Tab" &&
					((c.value = !0),
					requestAnimationFrame(() => {
						c.value = !1;
					}));
			}
			function f(p) {
				if (!s.value) return;
				let m = hy(t.containers);
				re(o) instanceof HTMLElement && m.add(re(o));
				let y = p.relatedTarget;
				y instanceof HTMLElement &&
					y.dataset.headlessuiFocusGuard !== "true" &&
					(my(m, y) ||
						(c.value
							? Nn(
									re(o),
									mt(a.value, {
										[es.Forwards]: () => Mt.Next,
										[es.Backwards]: () => Mt.Previous,
									}) | Mt.WrapAround,
									{ relativeTo: p.target }
							  )
							: p.target instanceof HTMLElement && eo(p.target)));
			}
			return () => {
				let p = {},
					m = { ref: o, onKeydown: d, onFocusout: f },
					E = t,
					{ features: y, initialFocus: v, containers: w } = E,
					S = tt(E, ["features", "initialFocus", "containers"]);
				return Ke(Ne, [
					!!(y & 4) &&
						Ke(Ci, {
							as: "button",
							type: "button",
							"data-headlessui-focus-guard": !0,
							onFocus: u,
							features: _i.Focusable,
						}),
					it({
						ourProps: m,
						theirProps: B(B({}, e), S),
						slot: p,
						attrs: e,
						slots: n,
						name: "FocusTrap",
					}),
					!!(y & 4) &&
						Ke(Ci, {
							as: "button",
							type: "button",
							"data-headlessui-focus-guard": !0,
							onFocus: u,
							features: _i.Focusable,
						}),
				]);
			};
		},
	}),
	{ features: py }
);
function Rk(t) {
	let e = Q(xr.slice());
	return (
		at(
			[t],
			([n], [r]) => {
				r === !0 && n === !1
					? Iu(() => {
							e.value.splice(0);
					  })
					: r === !1 && n === !0 && (e.value = xr.slice());
			},
			{ flush: "post" }
		),
		() => {
			var n;
			return (n = e.value.find((r) => r != null && r.isConnected)) != null
				? n
				: null;
		}
	);
}
function Pk({ ownerDocument: t }, e) {
	let n = Rk(e);
	Ze(() => {
		xt(
			() => {
				var r, o;
				e.value ||
					(((r = t.value) == null ? void 0 : r.activeElement) ===
						((o = t.value) == null ? void 0 : o.body) &&
						eo(n()));
			},
			{ flush: "post" }
		);
	}),
		zt(() => {
			e.value && eo(n());
		});
}
function Ik({ ownerDocument: t, container: e, initialFocus: n }, r) {
	let o = Q(null),
		i = Q(!1);
	return (
		Ze(() => (i.value = !0)),
		zt(() => (i.value = !1)),
		Ze(() => {
			at(
				[e, n, r],
				(s, l) => {
					if (
						s.every((u, c) => (l == null ? void 0 : l[c]) === u) ||
						!r.value
					)
						return;
					let a = re(e);
					a &&
						Iu(() => {
							var u, c;
							if (!i.value) return;
							let d = re(n),
								f =
									(u = t.value) == null
										? void 0
										: u.activeElement;
							if (d) {
								if (d === f) {
									o.value = f;
									return;
								}
							} else if (a.contains(f)) {
								o.value = f;
								return;
							}
							d
								? eo(d)
								: Nn(a, Mt.First | Mt.NoScroll) === li.Error &&
								  console.warn(
										"There are no focusable elements inside the <FocusTrap />"
								  ),
								(o.value =
									(c = t.value) == null
										? void 0
										: c.activeElement);
						});
				},
				{ immediate: !0, flush: "post" }
			);
		}),
		o
	);
}
function Nk(
	{ ownerDocument: t, container: e, containers: n, previousActiveElement: r },
	o
) {
	var i;
	fy(
		(i = t.value) == null ? void 0 : i.defaultView,
		"focus",
		(s) => {
			if (!o.value) return;
			let l = hy(n);
			re(e) instanceof HTMLElement && l.add(re(e));
			let a = r.value;
			if (!a) return;
			let u = s.target;
			u && u instanceof HTMLElement
				? my(l, u)
					? ((r.value = u), eo(u))
					: (s.preventDefault(), s.stopPropagation(), eo(a))
				: eo(r.value);
		},
		!0
	);
}
function my(t, e) {
	for (let n of t) if (n.contains(e)) return !0;
	return !1;
}
function Dk(t) {
	let e = bu(t.getSnapshot());
	return (
		zt(
			t.subscribe(() => {
				e.value = t.getSnapshot();
			})
		),
		e
	);
}
function jk(t, e) {
	let n = t(),
		r = new Set();
	return {
		getSnapshot() {
			return n;
		},
		subscribe(o) {
			return r.add(o), () => r.delete(o);
		},
		dispatch(o, ...i) {
			let s = e[o].call(n, ...i);
			s && ((n = s), r.forEach((l) => l()));
		},
	};
}
function Lk() {
	let t;
	return {
		before({ doc: e }) {
			var n;
			let r = e.documentElement;
			t =
				((n = e.defaultView) != null ? n : window).innerWidth -
				r.clientWidth;
		},
		after({ doc: e, d: n }) {
			let r = e.documentElement,
				o = r.clientWidth - r.offsetWidth,
				i = t - o;
			n.style(r, "paddingRight", `${i}px`);
		},
	};
}
function $k() {
	return Z0()
		? {
				before({ doc: t, d: e, meta: n }) {
					function r(o) {
						return n.containers
							.flatMap((i) => i())
							.some((i) => i.contains(o));
					}
					e.microTask(() => {
						var o;
						if (
							window.getComputedStyle(t.documentElement)
								.scrollBehavior !== "auto"
						) {
							let l = $o();
							l.style(
								t.documentElement,
								"scrollBehavior",
								"auto"
							),
								e.add(() => e.microTask(() => l.dispose()));
						}
						let i =
								(o = window.scrollY) != null
									? o
									: window.pageYOffset,
							s = null;
						e.addEventListener(
							t,
							"click",
							(l) => {
								if (l.target instanceof HTMLElement)
									try {
										let a = l.target.closest("a");
										if (!a) return;
										let { hash: u } = new URL(a.href),
											c = t.querySelector(u);
										c && !r(c) && (s = c);
									} catch (a) {}
							},
							!0
						),
							e.addEventListener(t, "touchstart", (l) => {
								if (l.target instanceof HTMLElement)
									if (r(l.target)) {
										let a = l.target;
										for (
											;
											a.parentElement &&
											r(a.parentElement);

										)
											a = a.parentElement;
										e.style(
											a,
											"overscrollBehavior",
											"contain"
										);
									} else
										e.style(
											l.target,
											"touchAction",
											"none"
										);
							}),
							e.addEventListener(
								t,
								"touchmove",
								(l) => {
									if (l.target instanceof HTMLElement)
										if (r(l.target)) {
											let a = l.target;
											for (
												;
												a.parentElement &&
												a.dataset.headlessuiPortal !==
													"" &&
												!(
													a.scrollHeight >
														a.clientHeight ||
													a.scrollWidth >
														a.clientWidth
												);

											)
												a = a.parentElement;
											a.dataset.headlessuiPortal === "" &&
												l.preventDefault();
										} else l.preventDefault();
								},
								{ passive: !1 }
							),
							e.add(() => {
								var l;
								let a =
									(l = window.scrollY) != null
										? l
										: window.pageYOffset;
								i !== a && window.scrollTo(0, i),
									s &&
										s.isConnected &&
										(s.scrollIntoView({ block: "nearest" }),
										(s = null));
							});
					});
				},
		  }
		: {};
}
function Bk() {
	return {
		before({ doc: t, d: e }) {
			e.style(t.documentElement, "overflow", "hidden");
		},
	};
}
function zk(t) {
	let e = {};
	for (let n of t) Object.assign(e, n(e));
	return e;
}
let Mo = jk(() => new Map(), {
	PUSH(t, e) {
		var n;
		let r =
			(n = this.get(t)) != null
				? n
				: { doc: t, count: 0, d: $o(), meta: new Set() };
		return r.count++, r.meta.add(e), this.set(t, r), this;
	},
	POP(t, e) {
		let n = this.get(t);
		return n && (n.count--, n.meta.delete(e)), this;
	},
	SCROLL_PREVENT({ doc: t, d: e, meta: n }) {
		let r = { doc: t, d: e, meta: zk(n) },
			o = [$k(), Lk(), Bk()];
		o.forEach(({ before: i }) => (i == null ? void 0 : i(r))),
			o.forEach(({ after: i }) => (i == null ? void 0 : i(r)));
	},
	SCROLL_ALLOW({ d: t }) {
		t.dispose();
	},
	TEARDOWN({ doc: t }) {
		this.delete(t);
	},
});
Mo.subscribe(() => {
	let t = Mo.getSnapshot(),
		e = new Map();
	for (let [n] of t) e.set(n, n.documentElement.style.overflow);
	for (let n of t.values()) {
		let r = e.get(n.doc) === "hidden",
			o = n.count !== 0;
		((o && !r) || (!o && r)) &&
			Mo.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
			n.count === 0 && Mo.dispatch("TEARDOWN", n);
	}
});
function Hk(t, e, n) {
	let r = Dk(Mo),
		o = z(() => {
			let i = t.value ? r.value.get(t.value) : void 0;
			return i ? i.count > 0 : !1;
		});
	return (
		at(
			[t, e],
			([i, s], [l], a) => {
				if (!i || !s) return;
				Mo.dispatch("PUSH", i, n);
				let u = !1;
				a(() => {
					u || (Mo.dispatch("POP", l != null ? l : i, n), (u = !0));
				});
			},
			{ immediate: !0 }
		),
		o
	);
}
let _c = new Map(),
	Gi = new Map();
function um(t, e = Q(!0)) {
	xt((n) => {
		var r;
		if (!e.value) return;
		let o = re(t);
		if (!o) return;
		n(function () {
			var s;
			if (!o) return;
			let l = (s = Gi.get(o)) != null ? s : 1;
			if ((l === 1 ? Gi.delete(o) : Gi.set(o, l - 1), l !== 1)) return;
			let a = _c.get(o);
			a &&
				(a["aria-hidden"] === null
					? o.removeAttribute("aria-hidden")
					: o.setAttribute("aria-hidden", a["aria-hidden"]),
				(o.inert = a.inert),
				_c.delete(o));
		});
		let i = (r = Gi.get(o)) != null ? r : 0;
		Gi.set(o, i + 1),
			i === 0 &&
				(_c.set(o, {
					"aria-hidden": o.getAttribute("aria-hidden"),
					inert: o.inert,
				}),
				o.setAttribute("aria-hidden", "true"),
				(o.inert = !0));
	});
}
function Fk({
	defaultContainers: t = [],
	portals: e,
	mainTreeNodeRef: n,
} = {}) {
	let r = Q(null),
		o = fr(r);
	function i() {
		var s, l, a;
		let u = [];
		for (let c of t)
			c !== null &&
				(c instanceof HTMLElement
					? u.push(c)
					: "value" in c &&
					  c.value instanceof HTMLElement &&
					  u.push(c.value));
		if (e != null && e.value) for (let c of e.value) u.push(c);
		for (let c of (s =
			o == null ? void 0 : o.querySelectorAll("html > *, body > *")) !=
		null
			? s
			: [])
			c !== document.body &&
				c !== document.head &&
				c instanceof HTMLElement &&
				c.id !== "headlessui-portal-root" &&
				(c.contains(re(r)) ||
					c.contains(
						(a = (l = re(r)) == null ? void 0 : l.getRootNode()) ==
							null
							? void 0
							: a.host
					) ||
					u.some((d) => c.contains(d)) ||
					u.push(c));
		return u;
	}
	return {
		resolveContainers: i,
		contains(s) {
			return i().some((l) => l.contains(s));
		},
		mainTreeNodeRef: r,
		MainTreeNode() {
			return n != null ? null : Ke(Ci, { features: _i.Hidden, ref: r });
		},
	};
}
let gy = Symbol("ForcePortalRootContext");
function Vk() {
	return Ge(gy, !1);
}
let cm = Oe({
		name: "ForcePortalRoot",
		props: {
			as: { type: [Object, String], default: "template" },
			force: { type: Boolean, default: !1 },
		},
		setup(t, { slots: e, attrs: n }) {
			return (
				wt(gy, t.force),
				() => {
					let i = t,
						{ force: r } = i,
						o = tt(i, ["force"]);
					return it({
						theirProps: o,
						ourProps: {},
						slot: {},
						slots: e,
						attrs: n,
						name: "ForcePortalRoot",
					});
				}
			);
		},
	}),
	yy = Symbol("StackContext");
var _d = ((t) => ((t[(t.Add = 0)] = "Add"), (t[(t.Remove = 1)] = "Remove"), t))(
	_d || {}
);
function Wk() {
	return Ge(yy, () => {});
}
function Uk({ type: t, enabled: e, element: n, onUpdate: r }) {
	let o = Wk();
	function i(...s) {
		r == null || r(...s), o(...s);
	}
	Ze(() => {
		at(
			e,
			(s, l) => {
				s ? i(0, t, n) : l === !0 && i(1, t, n);
			},
			{ immediate: !0, flush: "sync" }
		);
	}),
		zt(() => {
			e.value && i(1, t, n);
		}),
		wt(yy, i);
}
let Kk = Symbol("DescriptionContext");
function qk({ slot: t = Q({}), name: e = "Description", props: n = {} } = {}) {
	let r = Q([]);
	function o(i) {
		return (
			r.value.push(i),
			() => {
				let s = r.value.indexOf(i);
				s !== -1 && r.value.splice(s, 1);
			}
		);
	}
	return (
		wt(Kk, { register: o, slot: t, name: e, props: n }),
		z(() => (r.value.length > 0 ? r.value.join(" ") : void 0))
	);
}
function Jk(t) {
	let e = fr(t);
	if (!e) {
		if (t === null) return null;
		throw new Error(
			`[Headless UI]: Cannot find ownerDocument for contextElement: ${t}`
		);
	}
	let n = e.getElementById("headlessui-portal-root");
	if (n) return n;
	let r = e.createElement("div");
	return (
		r.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(r)
	);
}
let Gk = Oe({
		name: "Portal",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { slots: e, attrs: n }) {
			let r = Q(null),
				o = z(() => fr(r)),
				i = Vk(),
				s = Ge(vy, null),
				l = Q(i === !0 || s == null ? Jk(r.value) : s.resolveTarget()),
				a = Q(!1);
			Ze(() => {
				a.value = !0;
			}),
				xt(() => {
					i || (s != null && (l.value = s.resolveTarget()));
				});
			let u = Ge(Cd, null),
				c = !1,
				d = uo();
			return (
				at(r, () => {
					if (c || !u) return;
					let f = re(r);
					f && (zt(u.register(f), d), (c = !0));
				}),
				zt(() => {
					var f, p;
					let m =
						(f = o.value) == null
							? void 0
							: f.getElementById("headlessui-portal-root");
					m &&
						l.value === m &&
						l.value.children.length <= 0 &&
						((p = l.value.parentElement) == null ||
							p.removeChild(l.value));
				}),
				() => {
					if (!a.value || l.value === null) return null;
					let f = { ref: r, "data-headlessui-portal": "" };
					return Ke(
						_u,
						{ to: l.value },
						it({
							ourProps: f,
							theirProps: t,
							slot: {},
							attrs: n,
							slots: e,
							name: "Portal",
						})
					);
				}
			);
		},
	}),
	Cd = Symbol("PortalParentContext");
function Yk() {
	let t = Ge(Cd, null),
		e = Q([]);
	function n(i) {
		return e.value.push(i), t && t.register(i), () => r(i);
	}
	function r(i) {
		let s = e.value.indexOf(i);
		s !== -1 && e.value.splice(s, 1), t && t.unregister(i);
	}
	let o = { register: n, unregister: r, portals: e };
	return [
		e,
		Oe({
			name: "PortalWrapper",
			setup(i, { slots: s }) {
				return (
					wt(Cd, o),
					() => {
						var l;
						return (l = s.default) == null ? void 0 : l.call(s);
					}
				);
			},
		}),
	];
}
let vy = Symbol("PortalGroupContext"),
	Qk = Oe({
		name: "PortalGroup",
		props: {
			as: { type: [Object, String], default: "template" },
			target: { type: Object, default: null },
		},
		setup(t, { attrs: e, slots: n }) {
			let r = Yt({
				resolveTarget() {
					return t.target;
				},
			});
			return (
				wt(vy, r),
				() => {
					let s = t,
						{ target: o } = s,
						i = tt(s, ["target"]);
					return it({
						theirProps: i,
						ourProps: {},
						slot: {},
						attrs: e,
						slots: n,
						name: "PortalGroup",
					});
				}
			);
		},
	});
var Xk = ((t) => (
	(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
))(Xk || {});
let Md = Symbol("DialogContext");
function Qf(t) {
	let e = Ge(Md, null);
	if (e === null) {
		let n = new Error(`<${t} /> is missing a parent <Dialog /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Qf), n);
	}
	return e;
}
let xl = "DC8F892D-2EBD-447C-A4C8-A03058436FF4",
	Zk = Oe({
		name: "Dialog",
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			open: { type: [Boolean, String], default: xl },
			initialFocus: { type: Object, default: null },
			id: { type: String, default: () => `headlessui-dialog-${tn()}` },
			role: { type: String, default: "dialog" },
		},
		emits: { close: (t) => !0 },
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			var i;
			let s = Q(!1);
			Ze(() => {
				s.value = !0;
			});
			let l = !1,
				a = z(() =>
					t.role === "dialog" || t.role === "alertdialog"
						? t.role
						: (l ||
								((l = !0),
								console.warn(
									`Invalid role [${a}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`
								)),
						  "dialog")
				),
				u = Q(0),
				c = Bi(),
				d = z(() =>
					t.open === xl && c !== null
						? (c.value & ct.Open) === ct.Open
						: t.open
				),
				f = Q(null),
				p = z(() => fr(f));
			if ((o({ el: f, $el: f }), !(t.open !== xl || c !== null)))
				throw new Error(
					"You forgot to provide an `open` prop to the `Dialog`."
				);
			if (typeof d.value != "boolean")
				throw new Error(
					`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${
						d.value === xl ? void 0 : t.open
					}`
				);
			let m = z(() => (s.value && d.value ? 0 : 1)),
				y = z(() => m.value === 0),
				v = z(() => u.value > 1),
				w = Ge(Md, null) !== null,
				[S, E] = Yk(),
				{
					resolveContainers: h,
					mainTreeNodeRef: b,
					MainTreeNode: g,
				} = Fk({
					portals: S,
					defaultContainers: [
						z(() => {
							var K;
							return (K = j.panelRef.value) != null ? K : f.value;
						}),
					],
				}),
				x = z(() => (v.value ? "parent" : "leaf")),
				k = z(() =>
					c !== null ? (c.value & ct.Closing) === ct.Closing : !1
				),
				C = z(() => (w || k.value ? !1 : y.value)),
				_ = z(() => {
					var K, ie, X;
					return (X = Array.from(
						(ie =
							(K = p.value) == null
								? void 0
								: K.querySelectorAll("body > *")) != null
							? ie
							: []
					).find((de) =>
						de.id === "headlessui-portal-root"
							? !1
							: de.contains(re(b)) && de instanceof HTMLElement
					)) != null
						? X
						: null;
				});
			um(_, C);
			let T = z(() => (v.value ? !0 : y.value)),
				R = z(() => {
					var K, ie, X;
					return (X = Array.from(
						(ie =
							(K = p.value) == null
								? void 0
								: K.querySelectorAll(
										"[data-headlessui-portal]"
								  )) != null
							? ie
							: []
					).find(
						(de) => de.contains(re(b)) && de instanceof HTMLElement
					)) != null
						? X
						: null;
				});
			um(R, T),
				Uk({
					type: "Dialog",
					enabled: z(() => m.value === 0),
					element: f,
					onUpdate: (K, ie) => {
						if (ie === "Dialog")
							return mt(K, {
								[_d.Add]: () => (u.value += 1),
								[_d.Remove]: () => (u.value -= 1),
							});
					},
				});
			let P = qk({
					name: "DialogDescription",
					slot: z(() => ({ open: d.value })),
				}),
				D = Q(null),
				j = {
					titleId: D,
					panelRef: Q(null),
					dialogState: m,
					setTitleId(K) {
						D.value !== K && (D.value = K);
					},
					close() {
						e("close", !1);
					},
				};
			wt(Md, j);
			let M = z(() => !(!y.value || v.value));
			Yf(
				h,
				(K, ie) => {
					j.close(), bt(() => (ie == null ? void 0 : ie.focus()));
				},
				M
			);
			let I = z(() => !(v.value || m.value !== 0));
			fy(
				(i = p.value) == null ? void 0 : i.defaultView,
				"keydown",
				(K) => {
					I.value &&
						(K.defaultPrevented ||
							(K.key === Ae.Escape &&
								(K.preventDefault(),
								K.stopPropagation(),
								j.close())));
				}
			);
			let $ = z(() => !(k.value || m.value !== 0 || w));
			return (
				Hk(p, $, (K) => {
					var ie;
					return {
						containers: [
							...((ie = K.containers) != null ? ie : []),
							h,
						],
					};
				}),
				xt((K) => {
					if (m.value !== 0) return;
					let ie = re(f);
					if (!ie) return;
					let X = new ResizeObserver((de) => {
						for (let ze of de) {
							let Ee = ze.target.getBoundingClientRect();
							Ee.x === 0 &&
								Ee.y === 0 &&
								Ee.width === 0 &&
								Ee.height === 0 &&
								j.close();
						}
					});
					X.observe(ie), K(() => X.disconnect());
				}),
				() => {
					let Pe = t,
						{ id: K, open: ie, initialFocus: X } = Pe,
						de = tt(Pe, ["id", "open", "initialFocus"]),
						ze = ge(B({}, n), {
							ref: f,
							id: K,
							role: a.value,
							"aria-modal": m.value === 0 ? !0 : void 0,
							"aria-labelledby": D.value,
							"aria-describedby": P.value,
						}),
						Ee = { open: m.value === 0 };
					return Ke(cm, { force: !0 }, () => [
						Ke(Gk, () =>
							Ke(Qk, { target: f.value }, () =>
								Ke(cm, { force: !1 }, () =>
									Ke(
										Ji,
										{
											initialFocus: X,
											containers: h,
											features: y.value
												? mt(x.value, {
														parent: Ji.features
															.RestoreFocus,
														leaf:
															Ji.features.All &
															~Ji.features
																.FocusLock,
												  })
												: Ji.features.None,
										},
										() =>
											Ke(E, {}, () =>
												it({
													ourProps: ze,
													theirProps: B(B({}, de), n),
													slot: Ee,
													attrs: n,
													slots: r,
													visible: m.value === 0,
													features:
														fn.RenderStrategy |
														fn.Static,
													name: "Dialog",
												})
											)
									)
								)
							)
						),
						Ke(g),
					]);
				}
			);
		},
	}),
	e8 = Oe({
		name: "DialogPanel",
		props: {
			as: { type: [Object, String], default: "div" },
			id: {
				type: String,
				default: () => `headlessui-dialog-panel-${tn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Qf("DialogPanel");
			r({ el: o.panelRef, $el: o.panelRef });
			function i(s) {
				s.stopPropagation();
			}
			return () => {
				let u = t,
					{ id: s } = u,
					l = tt(u, ["id"]),
					a = { id: s, ref: o.panelRef, onClick: i };
				return it({
					ourProps: a,
					theirProps: l,
					slot: { open: o.dialogState.value === 0 },
					attrs: e,
					slots: n,
					name: "DialogPanel",
				});
			};
		},
	}),
	t8 = Oe({
		name: "DialogTitle",
		props: {
			as: { type: [Object, String], default: "h2" },
			id: {
				type: String,
				default: () => `headlessui-dialog-title-${tn()}`,
			},
		},
		setup(t, { attrs: e, slots: n }) {
			let r = Qf("DialogTitle");
			return (
				Ze(() => {
					r.setTitleId(t.id), zt(() => r.setTitleId(null));
				}),
				() => {
					let s = t,
						{ id: o } = s,
						i = tt(s, ["id"]);
					return it({
						ourProps: { id: o },
						theirProps: i,
						slot: { open: r.dialogState.value === 0 },
						attrs: e,
						slots: n,
						name: "DialogTitle",
					});
				}
			);
		},
	});
var n8 = ((t) => (
	(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
))(n8 || {});
let by = Symbol("DisclosureContext");
function Xf(t) {
	let e = Ge(by, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <Disclosure /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Xf), n);
	}
	return e;
}
let wy = Symbol("DisclosurePanelContext");
function r8() {
	return Ge(wy, null);
}
let CL = Oe({
		name: "Disclosure",
		props: {
			as: { type: [Object, String], default: "template" },
			defaultOpen: { type: [Boolean], default: !1 },
		},
		setup(t, { slots: e, attrs: n }) {
			let r = Q(t.defaultOpen ? 0 : 1),
				o = Q(null),
				i = Q(null),
				s = {
					buttonId: Q(`headlessui-disclosure-button-${tn()}`),
					panelId: Q(`headlessui-disclosure-panel-${tn()}`),
					disclosureState: r,
					panel: o,
					button: i,
					toggleDisclosure() {
						r.value = mt(r.value, { 0: 1, 1: 0 });
					},
					closeDisclosure() {
						r.value !== 1 && (r.value = 1);
					},
					close(l) {
						s.closeDisclosure();
						let a = l
							? l instanceof HTMLElement
								? l
								: l.value instanceof HTMLElement
								? re(l)
								: re(s.button)
							: re(s.button);
						a == null || a.focus();
					},
				};
			return (
				wt(by, s),
				Pu(z(() => mt(r.value, { 0: ct.Open, 1: ct.Closed }))),
				() => {
					let c = t,
						{ defaultOpen: l } = c,
						a = tt(c, ["defaultOpen"]),
						u = { open: r.value === 0, close: s.close };
					return it({
						theirProps: a,
						ourProps: {},
						slot: u,
						slots: e,
						attrs: n,
						name: "Disclosure",
					});
				}
			);
		},
	}),
	ML = Oe({
		name: "DisclosureButton",
		props: {
			as: { type: [Object, String], default: "button" },
			disabled: { type: [Boolean], default: !1 },
			id: { type: String, default: null },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Xf("DisclosureButton"),
				i = r8(),
				s = z(() => (i === null ? !1 : i.value === o.panelId.value));
			Ze(() => {
				s.value || (t.id !== null && (o.buttonId.value = t.id));
			}),
				zt(() => {
					s.value || (o.buttonId.value = null);
				});
			let l = Q(null);
			r({ el: l, $el: l }),
				s.value ||
					xt(() => {
						o.button.value = l.value;
					});
			let a = Ru(
				z(() => ({ as: t.as, type: e.type })),
				l
			);
			function u() {
				var f;
				t.disabled ||
					(s.value
						? (o.toggleDisclosure(),
						  (f = re(o.button)) == null || f.focus())
						: o.toggleDisclosure());
			}
			function c(f) {
				var p;
				if (!t.disabled)
					if (s.value)
						switch (f.key) {
							case Ae.Space:
							case Ae.Enter:
								f.preventDefault(),
									f.stopPropagation(),
									o.toggleDisclosure(),
									(p = re(o.button)) == null || p.focus();
								break;
						}
					else
						switch (f.key) {
							case Ae.Space:
							case Ae.Enter:
								f.preventDefault(),
									f.stopPropagation(),
									o.toggleDisclosure();
								break;
						}
			}
			function d(f) {
				switch (f.key) {
					case Ae.Space:
						f.preventDefault();
						break;
				}
			}
			return () => {
				var f;
				let p = { open: o.disclosureState.value === 0 },
					w = t,
					{ id: m } = w,
					y = tt(w, ["id"]),
					v = s.value
						? { ref: l, type: a.value, onClick: u, onKeydown: c }
						: {
								id: (f = o.buttonId.value) != null ? f : m,
								ref: l,
								type: a.value,
								"aria-expanded": o.disclosureState.value === 0,
								"aria-controls":
									o.disclosureState.value === 0 || re(o.panel)
										? o.panelId.value
										: void 0,
								disabled: t.disabled ? !0 : void 0,
								onClick: u,
								onKeydown: c,
								onKeyup: d,
						  };
				return it({
					ourProps: v,
					theirProps: y,
					slot: p,
					attrs: e,
					slots: n,
					name: "DisclosureButton",
				});
			};
		},
	}),
	EL = Oe({
		name: "DisclosurePanel",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: { type: String, default: null },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Xf("DisclosurePanel");
			Ze(() => {
				t.id !== null && (o.panelId.value = t.id);
			}),
				zt(() => {
					o.panelId.value = null;
				}),
				r({ el: o.panel, $el: o.panel }),
				wt(wy, o.panelId);
			let i = Bi(),
				s = z(() =>
					i !== null
						? (i.value & ct.Open) === ct.Open
						: o.disclosureState.value === 0
				);
			return () => {
				var l;
				let a = { open: o.disclosureState.value === 0, close: o.close },
					f = t,
					{ id: u } = f,
					c = tt(f, ["id"]),
					d = {
						id: (l = o.panelId.value) != null ? l : u,
						ref: o.panel,
					};
				return it({
					ourProps: d,
					theirProps: c,
					slot: a,
					attrs: e,
					slots: n,
					features: fn.RenderStrategy | fn.Static,
					visible: s.value,
					name: "DisclosurePanel",
				});
			};
		},
	}),
	dm =
		/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function fm(t) {
	var e, n;
	let r = (e = t.innerText) != null ? e : "",
		o = t.cloneNode(!0);
	if (!(o instanceof HTMLElement)) return r;
	let i = !1;
	for (let l of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]'))
		l.remove(), (i = !0);
	let s = i ? ((n = o.innerText) != null ? n : "") : r;
	return dm.test(s) && (s = s.replace(dm, "")), s;
}
function o8(t) {
	let e = t.getAttribute("aria-label");
	if (typeof e == "string") return e.trim();
	let n = t.getAttribute("aria-labelledby");
	if (n) {
		let r = n
			.split(" ")
			.map((o) => {
				let i = document.getElementById(o);
				if (i) {
					let s = i.getAttribute("aria-label");
					return typeof s == "string" ? s.trim() : fm(i).trim();
				}
				return null;
			})
			.filter(Boolean);
		if (r.length > 0) return r.join(", ");
	}
	return fm(t).trim();
}
function i8(t) {
	let e = Q(""),
		n = Q("");
	return () => {
		let r = re(t);
		if (!r) return "";
		let o = r.innerText;
		if (e.value === o) return n.value;
		let i = o8(r).trim().toLowerCase();
		return (e.value = o), (n.value = i), i;
	};
}
var s8 = ((t) => (
		(t[(t.Open = 0)] = "Open"), (t[(t.Closed = 1)] = "Closed"), t
	))(s8 || {}),
	l8 = ((t) => (
		(t[(t.Pointer = 0)] = "Pointer"), (t[(t.Other = 1)] = "Other"), t
	))(l8 || {});
function a8(t) {
	requestAnimationFrame(() => requestAnimationFrame(t));
}
let xy = Symbol("MenuContext");
function Nu(t) {
	let e = Ge(xy, null);
	if (e === null) {
		let n = new Error(`<${t} /> is missing a parent <Menu /> component.`);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Nu), n);
	}
	return e;
}
let u8 = Oe({
		name: "Menu",
		props: { as: { type: [Object, String], default: "template" } },
		setup(t, { slots: e, attrs: n }) {
			let r = Q(1),
				o = Q(null),
				i = Q(null),
				s = Q([]),
				l = Q(""),
				a = Q(null),
				u = Q(1);
			function c(f = (p) => p) {
				let p = a.value !== null ? s.value[a.value] : null,
					m = Wr(f(s.value.slice()), (v) => re(v.dataRef.domRef)),
					y = p ? m.indexOf(p) : null;
				return y === -1 && (y = null), { items: m, activeItemIndex: y };
			}
			let d = {
				menuState: r,
				buttonRef: o,
				itemsRef: i,
				items: s,
				searchQuery: l,
				activeItemIndex: a,
				activationTrigger: u,
				closeMenu: () => {
					(r.value = 1), (a.value = null);
				},
				openMenu: () => (r.value = 0),
				goToItem(f, p, m) {
					let y = c(),
						v = Sd(
							f === rt.Specific
								? { focus: rt.Specific, id: p }
								: { focus: f },
							{
								resolveItems: () => y.items,
								resolveActiveIndex: () => y.activeItemIndex,
								resolveId: (w) => w.id,
								resolveDisabled: (w) => w.dataRef.disabled,
							}
						);
					(l.value = ""),
						(a.value = v),
						(u.value = m != null ? m : 1),
						(s.value = y.items);
				},
				search(f) {
					let p = l.value !== "" ? 0 : 1;
					l.value += f.toLowerCase();
					let m = (
							a.value !== null
								? s.value
										.slice(a.value + p)
										.concat(s.value.slice(0, a.value + p))
								: s.value
						).find(
							(v) =>
								v.dataRef.textValue.startsWith(l.value) &&
								!v.dataRef.disabled
						),
						y = m ? s.value.indexOf(m) : -1;
					y === -1 || y === a.value || ((a.value = y), (u.value = 1));
				},
				clearSearch() {
					l.value = "";
				},
				registerItem(f, p) {
					let m = c((y) => [...y, { id: f, dataRef: p }]);
					(s.value = m.items),
						(a.value = m.activeItemIndex),
						(u.value = 1);
				},
				unregisterItem(f) {
					let p = c((m) => {
						let y = m.findIndex((v) => v.id === f);
						return y !== -1 && m.splice(y, 1), m;
					});
					(s.value = p.items),
						(a.value = p.activeItemIndex),
						(u.value = 1);
				},
			};
			return (
				Yf(
					[o, i],
					(f, p) => {
						var m;
						d.closeMenu(),
							Gf(p, Jf.Loose) ||
								(f.preventDefault(),
								(m = re(o)) == null || m.focus());
					},
					z(() => r.value === 0)
				),
				wt(xy, d),
				Pu(z(() => mt(r.value, { 0: ct.Open, 1: ct.Closed }))),
				() => {
					let f = { open: r.value === 0, close: d.closeMenu };
					return it({
						ourProps: {},
						theirProps: t,
						slot: f,
						slots: e,
						attrs: n,
						name: "Menu",
					});
				}
			);
		},
	}),
	c8 = Oe({
		name: "MenuButton",
		props: {
			disabled: { type: Boolean, default: !1 },
			as: { type: [Object, String], default: "button" },
			id: {
				type: String,
				default: () => `headlessui-menu-button-${tn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Nu("MenuButton");
			r({ el: o.buttonRef, $el: o.buttonRef });
			function i(u) {
				switch (u.key) {
					case Ae.Space:
					case Ae.Enter:
					case Ae.ArrowDown:
						u.preventDefault(),
							u.stopPropagation(),
							o.openMenu(),
							bt(() => {
								var c;
								(c = re(o.itemsRef)) == null ||
									c.focus({ preventScroll: !0 }),
									o.goToItem(rt.First);
							});
						break;
					case Ae.ArrowUp:
						u.preventDefault(),
							u.stopPropagation(),
							o.openMenu(),
							bt(() => {
								var c;
								(c = re(o.itemsRef)) == null ||
									c.focus({ preventScroll: !0 }),
									o.goToItem(rt.Last);
							});
						break;
				}
			}
			function s(u) {
				switch (u.key) {
					case Ae.Space:
						u.preventDefault();
						break;
				}
			}
			function l(u) {
				t.disabled ||
					(o.menuState.value === 0
						? (o.closeMenu(),
						  bt(() => {
								var c;
								return (c = re(o.buttonRef)) == null
									? void 0
									: c.focus({ preventScroll: !0 });
						  }))
						: (u.preventDefault(),
						  o.openMenu(),
						  a8(() => {
								var c;
								return (c = re(o.itemsRef)) == null
									? void 0
									: c.focus({ preventScroll: !0 });
						  })));
			}
			let a = Ru(
				z(() => ({ as: t.as, type: e.type })),
				o.buttonRef
			);
			return () => {
				var u;
				let c = { open: o.menuState.value === 0 },
					m = t,
					{ id: d } = m,
					f = tt(m, ["id"]),
					p = {
						ref: o.buttonRef,
						id: d,
						type: a.value,
						"aria-haspopup": "menu",
						"aria-controls":
							(u = re(o.itemsRef)) == null ? void 0 : u.id,
						"aria-expanded": o.menuState.value === 0,
						onKeydown: i,
						onKeyup: s,
						onClick: l,
					};
				return it({
					ourProps: p,
					theirProps: f,
					slot: c,
					attrs: e,
					slots: n,
					name: "MenuButton",
				});
			};
		},
	}),
	d8 = Oe({
		name: "MenuItems",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: {
				type: String,
				default: () => `headlessui-menu-items-${tn()}`,
			},
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Nu("MenuItems"),
				i = Q(null);
			r({ el: o.itemsRef, $el: o.itemsRef }),
				ry({
					container: z(() => re(o.itemsRef)),
					enabled: z(() => o.menuState.value === 0),
					accept(c) {
						return c.getAttribute("role") === "menuitem"
							? NodeFilter.FILTER_REJECT
							: c.hasAttribute("role")
							? NodeFilter.FILTER_SKIP
							: NodeFilter.FILTER_ACCEPT;
					},
					walk(c) {
						c.setAttribute("role", "none");
					},
				});
			function s(c) {
				var d;
				switch ((i.value && clearTimeout(i.value), c.key)) {
					case Ae.Space:
						if (o.searchQuery.value !== "")
							return (
								c.preventDefault(),
								c.stopPropagation(),
								o.search(c.key)
							);
					case Ae.Enter:
						if (
							(c.preventDefault(),
							c.stopPropagation(),
							o.activeItemIndex.value !== null)
						) {
							let f = o.items.value[o.activeItemIndex.value];
							(d = re(f.dataRef.domRef)) == null || d.click();
						}
						o.closeMenu(), X0(re(o.buttonRef));
						break;
					case Ae.ArrowDown:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Next)
						);
					case Ae.ArrowUp:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Previous)
						);
					case Ae.Home:
					case Ae.PageUp:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.First)
						);
					case Ae.End:
					case Ae.PageDown:
						return (
							c.preventDefault(),
							c.stopPropagation(),
							o.goToItem(rt.Last)
						);
					case Ae.Escape:
						c.preventDefault(),
							c.stopPropagation(),
							o.closeMenu(),
							bt(() => {
								var f;
								return (f = re(o.buttonRef)) == null
									? void 0
									: f.focus({ preventScroll: !0 });
							});
						break;
					case Ae.Tab:
						c.preventDefault(),
							c.stopPropagation(),
							o.closeMenu(),
							bt(() =>
								fk(
									re(o.buttonRef),
									c.shiftKey ? Mt.Previous : Mt.Next
								)
							);
						break;
					default:
						c.key.length === 1 &&
							(o.search(c.key),
							(i.value = setTimeout(() => o.clearSearch(), 350)));
						break;
				}
			}
			function l(c) {
				switch (c.key) {
					case Ae.Space:
						c.preventDefault();
						break;
				}
			}
			let a = Bi(),
				u = z(() =>
					a !== null
						? (a.value & ct.Open) === ct.Open
						: o.menuState.value === 0
				);
			return () => {
				var c, d;
				let f = { open: o.menuState.value === 0 },
					v = t,
					{ id: p } = v,
					m = tt(v, ["id"]),
					y = {
						"aria-activedescendant":
							o.activeItemIndex.value === null ||
							(c = o.items.value[o.activeItemIndex.value]) == null
								? void 0
								: c.id,
						"aria-labelledby":
							(d = re(o.buttonRef)) == null ? void 0 : d.id,
						id: p,
						onKeydown: s,
						onKeyup: l,
						role: "menu",
						tabIndex: 0,
						ref: o.itemsRef,
					};
				return it({
					ourProps: y,
					theirProps: m,
					slot: f,
					attrs: e,
					slots: n,
					features: fn.RenderStrategy | fn.Static,
					visible: u.value,
					name: "MenuItems",
				});
			};
		},
	}),
	f8 = Oe({
		name: "MenuItem",
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "template" },
			disabled: { type: Boolean, default: !1 },
			id: { type: String, default: () => `headlessui-menu-item-${tn()}` },
		},
		setup(t, { slots: e, attrs: n, expose: r }) {
			let o = Nu("MenuItem"),
				i = Q(null);
			r({ el: i, $el: i });
			let s = z(() =>
					o.activeItemIndex.value !== null
						? o.items.value[o.activeItemIndex.value].id === t.id
						: !1
				),
				l = i8(i),
				a = z(() => ({
					disabled: t.disabled,
					get textValue() {
						return l();
					},
					domRef: i,
				}));
			Ze(() => o.registerItem(t.id, a)),
				zt(() => o.unregisterItem(t.id)),
				xt(() => {
					o.menuState.value === 0 &&
						s.value &&
						o.activationTrigger.value !== 0 &&
						bt(() => {
							var y, v;
							return (v =
								(y = re(i)) == null
									? void 0
									: y.scrollIntoView) == null
								? void 0
								: v.call(y, { block: "nearest" });
						});
				});
			function u(y) {
				if (t.disabled) return y.preventDefault();
				o.closeMenu(), X0(re(o.buttonRef));
			}
			function c() {
				if (t.disabled) return o.goToItem(rt.Nothing);
				o.goToItem(rt.Specific, t.id);
			}
			let d = ny();
			function f(y) {
				d.update(y);
			}
			function p(y) {
				d.wasMoved(y) &&
					(t.disabled || s.value || o.goToItem(rt.Specific, t.id, 0));
			}
			function m(y) {
				d.wasMoved(y) &&
					(t.disabled || (s.value && o.goToItem(rt.Nothing)));
			}
			return () => {
				let { disabled: y } = t,
					v = { active: s.value, disabled: y, close: o.closeMenu },
					E = t,
					{ id: w } = E,
					S = tt(E, ["id"]);
				return it({
					ourProps: {
						id: w,
						ref: i,
						role: "menuitem",
						tabIndex: y === !0 ? void 0 : -1,
						"aria-disabled": y === !0 ? !0 : void 0,
						disabled: void 0,
						onClick: u,
						onFocus: c,
						onPointerenter: f,
						onMouseenter: f,
						onPointermove: p,
						onMousemove: p,
						onPointerleave: m,
						onMouseleave: m,
					},
					theirProps: B(B({}, n), S),
					slot: v,
					attrs: n,
					slots: e,
					name: "MenuItem",
				});
			};
		},
	}),
	h8 = Oe({
		props: { onFocus: { type: Function, required: !0 } },
		setup(t) {
			let e = Q(!0);
			return () =>
				e.value
					? Ke(Ci, {
							as: "button",
							type: "button",
							features: _i.Focusable,
							onFocus(n) {
								n.preventDefault();
								let r,
									o = 50;
								function i() {
									var s;
									if (o-- <= 0) {
										r && cancelAnimationFrame(r);
										return;
									}
									if ((s = t.onFocus) != null && s.call(t)) {
										(e.value = !1), cancelAnimationFrame(r);
										return;
									}
									r = requestAnimationFrame(i);
								}
								r = requestAnimationFrame(i);
							},
					  })
					: null;
		},
	});
var p8 = ((t) => (
		(t[(t.Forwards = 0)] = "Forwards"),
		(t[(t.Backwards = 1)] = "Backwards"),
		t
	))(p8 || {}),
	m8 = ((t) => (
		(t[(t.Less = -1)] = "Less"),
		(t[(t.Equal = 0)] = "Equal"),
		(t[(t.Greater = 1)] = "Greater"),
		t
	))(m8 || {});
let ky = Symbol("TabsContext");
function Xs(t) {
	let e = Ge(ky, null);
	if (e === null) {
		let n = new Error(
			`<${t} /> is missing a parent <TabGroup /> component.`
		);
		throw (Error.captureStackTrace && Error.captureStackTrace(n, Xs), n);
	}
	return e;
}
let Zf = Symbol("TabsSSRContext"),
	g8 = Oe({
		name: "TabGroup",
		emits: { change: (t) => !0 },
		props: {
			as: { type: [Object, String], default: "template" },
			selectedIndex: { type: [Number], default: null },
			defaultIndex: { type: [Number], default: 0 },
			vertical: { type: [Boolean], default: !1 },
			manual: { type: [Boolean], default: !1 },
		},
		inheritAttrs: !1,
		setup(t, { slots: e, attrs: n, emit: r }) {
			var o;
			let i = Q((o = t.selectedIndex) != null ? o : t.defaultIndex),
				s = Q([]),
				l = Q([]),
				a = z(() => t.selectedIndex !== null),
				u = z(() => (a.value ? t.selectedIndex : i.value));
			function c(y) {
				var v;
				let w = Wr(d.tabs.value, re),
					S = Wr(d.panels.value, re),
					E = w.filter((h) => {
						var b;
						return !(
							(b = re(h)) != null && b.hasAttribute("disabled")
						);
					});
				if (y < 0 || y > w.length - 1) {
					let h = mt(i.value === null ? 0 : Math.sign(y - i.value), {
							[-1]: () => 1,
							0: () =>
								mt(Math.sign(y), {
									[-1]: () => 0,
									0: () => 0,
									1: () => 1,
								}),
							1: () => 0,
						}),
						b = mt(h, {
							0: () => w.indexOf(E[0]),
							1: () => w.indexOf(E[E.length - 1]),
						});
					b !== -1 && (i.value = b),
						(d.tabs.value = w),
						(d.panels.value = S);
				} else {
					let h = w.slice(0, y),
						b = [...w.slice(y), ...h].find((x) => E.includes(x));
					if (!b) return;
					let g =
						(v = w.indexOf(b)) != null ? v : d.selectedIndex.value;
					g === -1 && (g = d.selectedIndex.value),
						(i.value = g),
						(d.tabs.value = w),
						(d.panels.value = S);
				}
			}
			let d = {
				selectedIndex: z(() => {
					var y, v;
					return (v = (y = i.value) != null ? y : t.defaultIndex) !=
						null
						? v
						: null;
				}),
				orientation: z(() => (t.vertical ? "vertical" : "horizontal")),
				activation: z(() => (t.manual ? "manual" : "auto")),
				tabs: s,
				panels: l,
				setSelectedIndex(y) {
					u.value !== y && r("change", y), a.value || c(y);
				},
				registerTab(y) {
					var v;
					if (s.value.includes(y)) return;
					let w = s.value[i.value];
					s.value.push(y), (s.value = Wr(s.value, re));
					let S = (v = s.value.indexOf(w)) != null ? v : i.value;
					S !== -1 && (i.value = S);
				},
				unregisterTab(y) {
					let v = s.value.indexOf(y);
					v !== -1 && s.value.splice(v, 1);
				},
				registerPanel(y) {
					l.value.includes(y) ||
						(l.value.push(y), (l.value = Wr(l.value, re)));
				},
				unregisterPanel(y) {
					let v = l.value.indexOf(y);
					v !== -1 && l.value.splice(v, 1);
				},
			};
			wt(ky, d);
			let f = Q({ tabs: [], panels: [] }),
				p = Q(!1);
			Ze(() => {
				p.value = !0;
			}),
				wt(
					Zf,
					z(() => (p.value ? null : f.value))
				);
			let m = z(() => t.selectedIndex);
			return (
				Ze(() => {
					at(
						[m],
						() => {
							var y;
							return c(
								(y = t.selectedIndex) != null
									? y
									: t.defaultIndex
							);
						},
						{ immediate: !0 }
					);
				}),
				xt(() => {
					if (!a.value || u.value == null || d.tabs.value.length <= 0)
						return;
					let y = Wr(d.tabs.value, re);
					y.some((v, w) => re(d.tabs.value[w]) !== re(v)) &&
						d.setSelectedIndex(
							y.findIndex(
								(v) => re(v) === re(d.tabs.value[u.value])
							)
						);
				}),
				() => {
					let y = { selectedIndex: i.value };
					return Ke(Ne, [
						s.value.length <= 0 &&
							Ke(h8, {
								onFocus: () => {
									for (let v of s.value) {
										let w = re(v);
										if (
											(w == null
												? void 0
												: w.tabIndex) === 0
										)
											return w.focus(), !0;
									}
									return !1;
								},
							}),
						it({
							theirProps: B(
								B({}, n),
								$i(t, [
									"selectedIndex",
									"defaultIndex",
									"manual",
									"vertical",
									"onChange",
								])
							),
							ourProps: {},
							slot: y,
							slots: e,
							attrs: n,
							name: "TabGroup",
						}),
					]);
				}
			);
		},
	}),
	y8 = Oe({
		name: "TabList",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { attrs: e, slots: n }) {
			let r = Xs("TabList");
			return () => {
				let o = { selectedIndex: r.selectedIndex.value },
					i = {
						role: "tablist",
						"aria-orientation": r.orientation.value,
					};
				return it({
					ourProps: i,
					theirProps: t,
					slot: o,
					attrs: e,
					slots: n,
					name: "TabList",
				});
			};
		},
	}),
	v8 = Oe({
		name: "Tab",
		props: {
			as: { type: [Object, String], default: "button" },
			disabled: { type: [Boolean], default: !1 },
			id: { type: String, default: () => `headlessui-tabs-tab-${tn()}` },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Xs("Tab"),
				i = Q(null);
			r({ el: i, $el: i }),
				Ze(() => o.registerTab(i)),
				zt(() => o.unregisterTab(i));
			let s = Ge(Zf),
				l = z(() => {
					if (s.value) {
						let v = s.value.tabs.indexOf(t.id);
						return v === -1 ? s.value.tabs.push(t.id) - 1 : v;
					}
					return -1;
				}),
				a = z(() => {
					let v = o.tabs.value.indexOf(i);
					return v === -1 ? l.value : v;
				}),
				u = z(() => a.value === o.selectedIndex.value);
			function c(v) {
				var w;
				let S = v();
				if (S === li.Success && o.activation.value === "auto") {
					let E = (w = fr(i)) == null ? void 0 : w.activeElement,
						h = o.tabs.value.findIndex((b) => re(b) === E);
					h !== -1 && o.setSelectedIndex(h);
				}
				return S;
			}
			function d(v) {
				let w = o.tabs.value.map((S) => re(S)).filter(Boolean);
				if (v.key === Ae.Space || v.key === Ae.Enter) {
					v.preventDefault(),
						v.stopPropagation(),
						o.setSelectedIndex(a.value);
					return;
				}
				switch (v.key) {
					case Ae.Home:
					case Ae.PageUp:
						return (
							v.preventDefault(),
							v.stopPropagation(),
							c(() => Nn(w, Mt.First))
						);
					case Ae.End:
					case Ae.PageDown:
						return (
							v.preventDefault(),
							v.stopPropagation(),
							c(() => Nn(w, Mt.Last))
						);
				}
				if (
					c(() =>
						mt(o.orientation.value, {
							vertical() {
								return v.key === Ae.ArrowUp
									? Nn(w, Mt.Previous | Mt.WrapAround)
									: v.key === Ae.ArrowDown
									? Nn(w, Mt.Next | Mt.WrapAround)
									: li.Error;
							},
							horizontal() {
								return v.key === Ae.ArrowLeft
									? Nn(w, Mt.Previous | Mt.WrapAround)
									: v.key === Ae.ArrowRight
									? Nn(w, Mt.Next | Mt.WrapAround)
									: li.Error;
							},
						})
					) === li.Success
				)
					return v.preventDefault();
			}
			let f = Q(!1);
			function p() {
				var v;
				f.value ||
					((f.value = !0),
					!t.disabled &&
						((v = re(i)) == null || v.focus({ preventScroll: !0 }),
						o.setSelectedIndex(a.value),
						Iu(() => {
							f.value = !1;
						})));
			}
			function m(v) {
				v.preventDefault();
			}
			let y = Ru(
				z(() => ({ as: t.as, type: e.type })),
				i
			);
			return () => {
				var v;
				let w = { selected: u.value },
					b = t,
					{ id: S } = b,
					E = tt(b, ["id"]),
					h = {
						ref: i,
						onKeydown: d,
						onMousedown: m,
						onClick: p,
						id: S,
						role: "tab",
						type: y.value,
						"aria-controls":
							(v = re(o.panels.value[a.value])) == null
								? void 0
								: v.id,
						"aria-selected": u.value,
						tabIndex: u.value ? 0 : -1,
						disabled: t.disabled ? !0 : void 0,
					};
				return it({
					ourProps: h,
					theirProps: E,
					slot: w,
					attrs: e,
					slots: n,
					name: "Tab",
				});
			};
		},
	}),
	b8 = Oe({
		name: "TabPanels",
		props: { as: { type: [Object, String], default: "div" } },
		setup(t, { slots: e, attrs: n }) {
			let r = Xs("TabPanels");
			return () => {
				let o = { selectedIndex: r.selectedIndex.value };
				return it({
					theirProps: t,
					ourProps: {},
					slot: o,
					attrs: n,
					slots: e,
					name: "TabPanels",
				});
			};
		},
	}),
	w8 = Oe({
		name: "TabPanel",
		props: {
			as: { type: [Object, String], default: "div" },
			static: { type: Boolean, default: !1 },
			unmount: { type: Boolean, default: !0 },
			id: {
				type: String,
				default: () => `headlessui-tabs-panel-${tn()}`,
			},
			tabIndex: { type: Number, default: 0 },
		},
		setup(t, { attrs: e, slots: n, expose: r }) {
			let o = Xs("TabPanel"),
				i = Q(null);
			r({ el: i, $el: i }),
				Ze(() => o.registerPanel(i)),
				zt(() => o.unregisterPanel(i));
			let s = Ge(Zf),
				l = z(() => {
					if (s.value) {
						let c = s.value.panels.indexOf(t.id);
						return c === -1 ? s.value.panels.push(t.id) - 1 : c;
					}
					return -1;
				}),
				a = z(() => {
					let c = o.panels.value.indexOf(i);
					return c === -1 ? l.value : c;
				}),
				u = z(() => a.value === o.selectedIndex.value);
			return () => {
				var c;
				let d = { selected: u.value },
					v = t,
					{ id: f, tabIndex: p } = v,
					m = tt(v, ["id", "tabIndex"]),
					y = {
						ref: i,
						id: f,
						role: "tabpanel",
						"aria-labelledby":
							(c = re(o.tabs.value[a.value])) == null
								? void 0
								: c.id,
						tabIndex: u.value ? p : -1,
					};
				return !u.value && t.unmount && !t.static
					? Ke(Ci, B({ as: "span", "aria-hidden": !0 }, y))
					: it({
							ourProps: y,
							theirProps: m,
							slot: d,
							attrs: e,
							slots: n,
							features: fn.Static | fn.RenderStrategy,
							visible: u.value,
							name: "TabPanel",
					  });
			};
		},
	});
function x8(t) {
	let e = { called: !1 };
	return (...n) => {
		if (!e.called) return (e.called = !0), t(...n);
	};
}
function Cc(t, ...e) {
	t && e.length > 0 && t.classList.add(...e);
}
function kl(t, ...e) {
	t && e.length > 0 && t.classList.remove(...e);
}
var Ed = ((t) => ((t.Finished = "finished"), (t.Cancelled = "cancelled"), t))(
	Ed || {}
);
function k8(t, e) {
	let n = $o();
	if (!t) return n.dispose;
	let { transitionDuration: r, transitionDelay: o } = getComputedStyle(t),
		[i, s] = [r, o].map((l) => {
			let [a = 0] = l
				.split(",")
				.filter(Boolean)
				.map((u) =>
					u.includes("ms") ? parseFloat(u) : parseFloat(u) * 1e3
				)
				.sort((u, c) => c - u);
			return a;
		});
	return (
		i !== 0 ? n.setTimeout(() => e("finished"), i + s) : e("finished"),
		n.add(() => e("cancelled")),
		n.dispose
	);
}
function hm(t, e, n, r, o, i) {
	let s = $o(),
		l = i !== void 0 ? x8(i) : () => {};
	return (
		kl(t, ...o),
		Cc(t, ...e, ...n),
		s.nextFrame(() => {
			kl(t, ...n),
				Cc(t, ...r),
				s.add(k8(t, (a) => (kl(t, ...r, ...e), Cc(t, ...o), l(a))));
		}),
		s.add(() => kl(t, ...e, ...n, ...r, ...o)),
		s.add(() => l("cancelled")),
		s.dispose
	);
}
function bo(t = "") {
	return t.split(/\s+/).filter((e) => e.length > 1);
}
let eh = Symbol("TransitionContext");
var S8 = ((t) => ((t.Visible = "visible"), (t.Hidden = "hidden"), t))(S8 || {});
function _8() {
	return Ge(eh, null) !== null;
}
function C8() {
	let t = Ge(eh, null);
	if (t === null)
		throw new Error(
			"A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."
		);
	return t;
}
function M8() {
	let t = Ge(th, null);
	if (t === null)
		throw new Error(
			"A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."
		);
	return t;
}
let th = Symbol("NestingContext");
function Du(t) {
	return "children" in t
		? Du(t.children)
		: t.value.filter(({ state: e }) => e === "visible").length > 0;
}
function Sy(t) {
	let e = Q([]),
		n = Q(!1);
	Ze(() => (n.value = !0)), zt(() => (n.value = !1));
	function r(i, s = Jr.Hidden) {
		let l = e.value.findIndex(({ id: a }) => a === i);
		l !== -1 &&
			(mt(s, {
				[Jr.Unmount]() {
					e.value.splice(l, 1);
				},
				[Jr.Hidden]() {
					e.value[l].state = "hidden";
				},
			}),
			!Du(e) && n.value && (t == null || t()));
	}
	function o(i) {
		let s = e.value.find(({ id: l }) => l === i);
		return (
			s
				? s.state !== "visible" && (s.state = "visible")
				: e.value.push({ id: i, state: "visible" }),
			() => r(i, Jr.Unmount)
		);
	}
	return { children: e, register: o, unregister: r };
}
let _y = fn.RenderStrategy,
	Cy = Oe({
		props: {
			as: { type: [Object, String], default: "div" },
			show: { type: [Boolean], default: null },
			unmount: { type: [Boolean], default: !0 },
			appear: { type: [Boolean], default: !1 },
			enter: { type: [String], default: "" },
			enterFrom: { type: [String], default: "" },
			enterTo: { type: [String], default: "" },
			entered: { type: [String], default: "" },
			leave: { type: [String], default: "" },
			leaveFrom: { type: [String], default: "" },
			leaveTo: { type: [String], default: "" },
		},
		emits: {
			beforeEnter: () => !0,
			afterEnter: () => !0,
			beforeLeave: () => !0,
			afterLeave: () => !0,
		},
		setup(t, { emit: e, attrs: n, slots: r, expose: o }) {
			let i = Q(0);
			function s() {
				(i.value |= ct.Opening), e("beforeEnter");
			}
			function l() {
				(i.value &= ~ct.Opening), e("afterEnter");
			}
			function a() {
				(i.value |= ct.Closing), e("beforeLeave");
			}
			function u() {
				(i.value &= ~ct.Closing), e("afterLeave");
			}
			if (!_8() && gk())
				return () =>
					Ke(
						My,
						ge(B({}, t), {
							onBeforeEnter: s,
							onAfterEnter: l,
							onBeforeLeave: a,
							onAfterLeave: u,
						}),
						r
					);
			let c = Q(null),
				d = z(() => (t.unmount ? Jr.Unmount : Jr.Hidden));
			o({ el: c, $el: c });
			let { show: f, appear: p } = C8(),
				{ register: m, unregister: y } = M8(),
				v = Q(f.value ? "visible" : "hidden"),
				w = { value: !0 },
				S = tn(),
				E = { value: !1 },
				h = Sy(() => {
					!E.value &&
						v.value !== "hidden" &&
						((v.value = "hidden"), y(S), u());
				});
			Ze(() => {
				let P = m(S);
				zt(P);
			}),
				xt(() => {
					if (d.value === Jr.Hidden && S) {
						if (f.value && v.value !== "visible") {
							v.value = "visible";
							return;
						}
						mt(v.value, {
							hidden: () => y(S),
							visible: () => m(S),
						});
					}
				});
			let b = bo(t.enter),
				g = bo(t.enterFrom),
				x = bo(t.enterTo),
				k = bo(t.entered),
				C = bo(t.leave),
				_ = bo(t.leaveFrom),
				T = bo(t.leaveTo);
			Ze(() => {
				xt(() => {
					if (v.value === "visible") {
						let P = re(c);
						if (P instanceof Comment && P.data === "")
							throw new Error(
								"Did you forget to passthrough the `ref` to the actual DOM node?"
							);
					}
				});
			});
			function R(P) {
				let D = w.value && !p.value,
					j = re(c);
				!j ||
					!(j instanceof HTMLElement) ||
					D ||
					((E.value = !0),
					f.value && s(),
					f.value || a(),
					P(
						f.value
							? hm(j, b, g, x, k, (M) => {
									(E.value = !1), M === Ed.Finished && l();
							  })
							: hm(j, C, _, T, k, (M) => {
									(E.value = !1),
										M === Ed.Finished &&
											(Du(h) ||
												((v.value = "hidden"),
												y(S),
												u()));
							  })
					));
			}
			return (
				Ze(() => {
					at(
						[f],
						(P, D, j) => {
							R(j), (w.value = !1);
						},
						{ immediate: !0 }
					);
				}),
				wt(th, h),
				Pu(
					z(
						() =>
							mt(v.value, {
								visible: ct.Open,
								hidden: ct.Closed,
							}) | i.value
					)
				),
				() => {
					let Pe = t,
						{
							appear: P,
							show: D,
							enter: j,
							enterFrom: M,
							enterTo: I,
							entered: $,
							leave: K,
							leaveFrom: ie,
							leaveTo: X,
						} = Pe,
						de = tt(Pe, [
							"appear",
							"show",
							"enter",
							"enterFrom",
							"enterTo",
							"entered",
							"leave",
							"leaveFrom",
							"leaveTo",
						]),
						ze = { ref: c },
						Ee = B(
							B({}, de),
							p.value && f.value && Qs.isServer
								? { class: be([n.class, de.class, ...b, ...g]) }
								: {}
						);
					return it({
						theirProps: Ee,
						ourProps: ze,
						slot: {},
						slots: r,
						attrs: n,
						features: _y,
						visible: v.value === "visible",
						name: "TransitionChild",
					});
				}
			);
		},
	}),
	E8 = Cy,
	My = Oe({
		inheritAttrs: !1,
		props: {
			as: { type: [Object, String], default: "div" },
			show: { type: [Boolean], default: null },
			unmount: { type: [Boolean], default: !0 },
			appear: { type: [Boolean], default: !1 },
			enter: { type: [String], default: "" },
			enterFrom: { type: [String], default: "" },
			enterTo: { type: [String], default: "" },
			entered: { type: [String], default: "" },
			leave: { type: [String], default: "" },
			leaveFrom: { type: [String], default: "" },
			leaveTo: { type: [String], default: "" },
		},
		emits: {
			beforeEnter: () => !0,
			afterEnter: () => !0,
			beforeLeave: () => !0,
			afterLeave: () => !0,
		},
		setup(t, { emit: e, attrs: n, slots: r }) {
			let o = Bi(),
				i = z(() =>
					t.show === null && o !== null
						? (o.value & ct.Open) === ct.Open
						: t.show
				);
			xt(() => {
				if (![!0, !1].includes(i.value))
					throw new Error(
						'A <Transition /> is used but it is missing a `:show="true | false"` prop.'
					);
			});
			let s = Q(i.value ? "visible" : "hidden"),
				l = Sy(() => {
					s.value = "hidden";
				}),
				a = Q(!0),
				u = { show: i, appear: z(() => t.appear || !a.value) };
			return (
				Ze(() => {
					xt(() => {
						(a.value = !1),
							i.value
								? (s.value = "visible")
								: Du(l) || (s.value = "hidden");
					});
				}),
				wt(th, l),
				wt(eh, u),
				() => {
					let c = $i(t, [
							"show",
							"appear",
							"unmount",
							"onBeforeEnter",
							"onBeforeLeave",
							"onAfterEnter",
							"onAfterLeave",
						]),
						d = { unmount: t.unmount };
					return it({
						ourProps: ge(B({}, d), { as: "template" }),
						theirProps: {},
						slot: {},
						slots: ge(B({}, r), {
							default: () => [
								Ke(
									E8,
									B(
										B(
											B(
												{
													onBeforeEnter: () =>
														e("beforeEnter"),
													onAfterEnter: () =>
														e("afterEnter"),
													onBeforeLeave: () =>
														e("beforeLeave"),
													onAfterLeave: () =>
														e("afterLeave"),
												},
												n
											),
											d
										),
										c
									),
									r.default
								),
							],
						}),
						attrs: {},
						features: _y,
						visible: s.value === "visible",
						name: "Transition",
					});
				}
			);
		},
	});
var an = "top",
	Rn = "bottom",
	Pn = "right",
	un = "left",
	nh = "auto",
	Zs = [an, Rn, Pn, un],
	Mi = "start",
	Rs = "end",
	T8 = "clippingParents",
	Ey = "viewport",
	Yi = "popper",
	A8 = "reference",
	pm = Zs.reduce(function (t, e) {
		return t.concat([e + "-" + Mi, e + "-" + Rs]);
	}, []),
	Ty = [].concat(Zs, [nh]).reduce(function (t, e) {
		return t.concat([e, e + "-" + Mi, e + "-" + Rs]);
	}, []),
	O8 = "beforeRead",
	R8 = "read",
	P8 = "afterRead",
	I8 = "beforeMain",
	N8 = "main",
	D8 = "afterMain",
	j8 = "beforeWrite",
	L8 = "write",
	$8 = "afterWrite",
	B8 = [O8, R8, P8, I8, N8, D8, j8, L8, $8];
function ar(t) {
	return t ? (t.nodeName || "").toLowerCase() : null;
}
function yn(t) {
	if (t == null) return window;
	if (t.toString() !== "[object Window]") {
		var e = t.ownerDocument;
		return (e && e.defaultView) || window;
	}
	return t;
}
function Bo(t) {
	var e = yn(t).Element;
	return t instanceof e || t instanceof Element;
}
function An(t) {
	var e = yn(t).HTMLElement;
	return t instanceof e || t instanceof HTMLElement;
}
function rh(t) {
	if (typeof ShadowRoot == "undefined") return !1;
	var e = yn(t).ShadowRoot;
	return t instanceof e || t instanceof ShadowRoot;
}
function z8(t) {
	var e = t.state;
	Object.keys(e.elements).forEach(function (n) {
		var r = e.styles[n] || {},
			o = e.attributes[n] || {},
			i = e.elements[n];
		!An(i) ||
			!ar(i) ||
			(Object.assign(i.style, r),
			Object.keys(o).forEach(function (s) {
				var l = o[s];
				l === !1
					? i.removeAttribute(s)
					: i.setAttribute(s, l === !0 ? "" : l);
			}));
	});
}
function H8(t) {
	var e = t.state,
		n = {
			popper: {
				position: e.options.strategy,
				left: "0",
				top: "0",
				margin: "0",
			},
			arrow: { position: "absolute" },
			reference: {},
		};
	return (
		Object.assign(e.elements.popper.style, n.popper),
		(e.styles = n),
		e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
		function () {
			Object.keys(e.elements).forEach(function (r) {
				var o = e.elements[r],
					i = e.attributes[r] || {},
					s = Object.keys(
						e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]
					),
					l = s.reduce(function (a, u) {
						return (a[u] = ""), a;
					}, {});
				!An(o) ||
					!ar(o) ||
					(Object.assign(o.style, l),
					Object.keys(i).forEach(function (a) {
						o.removeAttribute(a);
					}));
			});
		}
	);
}
const Ay = {
	name: "applyStyles",
	enabled: !0,
	phase: "write",
	fn: z8,
	effect: H8,
	requires: ["computeStyles"],
};
function rr(t) {
	return t.split("-")[0];
}
var Po = Math.max,
	wa = Math.min,
	Ei = Math.round;
function Td() {
	var t = navigator.userAgentData;
	return t != null && t.brands && Array.isArray(t.brands)
		? t.brands
				.map(function (e) {
					return e.brand + "/" + e.version;
				})
				.join(" ")
		: navigator.userAgent;
}
function Oy() {
	return !/^((?!chrome|android).)*safari/i.test(Td());
}
function Ti(t, e, n) {
	e === void 0 && (e = !1), n === void 0 && (n = !1);
	var r = t.getBoundingClientRect(),
		o = 1,
		i = 1;
	e &&
		An(t) &&
		((o = (t.offsetWidth > 0 && Ei(r.width) / t.offsetWidth) || 1),
		(i = (t.offsetHeight > 0 && Ei(r.height) / t.offsetHeight) || 1));
	var s = Bo(t) ? yn(t) : window,
		l = s.visualViewport,
		a = !Oy() && n,
		u = (r.left + (a && l ? l.offsetLeft : 0)) / o,
		c = (r.top + (a && l ? l.offsetTop : 0)) / i,
		d = r.width / o,
		f = r.height / i;
	return {
		width: d,
		height: f,
		top: c,
		right: u + d,
		bottom: c + f,
		left: u,
		x: u,
		y: c,
	};
}
function oh(t) {
	var e = Ti(t),
		n = t.offsetWidth,
		r = t.offsetHeight;
	return (
		Math.abs(e.width - n) <= 1 && (n = e.width),
		Math.abs(e.height - r) <= 1 && (r = e.height),
		{ x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
	);
}
function Ry(t, e) {
	var n = e.getRootNode && e.getRootNode();
	if (t.contains(e)) return !0;
	if (n && rh(n)) {
		var r = e;
		do {
			if (r && t.isSameNode(r)) return !0;
			r = r.parentNode || r.host;
		} while (r);
	}
	return !1;
}
function Mr(t) {
	return yn(t).getComputedStyle(t);
}
function F8(t) {
	return ["table", "td", "th"].indexOf(ar(t)) >= 0;
}
function co(t) {
	return ((Bo(t) ? t.ownerDocument : t.document) || window.document)
		.documentElement;
}
function ju(t) {
	return ar(t) === "html"
		? t
		: t.assignedSlot || t.parentNode || (rh(t) ? t.host : null) || co(t);
}
function mm(t) {
	return !An(t) || Mr(t).position === "fixed" ? null : t.offsetParent;
}
function V8(t) {
	var e = /firefox/i.test(Td()),
		n = /Trident/i.test(Td());
	if (n && An(t)) {
		var r = Mr(t);
		if (r.position === "fixed") return null;
	}
	var o = ju(t);
	for (
		rh(o) && (o = o.host);
		An(o) && ["html", "body"].indexOf(ar(o)) < 0;

	) {
		var i = Mr(o);
		if (
			i.transform !== "none" ||
			i.perspective !== "none" ||
			i.contain === "paint" ||
			["transform", "perspective"].indexOf(i.willChange) !== -1 ||
			(e && i.willChange === "filter") ||
			(e && i.filter && i.filter !== "none")
		)
			return o;
		o = o.parentNode;
	}
	return null;
}
function el(t) {
	for (var e = yn(t), n = mm(t); n && F8(n) && Mr(n).position === "static"; )
		n = mm(n);
	return n &&
		(ar(n) === "html" || (ar(n) === "body" && Mr(n).position === "static"))
		? e
		: n || V8(t) || e;
}
function ih(t) {
	return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fs(t, e, n) {
	return Po(t, wa(e, n));
}
function W8(t, e, n) {
	var r = fs(t, e, n);
	return r > n ? n : r;
}
function Py() {
	return { top: 0, right: 0, bottom: 0, left: 0 };
}
function Iy(t) {
	return Object.assign({}, Py(), t);
}
function Ny(t, e) {
	return e.reduce(function (n, r) {
		return (n[r] = t), n;
	}, {});
}
var U8 = function (e, n) {
	return (
		(e =
			typeof e == "function"
				? e(Object.assign({}, n.rects, { placement: n.placement }))
				: e),
		Iy(typeof e != "number" ? e : Ny(e, Zs))
	);
};
function K8(t) {
	var e,
		n = t.state,
		r = t.name,
		o = t.options,
		i = n.elements.arrow,
		s = n.modifiersData.popperOffsets,
		l = rr(n.placement),
		a = ih(l),
		u = [un, Pn].indexOf(l) >= 0,
		c = u ? "height" : "width";
	if (!(!i || !s)) {
		var d = U8(o.padding, n),
			f = oh(i),
			p = a === "y" ? an : un,
			m = a === "y" ? Rn : Pn,
			y =
				n.rects.reference[c] +
				n.rects.reference[a] -
				s[a] -
				n.rects.popper[c],
			v = s[a] - n.rects.reference[a],
			w = el(i),
			S = w ? (a === "y" ? w.clientHeight || 0 : w.clientWidth || 0) : 0,
			E = y / 2 - v / 2,
			h = d[p],
			b = S - f[c] - d[m],
			g = S / 2 - f[c] / 2 + E,
			x = fs(h, g, b),
			k = a;
		n.modifiersData[r] =
			((e = {}), (e[k] = x), (e.centerOffset = x - g), e);
	}
}
function q8(t) {
	var e = t.state,
		n = t.options,
		r = n.element,
		o = r === void 0 ? "[data-popper-arrow]" : r;
	o != null &&
		((typeof o == "string" &&
			((o = e.elements.popper.querySelector(o)), !o)) ||
			(Ry(e.elements.popper, o) && (e.elements.arrow = o)));
}
const J8 = {
	name: "arrow",
	enabled: !0,
	phase: "main",
	fn: K8,
	effect: q8,
	requires: ["popperOffsets"],
	requiresIfExists: ["preventOverflow"],
};
function Ai(t) {
	return t.split("-")[1];
}
var G8 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Y8(t, e) {
	var n = t.x,
		r = t.y,
		o = e.devicePixelRatio || 1;
	return { x: Ei(n * o) / o || 0, y: Ei(r * o) / o || 0 };
}
function gm(t) {
	var e,
		n = t.popper,
		r = t.popperRect,
		o = t.placement,
		i = t.variation,
		s = t.offsets,
		l = t.position,
		a = t.gpuAcceleration,
		u = t.adaptive,
		c = t.roundOffsets,
		d = t.isFixed,
		f = s.x,
		p = f === void 0 ? 0 : f,
		m = s.y,
		y = m === void 0 ? 0 : m,
		v = typeof c == "function" ? c({ x: p, y }) : { x: p, y };
	(p = v.x), (y = v.y);
	var w = s.hasOwnProperty("x"),
		S = s.hasOwnProperty("y"),
		E = un,
		h = an,
		b = window;
	if (u) {
		var g = el(n),
			x = "clientHeight",
			k = "clientWidth";
		if (
			(g === yn(n) &&
				((g = co(n)),
				Mr(g).position !== "static" &&
					l === "absolute" &&
					((x = "scrollHeight"), (k = "scrollWidth"))),
			(g = g),
			o === an || ((o === un || o === Pn) && i === Rs))
		) {
			h = Rn;
			var C =
				d && g === b && b.visualViewport
					? b.visualViewport.height
					: g[x];
			(y -= C - r.height), (y *= a ? 1 : -1);
		}
		if (o === un || ((o === an || o === Rn) && i === Rs)) {
			E = Pn;
			var _ =
				d && g === b && b.visualViewport
					? b.visualViewport.width
					: g[k];
			(p -= _ - r.width), (p *= a ? 1 : -1);
		}
	}
	var T = Object.assign({ position: l }, u && G8),
		R = c === !0 ? Y8({ x: p, y }, yn(n)) : { x: p, y };
	if (((p = R.x), (y = R.y), a)) {
		var P;
		return Object.assign(
			{},
			T,
			((P = {}),
			(P[h] = S ? "0" : ""),
			(P[E] = w ? "0" : ""),
			(P.transform =
				(b.devicePixelRatio || 1) <= 1
					? "translate(" + p + "px, " + y + "px)"
					: "translate3d(" + p + "px, " + y + "px, 0)"),
			P)
		);
	}
	return Object.assign(
		{},
		T,
		((e = {}),
		(e[h] = S ? y + "px" : ""),
		(e[E] = w ? p + "px" : ""),
		(e.transform = ""),
		e)
	);
}
function Q8(t) {
	var e = t.state,
		n = t.options,
		r = n.gpuAcceleration,
		o = r === void 0 ? !0 : r,
		i = n.adaptive,
		s = i === void 0 ? !0 : i,
		l = n.roundOffsets,
		a = l === void 0 ? !0 : l,
		u = {
			placement: rr(e.placement),
			variation: Ai(e.placement),
			popper: e.elements.popper,
			popperRect: e.rects.popper,
			gpuAcceleration: o,
			isFixed: e.options.strategy === "fixed",
		};
	e.modifiersData.popperOffsets != null &&
		(e.styles.popper = Object.assign(
			{},
			e.styles.popper,
			gm(
				Object.assign({}, u, {
					offsets: e.modifiersData.popperOffsets,
					position: e.options.strategy,
					adaptive: s,
					roundOffsets: a,
				})
			)
		)),
		e.modifiersData.arrow != null &&
			(e.styles.arrow = Object.assign(
				{},
				e.styles.arrow,
				gm(
					Object.assign({}, u, {
						offsets: e.modifiersData.arrow,
						position: "absolute",
						adaptive: !1,
						roundOffsets: a,
					})
				)
			)),
		(e.attributes.popper = Object.assign({}, e.attributes.popper, {
			"data-popper-placement": e.placement,
		}));
}
const X8 = {
	name: "computeStyles",
	enabled: !0,
	phase: "beforeWrite",
	fn: Q8,
	data: {},
};
var Sl = { passive: !0 };
function Z8(t) {
	var e = t.state,
		n = t.instance,
		r = t.options,
		o = r.scroll,
		i = o === void 0 ? !0 : o,
		s = r.resize,
		l = s === void 0 ? !0 : s,
		a = yn(e.elements.popper),
		u = [].concat(e.scrollParents.reference, e.scrollParents.popper);
	return (
		i &&
			u.forEach(function (c) {
				c.addEventListener("scroll", n.update, Sl);
			}),
		l && a.addEventListener("resize", n.update, Sl),
		function () {
			i &&
				u.forEach(function (c) {
					c.removeEventListener("scroll", n.update, Sl);
				}),
				l && a.removeEventListener("resize", n.update, Sl);
		}
	);
}
const eS = {
	name: "eventListeners",
	enabled: !0,
	phase: "write",
	fn: function () {},
	effect: Z8,
	data: {},
};
var tS = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Kl(t) {
	return t.replace(/left|right|bottom|top/g, function (e) {
		return tS[e];
	});
}
var nS = { start: "end", end: "start" };
function ym(t) {
	return t.replace(/start|end/g, function (e) {
		return nS[e];
	});
}
function sh(t) {
	var e = yn(t),
		n = e.pageXOffset,
		r = e.pageYOffset;
	return { scrollLeft: n, scrollTop: r };
}
function lh(t) {
	return Ti(co(t)).left + sh(t).scrollLeft;
}
function rS(t, e) {
	var n = yn(t),
		r = co(t),
		o = n.visualViewport,
		i = r.clientWidth,
		s = r.clientHeight,
		l = 0,
		a = 0;
	if (o) {
		(i = o.width), (s = o.height);
		var u = Oy();
		(u || (!u && e === "fixed")) && ((l = o.offsetLeft), (a = o.offsetTop));
	}
	return { width: i, height: s, x: l + lh(t), y: a };
}
function oS(t) {
	var e,
		n = co(t),
		r = sh(t),
		o = (e = t.ownerDocument) == null ? void 0 : e.body,
		i = Po(
			n.scrollWidth,
			n.clientWidth,
			o ? o.scrollWidth : 0,
			o ? o.clientWidth : 0
		),
		s = Po(
			n.scrollHeight,
			n.clientHeight,
			o ? o.scrollHeight : 0,
			o ? o.clientHeight : 0
		),
		l = -r.scrollLeft + lh(t),
		a = -r.scrollTop;
	return (
		Mr(o || n).direction === "rtl" &&
			(l += Po(n.clientWidth, o ? o.clientWidth : 0) - i),
		{ width: i, height: s, x: l, y: a }
	);
}
function ah(t) {
	var e = Mr(t),
		n = e.overflow,
		r = e.overflowX,
		o = e.overflowY;
	return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function Dy(t) {
	return ["html", "body", "#document"].indexOf(ar(t)) >= 0
		? t.ownerDocument.body
		: An(t) && ah(t)
		? t
		: Dy(ju(t));
}
function hs(t, e) {
	var n;
	e === void 0 && (e = []);
	var r = Dy(t),
		o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
		i = yn(r),
		s = o ? [i].concat(i.visualViewport || [], ah(r) ? r : []) : r,
		l = e.concat(s);
	return o ? l : l.concat(hs(ju(s)));
}
function Ad(t) {
	return Object.assign({}, t, {
		left: t.x,
		top: t.y,
		right: t.x + t.width,
		bottom: t.y + t.height,
	});
}
function iS(t, e) {
	var n = Ti(t, !1, e === "fixed");
	return (
		(n.top = n.top + t.clientTop),
		(n.left = n.left + t.clientLeft),
		(n.bottom = n.top + t.clientHeight),
		(n.right = n.left + t.clientWidth),
		(n.width = t.clientWidth),
		(n.height = t.clientHeight),
		(n.x = n.left),
		(n.y = n.top),
		n
	);
}
function vm(t, e, n) {
	return e === Ey ? Ad(rS(t, n)) : Bo(e) ? iS(e, n) : Ad(oS(co(t)));
}
function sS(t) {
	var e = hs(ju(t)),
		n = ["absolute", "fixed"].indexOf(Mr(t).position) >= 0,
		r = n && An(t) ? el(t) : t;
	return Bo(r)
		? e.filter(function (o) {
				return Bo(o) && Ry(o, r) && ar(o) !== "body";
		  })
		: [];
}
function lS(t, e, n, r) {
	var o = e === "clippingParents" ? sS(t) : [].concat(e),
		i = [].concat(o, [n]),
		s = i[0],
		l = i.reduce(function (a, u) {
			var c = vm(t, u, r);
			return (
				(a.top = Po(c.top, a.top)),
				(a.right = wa(c.right, a.right)),
				(a.bottom = wa(c.bottom, a.bottom)),
				(a.left = Po(c.left, a.left)),
				a
			);
		}, vm(t, s, r));
	return (
		(l.width = l.right - l.left),
		(l.height = l.bottom - l.top),
		(l.x = l.left),
		(l.y = l.top),
		l
	);
}
function jy(t) {
	var e = t.reference,
		n = t.element,
		r = t.placement,
		o = r ? rr(r) : null,
		i = r ? Ai(r) : null,
		s = e.x + e.width / 2 - n.width / 2,
		l = e.y + e.height / 2 - n.height / 2,
		a;
	switch (o) {
		case an:
			a = { x: s, y: e.y - n.height };
			break;
		case Rn:
			a = { x: s, y: e.y + e.height };
			break;
		case Pn:
			a = { x: e.x + e.width, y: l };
			break;
		case un:
			a = { x: e.x - n.width, y: l };
			break;
		default:
			a = { x: e.x, y: e.y };
	}
	var u = o ? ih(o) : null;
	if (u != null) {
		var c = u === "y" ? "height" : "width";
		switch (i) {
			case Mi:
				a[u] = a[u] - (e[c] / 2 - n[c] / 2);
				break;
			case Rs:
				a[u] = a[u] + (e[c] / 2 - n[c] / 2);
				break;
		}
	}
	return a;
}
function Ps(t, e) {
	e === void 0 && (e = {});
	var n = e,
		r = n.placement,
		o = r === void 0 ? t.placement : r,
		i = n.strategy,
		s = i === void 0 ? t.strategy : i,
		l = n.boundary,
		a = l === void 0 ? T8 : l,
		u = n.rootBoundary,
		c = u === void 0 ? Ey : u,
		d = n.elementContext,
		f = d === void 0 ? Yi : d,
		p = n.altBoundary,
		m = p === void 0 ? !1 : p,
		y = n.padding,
		v = y === void 0 ? 0 : y,
		w = Iy(typeof v != "number" ? v : Ny(v, Zs)),
		S = f === Yi ? A8 : Yi,
		E = t.rects.popper,
		h = t.elements[m ? S : f],
		b = lS(Bo(h) ? h : h.contextElement || co(t.elements.popper), a, c, s),
		g = Ti(t.elements.reference),
		x = jy({
			reference: g,
			element: E,
			strategy: "absolute",
			placement: o,
		}),
		k = Ad(Object.assign({}, E, x)),
		C = f === Yi ? k : g,
		_ = {
			top: b.top - C.top + w.top,
			bottom: C.bottom - b.bottom + w.bottom,
			left: b.left - C.left + w.left,
			right: C.right - b.right + w.right,
		},
		T = t.modifiersData.offset;
	if (f === Yi && T) {
		var R = T[o];
		Object.keys(_).forEach(function (P) {
			var D = [Pn, Rn].indexOf(P) >= 0 ? 1 : -1,
				j = [an, Rn].indexOf(P) >= 0 ? "y" : "x";
			_[P] += R[j] * D;
		});
	}
	return _;
}
function aS(t, e) {
	e === void 0 && (e = {});
	var n = e,
		r = n.placement,
		o = n.boundary,
		i = n.rootBoundary,
		s = n.padding,
		l = n.flipVariations,
		a = n.allowedAutoPlacements,
		u = a === void 0 ? Ty : a,
		c = Ai(r),
		d = c
			? l
				? pm
				: pm.filter(function (m) {
						return Ai(m) === c;
				  })
			: Zs,
		f = d.filter(function (m) {
			return u.indexOf(m) >= 0;
		});
	f.length === 0 && (f = d);
	var p = f.reduce(function (m, y) {
		return (
			(m[y] = Ps(t, {
				placement: y,
				boundary: o,
				rootBoundary: i,
				padding: s,
			})[rr(y)]),
			m
		);
	}, {});
	return Object.keys(p).sort(function (m, y) {
		return p[m] - p[y];
	});
}
function uS(t) {
	if (rr(t) === nh) return [];
	var e = Kl(t);
	return [ym(t), e, ym(e)];
}
function cS(t) {
	var e = t.state,
		n = t.options,
		r = t.name;
	if (!e.modifiersData[r]._skip) {
		for (
			var o = n.mainAxis,
				i = o === void 0 ? !0 : o,
				s = n.altAxis,
				l = s === void 0 ? !0 : s,
				a = n.fallbackPlacements,
				u = n.padding,
				c = n.boundary,
				d = n.rootBoundary,
				f = n.altBoundary,
				p = n.flipVariations,
				m = p === void 0 ? !0 : p,
				y = n.allowedAutoPlacements,
				v = e.options.placement,
				w = rr(v),
				S = w === v,
				E = a || (S || !m ? [Kl(v)] : uS(v)),
				h = [v].concat(E).reduce(function (Ee, Pe) {
					return Ee.concat(
						rr(Pe) === nh
							? aS(e, {
									placement: Pe,
									boundary: c,
									rootBoundary: d,
									padding: u,
									flipVariations: m,
									allowedAutoPlacements: y,
							  })
							: Pe
					);
				}, []),
				b = e.rects.reference,
				g = e.rects.popper,
				x = new Map(),
				k = !0,
				C = h[0],
				_ = 0;
			_ < h.length;
			_++
		) {
			var T = h[_],
				R = rr(T),
				P = Ai(T) === Mi,
				D = [an, Rn].indexOf(R) >= 0,
				j = D ? "width" : "height",
				M = Ps(e, {
					placement: T,
					boundary: c,
					rootBoundary: d,
					altBoundary: f,
					padding: u,
				}),
				I = D ? (P ? Pn : un) : P ? Rn : an;
			b[j] > g[j] && (I = Kl(I));
			var $ = Kl(I),
				K = [];
			if (
				(i && K.push(M[R] <= 0),
				l && K.push(M[I] <= 0, M[$] <= 0),
				K.every(function (Ee) {
					return Ee;
				}))
			) {
				(C = T), (k = !1);
				break;
			}
			x.set(T, K);
		}
		if (k)
			for (
				var ie = m ? 3 : 1,
					X = function (Pe) {
						var De = h.find(function (H) {
							var Z = x.get(H);
							if (Z)
								return Z.slice(0, Pe).every(function (oe) {
									return oe;
								});
						});
						if (De) return (C = De), "break";
					},
					de = ie;
				de > 0;
				de--
			) {
				var ze = X(de);
				if (ze === "break") break;
			}
		e.placement !== C &&
			((e.modifiersData[r]._skip = !0),
			(e.placement = C),
			(e.reset = !0));
	}
}
const dS = {
	name: "flip",
	enabled: !0,
	phase: "main",
	fn: cS,
	requiresIfExists: ["offset"],
	data: { _skip: !1 },
};
function bm(t, e, n) {
	return (
		n === void 0 && (n = { x: 0, y: 0 }),
		{
			top: t.top - e.height - n.y,
			right: t.right - e.width + n.x,
			bottom: t.bottom - e.height + n.y,
			left: t.left - e.width - n.x,
		}
	);
}
function wm(t) {
	return [an, Pn, Rn, un].some(function (e) {
		return t[e] >= 0;
	});
}
function fS(t) {
	var e = t.state,
		n = t.name,
		r = e.rects.reference,
		o = e.rects.popper,
		i = e.modifiersData.preventOverflow,
		s = Ps(e, { elementContext: "reference" }),
		l = Ps(e, { altBoundary: !0 }),
		a = bm(s, r),
		u = bm(l, o, i),
		c = wm(a),
		d = wm(u);
	(e.modifiersData[n] = {
		referenceClippingOffsets: a,
		popperEscapeOffsets: u,
		isReferenceHidden: c,
		hasPopperEscaped: d,
	}),
		(e.attributes.popper = Object.assign({}, e.attributes.popper, {
			"data-popper-reference-hidden": c,
			"data-popper-escaped": d,
		}));
}
const hS = {
	name: "hide",
	enabled: !0,
	phase: "main",
	requiresIfExists: ["preventOverflow"],
	fn: fS,
};
function pS(t, e, n) {
	var r = rr(t),
		o = [un, an].indexOf(r) >= 0 ? -1 : 1,
		i =
			typeof n == "function"
				? n(Object.assign({}, e, { placement: t }))
				: n,
		s = i[0],
		l = i[1];
	return (
		(s = s || 0),
		(l = (l || 0) * o),
		[un, Pn].indexOf(r) >= 0 ? { x: l, y: s } : { x: s, y: l }
	);
}
function mS(t) {
	var e = t.state,
		n = t.options,
		r = t.name,
		o = n.offset,
		i = o === void 0 ? [0, 0] : o,
		s = Ty.reduce(function (c, d) {
			return (c[d] = pS(d, e.rects, i)), c;
		}, {}),
		l = s[e.placement],
		a = l.x,
		u = l.y;
	e.modifiersData.popperOffsets != null &&
		((e.modifiersData.popperOffsets.x += a),
		(e.modifiersData.popperOffsets.y += u)),
		(e.modifiersData[r] = s);
}
const gS = {
	name: "offset",
	enabled: !0,
	phase: "main",
	requires: ["popperOffsets"],
	fn: mS,
};
function yS(t) {
	var e = t.state,
		n = t.name;
	e.modifiersData[n] = jy({
		reference: e.rects.reference,
		element: e.rects.popper,
		strategy: "absolute",
		placement: e.placement,
	});
}
const vS = {
	name: "popperOffsets",
	enabled: !0,
	phase: "read",
	fn: yS,
	data: {},
};
function bS(t) {
	return t === "x" ? "y" : "x";
}
function wS(t) {
	var e = t.state,
		n = t.options,
		r = t.name,
		o = n.mainAxis,
		i = o === void 0 ? !0 : o,
		s = n.altAxis,
		l = s === void 0 ? !1 : s,
		a = n.boundary,
		u = n.rootBoundary,
		c = n.altBoundary,
		d = n.padding,
		f = n.tether,
		p = f === void 0 ? !0 : f,
		m = n.tetherOffset,
		y = m === void 0 ? 0 : m,
		v = Ps(e, { boundary: a, rootBoundary: u, padding: d, altBoundary: c }),
		w = rr(e.placement),
		S = Ai(e.placement),
		E = !S,
		h = ih(w),
		b = bS(h),
		g = e.modifiersData.popperOffsets,
		x = e.rects.reference,
		k = e.rects.popper,
		C =
			typeof y == "function"
				? y(Object.assign({}, e.rects, { placement: e.placement }))
				: y,
		_ =
			typeof C == "number"
				? { mainAxis: C, altAxis: C }
				: Object.assign({ mainAxis: 0, altAxis: 0 }, C),
		T = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
		R = { x: 0, y: 0 };
	if (g) {
		if (i) {
			var P,
				D = h === "y" ? an : un,
				j = h === "y" ? Rn : Pn,
				M = h === "y" ? "height" : "width",
				I = g[h],
				$ = I + v[D],
				K = I - v[j],
				ie = p ? -k[M] / 2 : 0,
				X = S === Mi ? x[M] : k[M],
				de = S === Mi ? -k[M] : -x[M],
				ze = e.elements.arrow,
				Ee = p && ze ? oh(ze) : { width: 0, height: 0 },
				Pe = e.modifiersData["arrow#persistent"]
					? e.modifiersData["arrow#persistent"].padding
					: Py(),
				De = Pe[D],
				H = Pe[j],
				Z = fs(0, x[M], Ee[M]),
				oe = E
					? x[M] / 2 - ie - Z - De - _.mainAxis
					: X - Z - De - _.mainAxis,
				ce = E
					? -x[M] / 2 + ie + Z + H + _.mainAxis
					: de + Z + H + _.mainAxis,
				He = e.elements.arrow && el(e.elements.arrow),
				Ye = He
					? h === "y"
						? He.clientTop || 0
						: He.clientLeft || 0
					: 0,
				A = (P = T == null ? void 0 : T[h]) != null ? P : 0,
				O = I + oe - A - Ye,
				L = I + ce - A,
				q = fs(p ? wa($, O) : $, I, p ? Po(K, L) : K);
			(g[h] = q), (R[h] = q - I);
		}
		if (l) {
			var U,
				ee = h === "x" ? an : un,
				ae = h === "x" ? Rn : Pn,
				Y = g[b],
				te = b === "y" ? "height" : "width",
				G = Y + v[ee],
				ue = Y - v[ae],
				ye = [an, un].indexOf(w) !== -1,
				me = (U = T == null ? void 0 : T[b]) != null ? U : 0,
				_e = ye ? G : Y - x[te] - k[te] - me + _.altAxis,
				$e = ye ? Y + x[te] + k[te] - me - _.altAxis : ue,
				Qe = p && ye ? W8(_e, Y, $e) : fs(p ? _e : G, Y, p ? $e : ue);
			(g[b] = Qe), (R[b] = Qe - Y);
		}
		e.modifiersData[r] = R;
	}
}
const xS = {
	name: "preventOverflow",
	enabled: !0,
	phase: "main",
	fn: wS,
	requiresIfExists: ["offset"],
};
function kS(t) {
	return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function SS(t) {
	return t === yn(t) || !An(t) ? sh(t) : kS(t);
}
function _S(t) {
	var e = t.getBoundingClientRect(),
		n = Ei(e.width) / t.offsetWidth || 1,
		r = Ei(e.height) / t.offsetHeight || 1;
	return n !== 1 || r !== 1;
}
function CS(t, e, n) {
	n === void 0 && (n = !1);
	var r = An(e),
		o = An(e) && _S(e),
		i = co(e),
		s = Ti(t, o, n),
		l = { scrollLeft: 0, scrollTop: 0 },
		a = { x: 0, y: 0 };
	return (
		(r || (!r && !n)) &&
			((ar(e) !== "body" || ah(i)) && (l = SS(e)),
			An(e)
				? ((a = Ti(e, !0)), (a.x += e.clientLeft), (a.y += e.clientTop))
				: i && (a.x = lh(i))),
		{
			x: s.left + l.scrollLeft - a.x,
			y: s.top + l.scrollTop - a.y,
			width: s.width,
			height: s.height,
		}
	);
}
function MS(t) {
	var e = new Map(),
		n = new Set(),
		r = [];
	t.forEach(function (i) {
		e.set(i.name, i);
	});
	function o(i) {
		n.add(i.name);
		var s = [].concat(i.requires || [], i.requiresIfExists || []);
		s.forEach(function (l) {
			if (!n.has(l)) {
				var a = e.get(l);
				a && o(a);
			}
		}),
			r.push(i);
	}
	return (
		t.forEach(function (i) {
			n.has(i.name) || o(i);
		}),
		r
	);
}
function ES(t) {
	var e = MS(t);
	return B8.reduce(function (n, r) {
		return n.concat(
			e.filter(function (o) {
				return o.phase === r;
			})
		);
	}, []);
}
function TS(t) {
	var e;
	return function () {
		return (
			e ||
				(e = new Promise(function (n) {
					Promise.resolve().then(function () {
						(e = void 0), n(t());
					});
				})),
			e
		);
	};
}
function AS(t) {
	var e = t.reduce(function (n, r) {
		var o = n[r.name];
		return (
			(n[r.name] = o
				? Object.assign({}, o, r, {
						options: Object.assign({}, o.options, r.options),
						data: Object.assign({}, o.data, r.data),
				  })
				: r),
			n
		);
	}, {});
	return Object.keys(e).map(function (n) {
		return e[n];
	});
}
var xm = { placement: "bottom", modifiers: [], strategy: "absolute" };
function km() {
	for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
		e[n] = arguments[n];
	return !e.some(function (r) {
		return !(r && typeof r.getBoundingClientRect == "function");
	});
}
function OS(t) {
	t === void 0 && (t = {});
	var e = t,
		n = e.defaultModifiers,
		r = n === void 0 ? [] : n,
		o = e.defaultOptions,
		i = o === void 0 ? xm : o;
	return function (l, a, u) {
		u === void 0 && (u = i);
		var c = {
				placement: "bottom",
				orderedModifiers: [],
				options: Object.assign({}, xm, i),
				modifiersData: {},
				elements: { reference: l, popper: a },
				attributes: {},
				styles: {},
			},
			d = [],
			f = !1,
			p = {
				state: c,
				setOptions: function (w) {
					var S = typeof w == "function" ? w(c.options) : w;
					y(),
						(c.options = Object.assign({}, i, c.options, S)),
						(c.scrollParents = {
							reference: Bo(l)
								? hs(l)
								: l.contextElement
								? hs(l.contextElement)
								: [],
							popper: hs(a),
						});
					var E = ES(AS([].concat(r, c.options.modifiers)));
					return (
						(c.orderedModifiers = E.filter(function (h) {
							return h.enabled;
						})),
						m(),
						p.update()
					);
				},
				forceUpdate: function () {
					if (!f) {
						var w = c.elements,
							S = w.reference,
							E = w.popper;
						if (km(S, E)) {
							(c.rects = {
								reference: CS(
									S,
									el(E),
									c.options.strategy === "fixed"
								),
								popper: oh(E),
							}),
								(c.reset = !1),
								(c.placement = c.options.placement),
								c.orderedModifiers.forEach(function (_) {
									return (c.modifiersData[_.name] =
										Object.assign({}, _.data));
								});
							for (
								var h = 0;
								h < c.orderedModifiers.length;
								h++
							) {
								if (c.reset === !0) {
									(c.reset = !1), (h = -1);
									continue;
								}
								var b = c.orderedModifiers[h],
									g = b.fn,
									x = b.options,
									k = x === void 0 ? {} : x,
									C = b.name;
								typeof g == "function" &&
									(c =
										g({
											state: c,
											options: k,
											name: C,
											instance: p,
										}) || c);
							}
						}
					}
				},
				update: TS(function () {
					return new Promise(function (v) {
						p.forceUpdate(), v(c);
					});
				}),
				destroy: function () {
					y(), (f = !0);
				},
			};
		if (!km(l, a)) return p;
		p.setOptions(u).then(function (v) {
			!f && u.onFirstUpdate && u.onFirstUpdate(v);
		});
		function m() {
			c.orderedModifiers.forEach(function (v) {
				var w = v.name,
					S = v.options,
					E = S === void 0 ? {} : S,
					h = v.effect;
				if (typeof h == "function") {
					var b = h({ state: c, name: w, instance: p, options: E }),
						g = function () {};
					d.push(b || g);
				}
			});
		}
		function y() {
			d.forEach(function (v) {
				return v();
			}),
				(d = []);
		}
		return p;
	};
}
var RS = [eS, vS, X8, Ay, gS, dS, xS, J8, hS],
	Ly = OS({ defaultModifiers: RS });
const PS = {
		name: "Popover",
		inheritAttrs: !1,
		props: {
			show: { default: void 0 },
			trigger: { type: String, default: "click" },
			hoverDelay: { type: Number, default: 0 },
			leaveDelay: { type: Number, default: 0 },
			placement: { type: String, default: "bottom-start" },
			popoverClass: [String, Object, Array],
			transition: { default: null },
			hideOnBlur: { default: !0 },
		},
		emits: ["open", "close", "update:show"],
		expose: ["open", "close"],
		data() {
			return {
				showPopup: !1,
				targetWidth: null,
				pointerOverTargetOrPopup: !1,
			};
		},
		watch: {
			show(t) {
				t ? this.open() : this.close();
			},
		},
		created() {
			if (
				typeof window != "undefined" &&
				!document.getElementById("frappeui-popper-root")
			) {
				const t = document.createElement("div");
				(t.id = "frappeui-popper-root"), document.body.appendChild(t);
			}
		},
		mounted() {
			(this.listener = (t) => {
				[this.$refs.reference, this.$refs.popover].some(
					(r) => r && (t.target === r || r.contains(t.target))
				) || this.close();
			}),
				this.hideOnBlur &&
					document.addEventListener("click", this.listener),
				this.$nextTick(() => {
					this.targetWidth = this.$refs.target.clientWidth;
				});
		},
		beforeDestroy() {
			this.popper && this.popper.destroy(),
				document.removeEventListener("click", this.listener);
		},
		computed: {
			showPropPassed() {
				return this.show != null;
			},
			isOpen: {
				get() {
					return this.showPropPassed ? this.show : this.showPopup;
				},
				set(t) {
					(t = !!t),
						this.showPropPassed
							? this.$emit("update:show", t)
							: (this.showPopup = t),
						t === !1
							? this.$emit("close")
							: t === !0 && this.$emit("open");
				},
			},
			popupTransition() {
				let t = {
					default: {
						enterActiveClass: "transition duration-150 ease-out",
						enterFromClass: "translate-y-1 opacity-0",
						enterToClass: "translate-y-0 opacity-100",
						leaveActiveClass: "transition duration-150 ease-in",
						leaveFromClass: "translate-y-0 opacity-100",
						leaveToClass: "translate-y-1 opacity-0",
					},
				};
				return typeof this.transition == "string"
					? t[this.transition]
					: this.transition;
			},
		},
		methods: {
			setupPopper() {
				this.popper
					? this.updatePosition()
					: (this.popper = Ly(
							this.$refs.reference,
							this.$refs.popover,
							{ placement: this.placement }
					  ));
			},
			updatePosition() {
				this.popper && this.popper.update();
			},
			togglePopover(t) {
				t instanceof Event && (t = null),
					t == null && (t = !this.isOpen),
					(t = !!t),
					t ? this.open() : this.close();
			},
			open() {
				(this.isOpen = !0), this.$nextTick(() => this.setupPopper());
			},
			close() {
				this.isOpen = !1;
			},
			onMouseover() {
				(this.pointerOverTargetOrPopup = !0),
					this.leaveTimer &&
						(clearTimeout(this.leaveTimer),
						(this.leaveTimer = null)),
					this.trigger === "hover" &&
						(this.hoverDelay
							? (this.hoverTimer = setTimeout(() => {
									this.pointerOverTargetOrPopup &&
										this.open();
							  }, Number(this.hoverDelay) * 1e3))
							: this.open());
			},
			onMouseleave(t) {
				(this.pointerOverTargetOrPopup = !1),
					this.hoverTimer &&
						(clearTimeout(this.hoverTimer),
						(this.hoverTimer = null)),
					this.trigger === "hover" &&
						(this.leaveTimer && clearTimeout(this.leaveTimer),
						this.leaveDelay
							? (this.leaveTimer = setTimeout(() => {
									this.pointerOverTargetOrPopup ||
										this.close();
							  }, Number(this.leaveDelay) * 1e3))
							: this.pointerOverTargetOrPopup || this.close());
			},
		},
	},
	IS = { ref: "reference" },
	NS = { class: "rounded-lg border border-gray-100 bg-white shadow-xl" };
function DS(t, e, n, r, o, i) {
	return (
		N(),
		W(
			"div",
			IS,
			[
				V(
					"div",
					{
						ref: "target",
						class: be(["flex", t.$attrs.class]),
						onClick:
							e[0] ||
							(e[0] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onFocusin:
							e[1] ||
							(e[1] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onKeydown:
							e[2] ||
							(e[2] = (...s) =>
								i.updatePosition && i.updatePosition(...s)),
						onMouseover:
							e[3] ||
							(e[3] = (...s) =>
								i.onMouseover && i.onMouseover(...s)),
						onMouseleave:
							e[4] ||
							(e[4] = (...s) =>
								i.onMouseleave && i.onMouseleave(...s)),
					},
					[
						xe(
							t.$slots,
							"target",
							Et(
								Lt({
									togglePopover: i.togglePopover,
									updatePosition: i.updatePosition,
									open: i.open,
									close: i.close,
									isOpen: i.isOpen,
								})
							)
						),
					],
					34
				),
				(N(),
				Te(_u, { to: "#frappeui-popper-root" }, [
					V(
						"div",
						{
							ref: "popover",
							class: be([
								n.popoverClass,
								"popover-container relative z-[100]",
							]),
							style: ao({
								minWidth: o.targetWidth
									? o.targetWidth + "px"
									: null,
							}),
							onMouseover:
								e[5] ||
								(e[5] = (s) =>
									(o.pointerOverTargetOrPopup = !0)),
							onMouseleave:
								e[6] ||
								(e[6] = (...s) =>
									i.onMouseleave && i.onMouseleave(...s)),
						},
						[
							ve(
								Tu,
								Et(Lt(i.popupTransition)),
								{
									default: Ce(() => [
										ca(
											V(
												"div",
												null,
												[
													xe(
														t.$slots,
														"body",
														Et(
															Lt({
																togglePopover:
																	i.togglePopover,
																updatePosition:
																	i.updatePosition,
																open: i.open,
																close: i.close,
																isOpen: i.isOpen,
															})
														),
														() => [
															V("div", NS, [
																xe(
																	t.$slots,
																	"body-main",
																	Et(
																		Lt({
																			togglePopover:
																				i.togglePopover,
																			updatePosition:
																				i.updatePosition,
																			open: i.open,
																			close: i.close,
																			isOpen: i.isOpen,
																		})
																	)
																),
															]),
														]
													),
												],
												512
											),
											[[ma, i.isOpen]]
										),
									]),
									_: 3,
								},
								16
							),
						],
						38
					),
				])),
			],
			512
		)
	);
}
const tl = Le(PS, [["render", DS]]);
var $y =
	typeof globalThis != "undefined"
		? globalThis
		: typeof window != "undefined"
		? window
		: typeof global != "undefined"
		? global
		: typeof self != "undefined"
		? self
		: {};
function uh(t) {
	return t &&
		t.__esModule &&
		Object.prototype.hasOwnProperty.call(t, "default")
		? t.default
		: t;
}
var By = { exports: {} };
(function (t, e) {
	(function (r, o) {
		t.exports = o();
	})(typeof self != "undefined" ? self : $y, function () {
		return (function (n) {
			var r = {};
			function o(i) {
				if (r[i]) return r[i].exports;
				var s = (r[i] = { i, l: !1, exports: {} });
				return (
					n[i].call(s.exports, s, s.exports, o), (s.l = !0), s.exports
				);
			}
			return (
				(o.m = n),
				(o.c = r),
				(o.d = function (i, s, l) {
					o.o(i, s) ||
						Object.defineProperty(i, s, {
							configurable: !1,
							enumerable: !0,
							get: l,
						});
				}),
				(o.r = function (i) {
					Object.defineProperty(i, "__esModule", { value: !0 });
				}),
				(o.n = function (i) {
					var s =
						i && i.__esModule
							? function () {
									return i.default;
							  }
							: function () {
									return i;
							  };
					return o.d(s, "a", s), s;
				}),
				(o.o = function (i, s) {
					return Object.prototype.hasOwnProperty.call(i, s);
				}),
				(o.p = ""),
				o((o.s = 0))
			);
		})({
			"./dist/icons.json": function (n) {
				n.exports = {
					activity:
						'<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>',
					airplay:
						'<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>',
					"alert-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
					"alert-octagon":
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
					"alert-triangle":
						'<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>',
					"align-center":
						'<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>',
					"align-justify":
						'<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>',
					"align-left":
						'<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>',
					"align-right":
						'<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>',
					anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>',
					aperture:
						'<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>',
					archive:
						'<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>',
					"arrow-down-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>',
					"arrow-down-left":
						'<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>',
					"arrow-down-right":
						'<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>',
					"arrow-down":
						'<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>',
					"arrow-left-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>',
					"arrow-left":
						'<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>',
					"arrow-right-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>',
					"arrow-right":
						'<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>',
					"arrow-up-circle":
						'<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>',
					"arrow-up-left":
						'<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>',
					"arrow-up-right":
						'<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>',
					"arrow-up":
						'<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>',
					"at-sign":
						'<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>',
					award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>',
					"bar-chart-2":
						'<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>',
					"bar-chart":
						'<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>',
					"battery-charging":
						'<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>',
					battery:
						'<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>',
					"bell-off":
						'<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>',
					bluetooth:
						'<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>',
					bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>',
					"book-open":
						'<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>',
					book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>',
					bookmark:
						'<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>',
					box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					briefcase:
						'<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>',
					calendar:
						'<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>',
					"camera-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>',
					camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>',
					cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>',
					"check-circle":
						'<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>',
					"check-square":
						'<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>',
					check: '<polyline points="20 6 9 17 4 12"></polyline>',
					"chevron-down":
						'<polyline points="6 9 12 15 18 9"></polyline>',
					"chevron-left":
						'<polyline points="15 18 9 12 15 6"></polyline>',
					"chevron-right":
						'<polyline points="9 18 15 12 9 6"></polyline>',
					"chevron-up":
						'<polyline points="18 15 12 9 6 15"></polyline>',
					"chevrons-down":
						'<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>',
					"chevrons-left":
						'<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>',
					"chevrons-right":
						'<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>',
					"chevrons-up":
						'<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>',
					chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>',
					circle: '<circle cx="12" cy="12" r="10"></circle>',
					clipboard:
						'<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>',
					clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>',
					"cloud-drizzle":
						'<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
					"cloud-lightning":
						'<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>',
					"cloud-off":
						'<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					"cloud-rain":
						'<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
					"cloud-snow":
						'<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>',
					cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>',
					code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>',
					codepen:
						'<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>',
					codesandbox:
						'<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>',
					columns:
						'<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>',
					command:
						'<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>',
					compass:
						'<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>',
					copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>',
					"corner-down-left":
						'<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>',
					"corner-down-right":
						'<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>',
					"corner-left-down":
						'<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>',
					"corner-left-up":
						'<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>',
					"corner-right-down":
						'<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>',
					"corner-right-up":
						'<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>',
					"corner-up-left":
						'<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>',
					"corner-up-right":
						'<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>',
					cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>',
					"credit-card":
						'<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>',
					crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>',
					crosshair:
						'<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>',
					database:
						'<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>',
					delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>',
					disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>',
					"divide-circle":
						'<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>',
					"divide-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>',
					divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>',
					"dollar-sign":
						'<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>',
					"download-cloud":
						'<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>',
					download:
						'<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>',
					dribbble:
						'<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>',
					droplet:
						'<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>',
					"edit-2":
						'<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>',
					"edit-3":
						'<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>',
					edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>',
					"external-link":
						'<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>',
					"eye-off":
						'<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>',
					facebook:
						'<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>',
					"fast-forward":
						'<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>',
					feather:
						'<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>',
					figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>',
					"file-minus":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>',
					"file-plus":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>',
					"file-text":
						'<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>',
					file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>',
					film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>',
					filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>',
					flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>',
					"folder-minus":
						'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>',
					"folder-plus":
						'<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>',
					folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>',
					framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>',
					frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>',
					"git-branch":
						'<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>',
					"git-commit":
						'<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>',
					"git-merge":
						'<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>',
					"git-pull-request":
						'<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>',
					github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>',
					gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>',
					globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>',
					grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>',
					"hard-drive":
						'<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>',
					hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>',
					headphones:
						'<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>',
					heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>',
					"help-circle":
						'<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>',
					hexagon:
						'<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>',
					home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>',
					image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>',
					inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>',
					info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>',
					instagram:
						'<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>',
					italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>',
					key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>',
					layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>',
					layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>',
					"life-buoy":
						'<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>',
					"link-2":
						'<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>',
					link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>',
					linkedin:
						'<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>',
					list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
					loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>',
					lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>',
					"log-in":
						'<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>',
					"log-out":
						'<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>',
					mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>',
					"map-pin":
						'<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>',
					map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>',
					"maximize-2":
						'<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
					maximize:
						'<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>',
					meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>',
					"message-circle":
						'<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>',
					"message-square":
						'<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>',
					"mic-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
					mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
					"minimize-2":
						'<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
					minimize:
						'<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>',
					"minus-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>',
					"minus-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>',
					minus: '<line x1="5" y1="12" x2="19" y2="12"></line>',
					monitor:
						'<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>',
					moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>',
					"more-horizontal":
						'<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>',
					"more-vertical":
						'<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>',
					"mouse-pointer":
						'<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>',
					move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>',
					music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>',
					"navigation-2":
						'<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>',
					navigation:
						'<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>',
					octagon:
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>',
					package:
						'<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
					paperclip:
						'<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>',
					"pause-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>',
					pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>',
					"pen-tool":
						'<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>',
					percent:
						'<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>',
					"phone-call":
						'<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-forwarded":
						'<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-incoming":
						'<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-missed":
						'<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"phone-off":
						'<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>',
					"phone-outgoing":
						'<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
					"pie-chart":
						'<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>',
					"play-circle":
						'<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>',
					play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>',
					"plus-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
					"plus-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
					plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>',
					pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>',
					power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>',
					printer:
						'<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>',
					radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>',
					"refresh-ccw":
						'<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>',
					"refresh-cw":
						'<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>',
					repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>',
					rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>',
					"rotate-ccw":
						'<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>',
					"rotate-cw":
						'<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>',
					rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>',
					save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>',
					scissors:
						'<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>',
					search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>',
					send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>',
					server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>',
					settings:
						'<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>',
					"share-2":
						'<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>',
					share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>',
					"shield-off":
						'<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>',
					"shopping-bag":
						'<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>',
					"shopping-cart":
						'<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>',
					shuffle:
						'<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>',
					sidebar:
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>',
					"skip-back":
						'<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>',
					"skip-forward":
						'<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>',
					slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>',
					slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>',
					sliders:
						'<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>',
					smartphone:
						'<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
					smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
					speaker:
						'<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>',
					square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>',
					star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>',
					"stop-circle":
						'<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>',
					sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>',
					sunrise:
						'<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>',
					sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>',
					table: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>',
					tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
					tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>',
					target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>',
					terminal:
						'<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>',
					thermometer:
						'<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>',
					"thumbs-down":
						'<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>',
					"thumbs-up":
						'<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>',
					"toggle-left":
						'<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>',
					"toggle-right":
						'<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>',
					tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>',
					"trash-2":
						'<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>',
					trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>',
					trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>',
					"trending-down":
						'<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>',
					"trending-up":
						'<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>',
					triangle:
						'<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>',
					truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>',
					tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>',
					twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zM11 11V7M16 11V7"></path>',
					twitter:
						'<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>',
					type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>',
					umbrella:
						'<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>',
					underline:
						'<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>',
					unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>',
					"upload-cloud":
						'<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>',
					upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>',
					"user-check":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>',
					"user-minus":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>',
					"user-plus":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>',
					"user-x":
						'<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>',
					user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>',
					users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>',
					"video-off":
						'<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
					video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>',
					voicemail:
						'<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>',
					"volume-1":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
					"volume-2":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
					"volume-x":
						'<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>',
					volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>',
					watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>',
					"wifi-off":
						'<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
					wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
					wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>',
					"x-circle":
						'<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
					"x-octagon":
						'<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
					"x-square":
						'<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>',
					x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>',
					youtube:
						'<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>',
					"zap-off":
						'<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>',
					zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>',
					"zoom-in":
						'<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
					"zoom-out":
						'<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
				};
			},
			"./node_modules/classnames/dedupe.js": function (n, r, o) {
				var i, s;
				/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/ (function () {
					var l = (function () {
						function a() {}
						a.prototype = Object.create(null);
						function u(w, S) {
							for (var E = S.length, h = 0; h < E; ++h)
								y(w, S[h]);
						}
						var c = {}.hasOwnProperty;
						function d(w, S) {
							w[S] = !0;
						}
						function f(w, S) {
							for (var E in S) c.call(S, E) && (w[E] = !!S[E]);
						}
						var p = /\s+/;
						function m(w, S) {
							for (
								var E = S.split(p), h = E.length, b = 0;
								b < h;
								++b
							)
								w[E[b]] = !0;
						}
						function y(w, S) {
							if (S) {
								var E = typeof S;
								E === "string"
									? m(w, S)
									: Array.isArray(S)
									? u(w, S)
									: E === "object"
									? f(w, S)
									: E === "number" && d(w, S);
							}
						}
						function v() {
							for (
								var w = arguments.length, S = Array(w), E = 0;
								E < w;
								E++
							)
								S[E] = arguments[E];
							var h = new a();
							u(h, S);
							var b = [];
							for (var g in h) h[g] && b.push(g);
							return b.join(" ");
						}
						return v;
					})();
					typeof n != "undefined" && n.exports
						? (n.exports = l)
						: ((i = []),
						  (s = function () {
								return l;
						  }.apply(r, i)),
						  s !== void 0 && (n.exports = s));
				})();
			},
			"./node_modules/core-js/es/array/from.js": function (n, r, o) {
				o("./node_modules/core-js/modules/es.string.iterator.js"),
					o("./node_modules/core-js/modules/es.array.from.js");
				var i = o("./node_modules/core-js/internals/path.js");
				n.exports = i.Array.from;
			},
			"./node_modules/core-js/internals/a-function.js": function (n, r) {
				n.exports = function (o) {
					if (typeof o != "function")
						throw TypeError(String(o) + " is not a function");
					return o;
				};
			},
			"./node_modules/core-js/internals/an-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/is-object.js");
				n.exports = function (s) {
					if (!i(s)) throw TypeError(String(s) + " is not an object");
					return s;
				};
			},
			"./node_modules/core-js/internals/array-from.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/bind-context.js"),
					s = o("./node_modules/core-js/internals/to-object.js"),
					l = o(
						"./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
					),
					a = o(
						"./node_modules/core-js/internals/is-array-iterator-method.js"
					),
					u = o("./node_modules/core-js/internals/to-length.js"),
					c = o(
						"./node_modules/core-js/internals/create-property.js"
					),
					d = o(
						"./node_modules/core-js/internals/get-iterator-method.js"
					);
				n.exports = function (p) {
					var m = s(p),
						y = typeof this == "function" ? this : Array,
						v = arguments.length,
						w = v > 1 ? arguments[1] : void 0,
						S = w !== void 0,
						E = 0,
						h = d(m),
						b,
						g,
						x,
						k;
					if (
						(S && (w = i(w, v > 2 ? arguments[2] : void 0, 2)),
						h != null && !(y == Array && a(h)))
					)
						for (
							k = h.call(m), g = new y();
							!(x = k.next()).done;
							E++
						)
							c(g, E, S ? l(k, w, [x.value, E], !0) : x.value);
					else
						for (b = u(m.length), g = new y(b); b > E; E++)
							c(g, E, S ? w(m[E], E) : m[E]);
					return (g.length = E), g;
				};
			},
			"./node_modules/core-js/internals/array-includes.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/to-indexed-object.js"
					),
					s = o("./node_modules/core-js/internals/to-length.js"),
					l = o(
						"./node_modules/core-js/internals/to-absolute-index.js"
					);
				n.exports = function (a) {
					return function (u, c, d) {
						var f = i(u),
							p = s(f.length),
							m = l(d, p),
							y;
						if (a && c != c) {
							for (; p > m; )
								if (((y = f[m++]), y != y)) return !0;
						} else
							for (; p > m; m++)
								if ((a || m in f) && f[m] === c)
									return a || m || 0;
						return !a && -1;
					};
				};
			},
			"./node_modules/core-js/internals/bind-context.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/a-function.js");
				n.exports = function (s, l, a) {
					if ((i(s), l === void 0)) return s;
					switch (a) {
						case 0:
							return function () {
								return s.call(l);
							};
						case 1:
							return function (u) {
								return s.call(l, u);
							};
						case 2:
							return function (u, c) {
								return s.call(l, u, c);
							};
						case 3:
							return function (u, c, d) {
								return s.call(l, u, c, d);
							};
					}
					return function () {
						return s.apply(l, arguments);
					};
				};
			},
			"./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/an-object.js");
					n.exports = function (s, l, a, u) {
						try {
							return u ? l(i(a)[0], a[1]) : l(a);
						} catch (d) {
							var c = s.return;
							throw (c !== void 0 && i(c.call(s)), d);
						}
					};
				},
			"./node_modules/core-js/internals/check-correctness-of-iteration.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						s = i("iterator"),
						l = !1;
					try {
						var a = 0,
							u = {
								next: function () {
									return { done: !!a++ };
								},
								return: function () {
									l = !0;
								},
							};
						(u[s] = function () {
							return this;
						}),
							Array.from(u, function () {
								throw 2;
							});
					} catch (c) {}
					n.exports = function (c, d) {
						if (!d && !l) return !1;
						var f = !1;
						try {
							var p = {};
							(p[s] = function () {
								return {
									next: function () {
										return { done: (f = !0) };
									},
								};
							}),
								c(p);
						} catch (m) {}
						return f;
					};
				},
			"./node_modules/core-js/internals/classof-raw.js": function (n, r) {
				var o = {}.toString;
				n.exports = function (i) {
					return o.call(i).slice(8, -1);
				};
			},
			"./node_modules/core-js/internals/classof.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/classof-raw.js"),
					s = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					l = s("toStringTag"),
					a =
						i(
							(function () {
								return arguments;
							})()
						) == "Arguments",
					u = function (c, d) {
						try {
							return c[d];
						} catch (f) {}
					};
				n.exports = function (c) {
					var d, f, p;
					return c === void 0
						? "Undefined"
						: c === null
						? "Null"
						: typeof (f = u((d = Object(c)), l)) == "string"
						? f
						: a
						? i(d)
						: (p = i(d)) == "Object" &&
						  typeof d.callee == "function"
						? "Arguments"
						: p;
				};
			},
			"./node_modules/core-js/internals/copy-constructor-properties.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o("./node_modules/core-js/internals/own-keys.js"),
						l = o(
							"./node_modules/core-js/internals/object-get-own-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/object-define-property.js"
						);
					n.exports = function (u, c) {
						for (
							var d = s(c), f = a.f, p = l.f, m = 0;
							m < d.length;
							m++
						) {
							var y = d[m];
							i(u, y) || f(u, y, p(c, y));
						}
					};
				},
			"./node_modules/core-js/internals/correct-prototype-getter.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/fails.js");
					n.exports = !i(function () {
						function s() {}
						return (
							(s.prototype.constructor = null),
							Object.getPrototypeOf(new s()) !== s.prototype
						);
					});
				},
			"./node_modules/core-js/internals/create-iterator-constructor.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/iterators-core.js"
						).IteratorPrototype,
						s = o(
							"./node_modules/core-js/internals/object-create.js"
						),
						l = o(
							"./node_modules/core-js/internals/create-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/set-to-string-tag.js"
						),
						u = o("./node_modules/core-js/internals/iterators.js"),
						c = function () {
							return this;
						};
					n.exports = function (d, f, p) {
						var m = f + " Iterator";
						return (
							(d.prototype = s(i, { next: l(1, p) })),
							a(d, m, !1, !0),
							(u[m] = c),
							d
						);
					};
				},
			"./node_modules/core-js/internals/create-property-descriptor.js":
				function (n, r) {
					n.exports = function (o, i) {
						return {
							enumerable: !(o & 1),
							configurable: !(o & 2),
							writable: !(o & 4),
							value: i,
						};
					};
				},
			"./node_modules/core-js/internals/create-property.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-primitive.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-property.js"
					),
					l = o(
						"./node_modules/core-js/internals/create-property-descriptor.js"
					);
				n.exports = function (a, u, c) {
					var d = i(u);
					d in a ? s.f(a, d, l(0, c)) : (a[d] = c);
				};
			},
			"./node_modules/core-js/internals/define-iterator.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/export.js"),
					s = o(
						"./node_modules/core-js/internals/create-iterator-constructor.js"
					),
					l = o(
						"./node_modules/core-js/internals/object-get-prototype-of.js"
					),
					a = o(
						"./node_modules/core-js/internals/object-set-prototype-of.js"
					),
					u = o(
						"./node_modules/core-js/internals/set-to-string-tag.js"
					),
					c = o("./node_modules/core-js/internals/hide.js"),
					d = o("./node_modules/core-js/internals/redefine.js"),
					f = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					p = o("./node_modules/core-js/internals/is-pure.js"),
					m = o("./node_modules/core-js/internals/iterators.js"),
					y = o("./node_modules/core-js/internals/iterators-core.js"),
					v = y.IteratorPrototype,
					w = y.BUGGY_SAFARI_ITERATORS,
					S = f("iterator"),
					E = "keys",
					h = "values",
					b = "entries",
					g = function () {
						return this;
					};
				n.exports = function (x, k, C, _, T, R, P) {
					s(C, k, _);
					var D = function (Ee) {
							if (Ee === T && K) return K;
							if (!w && Ee in I) return I[Ee];
							switch (Ee) {
								case E:
									return function () {
										return new C(this, Ee);
									};
								case h:
									return function () {
										return new C(this, Ee);
									};
								case b:
									return function () {
										return new C(this, Ee);
									};
							}
							return function () {
								return new C(this);
							};
						},
						j = k + " Iterator",
						M = !1,
						I = x.prototype,
						$ = I[S] || I["@@iterator"] || (T && I[T]),
						K = (!w && $) || D(T),
						ie = (k == "Array" && I.entries) || $,
						X,
						de,
						ze;
					if (
						(ie &&
							((X = l(ie.call(new x()))),
							v !== Object.prototype &&
								X.next &&
								(!p &&
									l(X) !== v &&
									(a
										? a(X, v)
										: typeof X[S] != "function" &&
										  c(X, S, g)),
								u(X, j, !0, !0),
								p && (m[j] = g))),
						T == h &&
							$ &&
							$.name !== h &&
							((M = !0),
							(K = function () {
								return $.call(this);
							})),
						(!p || P) && I[S] !== K && c(I, S, K),
						(m[k] = K),
						T)
					)
						if (
							((de = {
								values: D(h),
								keys: R ? K : D(E),
								entries: D(b),
							}),
							P)
						)
							for (ze in de)
								(w || M || !(ze in I)) && d(I, ze, de[ze]);
						else i({ target: k, proto: !0, forced: w || M }, de);
					return de;
				};
			},
			"./node_modules/core-js/internals/descriptors.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js");
				n.exports = !i(function () {
					return (
						Object.defineProperty({}, "a", {
							get: function () {
								return 7;
							},
						}).a != 7
					);
				});
			},
			"./node_modules/core-js/internals/document-create-element.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/global.js"),
						s = o("./node_modules/core-js/internals/is-object.js"),
						l = i.document,
						a = s(l) && s(l.createElement);
					n.exports = function (u) {
						return a ? l.createElement(u) : {};
					};
				},
			"./node_modules/core-js/internals/enum-bug-keys.js": function (
				n,
				r
			) {
				n.exports = [
					"constructor",
					"hasOwnProperty",
					"isPrototypeOf",
					"propertyIsEnumerable",
					"toLocaleString",
					"toString",
					"valueOf",
				];
			},
			"./node_modules/core-js/internals/export.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/object-get-own-property-descriptor.js"
					).f,
					l = o("./node_modules/core-js/internals/hide.js"),
					a = o("./node_modules/core-js/internals/redefine.js"),
					u = o("./node_modules/core-js/internals/set-global.js"),
					c = o(
						"./node_modules/core-js/internals/copy-constructor-properties.js"
					),
					d = o("./node_modules/core-js/internals/is-forced.js");
				n.exports = function (f, p) {
					var m = f.target,
						y = f.global,
						v = f.stat,
						w,
						S,
						E,
						h,
						b,
						g;
					if (
						(y
							? (S = i)
							: v
							? (S = i[m] || u(m, {}))
							: (S = (i[m] || {}).prototype),
						S)
					)
						for (E in p) {
							if (
								((b = p[E]),
								f.noTargetGet
									? ((g = s(S, E)), (h = g && g.value))
									: (h = S[E]),
								(w = d(
									y ? E : m + (v ? "." : "#") + E,
									f.forced
								)),
								!w && h !== void 0)
							) {
								if (typeof b == typeof h) continue;
								c(b, h);
							}
							(f.sham || (h && h.sham)) && l(b, "sham", !0),
								a(S, E, b, f);
						}
				};
			},
			"./node_modules/core-js/internals/fails.js": function (n, r) {
				n.exports = function (o) {
					try {
						return !!o();
					} catch (i) {
						return !0;
					}
				};
			},
			"./node_modules/core-js/internals/function-to-string.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/shared.js");
				n.exports = i("native-function-to-string", Function.toString);
			},
			"./node_modules/core-js/internals/get-iterator-method.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/classof.js"),
						s = o("./node_modules/core-js/internals/iterators.js"),
						l = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						a = l("iterator");
					n.exports = function (u) {
						if (u != null)
							return u[a] || u["@@iterator"] || s[i(u)];
					};
				},
			"./node_modules/core-js/internals/global.js": function (n, r, o) {
				(function (i) {
					var s = "object",
						l = function (a) {
							return a && a.Math == Math && a;
						};
					n.exports =
						l(typeof globalThis == s && globalThis) ||
						l(typeof window == s && window) ||
						l(typeof self == s && self) ||
						l(typeof i == s && i) ||
						Function("return this")();
				}.call(this, o("./node_modules/webpack/buildin/global.js")));
			},
			"./node_modules/core-js/internals/has.js": function (n, r) {
				var o = {}.hasOwnProperty;
				n.exports = function (i, s) {
					return o.call(i, s);
				};
			},
			"./node_modules/core-js/internals/hidden-keys.js": function (n, r) {
				n.exports = {};
			},
			"./node_modules/core-js/internals/hide.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/descriptors.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-property.js"
					),
					l = o(
						"./node_modules/core-js/internals/create-property-descriptor.js"
					);
				n.exports = i
					? function (a, u, c) {
							return s.f(a, u, l(1, c));
					  }
					: function (a, u, c) {
							return (a[u] = c), a;
					  };
			},
			"./node_modules/core-js/internals/html.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = i.document;
				n.exports = s && s.documentElement;
			},
			"./node_modules/core-js/internals/ie8-dom-define.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/descriptors.js"),
					s = o("./node_modules/core-js/internals/fails.js"),
					l = o(
						"./node_modules/core-js/internals/document-create-element.js"
					);
				n.exports =
					!i &&
					!s(function () {
						return (
							Object.defineProperty(l("div"), "a", {
								get: function () {
									return 7;
								},
							}).a != 7
						);
					});
			},
			"./node_modules/core-js/internals/indexed-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js"),
					s = o("./node_modules/core-js/internals/classof-raw.js"),
					l = "".split;
				n.exports = i(function () {
					return !Object("z").propertyIsEnumerable(0);
				})
					? function (a) {
							return s(a) == "String" ? l.call(a, "") : Object(a);
					  }
					: Object;
			},
			"./node_modules/core-js/internals/internal-state.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/native-weak-map.js"
					),
					s = o("./node_modules/core-js/internals/global.js"),
					l = o("./node_modules/core-js/internals/is-object.js"),
					a = o("./node_modules/core-js/internals/hide.js"),
					u = o("./node_modules/core-js/internals/has.js"),
					c = o("./node_modules/core-js/internals/shared-key.js"),
					d = o("./node_modules/core-js/internals/hidden-keys.js"),
					f = s.WeakMap,
					p,
					m,
					y,
					v = function (x) {
						return y(x) ? m(x) : p(x, {});
					},
					w = function (x) {
						return function (k) {
							var C;
							if (!l(k) || (C = m(k)).type !== x)
								throw TypeError(
									"Incompatible receiver, " + x + " required"
								);
							return C;
						};
					};
				if (i) {
					var S = new f(),
						E = S.get,
						h = S.has,
						b = S.set;
					(p = function (x, k) {
						return b.call(S, x, k), k;
					}),
						(m = function (x) {
							return E.call(S, x) || {};
						}),
						(y = function (x) {
							return h.call(S, x);
						});
				} else {
					var g = c("state");
					(d[g] = !0),
						(p = function (x, k) {
							return a(x, g, k), k;
						}),
						(m = function (x) {
							return u(x, g) ? x[g] : {};
						}),
						(y = function (x) {
							return u(x, g);
						});
				}
				n.exports = {
					set: p,
					get: m,
					has: y,
					enforce: v,
					getterFor: w,
				};
			},
			"./node_modules/core-js/internals/is-array-iterator-method.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/well-known-symbol.js"
						),
						s = o("./node_modules/core-js/internals/iterators.js"),
						l = i("iterator"),
						a = Array.prototype;
					n.exports = function (u) {
						return u !== void 0 && (s.Array === u || a[l] === u);
					};
				},
			"./node_modules/core-js/internals/is-forced.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js"),
					s = /#|\.prototype\./,
					l = function (f, p) {
						var m = u[a(f)];
						return m == d
							? !0
							: m == c
							? !1
							: typeof p == "function"
							? i(p)
							: !!p;
					},
					a = (l.normalize = function (f) {
						return String(f).replace(s, ".").toLowerCase();
					}),
					u = (l.data = {}),
					c = (l.NATIVE = "N"),
					d = (l.POLYFILL = "P");
				n.exports = l;
			},
			"./node_modules/core-js/internals/is-object.js": function (n, r) {
				n.exports = function (o) {
					return typeof o == "object"
						? o !== null
						: typeof o == "function";
				};
			},
			"./node_modules/core-js/internals/is-pure.js": function (n, r) {
				n.exports = !1;
			},
			"./node_modules/core-js/internals/iterators-core.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-get-prototype-of.js"
					),
					s = o("./node_modules/core-js/internals/hide.js"),
					l = o("./node_modules/core-js/internals/has.js"),
					a = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					u = o("./node_modules/core-js/internals/is-pure.js"),
					c = a("iterator"),
					d = !1,
					f = function () {
						return this;
					},
					p,
					m,
					y;
				[].keys &&
					((y = [].keys()),
					"next" in y
						? ((m = i(i(y))), m !== Object.prototype && (p = m))
						: (d = !0)),
					p == null && (p = {}),
					!u && !l(p, c) && s(p, c, f),
					(n.exports = {
						IteratorPrototype: p,
						BUGGY_SAFARI_ITERATORS: d,
					});
			},
			"./node_modules/core-js/internals/iterators.js": function (n, r) {
				n.exports = {};
			},
			"./node_modules/core-js/internals/native-symbol.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/fails.js");
				n.exports =
					!!Object.getOwnPropertySymbols &&
					!i(function () {
						return !String(Symbol());
					});
			},
			"./node_modules/core-js/internals/native-weak-map.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/function-to-string.js"
					),
					l = i.WeakMap;
				n.exports =
					typeof l == "function" && /native code/.test(s.call(l));
			},
			"./node_modules/core-js/internals/object-create.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/an-object.js"),
					s = o(
						"./node_modules/core-js/internals/object-define-properties.js"
					),
					l = o("./node_modules/core-js/internals/enum-bug-keys.js"),
					a = o("./node_modules/core-js/internals/hidden-keys.js"),
					u = o("./node_modules/core-js/internals/html.js"),
					c = o(
						"./node_modules/core-js/internals/document-create-element.js"
					),
					d = o("./node_modules/core-js/internals/shared-key.js"),
					f = d("IE_PROTO"),
					p = "prototype",
					m = function () {},
					y = function () {
						var v = c("iframe"),
							w = l.length,
							S = "<",
							E = "script",
							h = ">",
							b = "java" + E + ":",
							g;
						for (
							v.style.display = "none",
								u.appendChild(v),
								v.src = String(b),
								g = v.contentWindow.document,
								g.open(),
								g.write(
									S +
										E +
										h +
										"document.F=Object" +
										S +
										"/" +
										E +
										h
								),
								g.close(),
								y = g.F;
							w--;

						)
							delete y[p][l[w]];
						return y();
					};
				(n.exports =
					Object.create ||
					function (w, S) {
						var E;
						return (
							w !== null
								? ((m[p] = i(w)),
								  (E = new m()),
								  (m[p] = null),
								  (E[f] = w))
								: (E = y()),
							S === void 0 ? E : s(E, S)
						);
					}),
					(a[f] = !0);
			},
			"./node_modules/core-js/internals/object-define-properties.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/object-define-property.js"
						),
						l = o("./node_modules/core-js/internals/an-object.js"),
						a = o(
							"./node_modules/core-js/internals/object-keys.js"
						);
					n.exports = i
						? Object.defineProperties
						: function (c, d) {
								l(c);
								for (
									var f = a(d), p = f.length, m = 0, y;
									p > m;

								)
									s.f(c, (y = f[m++]), d[y]);
								return c;
						  };
				},
			"./node_modules/core-js/internals/object-define-property.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/ie8-dom-define.js"
						),
						l = o("./node_modules/core-js/internals/an-object.js"),
						a = o(
							"./node_modules/core-js/internals/to-primitive.js"
						),
						u = Object.defineProperty;
					r.f = i
						? u
						: function (d, f, p) {
								if ((l(d), (f = a(f, !0)), l(p), s))
									try {
										return u(d, f, p);
									} catch (m) {}
								if ("get" in p || "set" in p)
									throw TypeError("Accessors not supported");
								return "value" in p && (d[f] = p.value), d;
						  };
				},
			"./node_modules/core-js/internals/object-get-own-property-descriptor.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/descriptors.js"
						),
						s = o(
							"./node_modules/core-js/internals/object-property-is-enumerable.js"
						),
						l = o(
							"./node_modules/core-js/internals/create-property-descriptor.js"
						),
						a = o(
							"./node_modules/core-js/internals/to-indexed-object.js"
						),
						u = o(
							"./node_modules/core-js/internals/to-primitive.js"
						),
						c = o("./node_modules/core-js/internals/has.js"),
						d = o(
							"./node_modules/core-js/internals/ie8-dom-define.js"
						),
						f = Object.getOwnPropertyDescriptor;
					r.f = i
						? f
						: function (m, y) {
								if (((m = a(m)), (y = u(y, !0)), d))
									try {
										return f(m, y);
									} catch (v) {}
								if (c(m, y)) return l(!s.f.call(m, y), m[y]);
						  };
				},
			"./node_modules/core-js/internals/object-get-own-property-names.js":
				function (n, r, o) {
					var i = o(
							"./node_modules/core-js/internals/object-keys-internal.js"
						),
						s = o(
							"./node_modules/core-js/internals/enum-bug-keys.js"
						),
						l = s.concat("length", "prototype");
					r.f =
						Object.getOwnPropertyNames ||
						function (u) {
							return i(u, l);
						};
				},
			"./node_modules/core-js/internals/object-get-own-property-symbols.js":
				function (n, r) {
					r.f = Object.getOwnPropertySymbols;
				},
			"./node_modules/core-js/internals/object-get-prototype-of.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o("./node_modules/core-js/internals/to-object.js"),
						l = o("./node_modules/core-js/internals/shared-key.js"),
						a = o(
							"./node_modules/core-js/internals/correct-prototype-getter.js"
						),
						u = l("IE_PROTO"),
						c = Object.prototype;
					n.exports = a
						? Object.getPrototypeOf
						: function (d) {
								return (
									(d = s(d)),
									i(d, u)
										? d[u]
										: typeof d.constructor == "function" &&
										  d instanceof d.constructor
										? d.constructor.prototype
										: d instanceof Object
										? c
										: null
								);
						  };
				},
			"./node_modules/core-js/internals/object-keys-internal.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/has.js"),
						s = o(
							"./node_modules/core-js/internals/to-indexed-object.js"
						),
						l = o(
							"./node_modules/core-js/internals/array-includes.js"
						),
						a = o(
							"./node_modules/core-js/internals/hidden-keys.js"
						),
						u = l(!1);
					n.exports = function (c, d) {
						var f = s(c),
							p = 0,
							m = [],
							y;
						for (y in f) !i(a, y) && i(f, y) && m.push(y);
						for (; d.length > p; )
							i(f, (y = d[p++])) && (~u(m, y) || m.push(y));
						return m;
					};
				},
			"./node_modules/core-js/internals/object-keys.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-keys-internal.js"
					),
					s = o("./node_modules/core-js/internals/enum-bug-keys.js");
				n.exports =
					Object.keys ||
					function (a) {
						return i(a, s);
					};
			},
			"./node_modules/core-js/internals/object-property-is-enumerable.js":
				function (n, r, o) {
					var i = {}.propertyIsEnumerable,
						s = Object.getOwnPropertyDescriptor,
						l = s && !i.call({ 1: 2 }, 1);
					r.f = l
						? function (u) {
								var c = s(this, u);
								return !!c && c.enumerable;
						  }
						: i;
				},
			"./node_modules/core-js/internals/object-set-prototype-of.js":
				function (n, r, o) {
					var i = o(
						"./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
					);
					n.exports =
						Object.setPrototypeOf ||
						("__proto__" in {}
							? (function () {
									var s = !1,
										l = {},
										a;
									try {
										(a = Object.getOwnPropertyDescriptor(
											Object.prototype,
											"__proto__"
										).set),
											a.call(l, []),
											(s = l instanceof Array);
									} catch (u) {}
									return function (c, d) {
										return (
											i(c, d),
											s
												? a.call(c, d)
												: (c.__proto__ = d),
											c
										);
									};
							  })()
							: void 0);
				},
			"./node_modules/core-js/internals/own-keys.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o(
						"./node_modules/core-js/internals/object-get-own-property-names.js"
					),
					l = o(
						"./node_modules/core-js/internals/object-get-own-property-symbols.js"
					),
					a = o("./node_modules/core-js/internals/an-object.js"),
					u = i.Reflect;
				n.exports =
					(u && u.ownKeys) ||
					function (d) {
						var f = s.f(a(d)),
							p = l.f;
						return p ? f.concat(p(d)) : f;
					};
			},
			"./node_modules/core-js/internals/path.js": function (n, r, o) {
				n.exports = o("./node_modules/core-js/internals/global.js");
			},
			"./node_modules/core-js/internals/redefine.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/shared.js"),
					l = o("./node_modules/core-js/internals/hide.js"),
					a = o("./node_modules/core-js/internals/has.js"),
					u = o("./node_modules/core-js/internals/set-global.js"),
					c = o(
						"./node_modules/core-js/internals/function-to-string.js"
					),
					d = o("./node_modules/core-js/internals/internal-state.js"),
					f = d.get,
					p = d.enforce,
					m = String(c).split("toString");
				s("inspectSource", function (y) {
					return c.call(y);
				}),
					(n.exports = function (y, v, w, S) {
						var E = S ? !!S.unsafe : !1,
							h = S ? !!S.enumerable : !1,
							b = S ? !!S.noTargetGet : !1;
						if (
							(typeof w == "function" &&
								(typeof v == "string" &&
									!a(w, "name") &&
									l(w, "name", v),
								(p(w).source = m.join(
									typeof v == "string" ? v : ""
								))),
							y === i)
						) {
							h ? (y[v] = w) : u(v, w);
							return;
						} else E ? !b && y[v] && (h = !0) : delete y[v];
						h ? (y[v] = w) : l(y, v, w);
					})(Function.prototype, "toString", function () {
						return (
							(typeof this == "function" && f(this).source) ||
							c.call(this)
						);
					});
			},
			"./node_modules/core-js/internals/require-object-coercible.js":
				function (n, r) {
					n.exports = function (o) {
						if (o == null)
							throw TypeError("Can't call method on " + o);
						return o;
					};
				},
			"./node_modules/core-js/internals/set-global.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/hide.js");
				n.exports = function (l, a) {
					try {
						s(i, l, a);
					} catch (u) {
						i[l] = a;
					}
					return a;
				};
			},
			"./node_modules/core-js/internals/set-to-string-tag.js": function (
				n,
				r,
				o
			) {
				var i = o(
						"./node_modules/core-js/internals/object-define-property.js"
					).f,
					s = o("./node_modules/core-js/internals/has.js"),
					l = o(
						"./node_modules/core-js/internals/well-known-symbol.js"
					),
					a = l("toStringTag");
				n.exports = function (u, c, d) {
					u &&
						!s((u = d ? u : u.prototype), a) &&
						i(u, a, { configurable: !0, value: c });
				};
			},
			"./node_modules/core-js/internals/shared-key.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/shared.js"),
					s = o("./node_modules/core-js/internals/uid.js"),
					l = i("keys");
				n.exports = function (a) {
					return l[a] || (l[a] = s(a));
				};
			},
			"./node_modules/core-js/internals/shared.js": function (n, r, o) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/set-global.js"),
					l = o("./node_modules/core-js/internals/is-pure.js"),
					a = "__core-js_shared__",
					u = i[a] || s(a, {});
				(n.exports = function (c, d) {
					return u[c] || (u[c] = d !== void 0 ? d : {});
				})("versions", []).push({
					version: "3.1.3",
					mode: l ? "pure" : "global",
					copyright: " 2019 Denis Pushkarev (zloirock.ru)",
				});
			},
			"./node_modules/core-js/internals/string-at.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = o(
						"./node_modules/core-js/internals/require-object-coercible.js"
					);
				n.exports = function (l, a, u) {
					var c = String(s(l)),
						d = i(a),
						f = c.length,
						p,
						m;
					return d < 0 || d >= f
						? u
							? ""
							: void 0
						: ((p = c.charCodeAt(d)),
						  p < 55296 ||
						  p > 56319 ||
						  d + 1 === f ||
						  (m = c.charCodeAt(d + 1)) < 56320 ||
						  m > 57343
								? u
									? c.charAt(d)
									: p
								: u
								? c.slice(d, d + 2)
								: ((p - 55296) << 10) + (m - 56320) + 65536);
				};
			},
			"./node_modules/core-js/internals/to-absolute-index.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = Math.max,
					l = Math.min;
				n.exports = function (a, u) {
					var c = i(a);
					return c < 0 ? s(c + u, 0) : l(c, u);
				};
			},
			"./node_modules/core-js/internals/to-indexed-object.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/indexed-object.js"),
					s = o(
						"./node_modules/core-js/internals/require-object-coercible.js"
					);
				n.exports = function (l) {
					return i(s(l));
				};
			},
			"./node_modules/core-js/internals/to-integer.js": function (n, r) {
				var o = Math.ceil,
					i = Math.floor;
				n.exports = function (s) {
					return isNaN((s = +s)) ? 0 : (s > 0 ? i : o)(s);
				};
			},
			"./node_modules/core-js/internals/to-length.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/to-integer.js"),
					s = Math.min;
				n.exports = function (l) {
					return l > 0 ? s(i(l), 9007199254740991) : 0;
				};
			},
			"./node_modules/core-js/internals/to-object.js": function (
				n,
				r,
				o
			) {
				var i = o(
					"./node_modules/core-js/internals/require-object-coercible.js"
				);
				n.exports = function (s) {
					return Object(i(s));
				};
			},
			"./node_modules/core-js/internals/to-primitive.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/is-object.js");
				n.exports = function (s, l) {
					if (!i(s)) return s;
					var a, u;
					if (
						(l &&
							typeof (a = s.toString) == "function" &&
							!i((u = a.call(s)))) ||
						(typeof (a = s.valueOf) == "function" &&
							!i((u = a.call(s)))) ||
						(!l &&
							typeof (a = s.toString) == "function" &&
							!i((u = a.call(s))))
					)
						return u;
					throw TypeError("Can't convert object to primitive value");
				};
			},
			"./node_modules/core-js/internals/uid.js": function (n, r) {
				var o = 0,
					i = Math.random();
				n.exports = function (s) {
					return "Symbol(".concat(
						s === void 0 ? "" : s,
						")_",
						(++o + i).toString(36)
					);
				};
			},
			"./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":
				function (n, r, o) {
					var i = o("./node_modules/core-js/internals/is-object.js"),
						s = o("./node_modules/core-js/internals/an-object.js");
					n.exports = function (l, a) {
						if ((s(l), !i(a) && a !== null))
							throw TypeError(
								"Can't set " + String(a) + " as a prototype"
							);
					};
				},
			"./node_modules/core-js/internals/well-known-symbol.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/global.js"),
					s = o("./node_modules/core-js/internals/shared.js"),
					l = o("./node_modules/core-js/internals/uid.js"),
					a = o("./node_modules/core-js/internals/native-symbol.js"),
					u = i.Symbol,
					c = s("wks");
				n.exports = function (d) {
					return (
						c[d] ||
						(c[d] = (a && u[d]) || (a ? u : l)("Symbol." + d))
					);
				};
			},
			"./node_modules/core-js/modules/es.array.from.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/export.js"),
					s = o("./node_modules/core-js/internals/array-from.js"),
					l = o(
						"./node_modules/core-js/internals/check-correctness-of-iteration.js"
					),
					a = !l(function (u) {
						Array.from(u);
					});
				i({ target: "Array", stat: !0, forced: a }, { from: s });
			},
			"./node_modules/core-js/modules/es.string.iterator.js": function (
				n,
				r,
				o
			) {
				var i = o("./node_modules/core-js/internals/string-at.js"),
					s = o("./node_modules/core-js/internals/internal-state.js"),
					l = o(
						"./node_modules/core-js/internals/define-iterator.js"
					),
					a = "String Iterator",
					u = s.set,
					c = s.getterFor(a);
				l(
					String,
					"String",
					function (d) {
						u(this, { type: a, string: String(d), index: 0 });
					},
					function () {
						var f = c(this),
							p = f.string,
							m = f.index,
							y;
						return m >= p.length
							? { value: void 0, done: !0 }
							: ((y = i(p, m, !0)),
							  (f.index += y.length),
							  { value: y, done: !1 });
					}
				);
			},
			"./node_modules/webpack/buildin/global.js": function (n, r) {
				var o;
				o = (function () {
					return this;
				})();
				try {
					o = o || Function("return this")() || (0, eval)("this");
				} catch (i) {
					typeof window == "object" && (o = window);
				}
				n.exports = o;
			},
			"./src/default-attrs.json": function (n) {
				n.exports = {
					xmlns: "http://www.w3.org/2000/svg",
					width: 24,
					height: 24,
					viewBox: "0 0 24 24",
					fill: "none",
					stroke: "currentColor",
					"stroke-width": 2,
					"stroke-linecap": "round",
					"stroke-linejoin": "round",
				};
			},
			"./src/icon.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i =
						Object.assign ||
						function (y) {
							for (var v = 1; v < arguments.length; v++) {
								var w = arguments[v];
								for (var S in w)
									Object.prototype.hasOwnProperty.call(
										w,
										S
									) && (y[S] = w[S]);
							}
							return y;
						},
					s = (function () {
						function y(v, w) {
							for (var S = 0; S < w.length; S++) {
								var E = w[S];
								(E.enumerable = E.enumerable || !1),
									(E.configurable = !0),
									"value" in E && (E.writable = !0),
									Object.defineProperty(v, E.key, E);
							}
						}
						return function (v, w, S) {
							return w && y(v.prototype, w), S && y(v, S), v;
						};
					})(),
					l = o("./node_modules/classnames/dedupe.js"),
					a = d(l),
					u = o("./src/default-attrs.json"),
					c = d(u);
				function d(y) {
					return y && y.__esModule ? y : { default: y };
				}
				function f(y, v) {
					if (!(y instanceof v))
						throw new TypeError(
							"Cannot call a class as a function"
						);
				}
				var p = (function () {
					function y(v, w) {
						var S =
							arguments.length > 2 && arguments[2] !== void 0
								? arguments[2]
								: [];
						f(this, y),
							(this.name = v),
							(this.contents = w),
							(this.tags = S),
							(this.attrs = i({}, c.default, {
								class: "feather feather-" + v,
							}));
					}
					return (
						s(y, [
							{
								key: "toSvg",
								value: function () {
									var w =
											arguments.length > 0 &&
											arguments[0] !== void 0
												? arguments[0]
												: {},
										S = i({}, this.attrs, w, {
											class: (0, a.default)(
												this.attrs.class,
												w.class
											),
										});
									return (
										"<svg " +
										m(S) +
										">" +
										this.contents +
										"</svg>"
									);
								},
							},
							{
								key: "toString",
								value: function () {
									return this.contents;
								},
							},
						]),
						y
					);
				})();
				function m(y) {
					return Object.keys(y)
						.map(function (v) {
							return v + '="' + y[v] + '"';
						})
						.join(" ");
				}
				r.default = p;
			},
			"./src/icons.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i = o("./src/icon.js"),
					s = d(i),
					l = o("./dist/icons.json"),
					a = d(l),
					u = o("./src/tags.json"),
					c = d(u);
				function d(f) {
					return f && f.__esModule ? f : { default: f };
				}
				r.default = Object.keys(a.default)
					.map(function (f) {
						return new s.default(f, a.default[f], c.default[f]);
					})
					.reduce(function (f, p) {
						return (f[p.name] = p), f;
					}, {});
			},
			"./src/index.js": function (n, r, o) {
				var i = o("./src/icons.js"),
					s = d(i),
					l = o("./src/to-svg.js"),
					a = d(l),
					u = o("./src/replace.js"),
					c = d(u);
				function d(f) {
					return f && f.__esModule ? f : { default: f };
				}
				n.exports = {
					icons: s.default,
					toSvg: a.default,
					replace: c.default,
				};
			},
			"./src/replace.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i =
						Object.assign ||
						function (m) {
							for (var y = 1; y < arguments.length; y++) {
								var v = arguments[y];
								for (var w in v)
									Object.prototype.hasOwnProperty.call(
										v,
										w
									) && (m[w] = v[w]);
							}
							return m;
						},
					s = o("./node_modules/classnames/dedupe.js"),
					l = c(s),
					a = o("./src/icons.js"),
					u = c(a);
				function c(m) {
					return m && m.__esModule ? m : { default: m };
				}
				function d() {
					var m =
						arguments.length > 0 && arguments[0] !== void 0
							? arguments[0]
							: {};
					if (typeof document == "undefined")
						throw new Error(
							"`feather.replace()` only works in a browser environment."
						);
					var y = document.querySelectorAll("[data-feather]");
					Array.from(y).forEach(function (v) {
						return f(v, m);
					});
				}
				function f(m) {
					var y =
							arguments.length > 1 && arguments[1] !== void 0
								? arguments[1]
								: {},
						v = p(m),
						w = v["data-feather"];
					delete v["data-feather"];
					var S = u.default[w].toSvg(
							i({}, y, v, {
								class: (0, l.default)(y.class, v.class),
							})
						),
						E = new DOMParser().parseFromString(S, "image/svg+xml"),
						h = E.querySelector("svg");
					m.parentNode.replaceChild(h, m);
				}
				function p(m) {
					return Array.from(m.attributes).reduce(function (y, v) {
						return (y[v.name] = v.value), y;
					}, {});
				}
				r.default = d;
			},
			"./src/tags.json": function (n) {
				n.exports = {
					activity: ["pulse", "health", "action", "motion"],
					airplay: ["stream", "cast", "mirroring"],
					"alert-circle": ["warning", "alert", "danger"],
					"alert-octagon": ["warning", "alert", "danger"],
					"alert-triangle": ["warning", "alert", "danger"],
					"align-center": ["text alignment", "center"],
					"align-justify": ["text alignment", "justified"],
					"align-left": ["text alignment", "left"],
					"align-right": ["text alignment", "right"],
					anchor: [],
					archive: ["index", "box"],
					"at-sign": ["mention", "at", "email", "message"],
					award: ["achievement", "badge"],
					aperture: ["camera", "photo"],
					"bar-chart": ["statistics", "diagram", "graph"],
					"bar-chart-2": ["statistics", "diagram", "graph"],
					battery: ["power", "electricity"],
					"battery-charging": ["power", "electricity"],
					bell: ["alarm", "notification", "sound"],
					"bell-off": ["alarm", "notification", "silent"],
					bluetooth: ["wireless"],
					"book-open": ["read", "library"],
					book: [
						"read",
						"dictionary",
						"booklet",
						"magazine",
						"library",
					],
					bookmark: ["read", "clip", "marker", "tag"],
					box: ["cube"],
					briefcase: ["work", "bag", "baggage", "folder"],
					calendar: ["date"],
					camera: ["photo"],
					cast: ["chromecast", "airplay"],
					"chevron-down": ["expand"],
					"chevron-up": ["collapse"],
					circle: ["off", "zero", "record"],
					clipboard: ["copy"],
					clock: ["time", "watch", "alarm"],
					"cloud-drizzle": ["weather", "shower"],
					"cloud-lightning": ["weather", "bolt"],
					"cloud-rain": ["weather"],
					"cloud-snow": ["weather", "blizzard"],
					cloud: ["weather"],
					codepen: ["logo"],
					codesandbox: ["logo"],
					code: ["source", "programming"],
					coffee: [
						"drink",
						"cup",
						"mug",
						"tea",
						"cafe",
						"hot",
						"beverage",
					],
					columns: ["layout"],
					command: ["keyboard", "cmd", "terminal", "prompt"],
					compass: ["navigation", "safari", "travel", "direction"],
					copy: ["clone", "duplicate"],
					"corner-down-left": ["arrow", "return"],
					"corner-down-right": ["arrow"],
					"corner-left-down": ["arrow"],
					"corner-left-up": ["arrow"],
					"corner-right-down": ["arrow"],
					"corner-right-up": ["arrow"],
					"corner-up-left": ["arrow"],
					"corner-up-right": ["arrow"],
					cpu: ["processor", "technology"],
					"credit-card": ["purchase", "payment", "cc"],
					crop: ["photo", "image"],
					crosshair: ["aim", "target"],
					database: ["storage", "memory"],
					delete: ["remove"],
					disc: ["album", "cd", "dvd", "music"],
					"dollar-sign": ["currency", "money", "payment"],
					droplet: ["water"],
					edit: ["pencil", "change"],
					"edit-2": ["pencil", "change"],
					"edit-3": ["pencil", "change"],
					eye: ["view", "watch"],
					"eye-off": ["view", "watch", "hide", "hidden"],
					"external-link": ["outbound"],
					facebook: ["logo", "social"],
					"fast-forward": ["music"],
					figma: ["logo", "design", "tool"],
					"file-minus": ["delete", "remove", "erase"],
					"file-plus": ["add", "create", "new"],
					"file-text": ["data", "txt", "pdf"],
					film: ["movie", "video"],
					filter: ["funnel", "hopper"],
					flag: ["report"],
					"folder-minus": ["directory"],
					"folder-plus": ["directory"],
					folder: ["directory"],
					framer: ["logo", "design", "tool"],
					frown: ["emoji", "face", "bad", "sad", "emotion"],
					gift: ["present", "box", "birthday", "party"],
					"git-branch": ["code", "version control"],
					"git-commit": ["code", "version control"],
					"git-merge": ["code", "version control"],
					"git-pull-request": ["code", "version control"],
					github: ["logo", "version control"],
					gitlab: ["logo", "version control"],
					globe: ["world", "browser", "language", "translate"],
					"hard-drive": ["computer", "server", "memory", "data"],
					hash: ["hashtag", "number", "pound"],
					headphones: ["music", "audio", "sound"],
					heart: ["like", "love", "emotion"],
					"help-circle": ["question mark"],
					hexagon: ["shape", "node.js", "logo"],
					home: ["house", "living"],
					image: ["picture"],
					inbox: ["email"],
					instagram: ["logo", "camera"],
					key: ["password", "login", "authentication", "secure"],
					layers: ["stack"],
					layout: ["window", "webpage"],
					"life-buoy": ["help", "life ring", "support"],
					link: ["chain", "url"],
					"link-2": ["chain", "url"],
					linkedin: ["logo", "social media"],
					list: ["options"],
					lock: ["security", "password", "secure"],
					"log-in": ["sign in", "arrow", "enter"],
					"log-out": ["sign out", "arrow", "exit"],
					mail: ["email", "message"],
					"map-pin": ["location", "navigation", "travel", "marker"],
					map: ["location", "navigation", "travel"],
					maximize: ["fullscreen"],
					"maximize-2": ["fullscreen", "arrows", "expand"],
					meh: ["emoji", "face", "neutral", "emotion"],
					menu: ["bars", "navigation", "hamburger"],
					"message-circle": ["comment", "chat"],
					"message-square": ["comment", "chat"],
					"mic-off": ["record", "sound", "mute"],
					mic: ["record", "sound", "listen"],
					minimize: ["exit fullscreen", "close"],
					"minimize-2": ["exit fullscreen", "arrows", "close"],
					minus: ["subtract"],
					monitor: ["tv", "screen", "display"],
					moon: ["dark", "night"],
					"more-horizontal": ["ellipsis"],
					"more-vertical": ["ellipsis"],
					"mouse-pointer": ["arrow", "cursor"],
					move: ["arrows"],
					music: ["note"],
					navigation: ["location", "travel"],
					"navigation-2": ["location", "travel"],
					octagon: ["stop"],
					package: ["box", "container"],
					paperclip: ["attachment"],
					pause: ["music", "stop"],
					"pause-circle": ["music", "audio", "stop"],
					"pen-tool": ["vector", "drawing"],
					percent: ["discount"],
					"phone-call": ["ring"],
					"phone-forwarded": ["call"],
					"phone-incoming": ["call"],
					"phone-missed": ["call"],
					"phone-off": ["call", "mute"],
					"phone-outgoing": ["call"],
					phone: ["call"],
					play: ["music", "start"],
					"pie-chart": ["statistics", "diagram"],
					"play-circle": ["music", "start"],
					plus: ["add", "new"],
					"plus-circle": ["add", "new"],
					"plus-square": ["add", "new"],
					pocket: ["logo", "save"],
					power: ["on", "off"],
					printer: ["fax", "office", "device"],
					radio: ["signal"],
					"refresh-cw": ["synchronise", "arrows"],
					"refresh-ccw": ["arrows"],
					repeat: ["loop", "arrows"],
					rewind: ["music"],
					"rotate-ccw": ["arrow"],
					"rotate-cw": ["arrow"],
					rss: ["feed", "subscribe"],
					save: ["floppy disk"],
					scissors: ["cut"],
					search: ["find", "magnifier", "magnifying glass"],
					send: [
						"message",
						"mail",
						"email",
						"paper airplane",
						"paper aeroplane",
					],
					settings: ["cog", "edit", "gear", "preferences"],
					"share-2": ["network", "connections"],
					shield: ["security", "secure"],
					"shield-off": ["security", "insecure"],
					"shopping-bag": ["ecommerce", "cart", "purchase", "store"],
					"shopping-cart": ["ecommerce", "cart", "purchase", "store"],
					shuffle: ["music"],
					"skip-back": ["music"],
					"skip-forward": ["music"],
					slack: ["logo"],
					slash: ["ban", "no"],
					sliders: ["settings", "controls"],
					smartphone: ["cellphone", "device"],
					smile: ["emoji", "face", "happy", "good", "emotion"],
					speaker: ["audio", "music"],
					star: ["bookmark", "favorite", "like"],
					"stop-circle": ["media", "music"],
					sun: ["brightness", "weather", "light"],
					sunrise: ["weather", "time", "morning", "day"],
					sunset: ["weather", "time", "evening", "night"],
					tablet: ["device"],
					tag: ["label"],
					target: ["logo", "bullseye"],
					terminal: ["code", "command line", "prompt"],
					thermometer: [
						"temperature",
						"celsius",
						"fahrenheit",
						"weather",
					],
					"thumbs-down": ["dislike", "bad", "emotion"],
					"thumbs-up": ["like", "good", "emotion"],
					"toggle-left": ["on", "off", "switch"],
					"toggle-right": ["on", "off", "switch"],
					tool: ["settings", "spanner"],
					trash: ["garbage", "delete", "remove", "bin"],
					"trash-2": ["garbage", "delete", "remove", "bin"],
					triangle: ["delta"],
					truck: [
						"delivery",
						"van",
						"shipping",
						"transport",
						"lorry",
					],
					tv: ["television", "stream"],
					twitch: ["logo"],
					twitter: ["logo", "social"],
					type: ["text"],
					umbrella: ["rain", "weather"],
					unlock: ["security"],
					"user-check": ["followed", "subscribed"],
					"user-minus": [
						"delete",
						"remove",
						"unfollow",
						"unsubscribe",
					],
					"user-plus": [
						"new",
						"add",
						"create",
						"follow",
						"subscribe",
					],
					"user-x": [
						"delete",
						"remove",
						"unfollow",
						"unsubscribe",
						"unavailable",
					],
					user: ["person", "account"],
					users: ["group"],
					"video-off": ["camera", "movie", "film"],
					video: ["camera", "movie", "film"],
					voicemail: ["phone"],
					volume: ["music", "sound", "mute"],
					"volume-1": ["music", "sound"],
					"volume-2": ["music", "sound"],
					"volume-x": ["music", "sound", "mute"],
					watch: ["clock", "time"],
					"wifi-off": ["disabled"],
					wifi: ["connection", "signal", "wireless"],
					wind: ["weather", "air"],
					"x-circle": [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					"x-octagon": [
						"delete",
						"stop",
						"alert",
						"warning",
						"times",
						"clear",
					],
					"x-square": [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					x: [
						"cancel",
						"close",
						"delete",
						"remove",
						"times",
						"clear",
					],
					youtube: ["logo", "video", "play"],
					"zap-off": ["flash", "camera", "lightning"],
					zap: ["flash", "camera", "lightning"],
					"zoom-in": ["magnifying glass"],
					"zoom-out": ["magnifying glass"],
				};
			},
			"./src/to-svg.js": function (n, r, o) {
				Object.defineProperty(r, "__esModule", { value: !0 });
				var i = o("./src/icons.js"),
					s = l(i);
				function l(u) {
					return u && u.__esModule ? u : { default: u };
				}
				function a(u) {
					var c =
						arguments.length > 1 && arguments[1] !== void 0
							? arguments[1]
							: {};
					if (
						(console.warn(
							"feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."
						),
						!u)
					)
						throw new Error(
							"The required `key` (icon name) parameter is missing."
						);
					if (!s.default[u])
						throw new Error(
							"No icon matching '" +
								u +
								"'. See the complete list of icons at https://feathericons.com"
						);
					return s.default[u].toSvg(c);
				}
				r.default = a;
			},
			0: function (n, r, o) {
				o("./node_modules/core-js/es/array/from.js"),
					(n.exports = o("./src/index.js"));
			},
		});
	});
})(By);
var jS = By.exports;
const Od = uh(jS),
	Sm = Object.keys(Od.icons),
	_r = {
		props: {
			name: {
				type: String,
				required: !0,
				validator(t) {
					const e = Sm.includes(t);
					return (
						e ||
							(console.groupCollapsed(
								"[frappe-ui] name property for feather-icon must be one of "
							),
							console.dir(Sm),
							console.groupEnd()),
						e
					);
				},
			},
			color: { type: String, default: null },
			strokeWidth: { type: Number, default: 1.5 },
		},
		render() {
			let t = Od.icons[this.name];
			return (
				t || (t = Od.icons.circle),
				Ke(
					"svg",
					pt(
						t.attrs,
						{
							fill: "none",
							stroke: "currentColor",
							color: this.color,
							"stroke-linecap": "round",
							"stroke-linejoin": "round",
							"stroke-width": this.strokeWidth,
							width: null,
							height: null,
							class: [t.attrs.class, "shrink-0"],
							innerHTML: t.contents,
						},
						this.$attrs
					)
				)
			);
		},
	},
	LS = { name: "LoadingIndicator" },
	$S = {
		class: "max-w-xs animate-spin",
		xmlns: "http://www.w3.org/2000/svg",
		fill: "none",
		viewBox: "0 0 24 24",
	},
	BS = V(
		"circle",
		{
			class: "opacity-25",
			cx: "12",
			cy: "12",
			r: "10",
			stroke: "currentColor",
			"stroke-width": "4",
		},
		null,
		-1
	),
	zS = V(
		"path",
		{
			class: "opacity-75",
			fill: "currentColor",
			d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z",
		},
		null,
		-1
	),
	HS = [BS, zS];
function FS(t, e, n, r, o, i) {
	return N(), W("svg", $S, HS);
}
const VS = Le(LS, [["render", FS]]),
	WS = ["disabled", "ariaLabel"],
	Oi = Oe({
		__name: "Button",
		props: {
			theme: { default: "gray" },
			size: { default: "sm" },
			variant: { default: "subtle" },
			label: {},
			icon: {},
			iconLeft: {},
			iconRight: {},
			loading: { type: Boolean, default: !1 },
			loadingText: {},
			disabled: { type: Boolean, default: !1 },
			route: {},
			link: {},
		},
		setup(t) {
			const e = t,
				n = zf(),
				r = G0(),
				o = z(() => {
					let c = {
							gray: "text-white bg-gray-900 hover:bg-gray-800 active:bg-gray-700",
							blue: "text-white bg-blue-500 hover:bg-blue-600 active:bg-blue-700",
							green: "text-white bg-green-600 hover:bg-green-700 active:bg-green-800",
							red: "text-white bg-red-600 hover:bg-red-700 active:bg-red-800",
						}[e.theme],
						d = {
							gray: "text-gray-800 bg-gray-100 hover:bg-gray-200 active:bg-gray-300",
							blue: "text-blue-600 bg-blue-100 hover:bg-blue-200 active:bg-blue-300",
							green: "text-green-800 bg-green-100 hover:bg-green-200 active:bg-green-300",
							red: "text-red-700 bg-red-100 hover:bg-red-200 active:bg-red-300",
						}[e.theme],
						f = {
							gray: "text-gray-800 bg-white border border-gray-300 hover:border-gray-400 active:border-gray-400 active:bg-gray-300",
							blue: "text-blue-600 bg-white border border-blue-300 hover:border-blue-400 active:border-blue-400 active:bg-blue-300",
							green: "text-green-800 bg-white border border-green-400 hover:border-green-500 active:border-green-500 active:bg-green-300",
							red: "text-red-700 bg-white border border-red-300 hover:border-red-400 active:border-red-400 active:bg-red-200",
						}[e.theme],
						p = {
							gray: "text-gray-800 bg-transparent hover:bg-gray-200 active:bg-gray-300",
							blue: "text-blue-600 bg-transparent hover:bg-blue-200 active:bg-blue-300",
							green: "text-green-800 bg-transparent hover:bg-green-200 active:bg-green-300",
							red: "text-red-700 bg-transparent hover:bg-red-200 active:bg-red-300",
						}[e.theme],
						m = {
							gray: "focus-visible:ring focus-visible:ring-gray-400",
							blue: "focus-visible:ring focus-visible:ring-blue-400",
							green: "focus-visible:ring focus-visible:ring-green-400",
							red: "focus-visible:ring focus-visible:ring-red-400",
						}[e.theme],
						y = { subtle: d, solid: c, outline: f, ghost: p }[
							e.variant
						],
						v = `${e.theme}-${e.variant}`,
						w = {
							gray: "bg-gray-100 text-gray-500",
							"gray-outline":
								"bg-gray-100 text-gray-500 border border-gray-300",
							"gray-ghost": "text-gray-500",
							"blue-solid": "bg-blue-300 text-white",
							"blue-subtle": "bg-blue-100 text-blue-400",
							"blue-outline":
								"bg-blue-100 text-blue-400 border border-blue-300",
							"blue-ghost": "text-blue-400",
							green: "bg-green-100 text-green-500",
							"green-outline":
								"bg-green-100 text-green-500 border border-green-400",
							"green-ghost": "text-green-500",
							red: "bg-red-100 text-red-400",
							"red-outline":
								"bg-red-100 text-red-400 border border-red-300",
							"red-ghost": "text-red-400",
						},
						S = w[v] || w[e.theme],
						E = {
							sm: "h-7 text-base px-2 rounded",
							md: "h-8 text-base font-medium px-2.5 rounded",
							lg: "h-10 text-lg font-medium px-3 rounded-md",
							xl: "h-11.5 text-xl font-medium px-3.5 rounded-lg",
							"2xl": "h-13 text-2xl font-medium px-3.5 rounded-xl",
						}[e.size];
					return (
						a.value &&
							(E = {
								sm: "h-7 w-7 rounded",
								md: "h-8 w-8 rounded",
								lg: "h-10 w-10 rounded-md",
								xl: "h-11.5 w-11.5 rounded-lg",
								"2xl": "h-13 w-13 rounded-xl",
							}[e.size]),
						[
							"inline-flex items-center justify-center gap-2 transition-colors focus:outline-none",
							s.value ? S : y,
							m,
							E,
						]
					);
				}),
				i = z(
					() =>
						({
							sm: "h-4",
							md: "h-4.5",
							lg: "h-5",
							xl: "h-6",
							"2xl": "h-6",
						}[e.size])
				),
				s = z(() => e.disabled || e.loading),
				l = z(() => (a.value ? e.label : null)),
				a = z(() => e.icon || n.icon),
				u = () => {
					if (e.route) return r.push(e.route);
					if (e.link) return window.open(e.link, "_blank");
				};
			return (c, d) => (
				N(),
				W(
					"button",
					pt(c.$attrs, {
						class: o.value,
						onClick: u,
						disabled: s.value,
						ariaLabel: l.value,
					}),
					[
						c.loading
							? (N(),
							  Te(
									VS,
									{
										key: 0,
										class: be({
											"h-3 w-3": c.size == "sm",
											"h-[13.5px] w-[13.5px]":
												c.size == "md",
											"h-[15px] w-[15px]": c.size == "lg",
											"h-4.5 w-4.5":
												c.size == "xl" ||
												c.size == "2xl",
										}),
									},
									null,
									8,
									["class"]
							  ))
							: c.$slots.prefix || c.iconLeft
							? xe(c.$slots, "prefix", { key: 1 }, () => [
									c.iconLeft
										? (N(),
										  Te(
												_r,
												{
													key: 0,
													name: c.iconLeft,
													class: be(i.value),
													"aria-hidden": "true",
												},
												null,
												8,
												["name", "class"]
										  ))
										: Re("", !0),
							  ])
							: Re("", !0),
						c.loading && c.loadingText
							? (N(),
							  W(Ne, { key: 2 }, [lr(We(c.loadingText), 1)], 64))
							: a.value && !c.loading
							? (N(),
							  W(
									Ne,
									{ key: 3 },
									[
										c.icon
											? (N(),
											  Te(
													_r,
													{
														key: 0,
														name: c.icon,
														class: be(i.value),
														"aria-label": c.label,
													},
													null,
													8,
													[
														"name",
														"class",
														"aria-label",
													]
											  ))
											: c.$slots.icon
											? xe(c.$slots, "icon", { key: 1 })
											: Re("", !0),
									],
									64
							  ))
							: (N(),
							  W(
									"span",
									{
										key: 4,
										class: be({ "sr-only": a.value }),
									},
									[
										xe(c.$slots, "default", {}, () => [
											lr(We(c.label), 1),
										]),
									],
									2
							  )),
						xe(c.$slots, "suffix", {}, () => [
							c.iconRight
								? (N(),
								  Te(
										_r,
										{
											key: 0,
											name: c.iconRight,
											class: be(i.value),
											"aria-hidden": "true",
										},
										null,
										8,
										["name", "class"]
								  ))
								: Re("", !0),
						]),
					],
					16,
					WS
				)
			);
		},
	}),
	US = {
		name: "Autocomplete",
		props: ["modelValue", "options", "placeholder"],
		emits: ["update:modelValue", "update:query", "change"],
		components: {
			Popover: tl,
			Button: Oi,
			FeatherIcon: _r,
			Combobox: Ck,
			ComboboxInput: Ek,
			ComboboxOptions: Tk,
			ComboboxOption: Ak,
			ComboboxButton: Mk,
		},
		data() {
			return { query: "", showOptions: !1 };
		},
		computed: {
			valuePropPassed() {
				return "value" in this.$attrs;
			},
			selectedValue: {
				get() {
					return this.valuePropPassed
						? this.$attrs.value
						: this.modelValue;
				},
				set(t) {
					(this.query = ""),
						t && (this.showOptions = !1),
						this.$emit(
							this.valuePropPassed
								? "change"
								: "update:modelValue",
							t
						);
				},
			},
			groups() {
				var e;
				return !this.options || this.options.length == 0
					? []
					: ((e = this.options[0]) != null && e.group
							? this.options
							: [{ group: "", items: this.options }]
					  )
							.map((n, r) => ({
								key: r,
								group: n.group,
								hideLabel: n.hideLabel || !1,
								items: this.filterOptions(n.items),
							}))
							.filter((n) => n.items.length > 0);
			},
		},
		watch: {
			query(t) {
				this.$emit("update:query", t);
			},
			showOptions(t) {
				t &&
					this.$nextTick(() => {
						this.$refs.search.el.focus();
					});
			},
		},
		methods: {
			filterOptions(t) {
				return this.query
					? t.filter((e) =>
							[e.label, e.value].some((r) =>
								(r || "")
									.toString()
									.toLowerCase()
									.includes(this.query.toLowerCase())
							)
					  )
					: t;
			},
			displayValue(t) {
				if (typeof t == "string") {
					let n = this.groups
						.flatMap((r) => r.items)
						.find((r) => r.value === t);
					return (n == null ? void 0 : n.label) || t;
				}
				return t == null ? void 0 : t.label;
			},
		},
	},
	KS = { class: "w-full" },
	qS = ["onClick"],
	JS = { class: "flex items-center" },
	GS = {
		key: 0,
		class: "overflow-hidden text-ellipsis whitespace-nowrap text-base leading-5",
	},
	YS = { key: 1, class: "text-base leading-5 text-gray-500" },
	QS = {
		class: "sticky top-0 z-10 flex items-stretch space-x-1.5 bg-white pt-1.5",
	},
	XS = { class: "relative w-full" },
	ZS = { key: 0, class: "px-2.5 py-1.5 text-sm font-medium text-gray-500" },
	e_ = { key: 0, class: "rounded-md px-2.5 py-1.5 text-base text-gray-600" };
function t_(t, e, n, r, o, i) {
	const s = Je("FeatherIcon"),
		l = Je("ComboboxInput"),
		a = Je("ComboboxOption"),
		u = Je("ComboboxOptions"),
		c = Je("Popover"),
		d = Je("Combobox");
	return (
		N(),
		Te(
			d,
			{
				modelValue: i.selectedValue,
				"onUpdate:modelValue":
					e[3] || (e[3] = (f) => (i.selectedValue = f)),
				nullable: "",
			},
			{
				default: Ce(({ open: f }) => [
					ve(
						c,
						{
							class: "w-full",
							show: o.showOptions,
							"onUpdate:show":
								e[2] || (e[2] = (p) => (o.showOptions = p)),
						},
						{
							target: Ce(({ open: p, togglePopover: m }) => [
								xe(
									t.$slots,
									"target",
									Et(Lt({ open: p, togglePopover: m })),
									() => [
										V("div", KS, [
											V(
												"button",
												{
													class: be([
														"flex h-7 w-full items-center justify-between gap-2 rounded bg-gray-100 px-2 py-1 transition-colors hover:bg-gray-200 focus:ring-2 focus:ring-gray-400",
														{ "bg-gray-200": f },
													]),
													onClick: () => m(),
												},
												[
													V("div", JS, [
														xe(t.$slots, "prefix"),
														i.selectedValue
															? (N(),
															  W(
																	"span",
																	GS,
																	We(
																		i.displayValue(
																			i.selectedValue
																		)
																	),
																	1
															  ))
															: (N(),
															  W(
																	"span",
																	YS,
																	We(
																		n.placeholder ||
																			""
																	),
																	1
															  )),
													]),
													ve(s, {
														name: "chevron-down",
														class: "h-4 w-4 text-gray-600",
														"aria-hidden": "true",
													}),
												],
												10,
												qS
											),
										]),
									]
								),
							]),
							body: Ce(({ isOpen: p }) => [
								ca(
									V(
										"div",
										null,
										[
											ve(
												u,
												{
													class: "mt-1 max-h-[15rem] overflow-y-auto rounded-lg bg-white px-1.5 pb-1.5 shadow-2xl",
													static: "",
												},
												{
													default: Ce(() => [
														V("div", QS, [
															V("div", XS, [
																ve(
																	l,
																	{
																		ref: "search",
																		class: "form-input w-full",
																		type: "text",
																		onChange:
																			e[0] ||
																			(e[0] =
																				(
																					m
																				) => {
																					o.query =
																						m.target.value;
																				}),
																		value: o.query,
																		autocomplete:
																			"off",
																		placeholder:
																			"Search",
																	},
																	null,
																	8,
																	["value"]
																),
																V(
																	"button",
																	{
																		class: "absolute right-0 inline-flex h-7 w-7 items-center justify-center",
																		onClick:
																			e[1] ||
																			(e[1] =
																				(
																					m
																				) =>
																					(i.selectedValue =
																						null)),
																	},
																	[
																		ve(s, {
																			name: "x",
																			class: "w-4",
																		}),
																	]
																),
															]),
														]),
														(N(!0),
														W(
															Ne,
															null,
															Rt(i.groups, (m) =>
																ca(
																	(N(),
																	W(
																		"div",
																		{
																			class: "mt-1.5",
																			key: m.key,
																		},
																		[
																			m.group &&
																			!m.hideLabel
																				? (N(),
																				  W(
																						"div",
																						ZS,
																						We(
																							m.group
																						),
																						1
																				  ))
																				: Re(
																						"",
																						!0
																				  ),
																			(N(
																				!0
																			),
																			W(
																				Ne,
																				null,
																				Rt(
																					m.items,
																					(
																						y
																					) => (
																						N(),
																						Te(
																							a,
																							{
																								as: "template",
																								key: y.value,
																								value: y,
																							},
																							{
																								default:
																									Ce(
																										({
																											active: v,
																											selected:
																												w,
																										}) => [
																											V(
																												"li",
																												{
																													class: be(
																														[
																															"flex items-center rounded px-2.5 py-1.5 text-base",
																															{
																																"bg-gray-100":
																																	v,
																															},
																														]
																													),
																												},
																												[
																													xe(
																														t.$slots,
																														"item-prefix",
																														Et(
																															Lt(
																																{
																																	active: v,
																																	selected:
																																		w,
																																	option: y,
																																}
																															)
																														)
																													),
																													lr(
																														" " +
																															We(
																																y.label
																															),
																														1
																													),
																												],
																												2
																											),
																										]
																									),
																								_: 2,
																							},
																							1032,
																							[
																								"value",
																							]
																						)
																					)
																				),
																				128
																			)),
																		]
																	)),
																	[
																		[
																			ma,
																			m
																				.items
																				.length >
																				0,
																		],
																	]
																)
															),
															128
														)),
														i.groups.length == 0
															? (N(),
															  W(
																	"li",
																	e_,
																	" No results found "
															  ))
															: Re("", !0),
													]),
													_: 3,
												}
											),
										],
										512
									),
									[[ma, p]]
								),
							]),
							_: 2,
						},
						1032,
						["show"]
					),
				]),
				_: 3,
			},
			8,
			["modelValue"]
		)
	);
}
const n_ = Le(US, [["render", t_]]);
var zy = { exports: {} },
	Hy = { exports: {} };
(function () {
	var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
		e = {
			rotl: function (n, r) {
				return (n << r) | (n >>> (32 - r));
			},
			rotr: function (n, r) {
				return (n << (32 - r)) | (n >>> r);
			},
			endian: function (n) {
				if (n.constructor == Number)
					return (
						(e.rotl(n, 8) & 16711935) | (e.rotl(n, 24) & 4278255360)
					);
				for (var r = 0; r < n.length; r++) n[r] = e.endian(n[r]);
				return n;
			},
			randomBytes: function (n) {
				for (var r = []; n > 0; n--)
					r.push(Math.floor(Math.random() * 256));
				return r;
			},
			bytesToWords: function (n) {
				for (var r = [], o = 0, i = 0; o < n.length; o++, i += 8)
					r[i >>> 5] |= n[o] << (24 - (i % 32));
				return r;
			},
			wordsToBytes: function (n) {
				for (var r = [], o = 0; o < n.length * 32; o += 8)
					r.push((n[o >>> 5] >>> (24 - (o % 32))) & 255);
				return r;
			},
			bytesToHex: function (n) {
				for (var r = [], o = 0; o < n.length; o++)
					r.push((n[o] >>> 4).toString(16)),
						r.push((n[o] & 15).toString(16));
				return r.join("");
			},
			hexToBytes: function (n) {
				for (var r = [], o = 0; o < n.length; o += 2)
					r.push(parseInt(n.substr(o, 2), 16));
				return r;
			},
			bytesToBase64: function (n) {
				for (var r = [], o = 0; o < n.length; o += 3)
					for (
						var i = (n[o] << 16) | (n[o + 1] << 8) | n[o + 2],
							s = 0;
						s < 4;
						s++
					)
						o * 8 + s * 6 <= n.length * 8
							? r.push(t.charAt((i >>> (6 * (3 - s))) & 63))
							: r.push("=");
				return r.join("");
			},
			base64ToBytes: function (n) {
				n = n.replace(/[^A-Z0-9+\/]/gi, "");
				for (var r = [], o = 0, i = 0; o < n.length; i = ++o % 4)
					i != 0 &&
						r.push(
							((t.indexOf(n.charAt(o - 1)) &
								(Math.pow(2, -2 * i + 8) - 1)) <<
								(i * 2)) |
								(t.indexOf(n.charAt(o)) >>> (6 - i * 2))
						);
				return r;
			},
		};
	Hy.exports = e;
})();
var r_ = Hy.exports,
	Rd = {
		utf8: {
			stringToBytes: function (t) {
				return Rd.bin.stringToBytes(unescape(encodeURIComponent(t)));
			},
			bytesToString: function (t) {
				return decodeURIComponent(escape(Rd.bin.bytesToString(t)));
			},
		},
		bin: {
			stringToBytes: function (t) {
				for (var e = [], n = 0; n < t.length; n++)
					e.push(t.charCodeAt(n) & 255);
				return e;
			},
			bytesToString: function (t) {
				for (var e = [], n = 0; n < t.length; n++)
					e.push(String.fromCharCode(t[n]));
				return e.join("");
			},
		},
	},
	_m = Rd;
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var o_ = function (t) {
	return t != null && (Fy(t) || i_(t) || !!t._isBuffer);
};
function Fy(t) {
	return (
		!!t.constructor &&
		typeof t.constructor.isBuffer == "function" &&
		t.constructor.isBuffer(t)
	);
}
function i_(t) {
	return (
		typeof t.readFloatLE == "function" &&
		typeof t.slice == "function" &&
		Fy(t.slice(0, 0))
	);
}
(function () {
	var t = r_,
		e = _m.utf8,
		n = o_,
		r = _m.bin,
		o = function (i, s) {
			i.constructor == String
				? s && s.encoding === "binary"
					? (i = r.stringToBytes(i))
					: (i = e.stringToBytes(i))
				: n(i)
				? (i = Array.prototype.slice.call(i, 0))
				: !Array.isArray(i) &&
				  i.constructor !== Uint8Array &&
				  (i = i.toString());
			for (
				var l = t.bytesToWords(i),
					a = i.length * 8,
					u = 1732584193,
					c = -271733879,
					d = -1732584194,
					f = 271733878,
					p = 0;
				p < l.length;
				p++
			)
				l[p] =
					(((l[p] << 8) | (l[p] >>> 24)) & 16711935) |
					(((l[p] << 24) | (l[p] >>> 8)) & 4278255360);
			(l[a >>> 5] |= 128 << a % 32),
				(l[(((a + 64) >>> 9) << 4) + 14] = a);
			for (
				var m = o._ff, y = o._gg, v = o._hh, w = o._ii, p = 0;
				p < l.length;
				p += 16
			) {
				var S = u,
					E = c,
					h = d,
					b = f;
				(u = m(u, c, d, f, l[p + 0], 7, -680876936)),
					(f = m(f, u, c, d, l[p + 1], 12, -389564586)),
					(d = m(d, f, u, c, l[p + 2], 17, 606105819)),
					(c = m(c, d, f, u, l[p + 3], 22, -1044525330)),
					(u = m(u, c, d, f, l[p + 4], 7, -176418897)),
					(f = m(f, u, c, d, l[p + 5], 12, 1200080426)),
					(d = m(d, f, u, c, l[p + 6], 17, -1473231341)),
					(c = m(c, d, f, u, l[p + 7], 22, -45705983)),
					(u = m(u, c, d, f, l[p + 8], 7, 1770035416)),
					(f = m(f, u, c, d, l[p + 9], 12, -1958414417)),
					(d = m(d, f, u, c, l[p + 10], 17, -42063)),
					(c = m(c, d, f, u, l[p + 11], 22, -1990404162)),
					(u = m(u, c, d, f, l[p + 12], 7, 1804603682)),
					(f = m(f, u, c, d, l[p + 13], 12, -40341101)),
					(d = m(d, f, u, c, l[p + 14], 17, -1502002290)),
					(c = m(c, d, f, u, l[p + 15], 22, 1236535329)),
					(u = y(u, c, d, f, l[p + 1], 5, -165796510)),
					(f = y(f, u, c, d, l[p + 6], 9, -1069501632)),
					(d = y(d, f, u, c, l[p + 11], 14, 643717713)),
					(c = y(c, d, f, u, l[p + 0], 20, -373897302)),
					(u = y(u, c, d, f, l[p + 5], 5, -701558691)),
					(f = y(f, u, c, d, l[p + 10], 9, 38016083)),
					(d = y(d, f, u, c, l[p + 15], 14, -660478335)),
					(c = y(c, d, f, u, l[p + 4], 20, -405537848)),
					(u = y(u, c, d, f, l[p + 9], 5, 568446438)),
					(f = y(f, u, c, d, l[p + 14], 9, -1019803690)),
					(d = y(d, f, u, c, l[p + 3], 14, -187363961)),
					(c = y(c, d, f, u, l[p + 8], 20, 1163531501)),
					(u = y(u, c, d, f, l[p + 13], 5, -1444681467)),
					(f = y(f, u, c, d, l[p + 2], 9, -51403784)),
					(d = y(d, f, u, c, l[p + 7], 14, 1735328473)),
					(c = y(c, d, f, u, l[p + 12], 20, -1926607734)),
					(u = v(u, c, d, f, l[p + 5], 4, -378558)),
					(f = v(f, u, c, d, l[p + 8], 11, -2022574463)),
					(d = v(d, f, u, c, l[p + 11], 16, 1839030562)),
					(c = v(c, d, f, u, l[p + 14], 23, -35309556)),
					(u = v(u, c, d, f, l[p + 1], 4, -1530992060)),
					(f = v(f, u, c, d, l[p + 4], 11, 1272893353)),
					(d = v(d, f, u, c, l[p + 7], 16, -155497632)),
					(c = v(c, d, f, u, l[p + 10], 23, -1094730640)),
					(u = v(u, c, d, f, l[p + 13], 4, 681279174)),
					(f = v(f, u, c, d, l[p + 0], 11, -358537222)),
					(d = v(d, f, u, c, l[p + 3], 16, -722521979)),
					(c = v(c, d, f, u, l[p + 6], 23, 76029189)),
					(u = v(u, c, d, f, l[p + 9], 4, -640364487)),
					(f = v(f, u, c, d, l[p + 12], 11, -421815835)),
					(d = v(d, f, u, c, l[p + 15], 16, 530742520)),
					(c = v(c, d, f, u, l[p + 2], 23, -995338651)),
					(u = w(u, c, d, f, l[p + 0], 6, -198630844)),
					(f = w(f, u, c, d, l[p + 7], 10, 1126891415)),
					(d = w(d, f, u, c, l[p + 14], 15, -1416354905)),
					(c = w(c, d, f, u, l[p + 5], 21, -57434055)),
					(u = w(u, c, d, f, l[p + 12], 6, 1700485571)),
					(f = w(f, u, c, d, l[p + 3], 10, -1894986606)),
					(d = w(d, f, u, c, l[p + 10], 15, -1051523)),
					(c = w(c, d, f, u, l[p + 1], 21, -2054922799)),
					(u = w(u, c, d, f, l[p + 8], 6, 1873313359)),
					(f = w(f, u, c, d, l[p + 15], 10, -30611744)),
					(d = w(d, f, u, c, l[p + 6], 15, -1560198380)),
					(c = w(c, d, f, u, l[p + 13], 21, 1309151649)),
					(u = w(u, c, d, f, l[p + 4], 6, -145523070)),
					(f = w(f, u, c, d, l[p + 11], 10, -1120210379)),
					(d = w(d, f, u, c, l[p + 2], 15, 718787259)),
					(c = w(c, d, f, u, l[p + 9], 21, -343485551)),
					(u = (u + S) >>> 0),
					(c = (c + E) >>> 0),
					(d = (d + h) >>> 0),
					(f = (f + b) >>> 0);
			}
			return t.endian([u, c, d, f]);
		};
	(o._ff = function (i, s, l, a, u, c, d) {
		var f = i + ((s & l) | (~s & a)) + (u >>> 0) + d;
		return ((f << c) | (f >>> (32 - c))) + s;
	}),
		(o._gg = function (i, s, l, a, u, c, d) {
			var f = i + ((s & a) | (l & ~a)) + (u >>> 0) + d;
			return ((f << c) | (f >>> (32 - c))) + s;
		}),
		(o._hh = function (i, s, l, a, u, c, d) {
			var f = i + (s ^ l ^ a) + (u >>> 0) + d;
			return ((f << c) | (f >>> (32 - c))) + s;
		}),
		(o._ii = function (i, s, l, a, u, c, d) {
			var f = i + (l ^ (s | ~a)) + (u >>> 0) + d;
			return ((f << c) | (f >>> (32 - c))) + s;
		}),
		(o._blocksize = 16),
		(o._digestsize = 16),
		(zy.exports = function (i, s) {
			if (i == null) throw new Error("Illegal argument " + i);
			var l = t.wordsToBytes(o(i, s));
			return s && s.asBytes
				? l
				: s && s.asString
				? r.bytesToString(l)
				: t.bytesToHex(l);
		});
})();
var s_ = zy.exports;
const l_ = uh(s_),
	a_ = ["src"],
	TL = Oe({
		__name: "Avatar",
		props: {
			image: {},
			label: {},
			size: { default: "md" },
			shape: { default: "circle" },
		},
		setup(t) {
			const e = t,
				n = z(
					() =>
						({
							circle: "rounded-full",
							square: {
								xs: "rounded-[4px]",
								sm: "rounded-[5px]",
								md: "rounded-[5px]",
								lg: "rounded-[6px]",
								xl: "rounded-[6px]",
								"2xl": "rounded-[8px]",
								"3xl": "rounded-[10px]",
							}[e.size],
						}[e.shape])
				),
				r = z(
					() =>
						({
							xs: "w-4 h-4",
							sm: "w-5 h-5",
							md: "w-6 h-6",
							lg: "w-7 h-7",
							xl: "w-8 h-8",
							"2xl": "w-10 h-10",
							"3xl": "w-11.5 h-11.5",
						}[e.size])
				),
				o = z(() => [
					"font-medium",
					{
						xs: "text-2xs",
						sm: "text-sm",
						md: "text-base",
						lg: "text-base",
						xl: "text-lg",
						"2xl": "text-xl",
						"3xl": "text-2xl",
					}[e.size],
				]),
				i = z(
					() =>
						({
							xs: "-mr-[.1rem] -mb-[.1rem] h-2 w-2",
							sm: "-mr-[.1rem] -mb-[.1rem] h-[9px] w-[9px]",
							md: "-mr-[.1rem] -mb-[.1rem] h-2.5 w-2.5",
							lg: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
							xl: "-mr-[.1rem] -mb-[.1rem] h-3 w-3",
							"2xl": "-mr-[.1rem] -mb-[.1rem] h-3.5 w-3.5",
							"3xl": "-mr-[.2rem] -mb-[.2rem] h-4 w-4",
						}[e.size])
				),
				s = z(
					() =>
						({
							xs: "h-1 w-1",
							sm: "h-[5px] w-[5px]",
							md: "h-1.5 w-1.5",
							lg: "h-2 w-2",
							xl: "h-2 w-2",
							"2xl": "h-2.5 w-2.5",
							"3xl": "h-3 w-3",
						}[e.size])
				),
				l = z(
					() =>
						({
							xs: "h-2.5 w-2.5",
							sm: "h-3 w-3",
							md: "h-4 w-4",
							lg: "h-4 w-4",
							xl: "h-4 w-4",
							"2xl": "h-5 w-5",
							"3xl": "h-5 w-5",
						}[e.size])
				),
				a = z(() => {
					if (!e.label) return;
					let u = [
							"gray",
							"blue",
							"green",
							"red",
							"yellow",
							"orange",
						],
						c = Math.floor(
							(parseInt(l_(e.label).substr(4, 2), 16) + 1) / 5.33
						),
						d = u[c % 6];
					return `bg-${d}-100 text-${d}-700`;
				});
			return (u, c) => (
				N(),
				W(
					"div",
					{
						class: be([
							"relative inline-block shrink-0",
							[r.value, n.value],
						]),
					},
					[
						u.image
							? (N(),
							  W(
									"img",
									{
										key: 0,
										src: u.image,
										class: be([
											n.value,
											"h-full w-full object-cover",
										]),
									},
									null,
									10,
									a_
							  ))
							: (N(),
							  W(
									"div",
									{
										key: 1,
										class: be([
											"flex h-full w-full items-center justify-center uppercase",
											[o.value, n.value, a.value],
										]),
									},
									[
										u.$slots.default
											? (N(),
											  W(
													"div",
													{
														key: 0,
														class: be(l.value),
													},
													[xe(u.$slots, "default")],
													2
											  ))
											: (N(),
											  W(
													Ne,
													{ key: 1 },
													[
														lr(
															We(
																u.label &&
																	u.label[0]
															),
															1
														),
													],
													64
											  )),
									],
									2
							  )),
						u.$slots.indicator
							? (N(),
							  W(
									"div",
									{
										key: 2,
										class: be([
											"absolute bottom-0 right-0 grid place-items-center rounded-full bg-white",
											i.value,
										]),
									},
									[
										V(
											"div",
											{ class: be(s.value) },
											[xe(u.$slots, "indicator")],
											2
										),
									],
									2
							  ))
							: Re("", !0),
					],
					2
				)
			);
		},
	}),
	AL = Oe({
		__name: "Badge",
		props: {
			theme: { default: "gray" },
			size: { default: "md" },
			variant: { default: "subtle" },
			label: {},
		},
		setup(t) {
			const e = t,
				n = z(() => {
					let r = {
							gray: "text-white bg-gray-900",
							blue: "text-white bg-blue-500",
							green: "text-white bg-green-600",
							orange: "text-white bg-amber-600",
							red: "text-white bg-red-600",
						}[e.theme],
						o = {
							gray: "text-gray-700 bg-gray-100",
							blue: "text-blue-600 bg-blue-100",
							green: "text-green-800 bg-green-200",
							orange: "text-amber-700 bg-amber-100",
							red: "text-red-600 bg-red-100",
						}[e.theme],
						i = {
							gray: "text-gray-700 bg-white border border-gray-300",
							blue: "text-blue-600 bg-white border border-blue-300",
							green: "text-green-800 bg-white border border-green-300",
							orange: "text-amber-700 bg-white border border-amber-300",
							red: "text-red-600 bg-white border border-red-300",
						}[e.theme],
						s = {
							gray: "text-gray-700 bg-transparent",
							blue: "text-blue-600 bg-transparent",
							green: "text-green-800 bg-transparent",
							orange: "text-amber-700 bg-transparent",
							red: "text-red-600 bg-transparent",
						}[e.theme],
						l = { subtle: o, solid: r, outline: i, ghost: s }[
							e.variant
						],
						a = {
							sm: "h-4 text-xs px-1.5",
							md: "h-5 text-xs px-1.5",
							lg: "h-6 text-sm px-2",
						}[e.size];
					return [l, a];
				});
			return (r, o) => (
				N(),
				W(
					"div",
					{
						class: be([
							"inline-flex select-none items-center gap-1 rounded-full",
							n.value,
						]),
					},
					[
						r.$slots.prefix
							? (N(),
							  W(
									"div",
									{
										key: 0,
										class: be([
											e.size == "lg"
												? "max-h-6"
												: "max-h-4",
										]),
									},
									[xe(r.$slots, "prefix")],
									2
							  ))
							: Re("", !0),
						xe(r.$slots, "default", {}, () => {
							var i;
							return [
								lr(
									We(
										(i = e.label) == null
											? void 0
											: i.toString()
									),
									1
								),
							];
						}),
						r.$slots.suffix
							? (N(),
							  W(
									"div",
									{
										key: 1,
										class: be([
											e.size == "lg"
												? "max-h-6"
												: "max-h-4",
										]),
									},
									[xe(r.$slots, "suffix")],
									2
							  ))
							: Re("", !0),
					],
					2
				)
			);
		},
	});
function Is(t) {
	return N1() ? (D1(t), !0) : !1;
}
function Er(t) {
	return typeof t == "function" ? t() : ne(t);
}
const Pd = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" &&
	globalThis instanceof WorkerGlobalScope;
const u_ = Object.prototype.toString,
	c_ = (t) => u_.call(t) === "[object Object]",
	Id = () => {};
function d_(t, e) {
	function n(...r) {
		return new Promise((o, i) => {
			Promise.resolve(
				t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })
			)
				.then(o)
				.catch(i);
		});
	}
	return n;
}
const Vy = (t) => t();
function f_(t, e = {}) {
	let n,
		r,
		o = Id;
	const i = (l) => {
		clearTimeout(l), o(), (o = Id);
	};
	return (l) => {
		const a = Er(t),
			u = Er(e.maxWait);
		return (
			n && i(n),
			a <= 0 || (u !== void 0 && u <= 0)
				? (r && (i(r), (r = null)), Promise.resolve(l()))
				: new Promise((c, d) => {
						(o = e.rejectOnCancel ? d : c),
							u &&
								!r &&
								(r = setTimeout(() => {
									n && i(n), (r = null), c(l());
								}, u)),
							(n = setTimeout(() => {
								r && i(r), (r = null), c(l());
							}, a));
				  })
		);
	};
}
function h_(t = Vy) {
	const e = Q(!0);
	function n() {
		e.value = !1;
	}
	function r() {
		e.value = !0;
	}
	const o = (...i) => {
		e.value && t(...i);
	};
	return { isActive: yu(e), pause: n, resume: r, eventFilter: o };
}
function p_(t) {
	return t || uo();
}
function Wy(t, e, n = {}) {
	const i = n,
		{ eventFilter: r = Vy } = i,
		o = tt(i, ["eventFilter"]);
	return at(t, d_(r, e), o);
}
function m_(t, e, n = {}) {
	const c = n,
		{ eventFilter: r } = c,
		o = tt(c, ["eventFilter"]),
		{ eventFilter: i, pause: s, resume: l, isActive: a } = h_(r);
	return {
		stop: Wy(t, e, ge(B({}, o), { eventFilter: i })),
		pause: s,
		resume: l,
		isActive: a,
	};
}
function Uy(t, e = !0, n) {
	p_() ? Ze(t, n) : e ? t() : bt(t);
}
function g_(t, e = 1e3, n = {}) {
	const { immediate: r = !0, immediateCallback: o = !1 } = n;
	let i = null;
	const s = Q(!1);
	function l() {
		i && (clearInterval(i), (i = null));
	}
	function a() {
		(s.value = !1), l();
	}
	function u() {
		const c = Er(e);
		c <= 0 || ((s.value = !0), o && t(), l(), (i = setInterval(t, c)));
	}
	if ((r && Pd && u(), Jt(e) || typeof e == "function")) {
		const c = at(e, () => {
			s.value && Pd && u();
		});
		Is(c);
	}
	return Is(a), { isActive: s, pause: a, resume: u };
}
function OL(t, e, n = {}) {
	const s = n,
		{ debounce: r = 0, maxWait: o = void 0 } = s,
		i = tt(s, ["debounce", "maxWait"]);
	return Wy(t, e, ge(B({}, i), { eventFilter: f_(r, { maxWait: o }) }));
}
function y_(t) {
	var e;
	const n = Er(t);
	return (e = n == null ? void 0 : n.$el) != null ? e : n;
}
const Ri = Pd ? window : void 0;
function Nd(...t) {
	let e, n, r, o;
	if (
		(typeof t[0] == "string" || Array.isArray(t[0])
			? (([n, r, o] = t), (e = Ri))
			: ([e, n, r, o] = t),
		!e)
	)
		return Id;
	Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
	const i = [],
		s = () => {
			i.forEach((c) => c()), (i.length = 0);
		},
		l = (c, d, f, p) => (
			c.addEventListener(d, f, p), () => c.removeEventListener(d, f, p)
		),
		a = at(
			() => [y_(e), Er(o)],
			([c, d]) => {
				if ((s(), !c)) return;
				const f = c_(d) ? B({}, d) : d;
				i.push(...n.flatMap((p) => r.map((m) => l(c, p, m, f))));
			},
			{ immediate: !0, flush: "post" }
		),
		u = () => {
			a(), s();
		};
	return Is(u), u;
}
function v_() {
	const t = Q(!1);
	return (
		uo() &&
			Ze(() => {
				t.value = !0;
			}),
		t
	);
}
function b_(t) {
	const e = v_();
	return z(() => (e.value, !!t()));
}
function w_(t, e = {}) {
	const { immediate: n = !0, fpsLimit: r = void 0, window: o = Ri } = e,
		i = Q(!1),
		s = r ? 1e3 / r : null;
	let l = 0,
		a = null;
	function u(f) {
		if (!i.value || !o) return;
		const p = f - (l || f);
		if (s && p < s) {
			a = o.requestAnimationFrame(u);
			return;
		}
		t({ delta: p, timestamp: f }),
			(l = f),
			(a = o.requestAnimationFrame(u));
	}
	function c() {
		!i.value && o && ((i.value = !0), (a = o.requestAnimationFrame(u)));
	}
	function d() {
		(i.value = !1),
			a != null && o && (o.cancelAnimationFrame(a), (a = null));
	}
	return n && c(), Is(d), { isActive: yu(i), pause: d, resume: c };
}
function x_(t, e = {}) {
	const { window: n = Ri } = e,
		r = b_(
			() => n && "matchMedia" in n && typeof n.matchMedia == "function"
		);
	let o;
	const i = Q(!1),
		s = (u) => {
			i.value = u.matches;
		},
		l = () => {
			o &&
				("removeEventListener" in o
					? o.removeEventListener("change", s)
					: o.removeListener(s));
		},
		a = xt(() => {
			r.value &&
				(l(),
				(o = n.matchMedia(Er(t))),
				"addEventListener" in o
					? o.addEventListener("change", s)
					: o.addListener(s),
				(i.value = o.matches));
		});
	return (
		Is(() => {
			a(), l(), (o = void 0);
		}),
		i
	);
}
const _l =
		typeof globalThis != "undefined"
			? globalThis
			: typeof window != "undefined"
			? window
			: typeof global != "undefined"
			? global
			: typeof self != "undefined"
			? self
			: {},
	Cl = "__vueuse_ssr_handlers__",
	k_ = S_();
function S_() {
	return Cl in _l || (_l[Cl] = _l[Cl] || {}), _l[Cl];
}
function __(t, e) {
	return k_[t] || e;
}
function C_(t) {
	return t == null
		? "any"
		: t instanceof Set
		? "set"
		: t instanceof Map
		? "map"
		: t instanceof Date
		? "date"
		: typeof t == "boolean"
		? "boolean"
		: typeof t == "string"
		? "string"
		: typeof t == "object"
		? "object"
		: Number.isNaN(t)
		? "any"
		: "number";
}
const M_ = {
		boolean: { read: (t) => t === "true", write: (t) => String(t) },
		object: { read: (t) => JSON.parse(t), write: (t) => JSON.stringify(t) },
		number: { read: (t) => Number.parseFloat(t), write: (t) => String(t) },
		any: { read: (t) => t, write: (t) => String(t) },
		string: { read: (t) => t, write: (t) => String(t) },
		map: {
			read: (t) => new Map(JSON.parse(t)),
			write: (t) => JSON.stringify(Array.from(t.entries())),
		},
		set: {
			read: (t) => new Set(JSON.parse(t)),
			write: (t) => JSON.stringify(Array.from(t)),
		},
		date: { read: (t) => new Date(t), write: (t) => t.toISOString() },
	},
	Cm = "vueuse-storage";
function RL(t, e, n, r = {}) {
	var o;
	const {
			flush: i = "pre",
			deep: s = !0,
			listenToStorageChanges: l = !0,
			writeDefaults: a = !0,
			mergeDefaults: u = !1,
			shallow: c,
			window: d = Ri,
			eventFilter: f,
			onError: p = (C) => {
				console.error(C);
			},
			initOnMounted: m,
		} = r,
		y = (c ? bu : Q)(typeof e == "function" ? e() : e);
	if (!n)
		try {
			n = __("getDefaultStorage", () => {
				var C;
				return (C = Ri) == null ? void 0 : C.localStorage;
			})();
		} catch (C) {
			p(C);
		}
	if (!n) return y;
	const v = Er(e),
		w = C_(v),
		S = (o = r.serializer) != null ? o : M_[w],
		{ pause: E, resume: h } = m_(y, () => b(y.value), {
			flush: i,
			deep: s,
			eventFilter: f,
		});
	return (
		d &&
			l &&
			Uy(() => {
				Nd(d, "storage", k), Nd(d, Cm, x), m && k();
			}),
		m || k(),
		y
	);
	function b(C) {
		try {
			if (C == null) n.removeItem(t);
			else {
				const _ = S.write(C),
					T = n.getItem(t);
				T !== _ &&
					(n.setItem(t, _),
					d &&
						d.dispatchEvent(
							new CustomEvent(Cm, {
								detail: {
									key: t,
									oldValue: T,
									newValue: _,
									storageArea: n,
								},
							})
						));
			}
		} catch (_) {
			p(_);
		}
	}
	function g(C) {
		const _ = C ? C.newValue : n.getItem(t);
		if (_ == null) return a && v != null && n.setItem(t, S.write(v)), v;
		if (!C && u) {
			const T = S.read(_);
			return typeof u == "function"
				? u(T, v)
				: w === "object" && !Array.isArray(T)
				? B(B({}, v), T)
				: T;
		} else return typeof _ != "string" ? _ : S.read(_);
	}
	function x(C) {
		k(C.detail);
	}
	function k(C) {
		if (!(C && C.storageArea !== n)) {
			if (C && C.key == null) {
				y.value = v;
				return;
			}
			if (!(C && C.key !== t)) {
				E();
				try {
					(C == null ? void 0 : C.newValue) !== S.write(y.value) &&
						(y.value = g(C));
				} catch (_) {
					p(_);
				} finally {
					C ? bt(h) : h();
				}
			}
		}
	}
}
function E_(t = {}) {
	const { controls: e = !1, interval: n = "requestAnimationFrame" } = t,
		r = Q(new Date()),
		o = () => (r.value = new Date()),
		i =
			n === "requestAnimationFrame"
				? w_(o, { immediate: !0 })
				: g_(o, n, { immediate: !0 });
	return e ? B({ now: r }, i) : r;
}
const T_ = [
		{ max: 6e4, value: 1e3, name: "second" },
		{ max: 276e4, value: 6e4, name: "minute" },
		{ max: 72e6, value: 36e5, name: "hour" },
		{ max: 5184e5, value: 864e5, name: "day" },
		{ max: 24192e5, value: 6048e5, name: "week" },
		{ max: 28512e6, value: 2592e6, name: "month" },
		{ max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" },
	],
	A_ = {
		justNow: "just now",
		past: (t) => (t.match(/\d/) ? `${t} ago` : t),
		future: (t) => (t.match(/\d/) ? `in ${t}` : t),
		month: (t, e) =>
			t === 1
				? e
					? "last month"
					: "next month"
				: `${t} month${t > 1 ? "s" : ""}`,
		year: (t, e) =>
			t === 1
				? e
					? "last year"
					: "next year"
				: `${t} year${t > 1 ? "s" : ""}`,
		day: (t, e) =>
			t === 1
				? e
					? "yesterday"
					: "tomorrow"
				: `${t} day${t > 1 ? "s" : ""}`,
		week: (t, e) =>
			t === 1
				? e
					? "last week"
					: "next week"
				: `${t} week${t > 1 ? "s" : ""}`,
		hour: (t) => `${t} hour${t > 1 ? "s" : ""}`,
		minute: (t) => `${t} minute${t > 1 ? "s" : ""}`,
		second: (t) => `${t} second${t > 1 ? "s" : ""}`,
		invalid: "",
	};
function O_(t) {
	return t.toISOString().slice(0, 10);
}
function PL(t, e = {}) {
	const { controls: n = !1, updateInterval: r = 3e4 } = e,
		l = E_({ interval: r, controls: !0 }),
		{ now: o } = l,
		i = tt(l, ["now"]),
		s = z(() => R_(new Date(Er(t)), e, Er(o)));
	return n ? B({ timeAgo: s }, i) : s;
}
function R_(t, e = {}, n = Date.now()) {
	var r;
	const {
			max: o,
			messages: i = A_,
			fullDateFormatter: s = O_,
			units: l = T_,
			showSecond: a = !1,
			rounding: u = "round",
		} = e,
		c = typeof u == "number" ? (v) => +v.toFixed(u) : Math[u],
		d = +n - +t,
		f = Math.abs(d);
	function p(v, w) {
		return c(Math.abs(v) / w.value);
	}
	function m(v, w) {
		const S = p(v, w),
			E = v > 0,
			h = y(w.name, S, E);
		return y(E ? "past" : "future", h, E);
	}
	function y(v, w, S) {
		const E = i[v];
		return typeof E == "function"
			? E(w, S)
			: E.replace("{0}", w.toString());
	}
	if (f < 6e4 && !a) return i.justNow;
	if (typeof o == "number" && f > o) return s(new Date(t));
	if (typeof o == "string") {
		const v = (r = l.find((w) => w.name === o)) == null ? void 0 : r.max;
		if (v && f > v) return s(new Date(t));
	}
	for (const [v, w] of l.entries()) {
		if (p(d, w) <= 0 && l[v - 1]) return m(d, l[v - 1]);
		if (f < w.max) return m(d, w);
	}
	return i.invalid;
}
function P_(t = {}) {
	const {
			window: e = Ri,
			initialWidth: n = Number.POSITIVE_INFINITY,
			initialHeight: r = Number.POSITIVE_INFINITY,
			listenOrientation: o = !0,
			includeScrollbar: i = !0,
		} = t,
		s = Q(n),
		l = Q(r),
		a = () => {
			e &&
				(i
					? ((s.value = e.innerWidth), (l.value = e.innerHeight))
					: ((s.value = e.document.documentElement.clientWidth),
					  (l.value = e.document.documentElement.clientHeight)));
		};
	if ((a(), Uy(a), Nd("resize", a, { passive: !0 }), o)) {
		const u = x_("(orientation: portrait)");
		at(u, () => a());
	}
	return { width: s, height: l };
}
const I_ = {
		name: "Dropdown",
		props: {
			button: { type: Object, default: null },
			options: { type: Array, default: () => [] },
			placement: { type: String, default: "left" },
		},
		components: {
			Menu: u8,
			MenuButton: c8,
			MenuItems: d8,
			MenuItem: f8,
			Button: Oi,
			FeatherIcon: _r,
			Popover: tl,
		},
		methods: {
			normalizeDropdownItem(t) {
				let e = t.onClick || null;
				return (
					!e &&
						t.route &&
						this.$router &&
						(e = () => this.$router.push(t.route)),
					{
						label: t.label,
						icon: t.icon,
						group: t.group,
						component: t.component,
						onClick: e,
					}
				);
			},
			filterOptions(t) {
				return (t || [])
					.filter(Boolean)
					.filter((e) => (e.condition ? e.condition() : !0))
					.map((e) => this.normalizeDropdownItem(e));
			},
		},
		computed: {
			groups() {
				var e;
				return (
					(e = this.options[0]) != null && e.group
						? this.options
						: [{ group: "", items: this.options }]
				).map((n, r) => ({
					key: r,
					group: n.group,
					hideLabel: n.hideLabel || !1,
					items: this.filterOptions(n.items),
				}));
			},
			dropdownTransition() {
				return {
					enterActiveClass: "transition duration-100 ease-out",
					enterFromClass: "transform scale-95 opacity-0",
					enterToClass: "transform scale-100 opacity-100",
					leaveActiveClass: "transition duration-75 ease-in",
					leaveFromClass: "transform scale-100 opacity-100",
					leaveToClass: "transform scale-95 opacity-0",
				};
			},
			popoverPlacement() {
				return this.placement === "left"
					? "bottom-start"
					: this.placement === "right"
					? "bottom-end"
					: this.placement === "center"
					? "bottom-center"
					: "bottom";
			},
		},
	},
	N_ = {
		key: 0,
		class: "flex h-7 items-center px-2 text-sm font-medium text-gray-500",
	},
	D_ = ["onClick"],
	j_ = { class: "whitespace-nowrap" };
function L_(t, e, n, r, o, i) {
	const s = Je("Button"),
		l = Je("MenuButton"),
		a = Je("FeatherIcon"),
		u = Je("MenuItem"),
		c = Je("MenuItems"),
		d = Je("Popover"),
		f = Je("Menu");
	return (
		N(),
		Te(
			f,
			{ as: "div", class: "relative inline-block text-left" },
			{
				default: Ce(({ open: p }) => [
					ve(
						d,
						{
							transition: i.dropdownTransition,
							show: p,
							placement: i.popoverPlacement,
						},
						{
							target: Ce(() => [
								ve(
									l,
									{ as: "div" },
									{
										default: Ce(() => [
											t.$slots.default
												? xe(
														t.$slots,
														"default",
														Et(
															pt(
																{ key: 0 },
																{ open: p }
															)
														)
												  )
												: (N(),
												  Te(
														s,
														pt(
															{
																key: 1,
																active: p,
															},
															n.button
														),
														{
															default: Ce(() => {
																var m;
																return [
																	lr(
																		We(
																			n.button
																				? ((m =
																						n.button) ==
																				  null
																						? void 0
																						: m.label) ||
																						null
																				: "Options"
																		),
																		1
																	),
																];
															}),
															_: 2,
														},
														1040,
														["active"]
												  )),
										]),
										_: 2,
									},
									1024
								),
							]),
							body: Ce(() => [
								ve(
									c,
									{
										class: be([
											"mt-2 min-w-40 divide-y divide-gray-100 rounded-lg bg-white shadow-2xl ring-1 ring-black ring-opacity-5 focus:outline-none",
											{
												"left-0 origin-top-left":
													n.placement == "left",
												"right-0 origin-top-right":
													n.placement == "right",
												"inset-x-0 origin-top":
													n.placement == "center",
											},
										]),
									},
									{
										default: Ce(() => [
											(N(!0),
											W(
												Ne,
												null,
												Rt(
													i.groups,
													(m) => (
														N(),
														W(
															"div",
															{
																key: m.key,
																class: "p-1.5",
															},
															[
																m.group &&
																!m.hideLabel
																	? (N(),
																	  W(
																			"div",
																			N_,
																			We(
																				m.group
																			),
																			1
																	  ))
																	: Re(
																			"",
																			!0
																	  ),
																(N(!0),
																W(
																	Ne,
																	null,
																	Rt(
																		m.items,
																		(y) => (
																			N(),
																			Te(
																				u,
																				{
																					key: y.label,
																				},
																				{
																					default:
																						Ce(
																							({
																								active: v,
																							}) => [
																								y.component
																									? (N(),
																									  Te(
																											Bn(
																												y.component
																											),
																											{
																												key: 0,
																												active: v,
																											},
																											null,
																											8,
																											[
																												"active",
																											]
																									  ))
																									: (N(),
																									  W(
																											"button",
																											{
																												key: 1,
																												class: be(
																													[
																														v
																															? "bg-gray-100"
																															: "text-gray-800",
																														"group flex h-7 w-full items-center rounded px-2 text-base",
																													]
																												),
																												onClick:
																													y.onClick,
																											},
																											[
																												y.icon &&
																												typeof y.icon ==
																													"string"
																													? (N(),
																													  Te(
																															a,
																															{
																																key: 0,
																																name: y.icon,
																																class: "mr-2 h-4 w-4 flex-shrink-0 text-gray-700",
																																"aria-hidden":
																																	"true",
																															},
																															null,
																															8,
																															[
																																"name",
																															]
																													  ))
																													: y.icon
																													? (N(),
																													  Te(
																															Bn(
																																y.icon
																															),
																															{
																																key: 1,
																																class: "mr-2 h-4 w-4 flex-shrink-0 text-gray-700",
																															}
																													  ))
																													: Re(
																															"",
																															!0
																													  ),
																												V(
																													"span",
																													j_,
																													We(
																														y.label
																													),
																													1
																												),
																											],
																											10,
																											D_
																									  )),
																							]
																						),
																					_: 2,
																				},
																				1024
																			)
																		)
																	),
																	128
																)),
															]
														)
													)
												),
												128
											)),
										]),
										_: 1,
									},
									8,
									["class"]
								),
							]),
							_: 2,
						},
						1032,
						["transition", "show", "placement"]
					),
				]),
				_: 3,
			}
		)
	);
}
const $_ = Le(I_, [["render", L_]]),
	B_ = { class: "flex min-w-0 items-center" },
	z_ = V(
		"svg",
		{
			class: "w-4 text-gray-600",
			xmlns: "http://www.w3.org/2000/svg",
			width: "24",
			height: "24",
			viewBox: "0 0 24 24",
			fill: "none",
			stroke: "currentColor",
			"stroke-width": "2",
			"stroke-linecap": "round",
			"stroke-linejoin": "round",
		},
		[
			V("circle", { cx: "12", cy: "12", r: "1" }),
			V("circle", { cx: "19", cy: "12", r: "1" }),
			V("circle", { cx: "5", cy: "12", r: "1" }),
		],
		-1
	),
	H_ = V(
		"span",
		{ class: "ml-1 mr-0.5 text-base text-gray-500", "aria-hidden": "true" },
		" / ",
		-1
	),
	F_ = {
		class: "flex min-w-0 items-center overflow-hidden text-ellipsis whitespace-nowrap",
	},
	V_ = {
		key: 0,
		class: "mx-0.5 text-base text-gray-500",
		"aria-hidden": "true",
	},
	IL = Oe({
		__name: "Breadcrumbs",
		props: { items: {} },
		setup(t) {
			const e = t,
				n = G0(),
				{ width: r } = P_(),
				o = z(() => (e.items || []).filter(Boolean)),
				i = z(() =>
					r.value > 640
						? []
						: o.value.slice(0, -2).map((a) => {
								let u = a.onClick
									? a.onClick
									: () => n.push(a.route);
								return ge(B({}, a), {
									icon: null,
									label: a.label,
									onClick: u,
								});
						  })
				),
				s = z(() => (r.value > 640 ? o.value : o.value.slice(-2)));
			return (l, a) => (
				N(),
				W("div", B_, [
					i.value.length
						? (N(),
						  W(
								Ne,
								{ key: 0 },
								[
									ve(
										$_,
										{ class: "h-7", options: i.value },
										{
											default: Ce(() => [
												ve(
													Oi,
													{ variant: "ghost" },
													{
														icon: Ce(() => [z_]),
														_: 1,
													}
												),
											]),
											_: 1,
										},
										8,
										["options"]
									),
									H_,
								],
								64
						  ))
						: Re("", !0),
					V("div", F_, [
						(N(!0),
						W(
							Ne,
							null,
							Rt(
								s.value,
								(u, c) => (
									N(),
									W(
										Ne,
										{ key: u.label },
										[
											(N(),
											Te(
												Bn(
													u.route
														? "router-link"
														: "button"
												),
												pt(
													{
														class: [
															"flex items-center rounded px-0.5 py-1 text-lg font-medium focus:outline-none focus-visible:ring-2 focus-visible:ring-gray-400",
															[
																c ==
																s.value.length -
																	1
																	? "text-gray-900"
																	: "text-gray-600 hover:text-gray-700",
															],
														],
													},
													u.route
														? { to: u.route }
														: { onClick: u.onClick }
												),
												{
													default: Ce(() => [
														xe(l.$slots, "prefix", {
															item: u,
														}),
														V(
															"span",
															null,
															We(u.label),
															1
														),
													]),
													_: 2,
												},
												1040,
												["class"]
											)),
											c != s.value.length - 1
												? (N(), W("span", V_, " / "))
												: Re("", !0),
										],
										64
									)
								)
							),
							128
						)),
					]),
				])
			);
		},
	});
let W_ = 0;
function U_() {
	return ++W_;
}
function Ky() {
	return "frappe-ui-" + U_();
}
const K_ = ["disabled", "id", "checked"],
	q_ = ["for"],
	Lu = Oe({
		__name: "Checkbox",
		props: {
			size: { default: "sm" },
			label: {},
			checked: { type: Boolean },
			disabled: { type: Boolean },
			padding: { type: Boolean, default: !1 },
			modelValue: { type: Boolean },
			id: {},
		},
		setup(t) {
			var s;
			const e = t,
				n = Js(),
				r = (s = e.id) != null ? s : Ky(),
				o = z(() => [
					{ sm: "text-base font-medium", md: "text-lg font-medium" }[
						e.size
					],
					e.disabled ? "text-gray-500" : "text-gray-800",
					"select-none",
				]),
				i = z(() => {
					let l = e.disabled
							? "border-gray-300 bg-gray-50 text-gray-400"
							: "border-gray-500 text-gray-900 hover:border-gray-600 focus:ring-offset-0 focus:border-gray-900 active:border-gray-700 transition",
						a = e.disabled
							? ""
							: e.padding
							? "focus:ring-0"
							: "hover:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400 active:bg-gray-100",
						u = { sm: "w-3.5 h-3.5", md: "w-4 h-4" }[e.size];
					return [l, a, u];
				});
			return (l, a) => (
				N(),
				W(
					"div",
					{
						class: be([
							"inline-flex items-center space-x-2 rounded transition",
							{
								"px-2.5 py-1.5": l.padding && l.size === "sm",
								"px-3 py-2": l.padding && l.size === "md",
								"focus-within:bg-gray-100 focus-within:ring-2 focus-within:ring-gray-400 hover:bg-gray-200 active:bg-gray-300":
									l.padding && !l.disabled,
							},
						]),
					},
					[
						V(
							"input",
							pt(
								{
									class: ["rounded-sm", i.value],
									type: "checkbox",
									disabled: l.disabled,
									id: ne(r),
									checked: !!l.modelValue,
									onChange:
										a[0] ||
										(a[0] = (u) =>
											l.$emit(
												"update:modelValue",
												u.target.checked
											)),
								},
								ne(n)
							),
							null,
							16,
							K_
						),
						l.label
							? (N(),
							  W(
									"label",
									{
										key: 0,
										class: be(["block", o.value]),
										for: ne(r),
									},
									We(l.label),
									11,
									q_
							  ))
							: Re("", !0),
					],
					2
				)
			);
		},
	});
function $u(t, e, n) {
	var r;
	return function () {
		var o = this,
			i = arguments,
			s = function () {
				(r = void 0), n || t.apply(o, i);
			},
			l = n && !r;
		clearTimeout(r), (r = window.setTimeout(s, e)), l && t.apply(o, i);
	};
}
const J_ = {
		name: "Input",
		inheritAttrs: !1,
		expose: ["getInputValue"],
		components: { FeatherIcon: _r },
		props: {
			label: { type: String },
			type: {
				type: String,
				default: "text",
				validator(t) {
					let e = [
						"text",
						"number",
						"checkbox",
						"textarea",
						"select",
						"email",
						"password",
						"date",
					].includes(t);
					return (
						e ||
							console.warn(
								`Invalid value "${t}" for "type" prop for Input`
							),
						e
					);
				},
			},
			modelValue: { type: [String, Number, Boolean, Object, Array] },
			inputClass: { type: [String, Array, Object] },
			debounce: { type: Number },
			options: { type: Array },
			disabled: { type: Boolean },
			rows: { type: Number, default: 3 },
			placeholder: { type: String },
			iconLeft: { type: String },
		},
		emits: ["input", "change", "update:modelValue"],
		methods: {
			focus() {
				this.$refs.input.focus();
			},
			blur() {
				this.$refs.input.blur();
			},
			getInputValue(t) {
				let e = t ? t.target : this.$refs.input,
					n = e.value;
				return this.type == "checkbox" && (n = e.checked), n;
			},
		},
		computed: {
			passedInputValue() {
				return "value" in this.$attrs
					? this.$attrs.value
					: this.modelValue || null;
			},
			inputAttributes() {
				let t = {},
					e = (n) => {
						this.$emit("input", this.getInputValue(n));
					};
				return (
					this.debounce && (e = $u(e, this.debounce)),
					this.type == "checkbox" &&
						(t.checked = this.passedInputValue),
					Object.assign(t, this.$attrs, {
						onInput: e,
						onChange: (n) => {
							this.$emit("change", this.getInputValue(n)),
								this.$emit(
									"update:modelValue",
									this.getInputValue(n)
								);
						},
					})
				);
			},
			selectOptions() {
				return this.options
					.map((t) =>
						typeof t == "string" ? { label: t, value: t } : t
					)
					.filter(Boolean);
			},
			isNormalInput() {
				return [
					"text",
					"number",
					"checkbox",
					"email",
					"password",
					"date",
				].includes(this.type);
			},
		},
	},
	G_ = { key: 0, class: "mb-2 block text-sm leading-4 text-gray-700" },
	Y_ = ["type", "disabled", "placeholder", "value"],
	Q_ = ["placeholder", "value", "disabled", "rows"],
	X_ = ["disabled"],
	Z_ = ["value", "disabled", "selected"],
	eC = { key: 1, class: "ml-2 inline-block text-base leading-4" };
function tC(t, e, n, r, o, i) {
	const s = Je("FeatherIcon");
	return (
		N(),
		W(
			"label",
			{
				class: be([
					n.type == "checkbox" ? "flex" : "block",
					t.$attrs.class,
				]),
			},
			[
				n.label && n.type != "checkbox"
					? (N(), W("span", G_, We(n.label), 1))
					: Re("", !0),
				V(
					"div",
					{
						class: be([
							"relative flex",
							{
								"items-center":
									i.isNormalInput || n.type == "select",
							},
						]),
					},
					[
						n.iconLeft && n.type != "checkbox"
							? (N(),
							  Te(
									s,
									{
										key: 0,
										name: n.iconLeft,
										class: be([
											"absolute mx-2 h-4 w-4 text-gray-600",
											{ "mt-2": n.type == "textarea" },
										]),
									},
									null,
									8,
									["name", "class"]
							  ))
							: Re("", !0),
						i.isNormalInput
							? (N(),
							  W(
									"input",
									pt({ key: 1 }, i.inputAttributes, {
										class: [
											"border-gray-400 placeholder-gray-500",
											[
												{
													"form-input block w-full":
														n.type != "checkbox",
													"form-checkbox":
														n.type == "checkbox",
													"pl-8":
														n.iconLeft &&
														n.type != "checkbox",
												},
												n.inputClass,
											],
										],
										ref: "input",
										type: n.type || "text",
										disabled: n.disabled,
										placeholder: n.placeholder,
										value: i.passedInputValue,
									}),
									null,
									16,
									Y_
							  ))
							: Re("", !0),
						n.type === "textarea"
							? (N(),
							  W(
									"textarea",
									pt({ key: 2 }, i.inputAttributes, {
										placeholder: n.placeholder,
										class: [
											"placeholder-gray-500",
											[
												"form-textarea block w-full resize-none",
												n.inputClass,
												{ "pl-8": n.iconLeft },
											],
										],
										ref: "input",
										value: i.passedInputValue,
										disabled: n.disabled,
										rows: n.rows,
									}),
									null,
									16,
									Q_
							  ))
							: Re("", !0),
						n.type === "select"
							? (N(),
							  W(
									"select",
									pt({ key: 3 }, i.inputAttributes, {
										class: [
											"form-select block w-full",
											{ "pl-8": n.iconLeft },
										],
										ref: "input",
										disabled: n.disabled,
									}),
									[
										(N(!0),
										W(
											Ne,
											null,
											Rt(
												i.selectOptions,
												(l) => (
													N(),
													W(
														"option",
														{
															key: l.value,
															value: l.value,
															disabled:
																l.disabled ||
																!1,
															selected:
																i.passedInputValue ===
																l.value,
														},
														We(l.label),
														9,
														Z_
													)
												)
											),
											128
										)),
									],
									16,
									X_
							  ))
							: Re("", !0),
					],
					2
				),
				n.label && n.type == "checkbox"
					? (N(), W("span", eC, We(n.label), 1))
					: Re("", !0),
			],
			2
		)
	);
}
const nC = Le(J_, [["render", tC]]),
	rC = {
		name: "DatePicker",
		props: [
			"modelValue",
			"placeholder",
			"readonly",
			"formatValue",
			"inputClass",
		],
		emits: ["update:modelValue"],
		components: { Input: nC, FeatherIcon: _r, Popover: tl },
		data() {
			return { currentYear: null, currentMonth: null };
		},
		created() {
			this.selectCurrentMonthYear();
		},
		computed: {
			today() {
				return this.getDate();
			},
			datesAsWeeks() {
				let t = [],
					e = this.dates.slice();
				for (; e.length; ) {
					let n = e.splice(0, 7);
					t.push(n);
				}
				return t;
			},
			dates() {
				if (!(this.currentYear && this.currentMonth)) return [];
				let t = this.currentMonth - 1,
					e = this.currentYear,
					n = this.getDate(e, t, 1),
					r = this.getDate(e, t + 1, 0),
					o = n.getDay(),
					i = 6 - r.getDay(),
					s = this.getDatesAfter(n, -o),
					l = this.getDatesAfter(r, i),
					a = this.getDaysInMonth(t, e),
					u = this.getDatesAfter(n, a - 1),
					c = [...s, n, ...u, ...l];
				if (c.length < 42) {
					const d = this.getDatesAfter(c.at(-1), 42 - c.length);
					c = c.concat(...d);
				}
				return c;
			},
			formatMonth() {
				return this.getDate(
					this.currentYear,
					this.currentMonth - 1,
					1
				).toLocaleString("en-US", { month: "short", year: "numeric" });
			},
		},
		methods: {
			selectDate(t) {
				this.$emit("update:modelValue", this.toValue(t));
			},
			selectCurrentMonthYear() {
				let t = this.modelValue
					? this.getDate(this.modelValue)
					: this.getDate();
				(this.currentYear = t.getFullYear()),
					(this.currentMonth = t.getMonth() + 1);
			},
			prevMonth() {
				this.changeMonth(-1);
			},
			nextMonth() {
				this.changeMonth(1);
			},
			changeMonth(t) {
				(this.currentMonth = this.currentMonth + t),
					this.currentMonth < 1 &&
						((this.currentMonth = 12),
						(this.currentYear = this.currentYear - 1)),
					this.currentMonth > 12 &&
						((this.currentMonth = 1),
						(this.currentYear = this.currentYear + 1));
			},
			getDatesAfter(t, e) {
				let n = 1;
				e < 0 && ((n = -1), (e = Math.abs(e)));
				let r = [];
				for (; e; )
					(t = this.getDate(
						t.getFullYear(),
						t.getMonth(),
						t.getDate() + n
					)),
						r.push(t),
						e--;
				return n === -1 ? r.reverse() : r;
			},
			getDaysInMonth(t, e) {
				let r = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t];
				return t === 1 && this.isLeapYear(e) ? 29 : r;
			},
			isLeapYear(t) {
				return t % 400 === 0 ? !0 : t % 100 === 0 ? !1 : t % 4 === 0;
			},
			toValue(t) {
				return t
					? (t.setHours(0, -t.getTimezoneOffset(), 0, 0),
					  t.toISOString().slice(0, 10))
					: "";
			},
			getDate(...t) {
				return new Date(...t);
			},
		},
	},
	oC = { class: "mt-1 select-none p-3 text-left" },
	iC = { class: "flex items-center justify-between" },
	sC = { class: "text-base font-medium text-blue-500" },
	lC = { class: "flex" },
	aC = {
		class: "grid h-5 w-5 cursor-pointer place-items-center rounded-md hover:bg-gray-100",
	},
	uC = {
		class: "ml-2 grid h-5 w-5 cursor-pointer place-items-center rounded-md hover:bg-gray-100",
	},
	cC = { class: "mt-2 text-sm" },
	dC = { class: "grid w-full grid-cols-7 place-items-center text-gray-600" },
	fC = { class: "grid w-full grid-cols-7 place-items-center gap-1" },
	hC = ["onClick"],
	pC = { class: "mt-2 flex w-full justify-end" },
	mC = ["onClick"];
function gC(t, e, n, r, o, i) {
	const s = Je("Input"),
		l = Je("FeatherIcon"),
		a = Je("Popover");
	return (
		N(),
		Te(
			a,
			{ onOpen: i.selectCurrentMonthYear, transition: "default" },
			{
				target: Ce(({ togglePopover: u }) => [
					ve(
						s,
						{
							type: "text",
							"icon-left": "calendar",
							class: be(n.inputClass),
							value:
								n.modelValue && n.formatValue
									? n.formatValue(n.modelValue)
									: n.modelValue || "",
							placeholder: n.placeholder,
							onFocus: (c) => (n.readonly ? null : u()),
							readonly: "",
						},
						null,
						8,
						["class", "value", "placeholder", "onFocus"]
					),
				]),
				"body-main": Ce(({ togglePopover: u }) => [
					V("div", oC, [
						V("div", iC, [
							V("span", sC, We(i.formatMonth), 1),
							V("span", lC, [
								V("div", aC, [
									ve(
										l,
										{
											onClick: i.prevMonth,
											name: "chevron-left",
											class: "h-4 w-4",
										},
										null,
										8,
										["onClick"]
									),
								]),
								V("div", uC, [
									ve(
										l,
										{
											onClick: i.nextMonth,
											name: "chevron-right",
											class: "h-4 w-4",
										},
										null,
										8,
										["onClick"]
									),
								]),
							]),
						]),
						V("div", cC, [
							V("div", dC, [
								(N(),
								W(
									Ne,
									null,
									Rt(
										["S", "M", "T", "W", "T", "F", "S"],
										(c, d) =>
											V(
												"div",
												{
													class: "grid h-6 w-6 place-items-center gap-1 text-center",
													key: d,
												},
												We(c),
												1
											)
									),
									64
								)),
							]),
							(N(!0),
							W(
								Ne,
								null,
								Rt(
									i.datesAsWeeks,
									(c, d) => (
										N(),
										W("div", { key: d, class: "mt-1" }, [
											V("div", fC, [
												(N(!0),
												W(
													Ne,
													null,
													Rt(
														c,
														(f) => (
															N(),
															W(
																"div",
																{
																	key: i.toValue(
																		f
																	),
																	class: be([
																		"grid h-6 w-6 cursor-pointer place-items-center rounded-md hover:bg-blue-100 hover:text-blue-700",
																		{
																			"text-gray-600":
																				f.getMonth() !==
																				o.currentMonth -
																					1,
																			"text-blue-500":
																				i.toValue(
																					f
																				) ===
																				i.toValue(
																					i.today
																				),
																			"bg-blue-100 font-semibold text-blue-500":
																				i.toValue(
																					f
																				) ===
																				n.modelValue,
																		},
																	]),
																	onClick:
																		() => {
																			i.selectDate(
																				f
																			),
																				u();
																		},
																},
																We(f.getDate()),
																11,
																hC
															)
														)
													),
													128
												)),
											]),
										])
									)
								),
								128
							)),
						]),
						V("div", pC, [
							V(
								"div",
								{
									class: "cursor-pointer rounded-md px-2 py-1 text-sm hover:bg-gray-100",
									onClick: () => {
										i.selectDate(""), u();
									},
								},
								" Clear ",
								8,
								mC
							),
						]),
					]),
				]),
				_: 1,
			},
			8,
			["onOpen"]
		)
	);
}
const NL = Le(rC, [["render", gC]]),
	yC = {
		name: "Dialog",
		props: {
			modelValue: { type: Boolean, required: !0 },
			options: {
				type: Object,
				default() {
					return {};
				},
			},
		},
		emits: ["update:modelValue", "close", "after-leave"],
		components: {
			HDialog: Zk,
			DialogPanel: e8,
			DialogTitle: t8,
			TransitionChild: Cy,
			TransitionRoot: My,
			Button: Oi,
			FeatherIcon: _r,
		},
		data() {
			return { dialogActions: [] };
		},
		watch: {
			"options.actions": {
				handler(t) {
					t &&
						(this.dialogActions = t.map((e) => {
							let n = Q(!1);
							return ge(B({}, e), {
								loading: n,
								onClick: e.onClick
									? () =>
											pr(this, null, function* () {
												n.value = !0;
												try {
													yield e.onClick();
												} finally {
													n.value = !1;
												}
											})
									: this.close,
							});
						}));
				},
				immediate: !0,
			},
		},
		methods: {
			close() {
				this.open = !1;
			},
		},
		computed: {
			open: {
				get() {
					return this.modelValue;
				},
				set(t) {
					this.$emit("update:modelValue", t),
						t || this.$emit("close");
				},
			},
			icon() {
				var e;
				if (!((e = this.options) != null && e.icon)) return null;
				let t = this.options.icon;
				return typeof t == "string" && (t = { name: t }), t;
			},
			dialogPositionClasses() {
				var e;
				let t =
					((e = this.options) == null ? void 0 : e.position) ||
					"center";
				return {
					"justify-center": t === "center",
					"pt-[20vh]": t === "top",
				};
			},
		},
	},
	vC = ["data-dialog"],
	bC = { class: "bg-white px-4 pb-6 pt-5 sm:px-6" },
	wC = { class: "flex" },
	xC = { class: "flex-1" },
	kC = { class: "mb-6 flex items-center justify-between" },
	SC = { class: "flex items-center space-x-2" },
	_C = { class: "text-2xl font-semibold leading-6 text-gray-900" },
	CC = V(
		"svg",
		{
			width: "16",
			height: "16",
			viewBox: "0 0 16 16",
			fill: "none",
			xmlns: "http://www.w3.org/2000/svg",
		},
		[
			V("path", {
				"fill-rule": "evenodd",
				"clip-rule": "evenodd",
				d: "M12.8567 3.85355C13.052 3.65829 13.052 3.34171 12.8567 3.14645C12.6615 2.95118 12.3449 2.95118 12.1496 3.14645L8.00201 7.29405L3.85441 3.14645C3.65914 2.95118 3.34256 2.95118 3.1473 3.14645C2.95204 3.34171 2.95204 3.65829 3.1473 3.85355L7.29491 8.00116L3.14645 12.1496C2.95118 12.3449 2.95118 12.6615 3.14645 12.8567C3.34171 13.052 3.65829 13.052 3.85355 12.8567L8.00201 8.70827L12.1505 12.8567C12.3457 13.052 12.6623 13.052 12.8576 12.8567C13.0528 12.6615 13.0528 12.3449 12.8576 12.1496L8.70912 8.00116L12.8567 3.85355Z",
				fill: "#383838",
			}),
		],
		-1
	),
	MC = { key: 0, class: "text-p-base text-gray-700" },
	EC = { key: 0, class: "px-4 pb-7 pt-4 sm:px-6" },
	TC = { class: "space-y-2" };
function AC(t, e, n, r, o, i) {
	const s = Je("TransitionChild"),
		l = Je("FeatherIcon"),
		a = Je("DialogTitle"),
		u = Je("Button"),
		c = Je("DialogPanel"),
		d = Je("HDialog"),
		f = Je("TransitionRoot");
	return (
		N(),
		Te(
			f,
			{
				as: "template",
				show: i.open,
				onAfterLeave: e[0] || (e[0] = (p) => t.$emit("after-leave")),
			},
			{
				default: Ce(() => [
					ve(
						d,
						{
							as: "div",
							class: "fixed inset-0 z-10 overflow-y-auto",
							onClose: i.close,
						},
						{
							default: Ce(() => [
								V(
									"div",
									{
										class: be([
											"flex min-h-screen flex-col items-center px-4 py-4 text-center",
											i.dialogPositionClasses,
										]),
									},
									[
										ve(
											s,
											{
												as: "template",
												enter: "ease-out duration-150",
												"enter-from": "opacity-0",
												"enter-to": "opacity-100",
												leave: "ease-in duration-150",
												"leave-from": "opacity-100",
												"leave-to": "opacity-0",
											},
											{
												default: Ce(() => [
													V(
														"div",
														{
															class: "fixed inset-0 bg-black-overlay-200 transition-opacity",
															"data-dialog":
																n.options.title,
														},
														null,
														8,
														vC
													),
												]),
												_: 1,
											}
										),
										ve(
											s,
											{
												as: "template",
												enter: "ease-out duration-150",
												"enter-from":
													"opacity-50 translate-y-2 scale-95",
												"enter-to":
													"opacity-100 translate-y-0 scale-100",
												leave: "ease-in duration-150",
												"leave-from":
													"opacity-100 translate-y-0 scale-100",
												"leave-to":
													"opacity-50 translate-y-4 translate-y-4 scale-95",
											},
											{
												default: Ce(() => [
													ve(
														c,
														{
															class: be([
																"my-8 inline-block w-full transform overflow-hidden rounded-xl bg-white text-left align-middle shadow-xl transition-all",
																{
																	"max-w-7xl":
																		n
																			.options
																			.size ===
																		"7xl",
																	"max-w-6xl":
																		n
																			.options
																			.size ===
																		"6xl",
																	"max-w-5xl":
																		n
																			.options
																			.size ===
																		"5xl",
																	"max-w-4xl":
																		n
																			.options
																			.size ===
																		"4xl",
																	"max-w-3xl":
																		n
																			.options
																			.size ===
																		"3xl",
																	"max-w-2xl":
																		n
																			.options
																			.size ===
																		"2xl",
																	"max-w-xl":
																		n
																			.options
																			.size ===
																		"xl",
																	"max-w-lg":
																		n
																			.options
																			.size ===
																			"lg" ||
																		!n
																			.options
																			.size,
																	"max-w-md":
																		n
																			.options
																			.size ===
																		"md",
																	"max-w-sm":
																		n
																			.options
																			.size ===
																		"sm",
																	"max-w-xs":
																		n
																			.options
																			.size ===
																		"xs",
																},
															]),
														},
														{
															default: Ce(() => [
																xe(
																	t.$slots,
																	"body",
																	{},
																	() => [
																		xe(
																			t.$slots,
																			"body-main",
																			{},
																			() => [
																				V(
																					"div",
																					bC,
																					[
																						V(
																							"div",
																							wC,
																							[
																								V(
																									"div",
																									xC,
																									[
																										V(
																											"div",
																											kC,
																											[
																												V(
																													"div",
																													SC,
																													[
																														i.icon
																															? (N(),
																															  W(
																																	"div",
																																	{
																																		key: 0,
																																		class: be(
																																			[
																																				"flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full",
																																				{
																																					"bg-gray-100":
																																						!i
																																							.icon
																																							.appearance,
																																					"bg-yellow-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"warning",
																																					"bg-blue-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"info",
																																					"bg-red-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"danger",
																																					"bg-green-100":
																																						i
																																							.icon
																																							.appearance ===
																																						"success",
																																				},
																																			]
																																		),
																																	},
																																	[
																																		ve(
																																			l,
																																			{
																																				name: i
																																					.icon
																																					.name,
																																				class: be(
																																					[
																																						"h-4 w-4",
																																						{
																																							"text-gray-600":
																																								!i
																																									.icon
																																									.appearance,
																																							"text-yellow-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"warning",
																																							"text-blue-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"info",
																																							"text-red-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"danger",
																																							"text-green-600":
																																								i
																																									.icon
																																									.appearance ===
																																								"success",
																																						},
																																					]
																																				),
																																				"aria-hidden":
																																					"true",
																																			},
																																			null,
																																			8,
																																			[
																																				"name",
																																				"class",
																																			]
																																		),
																																	],
																																	2
																															  ))
																															: Re(
																																	"",
																																	!0
																															  ),
																														ve(
																															a,
																															{
																																as: "header",
																															},
																															{
																																default:
																																	Ce(
																																		() => [
																																			xe(
																																				t.$slots,
																																				"body-title",
																																				{},
																																				() => [
																																					V(
																																						"h3",
																																						_C,
																																						We(
																																							n
																																								.options
																																								.title ||
																																								"Untitled"
																																						),
																																						1
																																					),
																																				]
																																			),
																																		]
																																	),
																																_: 3,
																															}
																														),
																													]
																												),
																												ve(
																													u,
																													{
																														variant:
																															"ghost",
																														onClick:
																															i.close,
																													},
																													{
																														icon: Ce(
																															() => [
																																CC,
																															]
																														),
																														_: 1,
																													},
																													8,
																													[
																														"onClick",
																													]
																												),
																											]
																										),
																										xe(
																											t.$slots,
																											"body-content",
																											{},
																											() => [
																												n
																													.options
																													.message
																													? (N(),
																													  W(
																															"p",
																															MC,
																															We(
																																n
																																	.options
																																	.message
																															),
																															1
																													  ))
																													: Re(
																															"",
																															!0
																													  ),
																											]
																										),
																									]
																								),
																							]
																						),
																					]
																				),
																			]
																		),
																		o
																			.dialogActions
																			.length ||
																		t.$slots
																			.actions
																			? (N(),
																			  W(
																					"div",
																					EC,
																					[
																						xe(
																							t.$slots,
																							"actions",
																							Et(
																								Lt(
																									{
																										close: i.close,
																									}
																								)
																							),
																							() => [
																								V(
																									"div",
																									TC,
																									[
																										(N(
																											!0
																										),
																										W(
																											Ne,
																											null,
																											Rt(
																												o.dialogActions,
																												(
																													p
																												) => (
																													N(),
																													Te(
																														u,
																														pt(
																															{
																																class: "w-full",
																																key: p.label,
																															},
																															p
																														),
																														{
																															default:
																																Ce(
																																	() => [
																																		lr(
																																			We(
																																				p.label
																																			),
																																			1
																																		),
																																	]
																																),
																															_: 2,
																														},
																														1040
																													)
																												)
																											),
																											128
																										)),
																									]
																								),
																							]
																						),
																					]
																			  ))
																			: Re(
																					"",
																					!0
																			  ),
																	]
																),
															]),
															_: 3,
														},
														8,
														["class"]
													),
												]),
												_: 3,
											}
										),
									],
									2
								),
							]),
							_: 3,
						},
						8,
						["onClose"]
					),
				]),
				_: 3,
			},
			8,
			["show"]
		)
	);
}
const DL = Le(yC, [["render", AC]]),
	OC = {
		name: "ErrorMessage",
		props: ["message"],
		computed: {
			errorMessage() {
				return this.message
					? this.message instanceof Error
						? this.message.messages || this.message.message
						: this.message
					: "";
			},
		},
	},
	RC = ["innerHTML"];
function PC(t, e, n, r, o, i) {
	return n.message
		? (N(),
		  W(
				"div",
				{
					key: 0,
					class: "whitespace-pre-line text-sm text-red-600",
					role: "alert",
					innerHTML: i.errorMessage,
				},
				null,
				8,
				RC
		  ))
		: Re("", !0);
}
const jL = Le(OC, [["render", PC]]);
class IC {
	constructor() {
		sc(this, "listeners");
		sc(this, "failed");
		(this.listeners = {}), (this.failed = !1);
	}
	on(e, n) {
		(this.listeners[e] = this.listeners[e] || []),
			this.listeners[e].push(n);
	}
	trigger(e, n) {
		(this.listeners[e] || []).forEach((o) => {
			o.call(this, n);
		});
	}
	upload(e, n) {
		return new Promise((r, o) => {
			let i = new XMLHttpRequest();
			i.upload.addEventListener("loadstart", () => {
				this.trigger("start");
			}),
				i.upload.addEventListener("progress", (a) => {
					a.lengthComputable &&
						this.trigger("progress", {
							uploaded: a.loaded,
							total: a.total,
						});
				}),
				i.upload.addEventListener("load", () => {
					this.trigger("finish");
				}),
				i.addEventListener("error", () => {
					this.trigger("error"), o();
				}),
				(i.onreadystatechange = () => {
					if (i.readyState == XMLHttpRequest.DONE) {
						let a;
						if (i.status === 200) {
							let u = null;
							try {
								u = JSON.parse(i.responseText);
							} catch (d) {
								u = i.responseText;
							}
							let c = u.message || u;
							r(c);
						} else if (i.status === 403)
							a = JSON.parse(i.responseText);
						else {
							this.failed = !0;
							try {
								a = JSON.parse(i.responseText);
							} catch (u) {}
						}
						a && a.exc && console.error(JSON.parse(a.exc)[0]), o(a);
					}
				});
			const s = n.upload_endpoint || "/api/method/upload_file";
			i.open("POST", s, !0),
				i.setRequestHeader("Accept", "application/json"),
				window.csrf_token &&
					window.csrf_token !== "{{ csrf_token }}" &&
					i.setRequestHeader(
						"X-Frappe-CSRF-Token",
						window.csrf_token
					);
			let l = new FormData();
			e && l.append("file", e, e.name),
				l.append("is_private", n.private ? "1" : "0"),
				l.append("folder", n.folder || "Home"),
				n.file_url && l.append("file_url", n.file_url),
				n.doctype && l.append("doctype", n.doctype),
				n.docname && l.append("docname", n.docname),
				n.fieldname && l.append("fieldname", n.fieldname),
				n.method && l.append("method", n.method),
				n.type && l.append("type", n.type),
				i.send(l);
		});
	}
}
const NC = {
		name: "FileUploader",
		props: ["fileTypes", "uploadArgs", "validateFile"],
		data() {
			return {
				uploader: null,
				uploading: !1,
				uploaded: 0,
				error: null,
				message: "",
				total: 0,
				file: null,
				finishedUploading: !1,
			};
		},
		computed: {
			progress() {
				let t = Math.floor((this.uploaded / this.total) * 100);
				return isNaN(t) ? 0 : t;
			},
			success() {
				return this.finishedUploading && !this.error;
			},
		},
		methods: {
			openFileSelector() {
				this.$refs.input.click();
			},
			onFileAdd(t) {
				return pr(this, null, function* () {
					if (
						((this.error = null),
						(this.file = t.target.files[0]),
						this.file && this.validateFile)
					)
						try {
							let e = yield this.validateFile(this.file);
							e && (this.error = e);
						} catch (e) {
							this.error = e;
						}
					this.error || this.uploadFile(this.file);
				});
			},
			uploadFile(t) {
				return pr(this, null, function* () {
					(this.error = null),
						(this.uploaded = 0),
						(this.total = 0),
						(this.uploader = new IC()),
						this.uploader.on("start", () => {
							this.uploading = !0;
						}),
						this.uploader.on("progress", (e) => {
							(this.uploaded = e.uploaded),
								(this.total = e.total);
						}),
						this.uploader.on("error", () => {
							(this.uploading = !1),
								(this.error = "Error Uploading File");
						}),
						this.uploader.on("finish", () => {
							(this.uploading = !1),
								(this.finishedUploading = !0);
						}),
						this.uploader
							.upload(t, this.uploadArgs || {})
							.then((e) => {
								this.$emit("success", e);
							})
							.catch((e) => {
								this.uploading = !1;
								let n = "Error Uploading File";
								e != null && e._server_messages
									? (n = JSON.parse(
											JSON.parse(e._server_messages)[0]
									  ).message)
									: e != null &&
									  e.exc &&
									  (n = JSON.parse(e.exc)[0]
											.split(
												`
`
											)
											.slice(-2, -1)[0]),
									(this.error = n),
									this.$emit("failure", e);
							});
				});
			},
		},
	},
	DC = ["accept"];
function jC(t, e, n, r, o, i) {
	return (
		N(),
		W("div", null, [
			V(
				"input",
				{
					ref: "input",
					type: "file",
					accept: n.fileTypes,
					class: "hidden",
					onChange:
						e[0] ||
						(e[0] = (...s) => i.onFileAdd && i.onFileAdd(...s)),
				},
				null,
				40,
				DC
			),
			xe(
				t.$slots,
				"default",
				Et(
					Lt({
						file: o.file,
						uploading: o.uploading,
						progress: i.progress,
						uploaded: o.uploaded,
						message: o.message,
						error: o.error,
						total: o.total,
						success: i.success,
						openFileSelector: i.openFileSelector,
					})
				)
			),
		])
	);
}
const LL = Le(NC, [["render", jC]]),
	LC = { class: "relative flex items-center" },
	$C = ["type", "placeholder", "disabled", "id", "value"],
	BC = Oe({
		__name: "TextInput",
		props: {
			type: { default: "text" },
			size: { default: "sm" },
			variant: { default: "subtle" },
			placeholder: {},
			disabled: { type: Boolean },
			id: {},
			modelValue: {},
			debounce: {},
		},
		emits: ["update:modelValue"],
		setup(t, { expose: e, emit: n }) {
			const r = t,
				o = n,
				i = zf(),
				s = Js(),
				l = Q(null);
			e({ el: l });
			const a = z(() => (r.disabled ? "text-gray-600" : "text-gray-800")),
				u = z(() => {
					let m = {
							sm: "text-base rounded h-7",
							md: "text-base rounded h-8",
							lg: "text-lg rounded-md h-10",
							xl: "text-xl rounded-md h-10",
						}[r.size],
						y = {
							sm: [
								"py-1.5",
								i.prefix ? "pl-8" : "pl-2",
								i.suffix ? "pr-8" : "pr-2",
							],
							md: [
								"py-1.5",
								i.prefix ? "pl-9" : "pl-2.5",
								i.suffix ? "pr-9" : "pr-2.5",
							],
							lg: [
								"py-1.5",
								i.prefix ? "pl-10" : "pl-3",
								i.suffix ? "pr-10" : "pr-3",
							],
							xl: [
								"py-1.5",
								i.prefix ? "pl-10" : "pl-3",
								i.suffix ? "pr-10" : "pr-3",
							],
						}[r.size],
						v = r.disabled ? "disabled" : r.variant,
						w = {
							subtle: "border border-gray-100 bg-gray-100 placeholder-gray-500 hover:border-gray-200 hover:bg-gray-200 focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							outline:
								"border border-gray-300 bg-white placeholder-gray-500 hover:border-gray-400 hover:shadow-sm focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							disabled: [
								"border bg-gray-50 placeholder-gray-400",
								r.variant === "outline"
									? "border-gray-300"
									: "border-transparent",
							],
						}[v];
					return [m, y, w, a.value, "transition-colors w-full"];
				});
			let c = z(
					() =>
						({ sm: "pl-2", md: "pl-2.5", lg: "pl-3", xl: "pl-3" }[
							r.size
						])
				),
				d = z(
					() =>
						({ sm: "pr-2", md: "pr-2.5", lg: "pr-3", xl: "pr-3" }[
							r.size
						])
				),
				f = (m) => {
					o("update:modelValue", m);
				};
			r.debounce && (f = $u(f, r.debounce));
			let p = (m) => {
				f(m.target.value);
			};
			return (m, y) => (
				N(),
				W("div", LC, [
					m.$slots.prefix
						? (N(),
						  W(
								"div",
								{
									key: 0,
									class: be([
										"absolute inset-y-0 left-0 flex items-center",
										a.value,
										ne(c),
									]),
								},
								[xe(m.$slots, "prefix")],
								2
						  ))
						: Re("", !0),
					V(
						"input",
						pt(
							{
								ref_key: "inputRef",
								ref: l,
								type: m.type,
								placeholder: m.placeholder,
								class: u.value,
								disabled: m.disabled,
								id: m.id,
								value: m.modelValue,
								onInput:
									y[0] ||
									(y[0] = (...v) => ne(p) && ne(p)(...v)),
								onChange:
									y[1] ||
									(y[1] = (...v) => ne(p) && ne(p)(...v)),
							},
							ne(s)
						),
						null,
						16,
						$C
					),
					m.$slots.suffix
						? (N(),
						  W(
								"div",
								{
									key: 1,
									class: be([
										"absolute inset-y-0 right-0 flex items-center",
										a.value,
										ne(d),
									]),
								},
								[xe(m.$slots, "suffix")],
								2
						  ))
						: Re("", !0),
				])
			);
		},
	}),
	zC = { class: "relative flex items-center" },
	HC = ["disabled", "id", "value"],
	FC = ["value", "disabled", "selected"],
	VC = Oe({
		__name: "Select",
		props: {
			size: { default: "sm" },
			variant: { default: "subtle" },
			placeholder: {},
			disabled: { type: Boolean },
			id: {},
			modelValue: {},
			options: {},
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			const n = t,
				r = e,
				o = zf(),
				i = Js();
			function s(d) {
				r("update:modelValue", d.target.value);
			}
			const l = z(() => {
					var d;
					return (
						((d = n.options) == null
							? void 0
							: d
									.map((f) =>
										typeof f == "string"
											? { label: f, value: f }
											: f
									)
									.filter(Boolean)) || []
					);
				}),
				a = z(() => (n.disabled ? "text-gray-500" : "text-gray-800")),
				u = z(() => {
					let d = {
							sm: "text-base rounded h-7",
							md: "text-base rounded h-8",
							lg: "text-lg rounded-md h-10",
							xl: "text-xl rounded-md h-10",
						}[n.size],
						f = {
							sm: ["py-0", o.prefix ? "pl-8" : "pl-2"],
							md: ["py-0", o.prefix ? "pl-9" : "pl-2.5"],
							lg: ["py-0", o.prefix ? "pl-10" : "pl-3"],
							xl: ["py-0", o.prefix ? "pl-10" : "pl-3"],
						}[n.size],
						p = n.disabled ? "disabled" : n.variant,
						m = {
							subtle: "border border-gray-100 bg-gray-100 hover:border-gray-200 hover:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							outline:
								"border border-gray-300 bg-white hover:border-gray-400 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							ghost: "bg-transparent border-transparent hover:bg-gray-200 focus:bg-gray-200 focus:border-gray-500 focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							disabled: [
								"border",
								n.variant !== "ghost" ? "bg-gray-50" : "",
								n.variant === "outline"
									? "border-gray-300"
									: "border-transparent",
							],
						}[p];
					return [d, f, m, a.value, "transition-colors w-full"];
				});
			let c = z(
				() =>
					({ sm: "pl-2", md: "pl-2.5", lg: "pl-3", xl: "pl-3" }[
						n.size
					])
			);
			return (d, f) => (
				N(),
				W("div", zC, [
					d.$slots.prefix
						? (N(),
						  W(
								"div",
								{
									key: 0,
									class: be([
										"absolute inset-y-0 left-0 flex items-center",
										a.value,
										ne(c),
									]),
								},
								[xe(d.$slots, "prefix")],
								2
						  ))
						: Re("", !0),
					V(
						"select",
						pt(
							{
								class: u.value,
								disabled: d.disabled,
								id: d.id,
								value: d.modelValue,
								onChange: s,
							},
							ne(i)
						),
						[
							(N(!0),
							W(
								Ne,
								null,
								Rt(
									l.value,
									(p) => (
										N(),
										W(
											"option",
											{
												key: p.value,
												value: p.value,
												disabled: p.disabled || !1,
												selected:
													d.modelValue === p.value,
											},
											We(p.label),
											9,
											FC
										)
									)
								),
								128
							)),
						],
						16,
						HC
					),
				])
			);
		},
	}),
	WC = ["placeholder", "disabled", "id", "value", "rows"],
	UC = Oe({
		__name: "Textarea",
		props: {
			size: { default: "sm" },
			variant: { default: "subtle" },
			placeholder: {},
			disabled: { type: Boolean },
			id: {},
			modelValue: {},
			debounce: {},
			rows: { default: 3 },
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			const n = t,
				r = e,
				o = Js(),
				i = z(() => {
					let a = {
							sm: "text-base rounded",
							md: "text-base rounded",
							lg: "text-lg rounded-md",
							xl: "text-xl rounded-md",
						}[n.size],
						u = {
							sm: ["py-1.5 px-2"],
							md: ["py-1.5 px-2.5"],
							lg: ["py-1.5 px-3"],
							xl: ["py-1.5 px-3"],
						}[n.size],
						c = n.disabled ? "disabled" : n.variant,
						d = {
							subtle: "border border-gray-100 bg-gray-100 placeholder-gray-500 hover:border-gray-200 hover:bg-gray-200 focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							outline:
								"border border-gray-300 bg-white placeholder-gray-500 hover:border-gray-400 hover:shadow-sm focus:bg-white focus:border-gray-500 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-gray-400",
							disabled: [
								"border bg-gray-50 placeholder-gray-400",
								n.variant === "outline"
									? "border-gray-300"
									: "border-transparent",
							],
						}[c];
					return [
						a,
						u,
						d,
						n.disabled ? "text-gray-600" : "text-gray-800",
						"transition-colors w-full block",
					];
				});
			let s = (a) => {
				r("update:modelValue", a);
			};
			n.debounce && (s = $u(s, n.debounce));
			let l = (a) => {
				s(a.target.value);
			};
			return (a, u) => (
				N(),
				W(
					"textarea",
					pt(
						{
							placeholder: a.placeholder,
							class: i.value,
							disabled: a.disabled,
							id: a.id,
							value: a.modelValue,
							rows: a.rows,
							onInput:
								u[0] || (u[0] = (...c) => ne(l) && ne(l)(...c)),
							onChange:
								u[1] || (u[1] = (...c) => ne(l) && ne(l)(...c)),
						},
						ne(o)
					),
					null,
					16,
					WC
				)
			);
		},
	}),
	KC = ["for"],
	qC = { inheritAttrs: !1 },
	$L = Oe(
		ge(B({}, qC), {
			__name: "FormControl",
			props: {
				label: {},
				description: {},
				type: { default: "text" },
				size: { default: "sm" },
			},
			setup(t) {
				const e = Ky(),
					n = t,
					r = Js(),
					o = z(() => {
						let l = {};
						for (let a in r)
							a !== "class" && a !== "style" && (l[a] = r[a]);
						return l;
					}),
					i = z(() => [
						{ sm: "text-xs", md: "text-base" }[n.size],
						"text-gray-600",
					]),
					s = z(() => [
						{ sm: "text-xs", md: "text-base" }[n.size],
						"text-gray-600",
					]);
				return (l, a) =>
					l.type != "checkbox"
						? (N(),
						  W(
								"div",
								{
									key: 0,
									class: be(["space-y-1.5", ne(r).class]),
								},
								[
									l.label
										? (N(),
										  W(
												"label",
												{
													key: 0,
													class: be([
														"block",
														i.value,
													]),
													for: ne(e),
												},
												We(l.label),
												11,
												KC
										  ))
										: Re("", !0),
									l.type === "select"
										? (N(),
										  Te(
												VC,
												pt(
													{ key: 1, id: ne(e) },
													ge(B({}, o.value), {
														size: l.size,
													})
												),
												hc({ _: 2 }, [
													l.$slots.prefix
														? {
																name: "prefix",
																fn: Ce(() => [
																	xe(
																		l.$slots,
																		"prefix"
																	),
																]),
																key: "0",
														  }
														: void 0,
												]),
												1040,
												["id"]
										  ))
										: l.type === "autocomplete"
										? (N(),
										  Te(
												n_,
												Et(
													pt(
														{ key: 2 },
														B({}, o.value)
													)
												),
												hc({ _: 2 }, [
													l.$slots.prefix
														? {
																name: "prefix",
																fn: Ce(() => [
																	xe(
																		l.$slots,
																		"prefix"
																	),
																]),
																key: "0",
														  }
														: void 0,
													l.$slots["item-prefix"]
														? {
																name: "item-prefix",
																fn: Ce((u) => [
																	xe(
																		l.$slots,
																		"item-prefix",
																		Et(
																			Lt(
																				u
																			)
																		)
																	),
																]),
																key: "1",
														  }
														: void 0,
												]),
												1040
										  ))
										: l.type === "textarea"
										? (N(),
										  Te(
												UC,
												pt(
													{ key: 3, id: ne(e) },
													ge(B({}, o.value), {
														size: l.size,
													})
												),
												null,
												16,
												["id"]
										  ))
										: (N(),
										  Te(
												BC,
												pt(
													{ key: 4, id: ne(e) },
													ge(B({}, o.value), {
														type: l.type,
														size: l.size,
													})
												),
												hc({ _: 2 }, [
													l.$slots.prefix
														? {
																name: "prefix",
																fn: Ce(() => [
																	xe(
																		l.$slots,
																		"prefix"
																	),
																]),
																key: "0",
														  }
														: void 0,
													l.$slots.suffix
														? {
																name: "suffix",
																fn: Ce(() => [
																	xe(
																		l.$slots,
																		"suffix"
																	),
																]),
																key: "1",
														  }
														: void 0,
												]),
												1040,
												["id"]
										  )),
									xe(l.$slots, "description", {}, () => [
										l.description
											? (N(),
											  W(
													"p",
													{
														key: 0,
														class: be(s.value),
													},
													We(l.description),
													3
											  ))
											: Re("", !0),
									]),
								],
								2
						  ))
						: (N(),
						  Te(
								Lu,
								pt(
									{ key: 1, id: ne(e) },
									ge(B({}, o.value), {
										label: l.label,
										size: l.size,
										class: ne(r).class,
									})
								),
								null,
								16,
								["id"]
						  ));
			},
		})
	),
	BL = {
		__name: "Tabs",
		props: {
			tabs: { type: Array, required: !0 },
			modelValue: { type: Number, default: 0 },
			options: { type: Object, default: () => ({ indicatorLeft: 20 }) },
		},
		emits: ["update:modelValue"],
		setup(t, { emit: e }) {
			var d, f;
			const n = t,
				r = e,
				o = z({
					get: () => n.modelValue,
					set: (p) => r("update:modelValue", p),
				}),
				i = Q([]),
				s = Q(null),
				l = Q((d = n.tabs) == null ? void 0 : d.length),
				a = Q((f = n.options) == null ? void 0 : f.indicatorLeft),
				u = Q("");
			function c(p) {
				p >= l.value && (p = l.value - 1);
				const m = i.value[p].el;
				(s.value.style.width = `${m.offsetWidth}px`),
					(a.value = m.offsetLeft);
			}
			return (
				at(o, (p) => {
					p >= l.value && (o.value = l.value - 1), bt(() => c(p));
				}),
				Ze(() => {
					c(o.value),
						bt(() => {
							u.value = "transition-all duration-300 ease-in-out";
						});
				}),
				(p, m) => (
					N(),
					Te(
						ne(g8),
						{
							as: "div",
							class: "flex flex-1 flex-col",
							defaultIndex: o.value,
							selectedIndex: o.value,
							onChange: m[0] || (m[0] = (y) => (o.value = y)),
						},
						{
							default: Ce(() => [
								ve(
									ne(y8),
									{
										class: "relative flex items-center gap-6 border-b pl-5",
									},
									{
										default: Ce(() => [
											(N(!0),
											W(
												Ne,
												null,
												Rt(
													t.tabs,
													(y, v) => (
														N(),
														Te(
															ne(v8),
															{
																ref_for: !0,
																ref_key:
																	"tabRef",
																ref: i,
																as: "template",
																key: v,
																class: "focus:outline-none focus:transition-none focus-visible:rounded focus-visible:ring-2 focus-visible:ring-gray-400",
															},
															{
																default: Ce(
																	({
																		selected:
																			w,
																	}) => [
																		xe(
																			p.$slots,
																			"tab",
																			Et(
																				Lt(
																					{
																						tab: y,
																						selected:
																							w,
																					}
																				)
																			),
																			() => [
																				V(
																					"button",
																					{
																						class: be(
																							[
																								"-mb-px flex items-center gap-2 border-b border-transparent py-2.5 text-base text-gray-600 duration-300 ease-in-out hover:border-gray-400 hover:text-gray-900",
																								{
																									"text-gray-900":
																										w,
																								},
																							]
																						),
																					},
																					[
																						y.icon
																							? (N(),
																							  Te(
																									Bn(
																										y.icon
																									),
																									{
																										key: 0,
																										class: "h-5",
																									}
																							  ))
																							: Re(
																									"",
																									!0
																							  ),
																						lr(
																							" " +
																								We(
																									y.label
																								),
																							1
																						),
																					],
																					2
																				),
																			]
																		),
																	]
																),
																_: 2,
															},
															1024
														)
													)
												),
												128
											)),
											V(
												"div",
												{
													ref_key: "indicator",
													ref: s,
													class: be([
														"absolute -bottom-px h-px bg-gray-900",
														u.value,
													]),
													style: ao({
														left: `${a.value}px`,
													}),
												},
												null,
												6
											),
										]),
										_: 3,
									}
								),
								ve(
									ne(b8),
									{ class: "flex flex-1 overflow-hidden" },
									{
										default: Ce(() => [
											(N(!0),
											W(
												Ne,
												null,
												Rt(
													t.tabs,
													(y, v) => (
														N(),
														Te(
															ne(w8),
															{
																class: "flex flex-1 flex-col overflow-y-auto focus:outline-none",
																key: v,
															},
															{
																default: Ce(
																	() => [
																		xe(
																			p.$slots,
																			"default",
																			Et(
																				Lt(
																					{
																						tab: y,
																					}
																				)
																			)
																		),
																	]
																),
																_: 2,
															},
															1024
														)
													)
												),
												128
											)),
										]),
										_: 3,
									}
								),
							]),
							_: 3,
						},
						8,
						["defaultIndex", "selectedIndex"]
					)
				)
			);
		},
	};
function Ft(t) {
	this.content = t;
}
Ft.prototype = {
	constructor: Ft,
	find: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			if (this.content[e] === t) return e;
		return -1;
	},
	get: function (t) {
		var e = this.find(t);
		return e == -1 ? void 0 : this.content[e + 1];
	},
	update: function (t, e, n) {
		var r = n && n != t ? this.remove(n) : this,
			o = r.find(t),
			i = r.content.slice();
		return (
			o == -1 ? i.push(n || t, e) : ((i[o + 1] = e), n && (i[o] = n)),
			new Ft(i)
		);
	},
	remove: function (t) {
		var e = this.find(t);
		if (e == -1) return this;
		var n = this.content.slice();
		return n.splice(e, 2), new Ft(n);
	},
	addToStart: function (t, e) {
		return new Ft([t, e].concat(this.remove(t).content));
	},
	addToEnd: function (t, e) {
		var n = this.remove(t).content.slice();
		return n.push(t, e), new Ft(n);
	},
	addBefore: function (t, e, n) {
		var r = this.remove(e),
			o = r.content.slice(),
			i = r.find(t);
		return o.splice(i == -1 ? o.length : i, 0, e, n), new Ft(o);
	},
	forEach: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			t(this.content[e], this.content[e + 1]);
	},
	prepend: function (t) {
		return (
			(t = Ft.from(t)),
			t.size ? new Ft(t.content.concat(this.subtract(t).content)) : this
		);
	},
	append: function (t) {
		return (
			(t = Ft.from(t)),
			t.size ? new Ft(this.subtract(t).content.concat(t.content)) : this
		);
	},
	subtract: function (t) {
		var e = this;
		t = Ft.from(t);
		for (var n = 0; n < t.content.length; n += 2)
			e = e.remove(t.content[n]);
		return e;
	},
	toObject: function () {
		var t = {};
		return (
			this.forEach(function (e, n) {
				t[e] = n;
			}),
			t
		);
	},
	get size() {
		return this.content.length >> 1;
	},
};
Ft.from = function (t) {
	if (t instanceof Ft) return t;
	var e = [];
	if (t) for (var n in t) e.push(n, t[n]);
	return new Ft(e);
};
function qy(t, e, n) {
	for (let r = 0; ; r++) {
		if (r == t.childCount || r == e.childCount)
			return t.childCount == e.childCount ? null : n;
		let o = t.child(r),
			i = e.child(r);
		if (o == i) {
			n += o.nodeSize;
			continue;
		}
		if (!o.sameMarkup(i)) return n;
		if (o.isText && o.text != i.text) {
			for (let s = 0; o.text[s] == i.text[s]; s++) n++;
			return n;
		}
		if (o.content.size || i.content.size) {
			let s = qy(o.content, i.content, n + 1);
			if (s != null) return s;
		}
		n += o.nodeSize;
	}
}
function Jy(t, e, n, r) {
	for (let o = t.childCount, i = e.childCount; ; ) {
		if (o == 0 || i == 0) return o == i ? null : { a: n, b: r };
		let s = t.child(--o),
			l = e.child(--i),
			a = s.nodeSize;
		if (s == l) {
			(n -= a), (r -= a);
			continue;
		}
		if (!s.sameMarkup(l)) return { a: n, b: r };
		if (s.isText && s.text != l.text) {
			let u = 0,
				c = Math.min(s.text.length, l.text.length);
			for (
				;
				u < c &&
				s.text[s.text.length - u - 1] == l.text[l.text.length - u - 1];

			)
				u++, n--, r--;
			return { a: n, b: r };
		}
		if (s.content.size || l.content.size) {
			let u = Jy(s.content, l.content, n - 1, r - 1);
			if (u) return u;
		}
		(n -= a), (r -= a);
	}
}
class J {
	constructor(e, n) {
		if (((this.content = e), (this.size = n || 0), n == null))
			for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
	}
	nodesBetween(e, n, r, o = 0, i) {
		for (let s = 0, l = 0; l < n; s++) {
			let a = this.content[s],
				u = l + a.nodeSize;
			if (u > e && r(a, o + l, i || null, s) !== !1 && a.content.size) {
				let c = l + 1;
				a.nodesBetween(
					Math.max(0, e - c),
					Math.min(a.content.size, n - c),
					r,
					o + c
				);
			}
			l = u;
		}
	}
	descendants(e) {
		this.nodesBetween(0, this.size, e);
	}
	textBetween(e, n, r, o) {
		let i = "",
			s = !0;
		return (
			this.nodesBetween(
				e,
				n,
				(l, a) => {
					let u = l.isText
						? l.text.slice(Math.max(e, a) - a, n - a)
						: l.isLeaf
						? o
							? typeof o == "function"
								? o(l)
								: o
							: l.type.spec.leafText
							? l.type.spec.leafText(l)
							: ""
						: "";
					l.isBlock &&
						((l.isLeaf && u) || l.isTextblock) &&
						r &&
						(s ? (s = !1) : (i += r)),
						(i += u);
				},
				0
			),
			i
		);
	}
	append(e) {
		if (!e.size) return this;
		if (!this.size) return e;
		let n = this.lastChild,
			r = e.firstChild,
			o = this.content.slice(),
			i = 0;
		for (
			n.isText &&
			n.sameMarkup(r) &&
			((o[o.length - 1] = n.withText(n.text + r.text)), (i = 1));
			i < e.content.length;
			i++
		)
			o.push(e.content[i]);
		return new J(o, this.size + e.size);
	}
	cut(e, n = this.size) {
		if (e == 0 && n == this.size) return this;
		let r = [],
			o = 0;
		if (n > e)
			for (let i = 0, s = 0; s < n; i++) {
				let l = this.content[i],
					a = s + l.nodeSize;
				a > e &&
					((s < e || a > n) &&
						(l.isText
							? (l = l.cut(
									Math.max(0, e - s),
									Math.min(l.text.length, n - s)
							  ))
							: (l = l.cut(
									Math.max(0, e - s - 1),
									Math.min(l.content.size, n - s - 1)
							  ))),
					r.push(l),
					(o += l.nodeSize)),
					(s = a);
			}
		return new J(r, o);
	}
	cutByIndex(e, n) {
		return e == n
			? J.empty
			: e == 0 && n == this.content.length
			? this
			: new J(this.content.slice(e, n));
	}
	replaceChild(e, n) {
		let r = this.content[e];
		if (r == n) return this;
		let o = this.content.slice(),
			i = this.size + n.nodeSize - r.nodeSize;
		return (o[e] = n), new J(o, i);
	}
	addToStart(e) {
		return new J([e].concat(this.content), this.size + e.nodeSize);
	}
	addToEnd(e) {
		return new J(this.content.concat(e), this.size + e.nodeSize);
	}
	eq(e) {
		if (this.content.length != e.content.length) return !1;
		for (let n = 0; n < this.content.length; n++)
			if (!this.content[n].eq(e.content[n])) return !1;
		return !0;
	}
	get firstChild() {
		return this.content.length ? this.content[0] : null;
	}
	get lastChild() {
		return this.content.length
			? this.content[this.content.length - 1]
			: null;
	}
	get childCount() {
		return this.content.length;
	}
	child(e) {
		let n = this.content[e];
		if (!n)
			throw new RangeError("Index " + e + " out of range for " + this);
		return n;
	}
	maybeChild(e) {
		return this.content[e] || null;
	}
	forEach(e) {
		for (let n = 0, r = 0; n < this.content.length; n++) {
			let o = this.content[n];
			e(o, r, n), (r += o.nodeSize);
		}
	}
	findDiffStart(e, n = 0) {
		return qy(this, e, n);
	}
	findDiffEnd(e, n = this.size, r = e.size) {
		return Jy(this, e, n, r);
	}
	findIndex(e, n = -1) {
		if (e == 0) return Ml(0, e);
		if (e == this.size) return Ml(this.content.length, e);
		if (e > this.size || e < 0)
			throw new RangeError(`Position ${e} outside of fragment (${this})`);
		for (let r = 0, o = 0; ; r++) {
			let i = this.child(r),
				s = o + i.nodeSize;
			if (s >= e) return s == e || n > 0 ? Ml(r + 1, s) : Ml(r, o);
			o = s;
		}
	}
	toString() {
		return "<" + this.toStringInner() + ">";
	}
	toStringInner() {
		return this.content.join(", ");
	}
	toJSON() {
		return this.content.length ? this.content.map((e) => e.toJSON()) : null;
	}
	static fromJSON(e, n) {
		if (!n) return J.empty;
		if (!Array.isArray(n))
			throw new RangeError("Invalid input for Fragment.fromJSON");
		return new J(n.map(e.nodeFromJSON));
	}
	static fromArray(e) {
		if (!e.length) return J.empty;
		let n,
			r = 0;
		for (let o = 0; o < e.length; o++) {
			let i = e[o];
			(r += i.nodeSize),
				o && i.isText && e[o - 1].sameMarkup(i)
					? (n || (n = e.slice(0, o)),
					  (n[n.length - 1] = i.withText(
							n[n.length - 1].text + i.text
					  )))
					: n && n.push(i);
		}
		return new J(n || e, r);
	}
	static from(e) {
		if (!e) return J.empty;
		if (e instanceof J) return e;
		if (Array.isArray(e)) return this.fromArray(e);
		if (e.attrs) return new J([e], e.nodeSize);
		throw new RangeError(
			"Can not convert " +
				e +
				" to a Fragment" +
				(e.nodesBetween
					? " (looks like multiple versions of prosemirror-model were loaded)"
					: "")
		);
	}
}
J.empty = new J([], 0);
const Mc = { index: 0, offset: 0 };
function Ml(t, e) {
	return (Mc.index = t), (Mc.offset = e), Mc;
}
function xa(t, e) {
	if (t === e) return !0;
	if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
	let n = Array.isArray(t);
	if (Array.isArray(e) != n) return !1;
	if (n) {
		if (t.length != e.length) return !1;
		for (let r = 0; r < t.length; r++) if (!xa(t[r], e[r])) return !1;
	} else {
		for (let r in t) if (!(r in e) || !xa(t[r], e[r])) return !1;
		for (let r in e) if (!(r in t)) return !1;
	}
	return !0;
}
let ot = class Dd {
	constructor(e, n) {
		(this.type = e), (this.attrs = n);
	}
	addToSet(e) {
		let n,
			r = !1;
		for (let o = 0; o < e.length; o++) {
			let i = e[o];
			if (this.eq(i)) return e;
			if (this.type.excludes(i.type)) n || (n = e.slice(0, o));
			else {
				if (i.type.excludes(this.type)) return e;
				!r &&
					i.type.rank > this.type.rank &&
					(n || (n = e.slice(0, o)), n.push(this), (r = !0)),
					n && n.push(i);
			}
		}
		return n || (n = e.slice()), r || n.push(this), n;
	}
	removeFromSet(e) {
		for (let n = 0; n < e.length; n++)
			if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
		return !1;
	}
	eq(e) {
		return this == e || (this.type == e.type && xa(this.attrs, e.attrs));
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return e;
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
		let r = e.marks[n.type];
		if (!r)
			throw new RangeError(
				`There is no mark type ${n.type} in this schema`
			);
		return r.create(n.attrs);
	}
	static sameSet(e, n) {
		if (e == n) return !0;
		if (e.length != n.length) return !1;
		for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
		return !0;
	}
	static setFrom(e) {
		if (!e || (Array.isArray(e) && e.length == 0)) return Dd.none;
		if (e instanceof Dd) return [e];
		let n = e.slice();
		return n.sort((r, o) => r.type.rank - o.type.rank), n;
	}
};
ot.none = [];
class ka extends Error {}
class le {
	constructor(e, n, r) {
		(this.content = e), (this.openStart = n), (this.openEnd = r);
	}
	get size() {
		return this.content.size - this.openStart - this.openEnd;
	}
	insertAt(e, n) {
		let r = Yy(this.content, e + this.openStart, n);
		return r && new le(r, this.openStart, this.openEnd);
	}
	removeBetween(e, n) {
		return new le(
			Gy(this.content, e + this.openStart, n + this.openStart),
			this.openStart,
			this.openEnd
		);
	}
	eq(e) {
		return (
			this.content.eq(e.content) &&
			this.openStart == e.openStart &&
			this.openEnd == e.openEnd
		);
	}
	toString() {
		return this.content + "(" + this.openStart + "," + this.openEnd + ")";
	}
	toJSON() {
		if (!this.content.size) return null;
		let e = { content: this.content.toJSON() };
		return (
			this.openStart > 0 && (e.openStart = this.openStart),
			this.openEnd > 0 && (e.openEnd = this.openEnd),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) return le.empty;
		let r = n.openStart || 0,
			o = n.openEnd || 0;
		if (typeof r != "number" || typeof o != "number")
			throw new RangeError("Invalid input for Slice.fromJSON");
		return new le(J.fromJSON(e, n.content), r, o);
	}
	static maxOpen(e, n = !0) {
		let r = 0,
			o = 0;
		for (
			let i = e.firstChild;
			i && !i.isLeaf && (n || !i.type.spec.isolating);
			i = i.firstChild
		)
			r++;
		for (
			let i = e.lastChild;
			i && !i.isLeaf && (n || !i.type.spec.isolating);
			i = i.lastChild
		)
			o++;
		return new le(e, r, o);
	}
}
le.empty = new le(J.empty, 0, 0);
function Gy(t, e, n) {
	let { index: r, offset: o } = t.findIndex(e),
		i = t.maybeChild(r),
		{ index: s, offset: l } = t.findIndex(n);
	if (o == e || i.isText) {
		if (l != n && !t.child(s).isText)
			throw new RangeError("Removing non-flat range");
		return t.cut(0, e).append(t.cut(n));
	}
	if (r != s) throw new RangeError("Removing non-flat range");
	return t.replaceChild(r, i.copy(Gy(i.content, e - o - 1, n - o - 1)));
}
function Yy(t, e, n, r) {
	let { index: o, offset: i } = t.findIndex(e),
		s = t.maybeChild(o);
	if (i == e || s.isText)
		return r && !r.canReplace(o, o, n)
			? null
			: t.cut(0, e).append(n).append(t.cut(e));
	let l = Yy(s.content, e - i - 1, n);
	return l && t.replaceChild(o, s.copy(l));
}
function JC(t, e, n) {
	if (n.openStart > t.depth)
		throw new ka("Inserted content deeper than insertion position");
	if (t.depth - n.openStart != e.depth - n.openEnd)
		throw new ka("Inconsistent open depths");
	return Qy(t, e, n, 0);
}
function Qy(t, e, n, r) {
	let o = t.index(r),
		i = t.node(r);
	if (o == e.index(r) && r < t.depth - n.openStart) {
		let s = Qy(t, e, n, r + 1);
		return i.copy(i.content.replaceChild(o, s));
	} else if (n.content.size)
		if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
			let s = t.parent,
				l = s.content;
			return No(
				s,
				l
					.cut(0, t.parentOffset)
					.append(n.content)
					.append(l.cut(e.parentOffset))
			);
		} else {
			let { start: s, end: l } = GC(n, t);
			return No(i, Zy(t, s, l, e, r));
		}
	else return No(i, Sa(t, e, r));
}
function Xy(t, e) {
	if (!e.type.compatibleContent(t.type))
		throw new ka("Cannot join " + e.type.name + " onto " + t.type.name);
}
function jd(t, e, n) {
	let r = t.node(n);
	return Xy(r, e.node(n)), r;
}
function Io(t, e) {
	let n = e.length - 1;
	n >= 0 && t.isText && t.sameMarkup(e[n])
		? (e[n] = t.withText(e[n].text + t.text))
		: e.push(t);
}
function ps(t, e, n, r) {
	let o = (e || t).node(n),
		i = 0,
		s = e ? e.index(n) : o.childCount;
	t &&
		((i = t.index(n)),
		t.depth > n ? i++ : t.textOffset && (Io(t.nodeAfter, r), i++));
	for (let l = i; l < s; l++) Io(o.child(l), r);
	e && e.depth == n && e.textOffset && Io(e.nodeBefore, r);
}
function No(t, e) {
	return t.type.checkContent(e), t.copy(e);
}
function Zy(t, e, n, r, o) {
	let i = t.depth > o && jd(t, e, o + 1),
		s = r.depth > o && jd(n, r, o + 1),
		l = [];
	return (
		ps(null, t, o, l),
		i && s && e.index(o) == n.index(o)
			? (Xy(i, s), Io(No(i, Zy(t, e, n, r, o + 1)), l))
			: (i && Io(No(i, Sa(t, e, o + 1)), l),
			  ps(e, n, o, l),
			  s && Io(No(s, Sa(n, r, o + 1)), l)),
		ps(r, null, o, l),
		new J(l)
	);
}
function Sa(t, e, n) {
	let r = [];
	if ((ps(null, t, n, r), t.depth > n)) {
		let o = jd(t, e, n + 1);
		Io(No(o, Sa(t, e, n + 1)), r);
	}
	return ps(e, null, n, r), new J(r);
}
function GC(t, e) {
	let n = e.depth - t.openStart,
		o = e.node(n).copy(t.content);
	for (let i = n - 1; i >= 0; i--) o = e.node(i).copy(J.from(o));
	return {
		start: o.resolveNoCache(t.openStart + n),
		end: o.resolveNoCache(o.content.size - t.openEnd - n),
	};
}
class Ns {
	constructor(e, n, r) {
		(this.pos = e),
			(this.path = n),
			(this.parentOffset = r),
			(this.depth = n.length / 3 - 1);
	}
	resolveDepth(e) {
		return e == null ? this.depth : e < 0 ? this.depth + e : e;
	}
	get parent() {
		return this.node(this.depth);
	}
	get doc() {
		return this.node(0);
	}
	node(e) {
		return this.path[this.resolveDepth(e) * 3];
	}
	index(e) {
		return this.path[this.resolveDepth(e) * 3 + 1];
	}
	indexAfter(e) {
		return (
			(e = this.resolveDepth(e)),
			this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
		);
	}
	start(e) {
		return (
			(e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1
		);
	}
	end(e) {
		return (
			(e = this.resolveDepth(e)),
			this.start(e) + this.node(e).content.size
		);
	}
	before(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position before the top-level node"
			);
		return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
	}
	after(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position after the top-level node"
			);
		return e == this.depth + 1
			? this.pos
			: this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
	}
	get textOffset() {
		return this.pos - this.path[this.path.length - 1];
	}
	get nodeAfter() {
		let e = this.parent,
			n = this.index(this.depth);
		if (n == e.childCount) return null;
		let r = this.pos - this.path[this.path.length - 1],
			o = e.child(n);
		return r ? e.child(n).cut(r) : o;
	}
	get nodeBefore() {
		let e = this.index(this.depth),
			n = this.pos - this.path[this.path.length - 1];
		return n
			? this.parent.child(e).cut(0, n)
			: e == 0
			? null
			: this.parent.child(e - 1);
	}
	posAtIndex(e, n) {
		n = this.resolveDepth(n);
		let r = this.path[n * 3],
			o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
		for (let i = 0; i < e; i++) o += r.child(i).nodeSize;
		return o;
	}
	marks() {
		let e = this.parent,
			n = this.index();
		if (e.content.size == 0) return ot.none;
		if (this.textOffset) return e.child(n).marks;
		let r = e.maybeChild(n - 1),
			o = e.maybeChild(n);
		if (!r) {
			let l = r;
			(r = o), (o = l);
		}
		let i = r.marks;
		for (var s = 0; s < i.length; s++)
			i[s].type.spec.inclusive === !1 &&
				(!o || !i[s].isInSet(o.marks)) &&
				(i = i[s--].removeFromSet(i));
		return i;
	}
	marksAcross(e) {
		let n = this.parent.maybeChild(this.index());
		if (!n || !n.isInline) return null;
		let r = n.marks,
			o = e.parent.maybeChild(e.index());
		for (var i = 0; i < r.length; i++)
			r[i].type.spec.inclusive === !1 &&
				(!o || !r[i].isInSet(o.marks)) &&
				(r = r[i--].removeFromSet(r));
		return r;
	}
	sharedDepth(e) {
		for (let n = this.depth; n > 0; n--)
			if (this.start(n) <= e && this.end(n) >= e) return n;
		return 0;
	}
	blockRange(e = this, n) {
		if (e.pos < this.pos) return e.blockRange(this);
		for (
			let r =
				this.depth -
				(this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
			r >= 0;
			r--
		)
			if (e.pos <= this.end(r) && (!n || n(this.node(r))))
				return new _a(this, e, r);
		return null;
	}
	sameParent(e) {
		return this.pos - this.parentOffset == e.pos - e.parentOffset;
	}
	max(e) {
		return e.pos > this.pos ? e : this;
	}
	min(e) {
		return e.pos < this.pos ? e : this;
	}
	toString() {
		let e = "";
		for (let n = 1; n <= this.depth; n++)
			e +=
				(e ? "/" : "") +
				this.node(n).type.name +
				"_" +
				this.index(n - 1);
		return e + ":" + this.parentOffset;
	}
	static resolve(e, n) {
		if (!(n >= 0 && n <= e.content.size))
			throw new RangeError("Position " + n + " out of range");
		let r = [],
			o = 0,
			i = n;
		for (let s = e; ; ) {
			let { index: l, offset: a } = s.content.findIndex(i),
				u = i - a;
			if ((r.push(s, l, o + a), !u || ((s = s.child(l)), s.isText)))
				break;
			(i = u - 1), (o += a + 1);
		}
		return new Ns(n, r, i);
	}
	static resolveCached(e, n) {
		for (let o = 0; o < Ec.length; o++) {
			let i = Ec[o];
			if (i.pos == n && i.doc == e) return i;
		}
		let r = (Ec[Tc] = Ns.resolve(e, n));
		return (Tc = (Tc + 1) % YC), r;
	}
}
let Ec = [],
	Tc = 0,
	YC = 12;
class _a {
	constructor(e, n, r) {
		(this.$from = e), (this.$to = n), (this.depth = r);
	}
	get start() {
		return this.$from.before(this.depth + 1);
	}
	get end() {
		return this.$to.after(this.depth + 1);
	}
	get parent() {
		return this.$from.node(this.depth);
	}
	get startIndex() {
		return this.$from.index(this.depth);
	}
	get endIndex() {
		return this.$to.indexAfter(this.depth);
	}
}
const QC = Object.create(null);
let Do = class Ld {
	constructor(e, n, r, o = ot.none) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = o),
			(this.content = r || J.empty);
	}
	get nodeSize() {
		return this.isLeaf ? 1 : 2 + this.content.size;
	}
	get childCount() {
		return this.content.childCount;
	}
	child(e) {
		return this.content.child(e);
	}
	maybeChild(e) {
		return this.content.maybeChild(e);
	}
	forEach(e) {
		this.content.forEach(e);
	}
	nodesBetween(e, n, r, o = 0) {
		this.content.nodesBetween(e, n, r, o, this);
	}
	descendants(e) {
		this.nodesBetween(0, this.content.size, e);
	}
	get textContent() {
		return this.isLeaf && this.type.spec.leafText
			? this.type.spec.leafText(this)
			: this.textBetween(0, this.content.size, "");
	}
	textBetween(e, n, r, o) {
		return this.content.textBetween(e, n, r, o);
	}
	get firstChild() {
		return this.content.firstChild;
	}
	get lastChild() {
		return this.content.lastChild;
	}
	eq(e) {
		return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
	}
	sameMarkup(e) {
		return this.hasMarkup(e.type, e.attrs, e.marks);
	}
	hasMarkup(e, n, r) {
		return (
			this.type == e &&
			xa(this.attrs, n || e.defaultAttrs || QC) &&
			ot.sameSet(this.marks, r || ot.none)
		);
	}
	copy(e = null) {
		return e == this.content
			? this
			: new Ld(this.type, this.attrs, e, this.marks);
	}
	mark(e) {
		return e == this.marks
			? this
			: new Ld(this.type, this.attrs, this.content, e);
	}
	cut(e, n = this.content.size) {
		return e == 0 && n == this.content.size
			? this
			: this.copy(this.content.cut(e, n));
	}
	slice(e, n = this.content.size, r = !1) {
		if (e == n) return le.empty;
		let o = this.resolve(e),
			i = this.resolve(n),
			s = r ? 0 : o.sharedDepth(n),
			l = o.start(s),
			u = o.node(s).content.cut(o.pos - l, i.pos - l);
		return new le(u, o.depth - s, i.depth - s);
	}
	replace(e, n, r) {
		return JC(this.resolve(e), this.resolve(n), r);
	}
	nodeAt(e) {
		for (let n = this; ; ) {
			let { index: r, offset: o } = n.content.findIndex(e);
			if (((n = n.maybeChild(r)), !n)) return null;
			if (o == e || n.isText) return n;
			e -= o + 1;
		}
	}
	childAfter(e) {
		let { index: n, offset: r } = this.content.findIndex(e);
		return { node: this.content.maybeChild(n), index: n, offset: r };
	}
	childBefore(e) {
		if (e == 0) return { node: null, index: 0, offset: 0 };
		let { index: n, offset: r } = this.content.findIndex(e);
		if (r < e) return { node: this.content.child(n), index: n, offset: r };
		let o = this.content.child(n - 1);
		return { node: o, index: n - 1, offset: r - o.nodeSize };
	}
	resolve(e) {
		return Ns.resolveCached(this, e);
	}
	resolveNoCache(e) {
		return Ns.resolve(this, e);
	}
	rangeHasMark(e, n, r) {
		let o = !1;
		return (
			n > e &&
				this.nodesBetween(
					e,
					n,
					(i) => (r.isInSet(i.marks) && (o = !0), !o)
				),
			o
		);
	}
	get isBlock() {
		return this.type.isBlock;
	}
	get isTextblock() {
		return this.type.isTextblock;
	}
	get inlineContent() {
		return this.type.inlineContent;
	}
	get isInline() {
		return this.type.isInline;
	}
	get isText() {
		return this.type.isText;
	}
	get isLeaf() {
		return this.type.isLeaf;
	}
	get isAtom() {
		return this.type.isAtom;
	}
	toString() {
		if (this.type.spec.toDebugString)
			return this.type.spec.toDebugString(this);
		let e = this.type.name;
		return (
			this.content.size &&
				(e += "(" + this.content.toStringInner() + ")"),
			ev(this.marks, e)
		);
	}
	contentMatchAt(e) {
		let n = this.type.contentMatch.matchFragment(this.content, 0, e);
		if (!n)
			throw new Error(
				"Called contentMatchAt on a node with invalid content"
			);
		return n;
	}
	canReplace(e, n, r = J.empty, o = 0, i = r.childCount) {
		let s = this.contentMatchAt(e).matchFragment(r, o, i),
			l = s && s.matchFragment(this.content, n);
		if (!l || !l.validEnd) return !1;
		for (let a = o; a < i; a++)
			if (!this.type.allowsMarks(r.child(a).marks)) return !1;
		return !0;
	}
	canReplaceWith(e, n, r, o) {
		if (o && !this.type.allowsMarks(o)) return !1;
		let i = this.contentMatchAt(e).matchType(r),
			s = i && i.matchFragment(this.content, n);
		return s ? s.validEnd : !1;
	}
	canAppend(e) {
		return e.content.size
			? this.canReplace(this.childCount, this.childCount, e.content)
			: this.type.compatibleContent(e.type);
	}
	check() {
		this.type.checkContent(this.content);
		let e = ot.none;
		for (let n = 0; n < this.marks.length; n++)
			e = this.marks[n].addToSet(e);
		if (!ot.sameSet(e, this.marks))
			throw new RangeError(
				`Invalid collection of marks for node ${
					this.type.name
				}: ${this.marks.map((n) => n.type.name)}`
			);
		this.content.forEach((n) => n.check());
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return (
			this.content.size && (e.content = this.content.toJSON()),
			this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Node.fromJSON");
		let r = null;
		if (n.marks) {
			if (!Array.isArray(n.marks))
				throw new RangeError("Invalid mark data for Node.fromJSON");
			r = n.marks.map(e.markFromJSON);
		}
		if (n.type == "text") {
			if (typeof n.text != "string")
				throw new RangeError("Invalid text node in JSON");
			return e.text(n.text, r);
		}
		let o = J.fromJSON(e, n.content);
		return e.nodeType(n.type).create(n.attrs, o, r);
	}
};
Do.prototype.text = void 0;
class Ca extends Do {
	constructor(e, n, r, o) {
		if ((super(e, n, null, o), !r))
			throw new RangeError("Empty text nodes are not allowed");
		this.text = r;
	}
	toString() {
		return this.type.spec.toDebugString
			? this.type.spec.toDebugString(this)
			: ev(this.marks, JSON.stringify(this.text));
	}
	get textContent() {
		return this.text;
	}
	textBetween(e, n) {
		return this.text.slice(e, n);
	}
	get nodeSize() {
		return this.text.length;
	}
	mark(e) {
		return e == this.marks
			? this
			: new Ca(this.type, this.attrs, this.text, e);
	}
	withText(e) {
		return e == this.text
			? this
			: new Ca(this.type, this.attrs, e, this.marks);
	}
	cut(e = 0, n = this.text.length) {
		return e == 0 && n == this.text.length
			? this
			: this.withText(this.text.slice(e, n));
	}
	eq(e) {
		return this.sameMarkup(e) && this.text == e.text;
	}
	toJSON() {
		let e = super.toJSON();
		return (e.text = this.text), e;
	}
}
function ev(t, e) {
	for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
	return e;
}
class zo {
	constructor(e) {
		(this.validEnd = e), (this.next = []), (this.wrapCache = []);
	}
	static parse(e, n) {
		let r = new XC(e, n);
		if (r.next == null) return zo.empty;
		let o = tv(r);
		r.next && r.err("Unexpected trailing text");
		let i = iM(oM(o));
		return sM(i, r), i;
	}
	matchType(e) {
		for (let n = 0; n < this.next.length; n++)
			if (this.next[n].type == e) return this.next[n].next;
		return null;
	}
	matchFragment(e, n = 0, r = e.childCount) {
		let o = this;
		for (let i = n; o && i < r; i++) o = o.matchType(e.child(i).type);
		return o;
	}
	get inlineContent() {
		return this.next.length != 0 && this.next[0].type.isInline;
	}
	get defaultType() {
		for (let e = 0; e < this.next.length; e++) {
			let { type: n } = this.next[e];
			if (!(n.isText || n.hasRequiredAttrs())) return n;
		}
		return null;
	}
	compatible(e) {
		for (let n = 0; n < this.next.length; n++)
			for (let r = 0; r < e.next.length; r++)
				if (this.next[n].type == e.next[r].type) return !0;
		return !1;
	}
	fillBefore(e, n = !1, r = 0) {
		let o = [this];
		function i(s, l) {
			let a = s.matchFragment(e, r);
			if (a && (!n || a.validEnd))
				return J.from(l.map((u) => u.createAndFill()));
			for (let u = 0; u < s.next.length; u++) {
				let { type: c, next: d } = s.next[u];
				if (!(c.isText || c.hasRequiredAttrs()) && o.indexOf(d) == -1) {
					o.push(d);
					let f = i(d, l.concat(c));
					if (f) return f;
				}
			}
			return null;
		}
		return i(this, []);
	}
	findWrapping(e) {
		for (let r = 0; r < this.wrapCache.length; r += 2)
			if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
		let n = this.computeWrapping(e);
		return this.wrapCache.push(e, n), n;
	}
	computeWrapping(e) {
		let n = Object.create(null),
			r = [{ match: this, type: null, via: null }];
		for (; r.length; ) {
			let o = r.shift(),
				i = o.match;
			if (i.matchType(e)) {
				let s = [];
				for (let l = o; l.type; l = l.via) s.push(l.type);
				return s.reverse();
			}
			for (let s = 0; s < i.next.length; s++) {
				let { type: l, next: a } = i.next[s];
				!l.isLeaf &&
					!l.hasRequiredAttrs() &&
					!(l.name in n) &&
					(!o.type || a.validEnd) &&
					(r.push({ match: l.contentMatch, type: l, via: o }),
					(n[l.name] = !0));
			}
		}
		return null;
	}
	get edgeCount() {
		return this.next.length;
	}
	edge(e) {
		if (e >= this.next.length)
			throw new RangeError(
				`There's no ${e}th edge in this content match`
			);
		return this.next[e];
	}
	toString() {
		let e = [];
		function n(r) {
			e.push(r);
			for (let o = 0; o < r.next.length; o++)
				e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
		}
		return (
			n(this),
			e.map((r, o) => {
				let i = o + (r.validEnd ? "*" : " ") + " ";
				for (let s = 0; s < r.next.length; s++)
					i +=
						(s ? ", " : "") +
						r.next[s].type.name +
						"->" +
						e.indexOf(r.next[s].next);
				return i;
			}).join(`
`)
		);
	}
}
zo.empty = new zo(!0);
class XC {
	constructor(e, n) {
		(this.string = e),
			(this.nodeTypes = n),
			(this.inline = null),
			(this.pos = 0),
			(this.tokens = e.split(/\s*(?=\b|\W|$)/)),
			this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
			this.tokens[0] == "" && this.tokens.shift();
	}
	get next() {
		return this.tokens[this.pos];
	}
	eat(e) {
		return this.next == e && (this.pos++ || !0);
	}
	err(e) {
		throw new SyntaxError(
			e + " (in content expression '" + this.string + "')"
		);
	}
}
function tv(t) {
	let e = [];
	do e.push(ZC(t));
	while (t.eat("|"));
	return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function ZC(t) {
	let e = [];
	do e.push(eM(t));
	while (t.next && t.next != ")" && t.next != "|");
	return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function eM(t) {
	let e = rM(t);
	for (;;)
		if (t.eat("+")) e = { type: "plus", expr: e };
		else if (t.eat("*")) e = { type: "star", expr: e };
		else if (t.eat("?")) e = { type: "opt", expr: e };
		else if (t.eat("{")) e = tM(t, e);
		else break;
	return e;
}
function Mm(t) {
	/\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
	let e = Number(t.next);
	return t.pos++, e;
}
function tM(t, e) {
	let n = Mm(t),
		r = n;
	return (
		t.eat(",") && (t.next != "}" ? (r = Mm(t)) : (r = -1)),
		t.eat("}") || t.err("Unclosed braced range"),
		{ type: "range", min: n, max: r, expr: e }
	);
}
function nM(t, e) {
	let n = t.nodeTypes,
		r = n[e];
	if (r) return [r];
	let o = [];
	for (let i in n) {
		let s = n[i];
		s.groups.indexOf(e) > -1 && o.push(s);
	}
	return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function rM(t) {
	if (t.eat("(")) {
		let e = tv(t);
		return t.eat(")") || t.err("Missing closing paren"), e;
	} else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
	else {
		let e = nM(t, t.next).map(
			(n) => (
				t.inline == null
					? (t.inline = n.isInline)
					: t.inline != n.isInline &&
					  t.err("Mixing inline and block content"),
				{ type: "name", value: n }
			)
		);
		return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
	}
}
function oM(t) {
	let e = [[]];
	return o(i(t, 0), n()), e;
	function n() {
		return e.push([]) - 1;
	}
	function r(s, l, a) {
		let u = { term: a, to: l };
		return e[s].push(u), u;
	}
	function o(s, l) {
		s.forEach((a) => (a.to = l));
	}
	function i(s, l) {
		if (s.type == "choice")
			return s.exprs.reduce((a, u) => a.concat(i(u, l)), []);
		if (s.type == "seq")
			for (let a = 0; ; a++) {
				let u = i(s.exprs[a], l);
				if (a == s.exprs.length - 1) return u;
				o(u, (l = n()));
			}
		else if (s.type == "star") {
			let a = n();
			return r(l, a), o(i(s.expr, a), a), [r(a)];
		} else if (s.type == "plus") {
			let a = n();
			return o(i(s.expr, l), a), o(i(s.expr, a), a), [r(a)];
		} else {
			if (s.type == "opt") return [r(l)].concat(i(s.expr, l));
			if (s.type == "range") {
				let a = l;
				for (let u = 0; u < s.min; u++) {
					let c = n();
					o(i(s.expr, a), c), (a = c);
				}
				if (s.max == -1) o(i(s.expr, a), a);
				else
					for (let u = s.min; u < s.max; u++) {
						let c = n();
						r(a, c), o(i(s.expr, a), c), (a = c);
					}
				return [r(a)];
			} else {
				if (s.type == "name") return [r(l, void 0, s.value)];
				throw new Error("Unknown expr type");
			}
		}
	}
}
function nv(t, e) {
	return e - t;
}
function Em(t, e) {
	let n = [];
	return r(e), n.sort(nv);
	function r(o) {
		let i = t[o];
		if (i.length == 1 && !i[0].term) return r(i[0].to);
		n.push(o);
		for (let s = 0; s < i.length; s++) {
			let { term: l, to: a } = i[s];
			!l && n.indexOf(a) == -1 && r(a);
		}
	}
}
function iM(t) {
	let e = Object.create(null);
	return n(Em(t, 0));
	function n(r) {
		let o = [];
		r.forEach((s) => {
			t[s].forEach(({ term: l, to: a }) => {
				if (!l) return;
				let u;
				for (let c = 0; c < o.length; c++)
					o[c][0] == l && (u = o[c][1]);
				Em(t, a).forEach((c) => {
					u || o.push([l, (u = [])]), u.indexOf(c) == -1 && u.push(c);
				});
			});
		});
		let i = (e[r.join(",")] = new zo(r.indexOf(t.length - 1) > -1));
		for (let s = 0; s < o.length; s++) {
			let l = o[s][1].sort(nv);
			i.next.push({ type: o[s][0], next: e[l.join(",")] || n(l) });
		}
		return i;
	}
}
function sM(t, e) {
	for (let n = 0, r = [t]; n < r.length; n++) {
		let o = r[n],
			i = !o.validEnd,
			s = [];
		for (let l = 0; l < o.next.length; l++) {
			let { type: a, next: u } = o.next[l];
			s.push(a.name),
				i && !(a.isText || a.hasRequiredAttrs()) && (i = !1),
				r.indexOf(u) == -1 && r.push(u);
		}
		i &&
			e.err(
				"Only non-generatable nodes (" +
					s.join(", ") +
					") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
			);
	}
}
function rv(t) {
	let e = Object.create(null);
	for (let n in t) {
		let r = t[n];
		if (!r.hasDefault) return null;
		e[n] = r.default;
	}
	return e;
}
function ov(t, e) {
	let n = Object.create(null);
	for (let r in t) {
		let o = e && e[r];
		if (o === void 0) {
			let i = t[r];
			if (i.hasDefault) o = i.default;
			else throw new RangeError("No value supplied for attribute " + r);
		}
		n[r] = o;
	}
	return n;
}
function iv(t) {
	let e = Object.create(null);
	if (t) for (let n in t) e[n] = new lM(t[n]);
	return e;
}
let Tm = class sv {
	constructor(e, n, r) {
		(this.name = e),
			(this.schema = n),
			(this.spec = r),
			(this.markSet = null),
			(this.groups = r.group ? r.group.split(" ") : []),
			(this.attrs = iv(r.attrs)),
			(this.defaultAttrs = rv(this.attrs)),
			(this.contentMatch = null),
			(this.inlineContent = null),
			(this.isBlock = !(r.inline || e == "text")),
			(this.isText = e == "text");
	}
	get isInline() {
		return !this.isBlock;
	}
	get isTextblock() {
		return this.isBlock && this.inlineContent;
	}
	get isLeaf() {
		return this.contentMatch == zo.empty;
	}
	get isAtom() {
		return this.isLeaf || !!this.spec.atom;
	}
	get whitespace() {
		return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
	}
	hasRequiredAttrs() {
		for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
		return !1;
	}
	compatibleContent(e) {
		return this == e || this.contentMatch.compatible(e.contentMatch);
	}
	computeAttrs(e) {
		return !e && this.defaultAttrs ? this.defaultAttrs : ov(this.attrs, e);
	}
	create(e = null, n, r) {
		if (this.isText)
			throw new Error("NodeType.create can't construct text nodes");
		return new Do(this, this.computeAttrs(e), J.from(n), ot.setFrom(r));
	}
	createChecked(e = null, n, r) {
		return (
			(n = J.from(n)),
			this.checkContent(n),
			new Do(this, this.computeAttrs(e), n, ot.setFrom(r))
		);
	}
	createAndFill(e = null, n, r) {
		if (((e = this.computeAttrs(e)), (n = J.from(n)), n.size)) {
			let s = this.contentMatch.fillBefore(n);
			if (!s) return null;
			n = s.append(n);
		}
		let o = this.contentMatch.matchFragment(n),
			i = o && o.fillBefore(J.empty, !0);
		return i ? new Do(this, e, n.append(i), ot.setFrom(r)) : null;
	}
	validContent(e) {
		let n = this.contentMatch.matchFragment(e);
		if (!n || !n.validEnd) return !1;
		for (let r = 0; r < e.childCount; r++)
			if (!this.allowsMarks(e.child(r).marks)) return !1;
		return !0;
	}
	checkContent(e) {
		if (!this.validContent(e))
			throw new RangeError(
				`Invalid content for node ${this.name}: ${e
					.toString()
					.slice(0, 50)}`
			);
	}
	allowsMarkType(e) {
		return this.markSet == null || this.markSet.indexOf(e) > -1;
	}
	allowsMarks(e) {
		if (this.markSet == null) return !0;
		for (let n = 0; n < e.length; n++)
			if (!this.allowsMarkType(e[n].type)) return !1;
		return !0;
	}
	allowedMarks(e) {
		if (this.markSet == null) return e;
		let n;
		for (let r = 0; r < e.length; r++)
			this.allowsMarkType(e[r].type)
				? n && n.push(e[r])
				: n || (n = e.slice(0, r));
		return n ? (n.length ? n : ot.none) : e;
	}
	static compile(e, n) {
		let r = Object.create(null);
		e.forEach((i, s) => (r[i] = new sv(i, n, s)));
		let o = n.spec.topNode || "doc";
		if (!r[o])
			throw new RangeError(
				"Schema is missing its top node type ('" + o + "')"
			);
		if (!r.text) throw new RangeError("Every schema needs a 'text' type");
		for (let i in r.text.attrs)
			throw new RangeError(
				"The text node type should not have attributes"
			);
		return r;
	}
};
class lM {
	constructor(e) {
		(this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default")),
			(this.default = e.default);
	}
	get isRequired() {
		return !this.hasDefault;
	}
}
class Bu {
	constructor(e, n, r, o) {
		(this.name = e),
			(this.rank = n),
			(this.schema = r),
			(this.spec = o),
			(this.attrs = iv(o.attrs)),
			(this.excluded = null);
		let i = rv(this.attrs);
		this.instance = i ? new ot(this, i) : null;
	}
	create(e = null) {
		return !e && this.instance
			? this.instance
			: new ot(this, ov(this.attrs, e));
	}
	static compile(e, n) {
		let r = Object.create(null),
			o = 0;
		return e.forEach((i, s) => (r[i] = new Bu(i, o++, n, s))), r;
	}
	removeFromSet(e) {
		for (var n = 0; n < e.length; n++)
			e[n].type == this &&
				((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
	}
	excludes(e) {
		return this.excluded.indexOf(e) > -1;
	}
}
class aM {
	constructor(e) {
		this.cached = Object.create(null);
		let n = (this.spec = {});
		for (let o in e) n[o] = e[o];
		(n.nodes = Ft.from(e.nodes)),
			(n.marks = Ft.from(e.marks || {})),
			(this.nodes = Tm.compile(this.spec.nodes, this)),
			(this.marks = Bu.compile(this.spec.marks, this));
		let r = Object.create(null);
		for (let o in this.nodes) {
			if (o in this.marks)
				throw new RangeError(o + " can not be both a node and a mark");
			let i = this.nodes[o],
				s = i.spec.content || "",
				l = i.spec.marks;
			(i.contentMatch = r[s] || (r[s] = zo.parse(s, this.nodes))),
				(i.inlineContent = i.contentMatch.inlineContent),
				(i.markSet =
					l == "_"
						? null
						: l
						? Am(this, l.split(" "))
						: l == "" || !i.inlineContent
						? []
						: null);
		}
		for (let o in this.marks) {
			let i = this.marks[o],
				s = i.spec.excludes;
			i.excluded =
				s == null ? [i] : s == "" ? [] : Am(this, s.split(" "));
		}
		(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
			(this.markFromJSON = this.markFromJSON.bind(this)),
			(this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
			(this.cached.wrappings = Object.create(null));
	}
	node(e, n = null, r, o) {
		if (typeof e == "string") e = this.nodeType(e);
		else if (e instanceof Tm) {
			if (e.schema != this)
				throw new RangeError(
					"Node type from different schema used (" + e.name + ")"
				);
		} else throw new RangeError("Invalid node type: " + e);
		return e.createChecked(n, r, o);
	}
	text(e, n) {
		let r = this.nodes.text;
		return new Ca(r, r.defaultAttrs, e, ot.setFrom(n));
	}
	mark(e, n) {
		return typeof e == "string" && (e = this.marks[e]), e.create(n);
	}
	nodeFromJSON(e) {
		return Do.fromJSON(this, e);
	}
	markFromJSON(e) {
		return ot.fromJSON(this, e);
	}
	nodeType(e) {
		let n = this.nodes[e];
		if (!n) throw new RangeError("Unknown node type: " + e);
		return n;
	}
}
function Am(t, e) {
	let n = [];
	for (let r = 0; r < e.length; r++) {
		let o = e[r],
			i = t.marks[o],
			s = i;
		if (i) n.push(i);
		else
			for (let l in t.marks) {
				let a = t.marks[l];
				(o == "_" ||
					(a.spec.group &&
						a.spec.group.split(" ").indexOf(o) > -1)) &&
					n.push((s = a));
			}
		if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
	}
	return n;
}
let zu = class $d {
	constructor(e, n) {
		(this.schema = e),
			(this.rules = n),
			(this.tags = []),
			(this.styles = []),
			n.forEach((r) => {
				r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
			}),
			(this.normalizeLists = !this.tags.some((r) => {
				if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return !1;
				let o = e.nodes[r.node];
				return o.contentMatch.matchType(o);
			}));
	}
	parse(e, n = {}) {
		let r = new Rm(this, n, !1);
		return r.addAll(e, n.from, n.to), r.finish();
	}
	parseSlice(e, n = {}) {
		let r = new Rm(this, n, !0);
		return r.addAll(e, n.from, n.to), le.maxOpen(r.finish());
	}
	matchTag(e, n, r) {
		for (
			let o = r ? this.tags.indexOf(r) + 1 : 0;
			o < this.tags.length;
			o++
		) {
			let i = this.tags[o];
			if (
				dM(e, i.tag) &&
				(i.namespace === void 0 || e.namespaceURI == i.namespace) &&
				(!i.context || n.matchesContext(i.context))
			) {
				if (i.getAttrs) {
					let s = i.getAttrs(e);
					if (s === !1) continue;
					i.attrs = s || void 0;
				}
				return i;
			}
		}
	}
	matchStyle(e, n, r, o) {
		for (
			let i = o ? this.styles.indexOf(o) + 1 : 0;
			i < this.styles.length;
			i++
		) {
			let s = this.styles[i],
				l = s.style;
			if (
				!(
					l.indexOf(e) != 0 ||
					(s.context && !r.matchesContext(s.context)) ||
					(l.length > e.length &&
						(l.charCodeAt(e.length) != 61 ||
							l.slice(e.length + 1) != n))
				)
			) {
				if (s.getAttrs) {
					let a = s.getAttrs(n);
					if (a === !1) continue;
					s.attrs = a || void 0;
				}
				return s;
			}
		}
	}
	static schemaRules(e) {
		let n = [];
		function r(o) {
			let i = o.priority == null ? 50 : o.priority,
				s = 0;
			for (; s < n.length; s++) {
				let l = n[s];
				if ((l.priority == null ? 50 : l.priority) < i) break;
			}
			n.splice(s, 0, o);
		}
		for (let o in e.marks) {
			let i = e.marks[o].spec.parseDOM;
			i &&
				i.forEach((s) => {
					r((s = Pm(s))),
						s.mark || s.ignore || s.clearMark || (s.mark = o);
				});
		}
		for (let o in e.nodes) {
			let i = e.nodes[o].spec.parseDOM;
			i &&
				i.forEach((s) => {
					r((s = Pm(s))),
						s.node || s.ignore || s.mark || (s.node = o);
				});
		}
		return n;
	}
	static fromSchema(e) {
		return (
			e.cached.domParser ||
			(e.cached.domParser = new $d(e, $d.schemaRules(e)))
		);
	}
};
const lv = {
		address: !0,
		article: !0,
		aside: !0,
		blockquote: !0,
		canvas: !0,
		dd: !0,
		div: !0,
		dl: !0,
		fieldset: !0,
		figcaption: !0,
		figure: !0,
		footer: !0,
		form: !0,
		h1: !0,
		h2: !0,
		h3: !0,
		h4: !0,
		h5: !0,
		h6: !0,
		header: !0,
		hgroup: !0,
		hr: !0,
		li: !0,
		noscript: !0,
		ol: !0,
		output: !0,
		p: !0,
		pre: !0,
		section: !0,
		table: !0,
		tfoot: !0,
		ul: !0,
	},
	uM = {
		head: !0,
		noscript: !0,
		object: !0,
		script: !0,
		style: !0,
		title: !0,
	},
	av = { ol: !0, ul: !0 },
	Ma = 1,
	Ea = 2,
	ms = 4;
function Om(t, e, n) {
	return e != null
		? (e ? Ma : 0) | (e === "full" ? Ea : 0)
		: t && t.whitespace == "pre"
		? Ma | Ea
		: n & ~ms;
}
class El {
	constructor(e, n, r, o, i, s, l) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = r),
			(this.pendingMarks = o),
			(this.solid = i),
			(this.options = l),
			(this.content = []),
			(this.activeMarks = ot.none),
			(this.stashMarks = []),
			(this.match = s || (l & ms ? null : e.contentMatch));
	}
	findWrapping(e) {
		if (!this.match) {
			if (!this.type) return [];
			let n = this.type.contentMatch.fillBefore(J.from(e));
			if (n) this.match = this.type.contentMatch.matchFragment(n);
			else {
				let r = this.type.contentMatch,
					o;
				return (o = r.findWrapping(e.type))
					? ((this.match = r), o)
					: null;
			}
		}
		return this.match.findWrapping(e.type);
	}
	finish(e) {
		if (!(this.options & Ma)) {
			let r = this.content[this.content.length - 1],
				o;
			if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
				let i = r;
				r.text.length == o[0].length
					? this.content.pop()
					: (this.content[this.content.length - 1] = i.withText(
							i.text.slice(0, i.text.length - o[0].length)
					  ));
			}
		}
		let n = J.from(this.content);
		return (
			!e &&
				this.match &&
				(n = n.append(this.match.fillBefore(J.empty, !0))),
			this.type ? this.type.create(this.attrs, n, this.marks) : n
		);
	}
	popFromStashMark(e) {
		for (let n = this.stashMarks.length - 1; n >= 0; n--)
			if (e.eq(this.stashMarks[n]))
				return this.stashMarks.splice(n, 1)[0];
	}
	applyPending(e) {
		for (let n = 0, r = this.pendingMarks; n < r.length; n++) {
			let o = r[n];
			(this.type ? this.type.allowsMarkType(o.type) : hM(o.type, e)) &&
				!o.isInSet(this.activeMarks) &&
				((this.activeMarks = o.addToSet(this.activeMarks)),
				(this.pendingMarks = o.removeFromSet(this.pendingMarks)));
		}
	}
	inlineContext(e) {
		return this.type
			? this.type.inlineContent
			: this.content.length
			? this.content[0].isInline
			: e.parentNode &&
			  !lv.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
	}
}
class Rm {
	constructor(e, n, r) {
		(this.parser = e),
			(this.options = n),
			(this.isOpen = r),
			(this.open = 0);
		let o = n.topNode,
			i,
			s = Om(null, n.preserveWhitespace, 0) | (r ? ms : 0);
		o
			? (i = new El(
					o.type,
					o.attrs,
					ot.none,
					ot.none,
					!0,
					n.topMatch || o.type.contentMatch,
					s
			  ))
			: r
			? (i = new El(null, null, ot.none, ot.none, !0, null, s))
			: (i = new El(
					e.schema.topNodeType,
					null,
					ot.none,
					ot.none,
					!0,
					null,
					s
			  )),
			(this.nodes = [i]),
			(this.find = n.findPositions),
			(this.needsBlock = !1);
	}
	get top() {
		return this.nodes[this.open];
	}
	addDOM(e) {
		e.nodeType == 3
			? this.addTextNode(e)
			: e.nodeType == 1 && this.addElement(e);
	}
	withStyleRules(e, n) {
		let r = e.getAttribute("style");
		if (!r) return n();
		let o = this.readStyles(fM(r));
		if (!o) return;
		let [i, s] = o,
			l = this.top;
		for (let a = 0; a < s.length; a++) this.removePendingMark(s[a], l);
		for (let a = 0; a < i.length; a++) this.addPendingMark(i[a]);
		n();
		for (let a = 0; a < i.length; a++) this.removePendingMark(i[a], l);
		for (let a = 0; a < s.length; a++) this.addPendingMark(s[a]);
	}
	addTextNode(e) {
		let n = e.nodeValue,
			r = this.top;
		if (
			r.options & Ea ||
			r.inlineContext(e) ||
			/[^ \t\r\n\u000c]/.test(n)
		) {
			if (r.options & Ma)
				r.options & Ea
					? (n = n.replace(
							/\r\n?/g,
							`
`
					  ))
					: (n = n.replace(/\r?\n|\r/g, " "));
			else if (
				((n = n.replace(/[ \t\r\n\u000c]+/g, " ")),
				/^[ \t\r\n\u000c]/.test(n) &&
					this.open == this.nodes.length - 1)
			) {
				let o = r.content[r.content.length - 1],
					i = e.previousSibling;
				(!o ||
					(i && i.nodeName == "BR") ||
					(o.isText && /[ \t\r\n\u000c]$/.test(o.text))) &&
					(n = n.slice(1));
			}
			n && this.insertNode(this.parser.schema.text(n)),
				this.findInText(e);
		} else this.findInside(e);
	}
	addElement(e, n) {
		let r = e.nodeName.toLowerCase(),
			o;
		av.hasOwnProperty(r) && this.parser.normalizeLists && cM(e);
		let i =
			(this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
			(o = this.parser.matchTag(e, this, n));
		if (i ? i.ignore : uM.hasOwnProperty(r))
			this.findInside(e), this.ignoreFallback(e);
		else if (!i || i.skip || i.closeParent) {
			i && i.closeParent
				? (this.open = Math.max(0, this.open - 1))
				: i && i.skip.nodeType && (e = i.skip);
			let s,
				l = this.top,
				a = this.needsBlock;
			if (lv.hasOwnProperty(r))
				l.content.length &&
					l.content[0].isInline &&
					this.open &&
					(this.open--, (l = this.top)),
					(s = !0),
					l.type || (this.needsBlock = !0);
			else if (!e.firstChild) {
				this.leafFallback(e);
				return;
			}
			i && i.skip
				? this.addAll(e)
				: this.withStyleRules(e, () => this.addAll(e)),
				s && this.sync(l),
				(this.needsBlock = a);
		} else
			this.withStyleRules(e, () => {
				this.addElementByRule(e, i, i.consuming === !1 ? o : void 0);
			});
	}
	leafFallback(e) {
		e.nodeName == "BR" &&
			this.top.type &&
			this.top.type.inlineContent &&
			this.addTextNode(
				e.ownerDocument.createTextNode(`
`)
			);
	}
	ignoreFallback(e) {
		e.nodeName == "BR" &&
			(!this.top.type || !this.top.type.inlineContent) &&
			this.findPlace(this.parser.schema.text("-"));
	}
	readStyles(e) {
		let n = ot.none,
			r = ot.none;
		for (let o = 0; o < e.length; o += 2)
			for (let i = void 0; ; ) {
				let s = this.parser.matchStyle(e[o], e[o + 1], this, i);
				if (!s) break;
				if (s.ignore) return null;
				if (
					(s.clearMark
						? this.top.pendingMarks
								.concat(this.top.activeMarks)
								.forEach((l) => {
									s.clearMark(l) && (r = l.addToSet(r));
								})
						: (n = this.parser.schema.marks[s.mark]
								.create(s.attrs)
								.addToSet(n)),
					s.consuming === !1)
				)
					i = s;
				else break;
			}
		return [n, r];
	}
	addElementByRule(e, n, r) {
		let o, i, s;
		n.node
			? ((i = this.parser.schema.nodes[n.node]),
			  i.isLeaf
					? this.insertNode(i.create(n.attrs)) || this.leafFallback(e)
					: (o = this.enter(
							i,
							n.attrs || null,
							n.preserveWhitespace
					  )))
			: ((s = this.parser.schema.marks[n.mark].create(n.attrs)),
			  this.addPendingMark(s));
		let l = this.top;
		if (i && i.isLeaf) this.findInside(e);
		else if (r) this.addElement(e, r);
		else if (n.getContent)
			this.findInside(e),
				n
					.getContent(e, this.parser.schema)
					.forEach((a) => this.insertNode(a));
		else {
			let a = e;
			typeof n.contentElement == "string"
				? (a = e.querySelector(n.contentElement))
				: typeof n.contentElement == "function"
				? (a = n.contentElement(e))
				: n.contentElement && (a = n.contentElement),
				this.findAround(e, a, !0),
				this.addAll(a);
		}
		o && this.sync(l) && this.open--, s && this.removePendingMark(s, l);
	}
	addAll(e, n, r) {
		let o = n || 0;
		for (
			let i = n ? e.childNodes[n] : e.firstChild,
				s = r == null ? null : e.childNodes[r];
			i != s;
			i = i.nextSibling, ++o
		)
			this.findAtPoint(e, o), this.addDOM(i);
		this.findAtPoint(e, o);
	}
	findPlace(e) {
		let n, r;
		for (let o = this.open; o >= 0; o--) {
			let i = this.nodes[o],
				s = i.findWrapping(e);
			if (
				(s &&
					(!n || n.length > s.length) &&
					((n = s), (r = i), !s.length)) ||
				i.solid
			)
				break;
		}
		if (!n) return !1;
		this.sync(r);
		for (let o = 0; o < n.length; o++) this.enterInner(n[o], null, !1);
		return !0;
	}
	insertNode(e) {
		if (e.isInline && this.needsBlock && !this.top.type) {
			let n = this.textblockFromContext();
			n && this.enterInner(n);
		}
		if (this.findPlace(e)) {
			this.closeExtra();
			let n = this.top;
			n.applyPending(e.type),
				n.match && (n.match = n.match.matchType(e.type));
			let r = n.activeMarks;
			for (let o = 0; o < e.marks.length; o++)
				(!n.type || n.type.allowsMarkType(e.marks[o].type)) &&
					(r = e.marks[o].addToSet(r));
			return n.content.push(e.mark(r)), !0;
		}
		return !1;
	}
	enter(e, n, r) {
		let o = this.findPlace(e.create(n));
		return o && this.enterInner(e, n, !0, r), o;
	}
	enterInner(e, n = null, r = !1, o) {
		this.closeExtra();
		let i = this.top;
		i.applyPending(e), (i.match = i.match && i.match.matchType(e));
		let s = Om(e, o, i.options);
		i.options & ms && i.content.length == 0 && (s |= ms),
			this.nodes.push(
				new El(e, n, i.activeMarks, i.pendingMarks, r, null, s)
			),
			this.open++;
	}
	closeExtra(e = !1) {
		let n = this.nodes.length - 1;
		if (n > this.open) {
			for (; n > this.open; n--)
				this.nodes[n - 1].content.push(this.nodes[n].finish(e));
			this.nodes.length = this.open + 1;
		}
	}
	finish() {
		return (
			(this.open = 0),
			this.closeExtra(this.isOpen),
			this.nodes[0].finish(this.isOpen || this.options.topOpen)
		);
	}
	sync(e) {
		for (let n = this.open; n >= 0; n--)
			if (this.nodes[n] == e) return (this.open = n), !0;
		return !1;
	}
	get currentPos() {
		this.closeExtra();
		let e = 0;
		for (let n = this.open; n >= 0; n--) {
			let r = this.nodes[n].content;
			for (let o = r.length - 1; o >= 0; o--) e += r[o].nodeSize;
			n && e++;
		}
		return e;
	}
	findAtPoint(e, n) {
		if (this.find)
			for (let r = 0; r < this.find.length; r++)
				this.find[r].node == e &&
					this.find[r].offset == n &&
					(this.find[r].pos = this.currentPos);
	}
	findInside(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[n].node) &&
					(this.find[n].pos = this.currentPos);
	}
	findAround(e, n, r) {
		if (e != n && this.find)
			for (let o = 0; o < this.find.length; o++)
				this.find[o].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[o].node) &&
					n.compareDocumentPosition(this.find[o].node) &
						(r ? 2 : 4) &&
					(this.find[o].pos = this.currentPos);
	}
	findInText(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].node == e &&
					(this.find[n].pos =
						this.currentPos -
						(e.nodeValue.length - this.find[n].offset));
	}
	matchesContext(e) {
		if (e.indexOf("|") > -1)
			return e.split(/\s*\|\s*/).some(this.matchesContext, this);
		let n = e.split("/"),
			r = this.options.context,
			o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
			i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1),
			s = (l, a) => {
				for (; l >= 0; l--) {
					let u = n[l];
					if (u == "") {
						if (l == n.length - 1 || l == 0) continue;
						for (; a >= i; a--) if (s(l - 1, a)) return !0;
						return !1;
					} else {
						let c =
							a > 0 || (a == 0 && o)
								? this.nodes[a].type
								: r && a >= i
								? r.node(a - i).type
								: null;
						if (!c || (c.name != u && c.groups.indexOf(u) == -1))
							return !1;
						a--;
					}
				}
				return !0;
			};
		return s(n.length - 1, this.open);
	}
	textblockFromContext() {
		let e = this.options.context;
		if (e)
			for (let n = e.depth; n >= 0; n--) {
				let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
				if (r && r.isTextblock && r.defaultAttrs) return r;
			}
		for (let n in this.parser.schema.nodes) {
			let r = this.parser.schema.nodes[n];
			if (r.isTextblock && r.defaultAttrs) return r;
		}
	}
	addPendingMark(e) {
		let n = pM(e, this.top.pendingMarks);
		n && this.top.stashMarks.push(n),
			(this.top.pendingMarks = e.addToSet(this.top.pendingMarks));
	}
	removePendingMark(e, n) {
		for (let r = this.open; r >= 0; r--) {
			let o = this.nodes[r];
			if (o.pendingMarks.lastIndexOf(e) > -1)
				o.pendingMarks = e.removeFromSet(o.pendingMarks);
			else {
				o.activeMarks = e.removeFromSet(o.activeMarks);
				let s = o.popFromStashMark(e);
				s &&
					o.type &&
					o.type.allowsMarkType(s.type) &&
					(o.activeMarks = s.addToSet(o.activeMarks));
			}
			if (o == n) break;
		}
	}
}
function cM(t) {
	for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
		let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
		r && av.hasOwnProperty(r) && n
			? (n.appendChild(e), (e = n))
			: r == "li"
			? (n = e)
			: r && (n = null);
	}
}
function dM(t, e) {
	return (
		t.matches ||
		t.msMatchesSelector ||
		t.webkitMatchesSelector ||
		t.mozMatchesSelector
	).call(t, e);
}
function fM(t) {
	let e = /\s*([\w-]+)\s*:\s*([^;]+)/g,
		n,
		r = [];
	for (; (n = e.exec(t)); ) r.push(n[1], n[2].trim());
	return r;
}
function Pm(t) {
	let e = {};
	for (let n in t) e[n] = t[n];
	return e;
}
function hM(t, e) {
	let n = e.schema.nodes;
	for (let r in n) {
		let o = n[r];
		if (!o.allowsMarkType(t)) continue;
		let i = [],
			s = (l) => {
				i.push(l);
				for (let a = 0; a < l.edgeCount; a++) {
					let { type: u, next: c } = l.edge(a);
					if (u == e || (i.indexOf(c) < 0 && s(c))) return !0;
				}
			};
		if (s(o.contentMatch)) return !0;
	}
}
function pM(t, e) {
	for (let n = 0; n < e.length; n++) if (t.eq(e[n])) return e[n];
}
class tr {
	constructor(e, n) {
		(this.nodes = e), (this.marks = n);
	}
	serializeFragment(e, n = {}, r) {
		r || (r = Ac(n).createDocumentFragment());
		let o = r,
			i = [];
		return (
			e.forEach((s) => {
				if (i.length || s.marks.length) {
					let l = 0,
						a = 0;
					for (; l < i.length && a < s.marks.length; ) {
						let u = s.marks[a];
						if (!this.marks[u.type.name]) {
							a++;
							continue;
						}
						if (!u.eq(i[l][0]) || u.type.spec.spanning === !1)
							break;
						l++, a++;
					}
					for (; l < i.length; ) o = i.pop()[1];
					for (; a < s.marks.length; ) {
						let u = s.marks[a++],
							c = this.serializeMark(u, s.isInline, n);
						c &&
							(i.push([u, o]),
							o.appendChild(c.dom),
							(o = c.contentDOM || c.dom));
					}
				}
				o.appendChild(this.serializeNodeInner(s, n));
			}),
			r
		);
	}
	serializeNodeInner(e, n) {
		let { dom: r, contentDOM: o } = tr.renderSpec(
			Ac(n),
			this.nodes[e.type.name](e)
		);
		if (o) {
			if (e.isLeaf)
				throw new RangeError(
					"Content hole not allowed in a leaf node spec"
				);
			this.serializeFragment(e.content, n, o);
		}
		return r;
	}
	serializeNode(e, n = {}) {
		let r = this.serializeNodeInner(e, n);
		for (let o = e.marks.length - 1; o >= 0; o--) {
			let i = this.serializeMark(e.marks[o], e.isInline, n);
			i && ((i.contentDOM || i.dom).appendChild(r), (r = i.dom));
		}
		return r;
	}
	serializeMark(e, n, r = {}) {
		let o = this.marks[e.type.name];
		return o && tr.renderSpec(Ac(r), o(e, n));
	}
	static renderSpec(e, n, r = null) {
		if (typeof n == "string") return { dom: e.createTextNode(n) };
		if (n.nodeType != null) return { dom: n };
		if (n.dom && n.dom.nodeType != null) return n;
		let o = n[0],
			i = o.indexOf(" ");
		i > 0 && ((r = o.slice(0, i)), (o = o.slice(i + 1)));
		let s,
			l = r ? e.createElementNS(r, o) : e.createElement(o),
			a = n[1],
			u = 1;
		if (
			a &&
			typeof a == "object" &&
			a.nodeType == null &&
			!Array.isArray(a)
		) {
			u = 2;
			for (let c in a)
				if (a[c] != null) {
					let d = c.indexOf(" ");
					d > 0
						? l.setAttributeNS(c.slice(0, d), c.slice(d + 1), a[c])
						: l.setAttribute(c, a[c]);
				}
		}
		for (let c = u; c < n.length; c++) {
			let d = n[c];
			if (d === 0) {
				if (c < n.length - 1 || c > u)
					throw new RangeError(
						"Content hole must be the only child of its parent node"
					);
				return { dom: l, contentDOM: l };
			} else {
				let { dom: f, contentDOM: p } = tr.renderSpec(e, d, r);
				if ((l.appendChild(f), p)) {
					if (s) throw new RangeError("Multiple content holes");
					s = p;
				}
			}
		}
		return { dom: l, contentDOM: s };
	}
	static fromSchema(e) {
		return (
			e.cached.domSerializer ||
			(e.cached.domSerializer = new tr(
				this.nodesFromSchema(e),
				this.marksFromSchema(e)
			))
		);
	}
	static nodesFromSchema(e) {
		let n = Im(e.nodes);
		return n.text || (n.text = (r) => r.text), n;
	}
	static marksFromSchema(e) {
		return Im(e.marks);
	}
}
function Im(t) {
	let e = {};
	for (let n in t) {
		let r = t[n].spec.toDOM;
		r && (e[n] = r);
	}
	return e;
}
function Ac(t) {
	return t.document || window.document;
}
const uv = 65535,
	cv = Math.pow(2, 16);
function mM(t, e) {
	return t + e * cv;
}
function Nm(t) {
	return t & uv;
}
function gM(t) {
	return (t - (t & uv)) / cv;
}
const dv = 1,
	fv = 2,
	ql = 4,
	hv = 8;
class Bd {
	constructor(e, n, r) {
		(this.pos = e), (this.delInfo = n), (this.recover = r);
	}
	get deleted() {
		return (this.delInfo & hv) > 0;
	}
	get deletedBefore() {
		return (this.delInfo & (dv | ql)) > 0;
	}
	get deletedAfter() {
		return (this.delInfo & (fv | ql)) > 0;
	}
	get deletedAcross() {
		return (this.delInfo & ql) > 0;
	}
}
class gn {
	constructor(e, n = !1) {
		if (((this.ranges = e), (this.inverted = n), !e.length && gn.empty))
			return gn.empty;
	}
	recover(e) {
		let n = 0,
			r = Nm(e);
		if (!this.inverted)
			for (let o = 0; o < r; o++)
				n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
		return this.ranges[r * 3] + n + gM(e);
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	map(e, n = 1) {
		return this._map(e, n, !0);
	}
	_map(e, n, r) {
		let o = 0,
			i = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let l = 0; l < this.ranges.length; l += 3) {
			let a = this.ranges[l] - (this.inverted ? o : 0);
			if (a > e) break;
			let u = this.ranges[l + i],
				c = this.ranges[l + s],
				d = a + u;
			if (e <= d) {
				let f = u ? (e == a ? -1 : e == d ? 1 : n) : n,
					p = a + o + (f < 0 ? 0 : c);
				if (r) return p;
				let m = e == (n < 0 ? a : d) ? null : mM(l / 3, e - a),
					y = e == a ? fv : e == d ? dv : ql;
				return (n < 0 ? e != a : e != d) && (y |= hv), new Bd(p, y, m);
			}
			o += c - u;
		}
		return r ? e + o : new Bd(e + o, 0, null);
	}
	touches(e, n) {
		let r = 0,
			o = Nm(n),
			i = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let l = 0; l < this.ranges.length; l += 3) {
			let a = this.ranges[l] - (this.inverted ? r : 0);
			if (a > e) break;
			let u = this.ranges[l + i],
				c = a + u;
			if (e <= c && l == o * 3) return !0;
			r += this.ranges[l + s] - u;
		}
		return !1;
	}
	forEach(e) {
		let n = this.inverted ? 2 : 1,
			r = this.inverted ? 1 : 2;
		for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
			let s = this.ranges[o],
				l = s - (this.inverted ? i : 0),
				a = s + (this.inverted ? 0 : i),
				u = this.ranges[o + n],
				c = this.ranges[o + r];
			e(l, l + u, a, a + c), (i += c - u);
		}
	}
	invert() {
		return new gn(this.ranges, !this.inverted);
	}
	toString() {
		return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
	}
	static offset(e) {
		return e == 0 ? gn.empty : new gn(e < 0 ? [0, -e, 0] : [0, 0, e]);
	}
}
gn.empty = new gn([]);
class mi {
	constructor(e = [], n, r = 0, o = e.length) {
		(this.maps = e), (this.mirror = n), (this.from = r), (this.to = o);
	}
	slice(e = 0, n = this.maps.length) {
		return new mi(this.maps, this.mirror, e, n);
	}
	copy() {
		return new mi(
			this.maps.slice(),
			this.mirror && this.mirror.slice(),
			this.from,
			this.to
		);
	}
	appendMap(e, n) {
		(this.to = this.maps.push(e)),
			n != null && this.setMirror(this.maps.length - 1, n);
	}
	appendMapping(e) {
		for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
			let o = e.getMirror(n);
			this.appendMap(e.maps[n], o != null && o < n ? r + o : void 0);
		}
	}
	getMirror(e) {
		if (this.mirror) {
			for (let n = 0; n < this.mirror.length; n++)
				if (this.mirror[n] == e)
					return this.mirror[n + (n % 2 ? -1 : 1)];
		}
	}
	setMirror(e, n) {
		this.mirror || (this.mirror = []), this.mirror.push(e, n);
	}
	appendMappingInverted(e) {
		for (
			let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
			n >= 0;
			n--
		) {
			let o = e.getMirror(n);
			this.appendMap(
				e.maps[n].invert(),
				o != null && o > n ? r - o - 1 : void 0
			);
		}
	}
	invert() {
		let e = new mi();
		return e.appendMappingInverted(this), e;
	}
	map(e, n = 1) {
		if (this.mirror) return this._map(e, n, !0);
		for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
		return e;
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	_map(e, n, r) {
		let o = 0;
		for (let i = this.from; i < this.to; i++) {
			let s = this.maps[i],
				l = s.mapResult(e, n);
			if (l.recover != null) {
				let a = this.getMirror(i);
				if (a != null && a > i && a < this.to) {
					(i = a), (e = this.maps[a].recover(l.recover));
					continue;
				}
			}
			(o |= l.delInfo), (e = l.pos);
		}
		return r ? e : new Bd(e, o, null);
	}
}
const Oc = Object.create(null);
class Qt {
	getMap() {
		return gn.empty;
	}
	merge(e) {
		return null;
	}
	static fromJSON(e, n) {
		if (!n || !n.stepType)
			throw new RangeError("Invalid input for Step.fromJSON");
		let r = Oc[n.stepType];
		if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in Oc) throw new RangeError("Duplicate use of step JSON ID " + e);
		return (Oc[e] = n), (n.prototype.jsonID = e), n;
	}
}
class At {
	constructor(e, n) {
		(this.doc = e), (this.failed = n);
	}
	static ok(e) {
		return new At(e, null);
	}
	static fail(e) {
		return new At(null, e);
	}
	static fromReplace(e, n, r, o) {
		try {
			return At.ok(e.replace(n, r, o));
		} catch (i) {
			if (i instanceof ka) return At.fail(i.message);
			throw i;
		}
	}
}
function ch(t, e, n) {
	let r = [];
	for (let o = 0; o < t.childCount; o++) {
		let i = t.child(o);
		i.content.size && (i = i.copy(ch(i.content, e, i))),
			i.isInline && (i = e(i, n, o)),
			r.push(i);
	}
	return J.fromArray(r);
}
class Gr extends Qt {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = e.resolve(this.from),
			o = r.node(r.sharedDepth(this.to)),
			i = new le(
				ch(
					n.content,
					(s, l) =>
						!s.isAtom || !l.type.allowsMarkType(this.mark.type)
							? s
							: s.mark(this.mark.addToSet(s.marks)),
					o
				),
				n.openStart,
				n.openEnd
			);
		return At.fromReplace(e, this.from, this.to, i);
	}
	invert() {
		return new nr(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new Gr(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof Gr &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new Gr(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark
			  )
			: null;
	}
	toJSON() {
		return {
			stepType: "addMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for AddMarkStep.fromJSON");
		return new Gr(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Qt.jsonID("addMark", Gr);
class nr extends Qt {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = new le(
				ch(
					n.content,
					(o) => o.mark(this.mark.removeFromSet(o.marks)),
					e
				),
				n.openStart,
				n.openEnd
			);
		return At.fromReplace(e, this.from, this.to, r);
	}
	invert() {
		return new Gr(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new nr(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof nr &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new nr(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark
			  )
			: null;
	}
	toJSON() {
		return {
			stepType: "removeMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
		return new nr(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Qt.jsonID("removeMark", nr);
class Yr extends Qt {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return At.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
		return At.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new le(J.from(r), 0, n.isLeaf ? 0 : 1)
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		if (n) {
			let r = this.mark.addToSet(n.marks);
			if (r.length == n.marks.length) {
				for (let o = 0; o < n.marks.length; o++)
					if (!n.marks[o].isInSet(r))
						return new Yr(this.pos, n.marks[o]);
				return new Yr(this.pos, this.mark);
			}
		}
		return new Pi(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new Yr(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "addNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
		return new Yr(n.pos, e.markFromJSON(n.mark));
	}
}
Qt.jsonID("addNodeMark", Yr);
class Pi extends Qt {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return At.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
		return At.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new le(J.from(r), 0, n.isLeaf ? 0 : 1)
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		return !n || !this.mark.isInSet(n.marks)
			? this
			: new Yr(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new Pi(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "removeNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError(
				"Invalid input for RemoveNodeMarkStep.fromJSON"
			);
		return new Pi(n.pos, e.markFromJSON(n.mark));
	}
}
Qt.jsonID("removeNodeMark", Pi);
class jt extends Qt {
	constructor(e, n, r, o = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.slice = r),
			(this.structure = o);
	}
	apply(e) {
		return this.structure && zd(e, this.from, this.to)
			? At.fail("Structure replace would overwrite content")
			: At.fromReplace(e, this.from, this.to, this.slice);
	}
	getMap() {
		return new gn([this.from, this.to - this.from, this.slice.size]);
	}
	invert(e) {
		return new jt(
			this.from,
			this.from + this.slice.size,
			e.slice(this.from, this.to)
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return n.deletedAcross && r.deletedAcross
			? null
			: new jt(n.pos, Math.max(n.pos, r.pos), this.slice);
	}
	merge(e) {
		if (!(e instanceof jt) || e.structure || this.structure) return null;
		if (
			this.from + this.slice.size == e.from &&
			!this.slice.openEnd &&
			!e.slice.openStart
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? le.empty
					: new le(
							this.slice.content.append(e.slice.content),
							this.slice.openStart,
							e.slice.openEnd
					  );
			return new jt(
				this.from,
				this.to + (e.to - e.from),
				n,
				this.structure
			);
		} else if (
			e.to == this.from &&
			!this.slice.openStart &&
			!e.slice.openEnd
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? le.empty
					: new le(
							e.slice.content.append(this.slice.content),
							e.slice.openStart,
							this.slice.openEnd
					  );
			return new jt(e.from, this.to, n, this.structure);
		} else return null;
	}
	toJSON() {
		let e = { stepType: "replace", from: this.from, to: this.to };
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for ReplaceStep.fromJSON");
		return new jt(n.from, n.to, le.fromJSON(e, n.slice), !!n.structure);
	}
}
Qt.jsonID("replace", jt);
class $t extends Qt {
	constructor(e, n, r, o, i, s, l = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.gapFrom = r),
			(this.gapTo = o),
			(this.slice = i),
			(this.insert = s),
			(this.structure = l);
	}
	apply(e) {
		if (
			this.structure &&
			(zd(e, this.from, this.gapFrom) || zd(e, this.gapTo, this.to))
		)
			return At.fail("Structure gap-replace would overwrite content");
		let n = e.slice(this.gapFrom, this.gapTo);
		if (n.openStart || n.openEnd) return At.fail("Gap is not a flat range");
		let r = this.slice.insertAt(this.insert, n.content);
		return r
			? At.fromReplace(e, this.from, this.to, r)
			: At.fail("Content does not fit in gap");
	}
	getMap() {
		return new gn([
			this.from,
			this.gapFrom - this.from,
			this.insert,
			this.gapTo,
			this.to - this.gapTo,
			this.slice.size - this.insert,
		]);
	}
	invert(e) {
		let n = this.gapTo - this.gapFrom;
		return new $t(
			this.from,
			this.from + this.slice.size + n,
			this.from + this.insert,
			this.from + this.insert + n,
			e
				.slice(this.from, this.to)
				.removeBetween(
					this.gapFrom - this.from,
					this.gapTo - this.from
				),
			this.gapFrom - this.from,
			this.structure
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1),
			o = e.map(this.gapFrom, -1),
			i = e.map(this.gapTo, 1);
		return (n.deletedAcross && r.deletedAcross) || o < n.pos || i > r.pos
			? null
			: new $t(
					n.pos,
					r.pos,
					o,
					i,
					this.slice,
					this.insert,
					this.structure
			  );
	}
	toJSON() {
		let e = {
			stepType: "replaceAround",
			from: this.from,
			to: this.to,
			gapFrom: this.gapFrom,
			gapTo: this.gapTo,
			insert: this.insert,
		};
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (
			typeof n.from != "number" ||
			typeof n.to != "number" ||
			typeof n.gapFrom != "number" ||
			typeof n.gapTo != "number" ||
			typeof n.insert != "number"
		)
			throw new RangeError(
				"Invalid input for ReplaceAroundStep.fromJSON"
			);
		return new $t(
			n.from,
			n.to,
			n.gapFrom,
			n.gapTo,
			le.fromJSON(e, n.slice),
			n.insert,
			!!n.structure
		);
	}
}
Qt.jsonID("replaceAround", $t);
function zd(t, e, n) {
	let r = t.resolve(e),
		o = n - e,
		i = r.depth;
	for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
		i--, o--;
	if (o > 0) {
		let s = r.node(i).maybeChild(r.indexAfter(i));
		for (; o > 0; ) {
			if (!s || s.isLeaf) return !0;
			(s = s.firstChild), o--;
		}
	}
	return !1;
}
function yM(t, e, n, r) {
	let o = [],
		i = [],
		s,
		l;
	t.doc.nodesBetween(e, n, (a, u, c) => {
		if (!a.isInline) return;
		let d = a.marks;
		if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
			let f = Math.max(u, e),
				p = Math.min(u + a.nodeSize, n),
				m = r.addToSet(d);
			for (let y = 0; y < d.length; y++)
				d[y].isInSet(m) ||
					(s && s.to == f && s.mark.eq(d[y])
						? (s.to = p)
						: o.push((s = new nr(f, p, d[y]))));
			l && l.to == f ? (l.to = p) : i.push((l = new Gr(f, p, r)));
		}
	}),
		o.forEach((a) => t.step(a)),
		i.forEach((a) => t.step(a));
}
function vM(t, e, n, r) {
	let o = [],
		i = 0;
	t.doc.nodesBetween(e, n, (s, l) => {
		if (!s.isInline) return;
		i++;
		let a = null;
		if (r instanceof Bu) {
			let u = s.marks,
				c;
			for (; (c = r.isInSet(u)); )
				(a || (a = [])).push(c), (u = c.removeFromSet(u));
		} else r ? r.isInSet(s.marks) && (a = [r]) : (a = s.marks);
		if (a && a.length) {
			let u = Math.min(l + s.nodeSize, n);
			for (let c = 0; c < a.length; c++) {
				let d = a[c],
					f;
				for (let p = 0; p < o.length; p++) {
					let m = o[p];
					m.step == i - 1 && d.eq(o[p].style) && (f = m);
				}
				f
					? ((f.to = u), (f.step = i))
					: o.push({
							style: d,
							from: Math.max(l, e),
							to: u,
							step: i,
					  });
			}
		}
	}),
		o.forEach((s) => t.step(new nr(s.from, s.to, s.style)));
}
function bM(t, e, n, r = n.contentMatch) {
	let o = t.doc.nodeAt(e),
		i = [],
		s = e + 1;
	for (let l = 0; l < o.childCount; l++) {
		let a = o.child(l),
			u = s + a.nodeSize,
			c = r.matchType(a.type);
		if (!c) i.push(new jt(s, u, le.empty));
		else {
			r = c;
			for (let d = 0; d < a.marks.length; d++)
				n.allowsMarkType(a.marks[d].type) ||
					t.step(new nr(s, u, a.marks[d]));
			if (a.isText && !n.spec.code) {
				let d,
					f = /\r?\n|\r/g,
					p;
				for (; (d = f.exec(a.text)); )
					p ||
						(p = new le(
							J.from(n.schema.text(" ", n.allowedMarks(a.marks))),
							0,
							0
						)),
						i.push(
							new jt(s + d.index, s + d.index + d[0].length, p)
						);
			}
		}
		s = u;
	}
	if (!r.validEnd) {
		let l = r.fillBefore(J.empty, !0);
		t.replace(s, s, new le(l, 0, 0));
	}
	for (let l = i.length - 1; l >= 0; l--) t.step(i[l]);
}
function wM(t, e, n) {
	return (
		(e == 0 || t.canReplace(e, t.childCount)) &&
		(n == t.childCount || t.canReplace(0, n))
	);
}
function Hi(t) {
	let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
	for (let r = t.depth; ; --r) {
		let o = t.$from.node(r),
			i = t.$from.index(r),
			s = t.$to.indexAfter(r);
		if (r < t.depth && o.canReplace(i, s, n)) return r;
		if (r == 0 || o.type.spec.isolating || !wM(o, i, s)) break;
	}
	return null;
}
function xM(t, e, n) {
	let { $from: r, $to: o, depth: i } = e,
		s = r.before(i + 1),
		l = o.after(i + 1),
		a = s,
		u = l,
		c = J.empty,
		d = 0;
	for (let m = i, y = !1; m > n; m--)
		y || r.index(m) > 0
			? ((y = !0), (c = J.from(r.node(m).copy(c))), d++)
			: a--;
	let f = J.empty,
		p = 0;
	for (let m = i, y = !1; m > n; m--)
		y || o.after(m + 1) < o.end(m)
			? ((y = !0), (f = J.from(o.node(m).copy(f))), p++)
			: u++;
	t.step(new $t(a, u, s, l, new le(c.append(f), d, p), c.size - d, !0));
}
function dh(t, e, n = null, r = t) {
	let o = kM(t, e),
		i = o && SM(r, e);
	return i ? o.map(Dm).concat({ type: e, attrs: n }).concat(i.map(Dm)) : null;
}
function Dm(t) {
	return { type: t, attrs: null };
}
function kM(t, e) {
	let { parent: n, startIndex: r, endIndex: o } = t,
		i = n.contentMatchAt(r).findWrapping(e);
	if (!i) return null;
	let s = i.length ? i[0] : e;
	return n.canReplaceWith(r, o, s) ? i : null;
}
function SM(t, e) {
	let { parent: n, startIndex: r, endIndex: o } = t,
		i = n.child(r),
		s = e.contentMatch.findWrapping(i.type);
	if (!s) return null;
	let a = (s.length ? s[s.length - 1] : e).contentMatch;
	for (let u = r; a && u < o; u++) a = a.matchType(n.child(u).type);
	return !a || !a.validEnd ? null : s;
}
function _M(t, e, n) {
	let r = J.empty;
	for (let s = n.length - 1; s >= 0; s--) {
		if (r.size) {
			let l = n[s].type.contentMatch.matchFragment(r);
			if (!l || !l.validEnd)
				throw new RangeError(
					"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
				);
		}
		r = J.from(n[s].type.create(n[s].attrs, r));
	}
	let o = e.start,
		i = e.end;
	t.step(new $t(o, i, o, i, new le(r, 0, 0), n.length, !0));
}
function CM(t, e, n, r, o) {
	if (!r.isTextblock)
		throw new RangeError(
			"Type given to setBlockType should be a textblock"
		);
	let i = t.steps.length;
	t.doc.nodesBetween(e, n, (s, l) => {
		if (
			s.isTextblock &&
			!s.hasMarkup(r, o) &&
			MM(t.doc, t.mapping.slice(i).map(l), r)
		) {
			t.clearIncompatible(t.mapping.slice(i).map(l, 1), r);
			let a = t.mapping.slice(i),
				u = a.map(l, 1),
				c = a.map(l + s.nodeSize, 1);
			return (
				t.step(
					new $t(
						u,
						c,
						u + 1,
						c - 1,
						new le(J.from(r.create(o, null, s.marks)), 0, 0),
						1,
						!0
					)
				),
				!1
			);
		}
	});
}
function MM(t, e, n) {
	let r = t.resolve(e),
		o = r.index();
	return r.parent.canReplaceWith(o, o + 1, n);
}
function EM(t, e, n, r, o) {
	let i = t.doc.nodeAt(e);
	if (!i) throw new RangeError("No node at given position");
	n || (n = i.type);
	let s = n.create(r, null, o || i.marks);
	if (i.isLeaf) return t.replaceWith(e, e + i.nodeSize, s);
	if (!n.validContent(i.content))
		throw new RangeError("Invalid content for node type " + n.name);
	t.step(
		new $t(
			e,
			e + i.nodeSize,
			e + 1,
			e + i.nodeSize - 1,
			new le(J.from(s), 0, 0),
			1,
			!0
		)
	);
}
function gi(t, e, n = 1, r) {
	let o = t.resolve(e),
		i = o.depth - n,
		s = (r && r[r.length - 1]) || o.parent;
	if (
		i < 0 ||
		o.parent.type.spec.isolating ||
		!o.parent.canReplace(o.index(), o.parent.childCount) ||
		!s.type.validContent(
			o.parent.content.cutByIndex(o.index(), o.parent.childCount)
		)
	)
		return !1;
	for (let u = o.depth - 1, c = n - 2; u > i; u--, c--) {
		let d = o.node(u),
			f = o.index(u);
		if (d.type.spec.isolating) return !1;
		let p = d.content.cutByIndex(f, d.childCount),
			m = r && r[c + 1];
		m && (p = p.replaceChild(0, m.type.create(m.attrs)));
		let y = (r && r[c]) || d;
		if (!d.canReplace(f + 1, d.childCount) || !y.type.validContent(p))
			return !1;
	}
	let l = o.indexAfter(i),
		a = r && r[0];
	return o.node(i).canReplaceWith(l, l, a ? a.type : o.node(i + 1).type);
}
function TM(t, e, n = 1, r) {
	let o = t.doc.resolve(e),
		i = J.empty,
		s = J.empty;
	for (let l = o.depth, a = o.depth - n, u = n - 1; l > a; l--, u--) {
		i = J.from(o.node(l).copy(i));
		let c = r && r[u];
		s = J.from(c ? c.type.create(c.attrs, s) : o.node(l).copy(s));
	}
	t.step(new jt(e, e, new le(i.append(s), n, n), !0));
}
function fo(t, e) {
	let n = t.resolve(e),
		r = n.index();
	return pv(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function pv(t, e) {
	return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function Hu(t, e, n = -1) {
	let r = t.resolve(e);
	for (let o = r.depth; ; o--) {
		let i,
			s,
			l = r.index(o);
		if (
			(o == r.depth
				? ((i = r.nodeBefore), (s = r.nodeAfter))
				: n > 0
				? ((i = r.node(o + 1)), l++, (s = r.node(o).maybeChild(l)))
				: ((i = r.node(o).maybeChild(l - 1)), (s = r.node(o + 1))),
			i && !i.isTextblock && pv(i, s) && r.node(o).canReplace(l, l + 1))
		)
			return e;
		if (o == 0) break;
		e = n < 0 ? r.before(o) : r.after(o);
	}
}
function AM(t, e, n) {
	let r = new jt(e - n, e + n, le.empty, !0);
	t.step(r);
}
function OM(t, e, n) {
	let r = t.resolve(e);
	if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
	if (r.parentOffset == 0)
		for (let o = r.depth - 1; o >= 0; o--) {
			let i = r.index(o);
			if (r.node(o).canReplaceWith(i, i, n)) return r.before(o + 1);
			if (i > 0) return null;
		}
	if (r.parentOffset == r.parent.content.size)
		for (let o = r.depth - 1; o >= 0; o--) {
			let i = r.indexAfter(o);
			if (r.node(o).canReplaceWith(i, i, n)) return r.after(o + 1);
			if (i < r.node(o).childCount) return null;
		}
	return null;
}
function mv(t, e, n) {
	let r = t.resolve(e);
	if (!n.content.size) return e;
	let o = n.content;
	for (let i = 0; i < n.openStart; i++) o = o.firstChild.content;
	for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
		for (let s = r.depth; s >= 0; s--) {
			let l =
					s == r.depth
						? 0
						: r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
						? -1
						: 1,
				a = r.index(s) + (l > 0 ? 1 : 0),
				u = r.node(s),
				c = !1;
			if (i == 1) c = u.canReplace(a, a, o);
			else {
				let d = u.contentMatchAt(a).findWrapping(o.firstChild.type);
				c = d && u.canReplaceWith(a, a, d[0]);
			}
			if (c)
				return l == 0
					? r.pos
					: l < 0
					? r.before(s + 1)
					: r.after(s + 1);
		}
	return null;
}
function Fu(t, e, n = e, r = le.empty) {
	if (e == n && !r.size) return null;
	let o = t.resolve(e),
		i = t.resolve(n);
	return gv(o, i, r) ? new jt(e, n, r) : new RM(o, i, r).fit();
}
function gv(t, e, n) {
	return (
		!n.openStart &&
		!n.openEnd &&
		t.start() == e.start() &&
		t.parent.canReplace(t.index(), e.index(), n.content)
	);
}
class RM {
	constructor(e, n, r) {
		(this.$from = e),
			(this.$to = n),
			(this.unplaced = r),
			(this.frontier = []),
			(this.placed = J.empty);
		for (let o = 0; o <= e.depth; o++) {
			let i = e.node(o);
			this.frontier.push({
				type: i.type,
				match: i.contentMatchAt(e.indexAfter(o)),
			});
		}
		for (let o = e.depth; o > 0; o--)
			this.placed = J.from(e.node(o).copy(this.placed));
	}
	get depth() {
		return this.frontier.length - 1;
	}
	fit() {
		for (; this.unplaced.size; ) {
			let u = this.findFittable();
			u ? this.placeNodes(u) : this.openMore() || this.dropNode();
		}
		let e = this.mustMoveInline(),
			n = this.placed.size - this.depth - this.$from.depth,
			r = this.$from,
			o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
		if (!o) return null;
		let i = this.placed,
			s = r.depth,
			l = o.depth;
		for (; s && l && i.childCount == 1; )
			(i = i.firstChild.content), s--, l--;
		let a = new le(i, s, l);
		return e > -1
			? new $t(r.pos, e, this.$to.pos, this.$to.end(), a, n)
			: a.size || r.pos != this.$to.pos
			? new jt(r.pos, o.pos, a)
			: null;
	}
	findFittable() {
		let e = this.unplaced.openStart;
		for (
			let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd;
			r < e;
			r++
		) {
			let i = n.firstChild;
			if (
				(n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r)
			) {
				e = r;
				break;
			}
			n = i.content;
		}
		for (let n = 1; n <= 2; n++)
			for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
				let o,
					i = null;
				r
					? ((i = Rc(this.unplaced.content, r - 1).firstChild),
					  (o = i.content))
					: (o = this.unplaced.content);
				let s = o.firstChild;
				for (let l = this.depth; l >= 0; l--) {
					let { type: a, match: u } = this.frontier[l],
						c,
						d = null;
					if (
						n == 1 &&
						(s
							? u.matchType(s.type) ||
							  (d = u.fillBefore(J.from(s), !1))
							: i && a.compatibleContent(i.type))
					)
						return {
							sliceDepth: r,
							frontierDepth: l,
							parent: i,
							inject: d,
						};
					if (n == 2 && s && (c = u.findWrapping(s.type)))
						return {
							sliceDepth: r,
							frontierDepth: l,
							parent: i,
							wrap: c,
						};
					if (i && u.matchType(i.type)) break;
				}
			}
	}
	openMore() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			o = Rc(e, n);
		return !o.childCount || o.firstChild.isLeaf
			? !1
			: ((this.unplaced = new le(
					e,
					n + 1,
					Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)
			  )),
			  !0);
	}
	dropNode() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			o = Rc(e, n);
		if (o.childCount <= 1 && n > 0) {
			let i = e.size - n <= n + o.size;
			this.unplaced = new le(ts(e, n - 1, 1), n - 1, i ? n - 1 : r);
		} else this.unplaced = new le(ts(e, n, 1), n, r);
	}
	placeNodes({
		sliceDepth: e,
		frontierDepth: n,
		parent: r,
		inject: o,
		wrap: i,
	}) {
		for (; this.depth > n; ) this.closeFrontierNode();
		if (i) for (let y = 0; y < i.length; y++) this.openFrontierNode(i[y]);
		let s = this.unplaced,
			l = r ? r.content : s.content,
			a = s.openStart - e,
			u = 0,
			c = [],
			{ match: d, type: f } = this.frontier[n];
		if (o) {
			for (let y = 0; y < o.childCount; y++) c.push(o.child(y));
			d = d.matchFragment(o);
		}
		let p = l.size + e - (s.content.size - s.openEnd);
		for (; u < l.childCount; ) {
			let y = l.child(u),
				v = d.matchType(y.type);
			if (!v) break;
			u++,
				(u > 1 || a == 0 || y.content.size) &&
					((d = v),
					c.push(
						yv(
							y.mark(f.allowedMarks(y.marks)),
							u == 1 ? a : 0,
							u == l.childCount ? p : -1
						)
					));
		}
		let m = u == l.childCount;
		m || (p = -1),
			(this.placed = ns(this.placed, n, J.from(c))),
			(this.frontier[n].match = d),
			m &&
				p < 0 &&
				r &&
				r.type == this.frontier[this.depth].type &&
				this.frontier.length > 1 &&
				this.closeFrontierNode();
		for (let y = 0, v = l; y < p; y++) {
			let w = v.lastChild;
			this.frontier.push({
				type: w.type,
				match: w.contentMatchAt(w.childCount),
			}),
				(v = w.content);
		}
		this.unplaced = m
			? e == 0
				? le.empty
				: new le(
						ts(s.content, e - 1, 1),
						e - 1,
						p < 0 ? s.openEnd : e - 1
				  )
			: new le(ts(s.content, e, u), s.openStart, s.openEnd);
	}
	mustMoveInline() {
		if (!this.$to.parent.isTextblock) return -1;
		let e = this.frontier[this.depth],
			n;
		if (
			!e.type.isTextblock ||
			!Pc(this.$to, this.$to.depth, e.type, e.match, !1) ||
			(this.$to.depth == this.depth &&
				(n = this.findCloseLevel(this.$to)) &&
				n.depth == this.depth)
		)
			return -1;
		let { depth: r } = this.$to,
			o = this.$to.after(r);
		for (; r > 1 && o == this.$to.end(--r); ) ++o;
		return o;
	}
	findCloseLevel(e) {
		e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
			let { match: r, type: o } = this.frontier[n],
				i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
				s = Pc(e, n, o, r, i);
			if (s) {
				for (let l = n - 1; l >= 0; l--) {
					let { match: a, type: u } = this.frontier[l],
						c = Pc(e, l, u, a, !0);
					if (!c || c.childCount) continue e;
				}
				return {
					depth: n,
					fit: s,
					move: i ? e.doc.resolve(e.after(n + 1)) : e,
				};
			}
		}
	}
	close(e) {
		let n = this.findCloseLevel(e);
		if (!n) return null;
		for (; this.depth > n.depth; ) this.closeFrontierNode();
		n.fit.childCount && (this.placed = ns(this.placed, n.depth, n.fit)),
			(e = n.move);
		for (let r = n.depth + 1; r <= e.depth; r++) {
			let o = e.node(r),
				i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
			this.openFrontierNode(o.type, o.attrs, i);
		}
		return e;
	}
	openFrontierNode(e, n = null, r) {
		let o = this.frontier[this.depth];
		(o.match = o.match.matchType(e)),
			(this.placed = ns(this.placed, this.depth, J.from(e.create(n, r)))),
			this.frontier.push({ type: e, match: e.contentMatch });
	}
	closeFrontierNode() {
		let n = this.frontier.pop().match.fillBefore(J.empty, !0);
		n.childCount &&
			(this.placed = ns(this.placed, this.frontier.length, n));
	}
}
function ts(t, e, n) {
	return e == 0
		? t.cutByIndex(n, t.childCount)
		: t.replaceChild(
				0,
				t.firstChild.copy(ts(t.firstChild.content, e - 1, n))
		  );
}
function ns(t, e, n) {
	return e == 0
		? t.append(n)
		: t.replaceChild(
				t.childCount - 1,
				t.lastChild.copy(ns(t.lastChild.content, e - 1, n))
		  );
}
function Rc(t, e) {
	for (let n = 0; n < e; n++) t = t.firstChild.content;
	return t;
}
function yv(t, e, n) {
	if (e <= 0) return t;
	let r = t.content;
	return (
		e > 1 &&
			(r = r.replaceChild(
				0,
				yv(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0)
			)),
		e > 0 &&
			((r = t.type.contentMatch.fillBefore(r).append(r)),
			n <= 0 &&
				(r = r.append(
					t.type.contentMatch.matchFragment(r).fillBefore(J.empty, !0)
				))),
		t.copy(r)
	);
}
function Pc(t, e, n, r, o) {
	let i = t.node(e),
		s = o ? t.indexAfter(e) : t.index(e);
	if (s == i.childCount && !n.compatibleContent(i.type)) return null;
	let l = r.fillBefore(i.content, !0, s);
	return l && !PM(n, i.content, s) ? l : null;
}
function PM(t, e, n) {
	for (let r = n; r < e.childCount; r++)
		if (!t.allowsMarks(e.child(r).marks)) return !0;
	return !1;
}
function IM(t) {
	return t.spec.defining || t.spec.definingForContent;
}
function NM(t, e, n, r) {
	if (!r.size) return t.deleteRange(e, n);
	let o = t.doc.resolve(e),
		i = t.doc.resolve(n);
	if (gv(o, i, r)) return t.step(new jt(e, n, r));
	let s = bv(o, t.doc.resolve(n));
	s[s.length - 1] == 0 && s.pop();
	let l = -(o.depth + 1);
	s.unshift(l);
	for (let f = o.depth, p = o.pos - 1; f > 0; f--, p--) {
		let m = o.node(f).type.spec;
		if (m.defining || m.definingAsContext || m.isolating) break;
		s.indexOf(f) > -1 ? (l = f) : o.before(f) == p && s.splice(1, 0, -f);
	}
	let a = s.indexOf(l),
		u = [],
		c = r.openStart;
	for (let f = r.content, p = 0; ; p++) {
		let m = f.firstChild;
		if ((u.push(m), p == r.openStart)) break;
		f = m.content;
	}
	for (let f = c - 1; f >= 0; f--) {
		let p = u[f],
			m = IM(p.type);
		if (m && !p.sameMarkup(o.node(Math.abs(l) - 1))) c = f;
		else if (m || !p.type.isTextblock) break;
	}
	for (let f = r.openStart; f >= 0; f--) {
		let p = (f + c + 1) % (r.openStart + 1),
			m = u[p];
		if (m)
			for (let y = 0; y < s.length; y++) {
				let v = s[(y + a) % s.length],
					w = !0;
				v < 0 && ((w = !1), (v = -v));
				let S = o.node(v - 1),
					E = o.index(v - 1);
				if (S.canReplaceWith(E, E, m.type, m.marks))
					return t.replace(
						o.before(v),
						w ? i.after(v) : n,
						new le(vv(r.content, 0, r.openStart, p), p, r.openEnd)
					);
			}
	}
	let d = t.steps.length;
	for (
		let f = s.length - 1;
		f >= 0 && (t.replace(e, n, r), !(t.steps.length > d));
		f--
	) {
		let p = s[f];
		p < 0 || ((e = o.before(p)), (n = i.after(p)));
	}
}
function vv(t, e, n, r, o) {
	if (e < n) {
		let i = t.firstChild;
		t = t.replaceChild(0, i.copy(vv(i.content, e + 1, n, r, i)));
	}
	if (e > r) {
		let i = o.contentMatchAt(0),
			s = i.fillBefore(t).append(t);
		t = s.append(i.matchFragment(s).fillBefore(J.empty, !0));
	}
	return t;
}
function DM(t, e, n, r) {
	if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
		let o = OM(t.doc, e, r.type);
		o != null && (e = n = o);
	}
	t.replaceRange(e, n, new le(J.from(r), 0, 0));
}
function jM(t, e, n) {
	let r = t.doc.resolve(e),
		o = t.doc.resolve(n),
		i = bv(r, o);
	for (let s = 0; s < i.length; s++) {
		let l = i[s],
			a = s == i.length - 1;
		if ((a && l == 0) || r.node(l).type.contentMatch.validEnd)
			return t.delete(r.start(l), o.end(l));
		if (
			l > 0 &&
			(a || r.node(l - 1).canReplace(r.index(l - 1), o.indexAfter(l - 1)))
		)
			return t.delete(r.before(l), o.after(l));
	}
	for (let s = 1; s <= r.depth && s <= o.depth; s++)
		if (
			e - r.start(s) == r.depth - s &&
			n > r.end(s) &&
			o.end(s) - n != o.depth - s
		)
			return t.delete(r.before(s), n);
	t.delete(e, n);
}
function bv(t, e) {
	let n = [],
		r = Math.min(t.depth, e.depth);
	for (let o = r; o >= 0; o--) {
		let i = t.start(o);
		if (
			i < t.pos - (t.depth - o) ||
			e.end(o) > e.pos + (e.depth - o) ||
			t.node(o).type.spec.isolating ||
			e.node(o).type.spec.isolating
		)
			break;
		(i == e.start(o) ||
			(o == t.depth &&
				o == e.depth &&
				t.parent.inlineContent &&
				e.parent.inlineContent &&
				o &&
				e.start(o - 1) == i - 1)) &&
			n.push(o);
	}
	return n;
}
class yi extends Qt {
	constructor(e, n, r) {
		super(), (this.pos = e), (this.attr = n), (this.value = r);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return At.fail("No node at attribute step's position");
		let r = Object.create(null);
		for (let i in n.attrs) r[i] = n.attrs[i];
		r[this.attr] = this.value;
		let o = n.type.create(r, null, n.marks);
		return At.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new le(J.from(o), 0, n.isLeaf ? 0 : 1)
		);
	}
	getMap() {
		return gn.empty;
	}
	invert(e) {
		return new yi(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new yi(n.pos, this.attr, this.value);
	}
	toJSON() {
		return {
			stepType: "attr",
			pos: this.pos,
			attr: this.attr,
			value: this.value,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number" || typeof n.attr != "string")
			throw new RangeError("Invalid input for AttrStep.fromJSON");
		return new yi(n.pos, n.attr, n.value);
	}
}
Qt.jsonID("attr", yi);
class Ds extends Qt {
	constructor(e, n) {
		super(), (this.attr = e), (this.value = n);
	}
	apply(e) {
		let n = Object.create(null);
		for (let o in e.attrs) n[o] = e.attrs[o];
		n[this.attr] = this.value;
		let r = e.type.create(n, e.content, e.marks);
		return At.ok(r);
	}
	getMap() {
		return gn.empty;
	}
	invert(e) {
		return new Ds(this.attr, e.attrs[this.attr]);
	}
	map(e) {
		return this;
	}
	toJSON() {
		return { stepType: "docAttr", attr: this.attr, value: this.value };
	}
	static fromJSON(e, n) {
		if (typeof n.attr != "string")
			throw new RangeError("Invalid input for DocAttrStep.fromJSON");
		return new Ds(n.attr, n.value);
	}
}
Qt.jsonID("docAttr", Ds);
let Ii = class extends Error {};
Ii = function t(e) {
	let n = Error.call(this, e);
	return (n.__proto__ = t.prototype), n;
};
Ii.prototype = Object.create(Error.prototype);
Ii.prototype.constructor = Ii;
Ii.prototype.name = "TransformError";
class fh {
	constructor(e) {
		(this.doc = e),
			(this.steps = []),
			(this.docs = []),
			(this.mapping = new mi());
	}
	get before() {
		return this.docs.length ? this.docs[0] : this.doc;
	}
	step(e) {
		let n = this.maybeStep(e);
		if (n.failed) throw new Ii(n.failed);
		return this;
	}
	maybeStep(e) {
		let n = e.apply(this.doc);
		return n.failed || this.addStep(e, n.doc), n;
	}
	get docChanged() {
		return this.steps.length > 0;
	}
	addStep(e, n) {
		this.docs.push(this.doc),
			this.steps.push(e),
			this.mapping.appendMap(e.getMap()),
			(this.doc = n);
	}
	replace(e, n = e, r = le.empty) {
		let o = Fu(this.doc, e, n, r);
		return o && this.step(o), this;
	}
	replaceWith(e, n, r) {
		return this.replace(e, n, new le(J.from(r), 0, 0));
	}
	delete(e, n) {
		return this.replace(e, n, le.empty);
	}
	insert(e, n) {
		return this.replaceWith(e, e, n);
	}
	replaceRange(e, n, r) {
		return NM(this, e, n, r), this;
	}
	replaceRangeWith(e, n, r) {
		return DM(this, e, n, r), this;
	}
	deleteRange(e, n) {
		return jM(this, e, n), this;
	}
	lift(e, n) {
		return xM(this, e, n), this;
	}
	join(e, n = 1) {
		return AM(this, e, n), this;
	}
	wrap(e, n) {
		return _M(this, e, n), this;
	}
	setBlockType(e, n = e, r, o = null) {
		return CM(this, e, n, r, o), this;
	}
	setNodeMarkup(e, n, r = null, o) {
		return EM(this, e, n, r, o), this;
	}
	setNodeAttribute(e, n, r) {
		return this.step(new yi(e, n, r)), this;
	}
	setDocAttribute(e, n) {
		return this.step(new Ds(e, n)), this;
	}
	addNodeMark(e, n) {
		return this.step(new Yr(e, n)), this;
	}
	removeNodeMark(e, n) {
		if (!(n instanceof ot)) {
			let r = this.doc.nodeAt(e);
			if (!r) throw new RangeError("No node at position " + e);
			if (((n = n.isInSet(r.marks)), !n)) return this;
		}
		return this.step(new Pi(e, n)), this;
	}
	split(e, n = 1, r) {
		return TM(this, e, n, r), this;
	}
	addMark(e, n, r) {
		return yM(this, e, n, r), this;
	}
	removeMark(e, n, r) {
		return vM(this, e, n, r), this;
	}
	clearIncompatible(e, n, r) {
		return bM(this, e, n, r), this;
	}
}
const Ic = Object.create(null);
class Me {
	constructor(e, n, r) {
		(this.$anchor = e),
			(this.$head = n),
			(this.ranges = r || [new wv(e.min(n), e.max(n))]);
	}
	get anchor() {
		return this.$anchor.pos;
	}
	get head() {
		return this.$head.pos;
	}
	get from() {
		return this.$from.pos;
	}
	get to() {
		return this.$to.pos;
	}
	get $from() {
		return this.ranges[0].$from;
	}
	get $to() {
		return this.ranges[0].$to;
	}
	get empty() {
		let e = this.ranges;
		for (let n = 0; n < e.length; n++)
			if (e[n].$from.pos != e[n].$to.pos) return !1;
		return !0;
	}
	content() {
		return this.$from.doc.slice(this.from, this.to, !0);
	}
	replace(e, n = le.empty) {
		let r = n.content.lastChild,
			o = null;
		for (let l = 0; l < n.openEnd; l++) (o = r), (r = r.lastChild);
		let i = e.steps.length,
			s = this.ranges;
		for (let l = 0; l < s.length; l++) {
			let { $from: a, $to: u } = s[l],
				c = e.mapping.slice(i);
			e.replaceRange(c.map(a.pos), c.map(u.pos), l ? le.empty : n),
				l == 0 &&
					$m(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
		}
	}
	replaceWith(e, n) {
		let r = e.steps.length,
			o = this.ranges;
		for (let i = 0; i < o.length; i++) {
			let { $from: s, $to: l } = o[i],
				a = e.mapping.slice(r),
				u = a.map(s.pos),
				c = a.map(l.pos);
			i
				? e.deleteRange(u, c)
				: (e.replaceRangeWith(u, c, n), $m(e, r, n.isInline ? -1 : 1));
		}
	}
	static findFrom(e, n, r = !1) {
		let o = e.parent.inlineContent
			? new Se(e)
			: ni(e.node(0), e.parent, e.pos, e.index(), n, r);
		if (o) return o;
		for (let i = e.depth - 1; i >= 0; i--) {
			let s =
				n < 0
					? ni(
							e.node(0),
							e.node(i),
							e.before(i + 1),
							e.index(i),
							n,
							r
					  )
					: ni(
							e.node(0),
							e.node(i),
							e.after(i + 1),
							e.index(i) + 1,
							n,
							r
					  );
			if (s) return s;
		}
		return null;
	}
	static near(e, n = 1) {
		return this.findFrom(e, n) || this.findFrom(e, -n) || new zn(e.node(0));
	}
	static atStart(e) {
		return ni(e, e, 0, 0, 1) || new zn(e);
	}
	static atEnd(e) {
		return ni(e, e, e.content.size, e.childCount, -1) || new zn(e);
	}
	static fromJSON(e, n) {
		if (!n || !n.type)
			throw new RangeError("Invalid input for Selection.fromJSON");
		let r = Ic[n.type];
		if (!r) throw new RangeError(`No selection type ${n.type} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in Ic)
			throw new RangeError("Duplicate use of selection JSON ID " + e);
		return (Ic[e] = n), (n.prototype.jsonID = e), n;
	}
	getBookmark() {
		return Se.between(this.$anchor, this.$head).getBookmark();
	}
}
Me.prototype.visible = !0;
class wv {
	constructor(e, n) {
		(this.$from = e), (this.$to = n);
	}
}
let jm = !1;
function Lm(t) {
	!jm &&
		!t.parent.inlineContent &&
		((jm = !0),
		console.warn(
			"TextSelection endpoint not pointing into a node with inline content (" +
				t.parent.type.name +
				")"
		));
}
class Se extends Me {
	constructor(e, n = e) {
		Lm(e), Lm(n), super(e, n);
	}
	get $cursor() {
		return this.$anchor.pos == this.$head.pos ? this.$head : null;
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		if (!r.parent.inlineContent) return Me.near(r);
		let o = e.resolve(n.map(this.anchor));
		return new Se(o.parent.inlineContent ? o : r, r);
	}
	replace(e, n = le.empty) {
		if ((super.replace(e, n), n == le.empty)) {
			let r = this.$from.marksAcross(this.$to);
			r && e.ensureMarks(r);
		}
	}
	eq(e) {
		return (
			e instanceof Se && e.anchor == this.anchor && e.head == this.head
		);
	}
	getBookmark() {
		return new Vu(this.anchor, this.head);
	}
	toJSON() {
		return { type: "text", anchor: this.anchor, head: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number" || typeof n.head != "number")
			throw new RangeError("Invalid input for TextSelection.fromJSON");
		return new Se(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		let o = e.resolve(n);
		return new this(o, r == n ? o : e.resolve(r));
	}
	static between(e, n, r) {
		let o = e.pos - n.pos;
		if (((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent)) {
			let i = Me.findFrom(n, r, !0) || Me.findFrom(n, -r, !0);
			if (i) n = i.$head;
			else return Me.near(n, r);
		}
		return (
			e.parent.inlineContent ||
				(o == 0
					? (e = n)
					: ((e = (Me.findFrom(e, -r, !0) || Me.findFrom(e, r, !0))
							.$anchor),
					  e.pos < n.pos != o < 0 && (e = n))),
			new Se(e, n)
		);
	}
}
Me.jsonID("text", Se);
class Vu {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new Vu(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		return Se.between(e.resolve(this.anchor), e.resolve(this.head));
	}
}
class we extends Me {
	constructor(e) {
		let n = e.nodeAfter,
			r = e.node(0).resolve(e.pos + n.nodeSize);
		super(e, r), (this.node = n);
	}
	map(e, n) {
		let { deleted: r, pos: o } = n.mapResult(this.anchor),
			i = e.resolve(o);
		return r ? Me.near(i) : new we(i);
	}
	content() {
		return new le(J.from(this.node), 0, 0);
	}
	eq(e) {
		return e instanceof we && e.anchor == this.anchor;
	}
	toJSON() {
		return { type: "node", anchor: this.anchor };
	}
	getBookmark() {
		return new hh(this.anchor);
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number")
			throw new RangeError("Invalid input for NodeSelection.fromJSON");
		return new we(e.resolve(n.anchor));
	}
	static create(e, n) {
		return new we(e.resolve(n));
	}
	static isSelectable(e) {
		return !e.isText && e.type.spec.selectable !== !1;
	}
}
we.prototype.visible = !1;
Me.jsonID("node", we);
class hh {
	constructor(e) {
		this.anchor = e;
	}
	map(e) {
		let { deleted: n, pos: r } = e.mapResult(this.anchor);
		return n ? new Vu(r, r) : new hh(r);
	}
	resolve(e) {
		let n = e.resolve(this.anchor),
			r = n.nodeAfter;
		return r && we.isSelectable(r) ? new we(n) : Me.near(n);
	}
}
class zn extends Me {
	constructor(e) {
		super(e.resolve(0), e.resolve(e.content.size));
	}
	replace(e, n = le.empty) {
		if (n == le.empty) {
			e.delete(0, e.doc.content.size);
			let r = Me.atStart(e.doc);
			r.eq(e.selection) || e.setSelection(r);
		} else super.replace(e, n);
	}
	toJSON() {
		return { type: "all" };
	}
	static fromJSON(e) {
		return new zn(e);
	}
	map(e) {
		return new zn(e);
	}
	eq(e) {
		return e instanceof zn;
	}
	getBookmark() {
		return LM;
	}
}
Me.jsonID("all", zn);
const LM = {
	map() {
		return this;
	},
	resolve(t) {
		return new zn(t);
	},
};
function ni(t, e, n, r, o, i = !1) {
	if (e.inlineContent) return Se.create(t, n);
	for (
		let s = r - (o > 0 ? 0 : 1);
		o > 0 ? s < e.childCount : s >= 0;
		s += o
	) {
		let l = e.child(s);
		if (l.isAtom) {
			if (!i && we.isSelectable(l))
				return we.create(t, n - (o < 0 ? l.nodeSize : 0));
		} else {
			let a = ni(t, l, n + o, o < 0 ? l.childCount : 0, o, i);
			if (a) return a;
		}
		n += l.nodeSize * o;
	}
	return null;
}
function $m(t, e, n) {
	let r = t.steps.length - 1;
	if (r < e) return;
	let o = t.steps[r];
	if (!(o instanceof jt || o instanceof $t)) return;
	let i = t.mapping.maps[r],
		s;
	i.forEach((l, a, u, c) => {
		s == null && (s = c);
	}),
		t.setSelection(Me.near(t.doc.resolve(s), n));
}
const Bm = 1,
	Tl = 2,
	zm = 4;
class $M extends fh {
	constructor(e) {
		super(e.doc),
			(this.curSelectionFor = 0),
			(this.updated = 0),
			(this.meta = Object.create(null)),
			(this.time = Date.now()),
			(this.curSelection = e.selection),
			(this.storedMarks = e.storedMarks);
	}
	get selection() {
		return (
			this.curSelectionFor < this.steps.length &&
				((this.curSelection = this.curSelection.map(
					this.doc,
					this.mapping.slice(this.curSelectionFor)
				)),
				(this.curSelectionFor = this.steps.length)),
			this.curSelection
		);
	}
	setSelection(e) {
		if (e.$from.doc != this.doc)
			throw new RangeError(
				"Selection passed to setSelection must point at the current document"
			);
		return (
			(this.curSelection = e),
			(this.curSelectionFor = this.steps.length),
			(this.updated = (this.updated | Bm) & ~Tl),
			(this.storedMarks = null),
			this
		);
	}
	get selectionSet() {
		return (this.updated & Bm) > 0;
	}
	setStoredMarks(e) {
		return (this.storedMarks = e), (this.updated |= Tl), this;
	}
	ensureMarks(e) {
		return (
			ot.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
				this.setStoredMarks(e),
			this
		);
	}
	addStoredMark(e) {
		return this.ensureMarks(
			e.addToSet(this.storedMarks || this.selection.$head.marks())
		);
	}
	removeStoredMark(e) {
		return this.ensureMarks(
			e.removeFromSet(this.storedMarks || this.selection.$head.marks())
		);
	}
	get storedMarksSet() {
		return (this.updated & Tl) > 0;
	}
	addStep(e, n) {
		super.addStep(e, n),
			(this.updated = this.updated & ~Tl),
			(this.storedMarks = null);
	}
	setTime(e) {
		return (this.time = e), this;
	}
	replaceSelection(e) {
		return this.selection.replace(this, e), this;
	}
	replaceSelectionWith(e, n = !0) {
		let r = this.selection;
		return (
			n &&
				(e = e.mark(
					this.storedMarks ||
						(r.empty
							? r.$from.marks()
							: r.$from.marksAcross(r.$to) || ot.none)
				)),
			r.replaceWith(this, e),
			this
		);
	}
	deleteSelection() {
		return this.selection.replace(this), this;
	}
	insertText(e, n, r) {
		let o = this.doc.type.schema;
		if (n == null)
			return e
				? this.replaceSelectionWith(o.text(e), !0)
				: this.deleteSelection();
		{
			if ((r == null && (r = n), (r = r == null ? n : r), !e))
				return this.deleteRange(n, r);
			let i = this.storedMarks;
			if (!i) {
				let s = this.doc.resolve(n);
				i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
			}
			return (
				this.replaceRangeWith(n, r, o.text(e, i)),
				this.selection.empty ||
					this.setSelection(Me.near(this.selection.$to)),
				this
			);
		}
	}
	setMeta(e, n) {
		return (this.meta[typeof e == "string" ? e : e.key] = n), this;
	}
	getMeta(e) {
		return this.meta[typeof e == "string" ? e : e.key];
	}
	get isGeneric() {
		for (let e in this.meta) return !1;
		return !0;
	}
	scrollIntoView() {
		return (this.updated |= zm), this;
	}
	get scrolledIntoView() {
		return (this.updated & zm) > 0;
	}
}
function Hm(t, e) {
	return !e || !t ? t : t.bind(e);
}
class rs {
	constructor(e, n, r) {
		(this.name = e),
			(this.init = Hm(n.init, r)),
			(this.apply = Hm(n.apply, r));
	}
}
const BM = [
	new rs("doc", {
		init(t) {
			return t.doc || t.schema.topNodeType.createAndFill();
		},
		apply(t) {
			return t.doc;
		},
	}),
	new rs("selection", {
		init(t, e) {
			return t.selection || Me.atStart(e.doc);
		},
		apply(t) {
			return t.selection;
		},
	}),
	new rs("storedMarks", {
		init(t) {
			return t.storedMarks || null;
		},
		apply(t, e, n, r) {
			return r.selection.$cursor ? t.storedMarks : null;
		},
	}),
	new rs("scrollToSelection", {
		init() {
			return 0;
		},
		apply(t, e) {
			return t.scrolledIntoView ? e + 1 : e;
		},
	}),
];
class Nc {
	constructor(e, n) {
		(this.schema = e),
			(this.plugins = []),
			(this.pluginsByKey = Object.create(null)),
			(this.fields = BM.slice()),
			n &&
				n.forEach((r) => {
					if (this.pluginsByKey[r.key])
						throw new RangeError(
							"Adding different instances of a keyed plugin (" +
								r.key +
								")"
						);
					this.plugins.push(r),
						(this.pluginsByKey[r.key] = r),
						r.spec.state &&
							this.fields.push(new rs(r.key, r.spec.state, r));
				});
	}
}
class ai {
	constructor(e) {
		this.config = e;
	}
	get schema() {
		return this.config.schema;
	}
	get plugins() {
		return this.config.plugins;
	}
	apply(e) {
		return this.applyTransaction(e).state;
	}
	filterTransaction(e, n = -1) {
		for (let r = 0; r < this.config.plugins.length; r++)
			if (r != n) {
				let o = this.config.plugins[r];
				if (
					o.spec.filterTransaction &&
					!o.spec.filterTransaction.call(o, e, this)
				)
					return !1;
			}
		return !0;
	}
	applyTransaction(e) {
		if (!this.filterTransaction(e))
			return { state: this, transactions: [] };
		let n = [e],
			r = this.applyInner(e),
			o = null;
		for (;;) {
			let i = !1;
			for (let s = 0; s < this.config.plugins.length; s++) {
				let l = this.config.plugins[s];
				if (l.spec.appendTransaction) {
					let a = o ? o[s].n : 0,
						u = o ? o[s].state : this,
						c =
							a < n.length &&
							l.spec.appendTransaction.call(
								l,
								a ? n.slice(a) : n,
								u,
								r
							);
					if (c && r.filterTransaction(c, s)) {
						if ((c.setMeta("appendedTransaction", e), !o)) {
							o = [];
							for (let d = 0; d < this.config.plugins.length; d++)
								o.push(
									d < s
										? { state: r, n: n.length }
										: { state: this, n: 0 }
								);
						}
						n.push(c), (r = r.applyInner(c)), (i = !0);
					}
					o && (o[s] = { state: r, n: n.length });
				}
			}
			if (!i) return { state: r, transactions: n };
		}
	}
	applyInner(e) {
		if (!e.before.eq(this.doc))
			throw new RangeError("Applying a mismatched transaction");
		let n = new ai(this.config),
			r = this.config.fields;
		for (let o = 0; o < r.length; o++) {
			let i = r[o];
			n[i.name] = i.apply(e, this[i.name], this, n);
		}
		return n;
	}
	get tr() {
		return new $M(this);
	}
	static create(e) {
		let n = new Nc(e.doc ? e.doc.type.schema : e.schema, e.plugins),
			r = new ai(n);
		for (let o = 0; o < n.fields.length; o++)
			r[n.fields[o].name] = n.fields[o].init(e, r);
		return r;
	}
	reconfigure(e) {
		let n = new Nc(this.schema, e.plugins),
			r = n.fields,
			o = new ai(n);
		for (let i = 0; i < r.length; i++) {
			let s = r[i].name;
			o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
		}
		return o;
	}
	toJSON(e) {
		let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
		if (
			(this.storedMarks &&
				(n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
			e && typeof e == "object")
		)
			for (let r in e) {
				if (r == "doc" || r == "selection")
					throw new RangeError(
						"The JSON fields `doc` and `selection` are reserved"
					);
				let o = e[r],
					i = o.spec.state;
				i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
			}
		return n;
	}
	static fromJSON(e, n, r) {
		if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
		if (!e.schema)
			throw new RangeError("Required config field 'schema' missing");
		let o = new Nc(e.schema, e.plugins),
			i = new ai(o);
		return (
			o.fields.forEach((s) => {
				if (s.name == "doc") i.doc = Do.fromJSON(e.schema, n.doc);
				else if (s.name == "selection")
					i.selection = Me.fromJSON(i.doc, n.selection);
				else if (s.name == "storedMarks")
					n.storedMarks &&
						(i.storedMarks = n.storedMarks.map(
							e.schema.markFromJSON
						));
				else {
					if (r)
						for (let l in r) {
							let a = r[l],
								u = a.spec.state;
							if (
								a.key == s.name &&
								u &&
								u.fromJSON &&
								Object.prototype.hasOwnProperty.call(n, l)
							) {
								i[s.name] = u.fromJSON.call(a, e, n[l], i);
								return;
							}
						}
					i[s.name] = s.init(e, i);
				}
			}),
			i
		);
	}
}
function xv(t, e, n) {
	for (let r in t) {
		let o = t[r];
		o instanceof Function
			? (o = o.bind(e))
			: r == "handleDOMEvents" && (o = xv(o, e, {})),
			(n[r] = o);
	}
	return n;
}
class kt {
	constructor(e) {
		(this.spec = e),
			(this.props = {}),
			e.props && xv(e.props, this, this.props),
			(this.key = e.key ? e.key.key : kv("plugin"));
	}
	getState(e) {
		return e[this.key];
	}
}
const Dc = Object.create(null);
function kv(t) {
	return t in Dc ? t + "$" + ++Dc[t] : ((Dc[t] = 0), t + "$");
}
class Dt {
	constructor(e = "key") {
		this.key = kv(e);
	}
	get(e) {
		return e.config.pluginsByKey[this.key];
	}
	getState(e) {
		return e[this.key];
	}
}
const en = function (t) {
		for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
	},
	js = function (t) {
		let e = t.assignedSlot || t.parentNode;
		return e && e.nodeType == 11 ? e.host : e;
	};
let Fm = null;
const wr = function (t, e, n) {
		let r = Fm || (Fm = document.createRange());
		return (
			r.setEnd(t, n == null ? t.nodeValue.length : n),
			r.setStart(t, e || 0),
			r
		);
	},
	Ho = function (t, e, n, r) {
		return n && (Vm(t, e, n, r, -1) || Vm(t, e, n, r, 1));
	},
	zM = /^(img|br|input|textarea|hr)$/i;
function Vm(t, e, n, r, o) {
	for (;;) {
		if (t == n && e == r) return !0;
		if (e == (o < 0 ? 0 : Zn(t))) {
			let i = t.parentNode;
			if (
				!i ||
				i.nodeType != 1 ||
				ph(t) ||
				zM.test(t.nodeName) ||
				t.contentEditable == "false"
			)
				return !1;
			(e = en(t) + (o < 0 ? 0 : 1)), (t = i);
		} else if (t.nodeType == 1) {
			if (
				((t = t.childNodes[e + (o < 0 ? -1 : 0)]),
				t.contentEditable == "false")
			)
				return !1;
			e = o < 0 ? Zn(t) : 0;
		} else return !1;
	}
}
function Zn(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function HM(t, e, n) {
	for (let r = e == 0, o = e == Zn(t); r || o; ) {
		if (t == n) return !0;
		let i = en(t);
		if (((t = t.parentNode), !t)) return !1;
		(r = r && i == 0), (o = o && i == Zn(t));
	}
}
function ph(t) {
	let e;
	for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
	return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const Wu = function (t) {
	return (
		t.focusNode &&
		Ho(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
	);
};
function So(t, e) {
	let n = document.createEvent("Event");
	return (
		n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
	);
}
function FM(t) {
	let e = t.activeElement;
	for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
	return e;
}
function VM(t, e, n) {
	if (t.caretPositionFromPoint)
		try {
			let r = t.caretPositionFromPoint(e, n);
			if (r) return { node: r.offsetNode, offset: r.offset };
		} catch (r) {}
	if (t.caretRangeFromPoint) {
		let r = t.caretRangeFromPoint(e, n);
		if (r) return { node: r.startContainer, offset: r.startOffset };
	}
}
const ur = typeof navigator != "undefined" ? navigator : null,
	Wm = typeof document != "undefined" ? document : null,
	ho = (ur && ur.userAgent) || "",
	Hd = /Edge\/(\d+)/.exec(ho),
	Sv = /MSIE \d/.exec(ho),
	Fd = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ho),
	cn = !!(Sv || Fd || Hd),
	to = Sv ? document.documentMode : Fd ? +Fd[1] : Hd ? +Hd[1] : 0,
	Vn = !cn && /gecko\/(\d+)/i.test(ho);
Vn && +(/Firefox\/(\d+)/.exec(ho) || [0, 0])[1];
const Vd = !cn && /Chrome\/(\d+)/.exec(ho),
	Kt = !!Vd,
	WM = Vd ? +Vd[1] : 0,
	nn = !cn && !!ur && /Apple Computer/.test(ur.vendor),
	Ni = nn && (/Mobile\/\w+/.test(ho) || (!!ur && ur.maxTouchPoints > 2)),
	Sn = Ni || (ur ? /Mac/.test(ur.platform) : !1),
	UM = ur ? /Win/.test(ur.platform) : !1,
	Dn = /Android \d/.test(ho),
	nl = !!Wm && "webkitFontSmoothing" in Wm.documentElement.style,
	KM = nl
		? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
		: 0;
function qM(t) {
	return {
		left: 0,
		right: t.documentElement.clientWidth,
		top: 0,
		bottom: t.documentElement.clientHeight,
	};
}
function gr(t, e) {
	return typeof t == "number" ? t : t[e];
}
function JM(t) {
	let e = t.getBoundingClientRect(),
		n = e.width / t.offsetWidth || 1,
		r = e.height / t.offsetHeight || 1;
	return {
		left: e.left,
		right: e.left + t.clientWidth * n,
		top: e.top,
		bottom: e.top + t.clientHeight * r,
	};
}
function Um(t, e, n) {
	let r = t.someProp("scrollThreshold") || 0,
		o = t.someProp("scrollMargin") || 5,
		i = t.dom.ownerDocument;
	for (let s = n || t.dom; s; s = js(s)) {
		if (s.nodeType != 1) continue;
		let l = s,
			a = l == i.body,
			u = a ? qM(i) : JM(l),
			c = 0,
			d = 0;
		if (
			(e.top < u.top + gr(r, "top")
				? (d = -(u.top - e.top + gr(o, "top")))
				: e.bottom > u.bottom - gr(r, "bottom") &&
				  (d =
						e.bottom - e.top > u.bottom - u.top
							? e.top + gr(o, "top") - u.top
							: e.bottom - u.bottom + gr(o, "bottom")),
			e.left < u.left + gr(r, "left")
				? (c = -(u.left - e.left + gr(o, "left")))
				: e.right > u.right - gr(r, "right") &&
				  (c = e.right - u.right + gr(o, "right")),
			c || d)
		)
			if (a) i.defaultView.scrollBy(c, d);
			else {
				let f = l.scrollLeft,
					p = l.scrollTop;
				d && (l.scrollTop += d), c && (l.scrollLeft += c);
				let m = l.scrollLeft - f,
					y = l.scrollTop - p;
				e = {
					left: e.left - m,
					top: e.top - y,
					right: e.right - m,
					bottom: e.bottom - y,
				};
			}
		if (a || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
	}
}
function GM(t) {
	let e = t.dom.getBoundingClientRect(),
		n = Math.max(0, e.top),
		r,
		o;
	for (
		let i = (e.left + e.right) / 2, s = n + 1;
		s < Math.min(innerHeight, e.bottom);
		s += 5
	) {
		let l = t.root.elementFromPoint(i, s);
		if (!l || l == t.dom || !t.dom.contains(l)) continue;
		let a = l.getBoundingClientRect();
		if (a.top >= n - 20) {
			(r = l), (o = a.top);
			break;
		}
	}
	return { refDOM: r, refTop: o, stack: _v(t.dom) };
}
function _v(t) {
	let e = [],
		n = t.ownerDocument;
	for (
		let r = t;
		r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
		r = js(r)
	);
	return e;
}
function YM({ refDOM: t, refTop: e, stack: n }) {
	let r = t ? t.getBoundingClientRect().top : 0;
	Cv(n, r == 0 ? 0 : r - e);
}
function Cv(t, e) {
	for (let n = 0; n < t.length; n++) {
		let { dom: r, top: o, left: i } = t[n];
		r.scrollTop != o + e && (r.scrollTop = o + e),
			r.scrollLeft != i && (r.scrollLeft = i);
	}
}
let Qo = null;
function QM(t) {
	if (t.setActive) return t.setActive();
	if (Qo) return t.focus(Qo);
	let e = _v(t);
	t.focus(
		Qo == null
			? {
					get preventScroll() {
						return (Qo = { preventScroll: !0 }), !0;
					},
			  }
			: void 0
	),
		Qo || ((Qo = !1), Cv(e, 0));
}
function Mv(t, e) {
	let n,
		r = 2e8,
		o,
		i = 0,
		s = e.top,
		l = e.top,
		a,
		u;
	for (let c = t.firstChild, d = 0; c; c = c.nextSibling, d++) {
		let f;
		if (c.nodeType == 1) f = c.getClientRects();
		else if (c.nodeType == 3) f = wr(c).getClientRects();
		else continue;
		for (let p = 0; p < f.length; p++) {
			let m = f[p];
			if (m.top <= s && m.bottom >= l) {
				(s = Math.max(m.bottom, s)), (l = Math.min(m.top, l));
				let y =
					m.left > e.left
						? m.left - e.left
						: m.right < e.left
						? e.left - m.right
						: 0;
				if (y < r) {
					(n = c),
						(r = y),
						(o =
							y && n.nodeType == 3
								? {
										left:
											m.right < e.left ? m.right : m.left,
										top: e.top,
								  }
								: e),
						c.nodeType == 1 &&
							y &&
							(i =
								d + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
					continue;
				}
			} else
				m.top > e.top &&
					!a &&
					m.left <= e.left &&
					m.right >= e.left &&
					((a = c),
					(u = {
						left: Math.max(m.left, Math.min(m.right, e.left)),
						top: m.top,
					}));
			!n &&
				((e.left >= m.right && e.top >= m.top) ||
					(e.left >= m.left && e.top >= m.bottom)) &&
				(i = d + 1);
		}
	}
	return (
		!n && a && ((n = a), (o = u), (r = 0)),
		n && n.nodeType == 3
			? XM(n, o)
			: !n || (r && n.nodeType == 1)
			? { node: t, offset: i }
			: Mv(n, o)
	);
}
function XM(t, e) {
	let n = t.nodeValue.length,
		r = document.createRange();
	for (let o = 0; o < n; o++) {
		r.setEnd(t, o + 1), r.setStart(t, o);
		let i = Dr(r, 1);
		if (i.top != i.bottom && mh(e, i))
			return {
				node: t,
				offset: o + (e.left >= (i.left + i.right) / 2 ? 1 : 0),
			};
	}
	return { node: t, offset: 0 };
}
function mh(t, e) {
	return (
		t.left >= e.left - 1 &&
		t.left <= e.right + 1 &&
		t.top >= e.top - 1 &&
		t.top <= e.bottom + 1
	);
}
function ZM(t, e) {
	let n = t.parentNode;
	return n &&
		/^li$/i.test(n.nodeName) &&
		e.left < t.getBoundingClientRect().left
		? n
		: t;
}
function eE(t, e, n) {
	let { node: r, offset: o } = Mv(e, n),
		i = -1;
	if (r.nodeType == 1 && !r.firstChild) {
		let s = r.getBoundingClientRect();
		i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
	}
	return t.docView.posFromDOM(r, o, i);
}
function tE(t, e, n, r) {
	let o = -1;
	for (let i = e, s = !1; i != t.dom; ) {
		let l = t.docView.nearestDesc(i, !0);
		if (!l) return null;
		if (
			l.dom.nodeType == 1 &&
			((l.node.isBlock && l.parent && !s) || !l.contentDOM)
		) {
			let a = l.dom.getBoundingClientRect();
			if (
				(l.node.isBlock &&
					l.parent &&
					!s &&
					((s = !0),
					a.left > r.left || a.top > r.top
						? (o = l.posBefore)
						: (a.right < r.left || a.bottom < r.top) &&
						  (o = l.posAfter)),
				!l.contentDOM && o < 0 && !l.node.isText)
			)
				return (
					l.node.isBlock
						? r.top < (a.top + a.bottom) / 2
						: r.left < (a.left + a.right) / 2
				)
					? l.posBefore
					: l.posAfter;
		}
		i = l.dom.parentNode;
	}
	return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function Ev(t, e, n) {
	let r = t.childNodes.length;
	if (r && n.top < n.bottom)
		for (
			let o = Math.max(
					0,
					Math.min(
						r - 1,
						Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) -
							2
					)
				),
				i = o;
			;

		) {
			let s = t.childNodes[i];
			if (s.nodeType == 1) {
				let l = s.getClientRects();
				for (let a = 0; a < l.length; a++) {
					let u = l[a];
					if (mh(e, u)) return Ev(s, e, u);
				}
			}
			if ((i = (i + 1) % r) == o) break;
		}
	return t;
}
function nE(t, e) {
	let n = t.dom.ownerDocument,
		r,
		o = 0,
		i = VM(n, e.left, e.top);
	i && ({ node: r, offset: o } = i);
	let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
			e.left,
			e.top
		),
		l;
	if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
		let u = t.dom.getBoundingClientRect();
		if (!mh(e, u) || ((s = Ev(t.dom, e, u)), !s)) return null;
	}
	if (nn) for (let u = s; r && u; u = js(u)) u.draggable && (r = void 0);
	if (((s = ZM(s, e)), r)) {
		if (
			Vn &&
			r.nodeType == 1 &&
			((o = Math.min(o, r.childNodes.length)), o < r.childNodes.length)
		) {
			let c = r.childNodes[o],
				d;
			c.nodeName == "IMG" &&
				(d = c.getBoundingClientRect()).right <= e.left &&
				d.bottom > e.top &&
				o++;
		}
		let u;
		nl &&
			o &&
			r.nodeType == 1 &&
			(u = r.childNodes[o - 1]).nodeType == 1 &&
			u.contentEditable == "false" &&
			u.getBoundingClientRect().top >= e.top &&
			o--,
			r == t.dom &&
			o == r.childNodes.length - 1 &&
			r.lastChild.nodeType == 1 &&
			e.top > r.lastChild.getBoundingClientRect().bottom
				? (l = t.state.doc.content.size)
				: (o == 0 ||
						r.nodeType != 1 ||
						r.childNodes[o - 1].nodeName != "BR") &&
				  (l = tE(t, r, o, e));
	}
	l == null && (l = eE(t, s, e));
	let a = t.docView.nearestDesc(s, !0);
	return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function Km(t) {
	return t.top < t.bottom || t.left < t.right;
}
function Dr(t, e) {
	let n = t.getClientRects();
	if (n.length) {
		let r = n[e < 0 ? 0 : n.length - 1];
		if (Km(r)) return r;
	}
	return Array.prototype.find.call(n, Km) || t.getBoundingClientRect();
}
const rE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Tv(t, e, n) {
	let {
			node: r,
			offset: o,
			atom: i,
		} = t.docView.domFromPos(e, n < 0 ? -1 : 1),
		s = nl || Vn;
	if (r.nodeType == 3)
		if (
			s &&
			(rE.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))
		) {
			let a = Dr(wr(r, o, o), n);
			if (
				Vn &&
				o &&
				/\s/.test(r.nodeValue[o - 1]) &&
				o < r.nodeValue.length
			) {
				let u = Dr(wr(r, o - 1, o - 1), -1);
				if (u.top == a.top) {
					let c = Dr(wr(r, o, o + 1), -1);
					if (c.top != a.top) return Qi(c, c.left < u.left);
				}
			}
			return a;
		} else {
			let a = o,
				u = o,
				c = n < 0 ? 1 : -1;
			return (
				n < 0 && !o
					? (u++, (c = -1))
					: n >= 0 && o == r.nodeValue.length
					? (a--, (c = 1))
					: n < 0
					? a--
					: u++,
				Qi(Dr(wr(r, a, u), c), c < 0)
			);
		}
	if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
		if (i == null && o && (n < 0 || o == Zn(r))) {
			let a = r.childNodes[o - 1];
			if (a.nodeType == 1) return jc(a.getBoundingClientRect(), !1);
		}
		if (i == null && o < Zn(r)) {
			let a = r.childNodes[o];
			if (a.nodeType == 1) return jc(a.getBoundingClientRect(), !0);
		}
		return jc(r.getBoundingClientRect(), n >= 0);
	}
	if (i == null && o && (n < 0 || o == Zn(r))) {
		let a = r.childNodes[o - 1],
			u =
				a.nodeType == 3
					? wr(a, Zn(a) - (s ? 0 : 1))
					: a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling)
					? a
					: null;
		if (u) return Qi(Dr(u, 1), !1);
	}
	if (i == null && o < Zn(r)) {
		let a = r.childNodes[o];
		for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
			a = a.nextSibling;
		let u = a
			? a.nodeType == 3
				? wr(a, 0, s ? 0 : 1)
				: a.nodeType == 1
				? a
				: null
			: null;
		if (u) return Qi(Dr(u, -1), !0);
	}
	return Qi(Dr(r.nodeType == 3 ? wr(r) : r, -n), n >= 0);
}
function Qi(t, e) {
	if (t.width == 0) return t;
	let n = e ? t.left : t.right;
	return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function jc(t, e) {
	if (t.height == 0) return t;
	let n = e ? t.top : t.bottom;
	return { top: n, bottom: n, left: t.left, right: t.right };
}
function Av(t, e, n) {
	let r = t.state,
		o = t.root.activeElement;
	r != e && t.updateState(e), o != t.dom && t.focus();
	try {
		return n();
	} finally {
		r != e && t.updateState(r), o != t.dom && o && o.focus();
	}
}
function oE(t, e, n) {
	let r = e.selection,
		o = n == "up" ? r.$from : r.$to;
	return Av(t, e, () => {
		let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
		for (;;) {
			let l = t.docView.nearestDesc(i, !0);
			if (!l) break;
			if (l.node.isBlock) {
				i = l.contentDOM || l.dom;
				break;
			}
			i = l.dom.parentNode;
		}
		let s = Tv(t, o.pos, 1);
		for (let l = i.firstChild; l; l = l.nextSibling) {
			let a;
			if (l.nodeType == 1) a = l.getClientRects();
			else if (l.nodeType == 3)
				a = wr(l, 0, l.nodeValue.length).getClientRects();
			else continue;
			for (let u = 0; u < a.length; u++) {
				let c = a[u];
				if (
					c.bottom > c.top + 1 &&
					(n == "up"
						? s.top - c.top > (c.bottom - s.top) * 2
						: c.bottom - s.bottom > (s.bottom - c.top) * 2)
				)
					return !1;
			}
		}
		return !0;
	});
}
const iE = /[\u0590-\u08ac]/;
function sE(t, e, n) {
	let { $head: r } = e.selection;
	if (!r.parent.isTextblock) return !1;
	let o = r.parentOffset,
		i = !o,
		s = o == r.parent.content.size,
		l = t.domSelection();
	return !iE.test(r.parent.textContent) || !l.modify
		? n == "left" || n == "backward"
			? i
			: s
		: Av(t, e, () => {
				let {
						focusNode: a,
						focusOffset: u,
						anchorNode: c,
						anchorOffset: d,
					} = t.domSelectionRange(),
					f = l.caretBidiLevel;
				l.modify("move", n, "character");
				let p = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
					{ focusNode: m, focusOffset: y } = t.domSelectionRange(),
					v =
						(m &&
							!p.contains(m.nodeType == 1 ? m : m.parentNode)) ||
						(a == m && u == y);
				try {
					l.collapse(c, d),
						a && (a != c || u != d) && l.extend && l.extend(a, u);
				} catch (w) {}
				return f != null && (l.caretBidiLevel = f), v;
		  });
}
let qm = null,
	Jm = null,
	Gm = !1;
function lE(t, e, n) {
	return qm == e && Jm == n
		? Gm
		: ((qm = e),
		  (Jm = n),
		  (Gm = n == "up" || n == "down" ? oE(t, e, n) : sE(t, e, n)));
}
const On = 0,
	Ym = 1,
	Eo = 2,
	cr = 3;
class rl {
	constructor(e, n, r, o) {
		(this.parent = e),
			(this.children = n),
			(this.dom = r),
			(this.contentDOM = o),
			(this.dirty = On),
			(r.pmViewDesc = this);
	}
	matchesWidget(e) {
		return !1;
	}
	matchesMark(e) {
		return !1;
	}
	matchesNode(e, n, r) {
		return !1;
	}
	matchesHack(e) {
		return !1;
	}
	parseRule() {
		return null;
	}
	stopEvent(e) {
		return !1;
	}
	get size() {
		let e = 0;
		for (let n = 0; n < this.children.length; n++)
			e += this.children[n].size;
		return e;
	}
	get border() {
		return 0;
	}
	destroy() {
		(this.parent = void 0),
			this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
		for (let e = 0; e < this.children.length; e++)
			this.children[e].destroy();
	}
	posBeforeChild(e) {
		for (let n = 0, r = this.posAtStart; ; n++) {
			let o = this.children[n];
			if (o == e) return r;
			r += o.size;
		}
	}
	get posBefore() {
		return this.parent.posBeforeChild(this);
	}
	get posAtStart() {
		return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
	}
	get posAfter() {
		return this.posBefore + this.size;
	}
	get posAtEnd() {
		return this.posAtStart + this.size - 2 * this.border;
	}
	localPosFromDOM(e, n, r) {
		if (
			this.contentDOM &&
			this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
		)
			if (r < 0) {
				let i, s;
				if (e == this.contentDOM) i = e.childNodes[n - 1];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					i = e.previousSibling;
				}
				for (; i && !((s = i.pmViewDesc) && s.parent == this); )
					i = i.previousSibling;
				return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
			} else {
				let i, s;
				if (e == this.contentDOM) i = e.childNodes[n];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					i = e.nextSibling;
				}
				for (; i && !((s = i.pmViewDesc) && s.parent == this); )
					i = i.nextSibling;
				return i ? this.posBeforeChild(s) : this.posAtEnd;
			}
		let o;
		if (e == this.dom && this.contentDOM) o = n > en(this.contentDOM);
		else if (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			this.dom.contains(this.contentDOM)
		)
			o = e.compareDocumentPosition(this.contentDOM) & 2;
		else if (this.dom.firstChild) {
			if (n == 0)
				for (let i = e; ; i = i.parentNode) {
					if (i == this.dom) {
						o = !1;
						break;
					}
					if (i.previousSibling) break;
				}
			if (o == null && n == e.childNodes.length)
				for (let i = e; ; i = i.parentNode) {
					if (i == this.dom) {
						o = !0;
						break;
					}
					if (i.nextSibling) break;
				}
		}
		return (o == null ? r > 0 : o) ? this.posAtEnd : this.posAtStart;
	}
	nearestDesc(e, n = !1) {
		for (let r = !0, o = e; o; o = o.parentNode) {
			let i = this.getDesc(o),
				s;
			if (i && (!n || i.node))
				if (
					r &&
					(s = i.nodeDOM) &&
					!(s.nodeType == 1
						? s.contains(e.nodeType == 1 ? e : e.parentNode)
						: s == e)
				)
					r = !1;
				else return i;
		}
	}
	getDesc(e) {
		let n = e.pmViewDesc;
		for (let r = n; r; r = r.parent) if (r == this) return n;
	}
	posFromDOM(e, n, r) {
		for (let o = e; o; o = o.parentNode) {
			let i = this.getDesc(o);
			if (i) return i.localPosFromDOM(e, n, r);
		}
		return -1;
	}
	descAt(e) {
		for (let n = 0, r = 0; n < this.children.length; n++) {
			let o = this.children[n],
				i = r + o.size;
			if (r == e && i != r) {
				for (; !o.border && o.children.length; ) o = o.children[0];
				return o;
			}
			if (e < i) return o.descAt(e - r - o.border);
			r = i;
		}
	}
	domFromPos(e, n) {
		if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
		let r = 0,
			o = 0;
		for (let i = 0; r < this.children.length; r++) {
			let s = this.children[r],
				l = i + s.size;
			if (l > e || s instanceof Rv) {
				o = e - i;
				break;
			}
			i = l;
		}
		if (o)
			return this.children[r].domFromPos(o - this.children[r].border, n);
		for (
			let i;
			r &&
			!(i = this.children[r - 1]).size &&
			i instanceof Ov &&
			i.side >= 0;
			r--
		);
		if (n <= 0) {
			let i,
				s = !0;
			for (
				;
				(i = r ? this.children[r - 1] : null),
					!(!i || i.dom.parentNode == this.contentDOM);
				r--, s = !1
			);
			return i && n && s && !i.border && !i.domAtom
				? i.domFromPos(i.size, n)
				: { node: this.contentDOM, offset: i ? en(i.dom) + 1 : 0 };
		} else {
			let i,
				s = !0;
			for (
				;
				(i = r < this.children.length ? this.children[r] : null),
					!(!i || i.dom.parentNode == this.contentDOM);
				r++, s = !1
			);
			return i && s && !i.border && !i.domAtom
				? i.domFromPos(0, n)
				: {
						node: this.contentDOM,
						offset: i
							? en(i.dom)
							: this.contentDOM.childNodes.length,
				  };
		}
	}
	parseRange(e, n, r = 0) {
		if (this.children.length == 0)
			return {
				node: this.contentDOM,
				from: e,
				to: n,
				fromOffset: 0,
				toOffset: this.contentDOM.childNodes.length,
			};
		let o = -1,
			i = -1;
		for (let s = r, l = 0; ; l++) {
			let a = this.children[l],
				u = s + a.size;
			if (o == -1 && e <= u) {
				let c = s + a.border;
				if (
					e >= c &&
					n <= u - a.border &&
					a.node &&
					a.contentDOM &&
					this.contentDOM.contains(a.contentDOM)
				)
					return a.parseRange(e, n, c);
				e = s;
				for (let d = l; d > 0; d--) {
					let f = this.children[d - 1];
					if (
						f.size &&
						f.dom.parentNode == this.contentDOM &&
						!f.emptyChildAt(1)
					) {
						o = en(f.dom) + 1;
						break;
					}
					e -= f.size;
				}
				o == -1 && (o = 0);
			}
			if (o > -1 && (u > n || l == this.children.length - 1)) {
				n = u;
				for (let c = l + 1; c < this.children.length; c++) {
					let d = this.children[c];
					if (
						d.size &&
						d.dom.parentNode == this.contentDOM &&
						!d.emptyChildAt(-1)
					) {
						i = en(d.dom);
						break;
					}
					n += d.size;
				}
				i == -1 && (i = this.contentDOM.childNodes.length);
				break;
			}
			s = u;
		}
		return {
			node: this.contentDOM,
			from: e,
			to: n,
			fromOffset: o,
			toOffset: i,
		};
	}
	emptyChildAt(e) {
		if (this.border || !this.contentDOM || !this.children.length) return !1;
		let n = this.children[e < 0 ? 0 : this.children.length - 1];
		return n.size == 0 || n.emptyChildAt(e);
	}
	domAfterPos(e) {
		let { node: n, offset: r } = this.domFromPos(e, 0);
		if (n.nodeType != 1 || r == n.childNodes.length)
			throw new RangeError("No node after pos " + e);
		return n.childNodes[r];
	}
	setSelection(e, n, r, o = !1) {
		let i = Math.min(e, n),
			s = Math.max(e, n);
		for (let f = 0, p = 0; f < this.children.length; f++) {
			let m = this.children[f],
				y = p + m.size;
			if (i > p && s < y)
				return m.setSelection(e - p - m.border, n - p - m.border, r, o);
			p = y;
		}
		let l = this.domFromPos(e, e ? -1 : 1),
			a = n == e ? l : this.domFromPos(n, n ? -1 : 1),
			u = r.getSelection(),
			c = !1;
		if ((Vn || nn) && e == n) {
			let { node: f, offset: p } = l;
			if (f.nodeType == 3) {
				if (
					((c = !!(
						p &&
						f.nodeValue[p - 1] ==
							`
`
					)),
					c && p == f.nodeValue.length)
				)
					for (let m = f, y; m; m = m.parentNode) {
						if ((y = m.nextSibling)) {
							y.nodeName == "BR" &&
								(l = a =
									{ node: y.parentNode, offset: en(y) + 1 });
							break;
						}
						let v = m.pmViewDesc;
						if (v && v.node && v.node.isBlock) break;
					}
			} else {
				let m = f.childNodes[p - 1];
				c = m && (m.nodeName == "BR" || m.contentEditable == "false");
			}
		}
		if (
			Vn &&
			u.focusNode &&
			u.focusNode != a.node &&
			u.focusNode.nodeType == 1
		) {
			let f = u.focusNode.childNodes[u.focusOffset];
			f && f.contentEditable == "false" && (o = !0);
		}
		if (
			!(o || (c && nn)) &&
			Ho(l.node, l.offset, u.anchorNode, u.anchorOffset) &&
			Ho(a.node, a.offset, u.focusNode, u.focusOffset)
		)
			return;
		let d = !1;
		if ((u.extend || e == n) && !c) {
			u.collapse(l.node, l.offset);
			try {
				e != n && u.extend(a.node, a.offset), (d = !0);
			} catch (f) {}
		}
		if (!d) {
			if (e > n) {
				let p = l;
				(l = a), (a = p);
			}
			let f = document.createRange();
			f.setEnd(a.node, a.offset),
				f.setStart(l.node, l.offset),
				u.removeAllRanges(),
				u.addRange(f);
		}
	}
	ignoreMutation(e) {
		return !this.contentDOM && e.type != "selection";
	}
	get contentLost() {
		return (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			!this.dom.contains(this.contentDOM)
		);
	}
	markDirty(e, n) {
		for (let r = 0, o = 0; o < this.children.length; o++) {
			let i = this.children[o],
				s = r + i.size;
			if (r == s ? e <= s && n >= r : e < s && n > r) {
				let l = r + i.border,
					a = s - i.border;
				if (e >= l && n <= a) {
					(this.dirty = e == r || n == s ? Eo : Ym),
						e == l &&
						n == a &&
						(i.contentLost || i.dom.parentNode != this.contentDOM)
							? (i.dirty = cr)
							: i.markDirty(e - l, n - l);
					return;
				} else
					i.dirty =
						i.dom == i.contentDOM &&
						i.dom.parentNode == this.contentDOM &&
						!i.children.length
							? Eo
							: cr;
			}
			r = s;
		}
		this.dirty = Eo;
	}
	markParentsDirty() {
		let e = 1;
		for (let n = this.parent; n; n = n.parent, e++) {
			let r = e == 1 ? Eo : Ym;
			n.dirty < r && (n.dirty = r);
		}
	}
	get domAtom() {
		return !1;
	}
	get ignoreForCoords() {
		return !1;
	}
}
class Ov extends rl {
	constructor(e, n, r, o) {
		let i,
			s = n.type.toDOM;
		if (
			(typeof s == "function" &&
				(s = s(r, () => {
					if (!i) return o;
					if (i.parent) return i.parent.posBeforeChild(i);
				})),
			!n.type.spec.raw)
		) {
			if (s.nodeType != 1) {
				let l = document.createElement("span");
				l.appendChild(s), (s = l);
			}
			(s.contentEditable = "false"),
				s.classList.add("ProseMirror-widget");
		}
		super(e, [], s, null), (this.widget = n), (this.widget = n), (i = this);
	}
	matchesWidget(e) {
		return this.dirty == On && e.type.eq(this.widget.type);
	}
	parseRule() {
		return { ignore: !0 };
	}
	stopEvent(e) {
		let n = this.widget.spec.stopEvent;
		return n ? n(e) : !1;
	}
	ignoreMutation(e) {
		return e.type != "selection" || this.widget.spec.ignoreSelection;
	}
	destroy() {
		this.widget.type.destroy(this.dom), super.destroy();
	}
	get domAtom() {
		return !0;
	}
	get side() {
		return this.widget.type.side;
	}
}
class aE extends rl {
	constructor(e, n, r, o) {
		super(e, [], n, null), (this.textDOM = r), (this.text = o);
	}
	get size() {
		return this.text.length;
	}
	localPosFromDOM(e, n) {
		return e != this.textDOM
			? this.posAtStart + (n ? this.size : 0)
			: this.posAtStart + n;
	}
	domFromPos(e) {
		return { node: this.textDOM, offset: e };
	}
	ignoreMutation(e) {
		return e.type === "characterData" && e.target.nodeValue == e.oldValue;
	}
}
class Fo extends rl {
	constructor(e, n, r, o) {
		super(e, [], r, o), (this.mark = n);
	}
	static create(e, n, r, o) {
		let i = o.nodeViews[n.type.name],
			s = i && i(n, o, r);
		return (
			(!s || !s.dom) &&
				(s = tr.renderSpec(document, n.type.spec.toDOM(n, r))),
			new Fo(e, n, s.dom, s.contentDOM || s.dom)
		);
	}
	parseRule() {
		return this.dirty & cr || this.mark.type.spec.reparseInView
			? null
			: {
					mark: this.mark.type.name,
					attrs: this.mark.attrs,
					contentElement: this.contentDOM,
			  };
	}
	matchesMark(e) {
		return this.dirty != cr && this.mark.eq(e);
	}
	markDirty(e, n) {
		if ((super.markDirty(e, n), this.dirty != On)) {
			let r = this.parent;
			for (; !r.node; ) r = r.parent;
			r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = On);
		}
	}
	slice(e, n, r) {
		let o = Fo.create(this.parent, this.mark, !0, r),
			i = this.children,
			s = this.size;
		n < s && (i = Kd(i, n, s, r)), e > 0 && (i = Kd(i, 0, e, r));
		for (let l = 0; l < i.length; l++) i[l].parent = o;
		return (o.children = i), o;
	}
}
class no extends rl {
	constructor(e, n, r, o, i, s, l, a, u) {
		super(e, [], i, s),
			(this.node = n),
			(this.outerDeco = r),
			(this.innerDeco = o),
			(this.nodeDOM = l);
	}
	static create(e, n, r, o, i, s) {
		let l = i.nodeViews[n.type.name],
			a,
			u =
				l &&
				l(
					n,
					i,
					() => {
						if (!a) return s;
						if (a.parent) return a.parent.posBeforeChild(a);
					},
					r,
					o
				),
			c = u && u.dom,
			d = u && u.contentDOM;
		if (n.isText) {
			if (!c) c = document.createTextNode(n.text);
			else if (c.nodeType != 3)
				throw new RangeError(
					"Text must be rendered as a DOM text node"
				);
		} else
			c ||
				({ dom: c, contentDOM: d } = tr.renderSpec(
					document,
					n.type.spec.toDOM(n)
				));
		!d &&
			!n.isText &&
			c.nodeName != "BR" &&
			(c.hasAttribute("contenteditable") || (c.contentEditable = "false"),
			n.type.spec.draggable && (c.draggable = !0));
		let f = c;
		return (
			(c = Nv(c, r, n)),
			u
				? (a = new uE(e, n, r, o, c, d || null, f, u, i, s + 1))
				: n.isText
				? new Uu(e, n, r, o, c, f, i)
				: new no(e, n, r, o, c, d || null, f, i, s + 1)
		);
	}
	parseRule() {
		if (this.node.type.spec.reparseInView) return null;
		let e = { node: this.node.type.name, attrs: this.node.attrs };
		if (
			(this.node.type.whitespace == "pre" &&
				(e.preserveWhitespace = "full"),
			!this.contentDOM)
		)
			e.getContent = () => this.node.content;
		else if (!this.contentLost) e.contentElement = this.contentDOM;
		else {
			for (let n = this.children.length - 1; n >= 0; n--) {
				let r = this.children[n];
				if (this.dom.contains(r.dom.parentNode)) {
					e.contentElement = r.dom.parentNode;
					break;
				}
			}
			e.contentElement || (e.getContent = () => J.empty);
		}
		return e;
	}
	matchesNode(e, n, r) {
		return (
			this.dirty == On &&
			e.eq(this.node) &&
			Ud(n, this.outerDeco) &&
			r.eq(this.innerDeco)
		);
	}
	get size() {
		return this.node.nodeSize;
	}
	get border() {
		return this.node.isLeaf ? 0 : 1;
	}
	updateChildren(e, n) {
		let r = this.node.inlineContent,
			o = n,
			i = e.composing ? this.localCompositionInfo(e, n) : null,
			s = i && i.pos > -1 ? i : null,
			l = i && i.pos < 0,
			a = new dE(this, s && s.node, e);
		pE(
			this.node,
			this.innerDeco,
			(u, c, d) => {
				u.spec.marks
					? a.syncToMarks(u.spec.marks, r, e)
					: u.type.side >= 0 &&
					  !d &&
					  a.syncToMarks(
							c == this.node.childCount
								? ot.none
								: this.node.child(c).marks,
							r,
							e
					  ),
					a.placeWidget(u, e, o);
			},
			(u, c, d, f) => {
				a.syncToMarks(u.marks, r, e);
				let p;
				a.findNodeMatch(u, c, d, f) ||
					(l &&
						e.state.selection.from > o &&
						e.state.selection.to < o + u.nodeSize &&
						(p = a.findIndexWithChild(i.node)) > -1 &&
						a.updateNodeAt(u, c, d, p, e)) ||
					a.updateNextNode(u, c, d, e, f, o) ||
					a.addNode(u, c, d, e, o),
					(o += u.nodeSize);
			}
		),
			a.syncToMarks([], r, e),
			this.node.isTextblock && a.addTextblockHacks(),
			a.destroyRest(),
			(a.changed || this.dirty == Eo) &&
				(s && this.protectLocalComposition(e, s),
				Pv(this.contentDOM, this.children, e),
				Ni && mE(this.dom));
	}
	localCompositionInfo(e, n) {
		let { from: r, to: o } = e.state.selection;
		if (
			!(e.state.selection instanceof Se) ||
			r < n ||
			o > n + this.node.content.size
		)
			return null;
		let i = e.domSelectionRange(),
			s = gE(i.focusNode, i.focusOffset);
		if (!s || !this.dom.contains(s.parentNode)) return null;
		if (this.node.inlineContent) {
			let l = s.nodeValue,
				a = yE(this.node.content, l, r - n, o - n);
			return a < 0 ? null : { node: s, pos: a, text: l };
		} else return { node: s, pos: -1, text: "" };
	}
	protectLocalComposition(e, { node: n, pos: r, text: o }) {
		if (this.getDesc(n)) return;
		let i = n;
		for (; i.parentNode != this.contentDOM; i = i.parentNode) {
			for (; i.previousSibling; )
				i.parentNode.removeChild(i.previousSibling);
			for (; i.nextSibling; ) i.parentNode.removeChild(i.nextSibling);
			i.pmViewDesc && (i.pmViewDesc = void 0);
		}
		let s = new aE(this, i, n, o);
		e.input.compositionNodes.push(s),
			(this.children = Kd(this.children, r, r + o.length, e, s));
	}
	update(e, n, r, o) {
		return this.dirty == cr || !e.sameMarkup(this.node)
			? !1
			: (this.updateInner(e, n, r, o), !0);
	}
	updateInner(e, n, r, o) {
		this.updateOuterDeco(n),
			(this.node = e),
			(this.innerDeco = r),
			this.contentDOM && this.updateChildren(o, this.posAtStart),
			(this.dirty = On);
	}
	updateOuterDeco(e) {
		if (Ud(e, this.outerDeco)) return;
		let n = this.nodeDOM.nodeType != 1,
			r = this.dom;
		(this.dom = Iv(
			this.dom,
			this.nodeDOM,
			Wd(this.outerDeco, this.node, n),
			Wd(e, this.node, n)
		)),
			this.dom != r &&
				((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
			(this.outerDeco = e);
	}
	selectNode() {
		this.nodeDOM.nodeType == 1 &&
			this.nodeDOM.classList.add("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				(this.dom.draggable = !0);
	}
	deselectNode() {
		this.nodeDOM.nodeType == 1 &&
			this.nodeDOM.classList.remove("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				this.dom.removeAttribute("draggable");
	}
	get domAtom() {
		return this.node.isAtom;
	}
}
function Qm(t, e, n, r, o) {
	Nv(r, e, t);
	let i = new no(void 0, t, e, n, r, r, r, o, 0);
	return i.contentDOM && i.updateChildren(o, 0), i;
}
class Uu extends no {
	constructor(e, n, r, o, i, s, l) {
		super(e, n, r, o, i, null, s, l, 0);
	}
	parseRule() {
		let e = this.nodeDOM.parentNode;
		for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
		return { skip: e || !0 };
	}
	update(e, n, r, o) {
		return this.dirty == cr ||
			(this.dirty != On && !this.inParent()) ||
			!e.sameMarkup(this.node)
			? !1
			: (this.updateOuterDeco(n),
			  (this.dirty != On || e.text != this.node.text) &&
					e.text != this.nodeDOM.nodeValue &&
					((this.nodeDOM.nodeValue = e.text),
					o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
			  (this.node = e),
			  (this.dirty = On),
			  !0);
	}
	inParent() {
		let e = this.parent.contentDOM;
		for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
		return !1;
	}
	domFromPos(e) {
		return { node: this.nodeDOM, offset: e };
	}
	localPosFromDOM(e, n, r) {
		return e == this.nodeDOM
			? this.posAtStart + Math.min(n, this.node.text.length)
			: super.localPosFromDOM(e, n, r);
	}
	ignoreMutation(e) {
		return e.type != "characterData" && e.type != "selection";
	}
	slice(e, n, r) {
		let o = this.node.cut(e, n),
			i = document.createTextNode(o.text);
		return new Uu(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
	}
	markDirty(e, n) {
		super.markDirty(e, n),
			this.dom != this.nodeDOM &&
				(e == 0 || n == this.nodeDOM.nodeValue.length) &&
				(this.dirty = cr);
	}
	get domAtom() {
		return !1;
	}
}
class Rv extends rl {
	parseRule() {
		return { ignore: !0 };
	}
	matchesHack(e) {
		return this.dirty == On && this.dom.nodeName == e;
	}
	get domAtom() {
		return !0;
	}
	get ignoreForCoords() {
		return this.dom.nodeName == "IMG";
	}
}
class uE extends no {
	constructor(e, n, r, o, i, s, l, a, u, c) {
		super(e, n, r, o, i, s, l, u, c), (this.spec = a);
	}
	update(e, n, r, o) {
		if (this.dirty == cr) return !1;
		if (this.spec.update) {
			let i = this.spec.update(e, n, r);
			return i && this.updateInner(e, n, r, o), i;
		} else
			return !this.contentDOM && !e.isLeaf
				? !1
				: super.update(e, n, r, o);
	}
	selectNode() {
		this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
	}
	deselectNode() {
		this.spec.deselectNode
			? this.spec.deselectNode()
			: super.deselectNode();
	}
	setSelection(e, n, r, o) {
		this.spec.setSelection
			? this.spec.setSelection(e, n, r)
			: super.setSelection(e, n, r, o);
	}
	destroy() {
		this.spec.destroy && this.spec.destroy(), super.destroy();
	}
	stopEvent(e) {
		return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
	}
	ignoreMutation(e) {
		return this.spec.ignoreMutation
			? this.spec.ignoreMutation(e)
			: super.ignoreMutation(e);
	}
}
function Pv(t, e, n) {
	let r = t.firstChild,
		o = !1;
	for (let i = 0; i < e.length; i++) {
		let s = e[i],
			l = s.dom;
		if (l.parentNode == t) {
			for (; l != r; ) (r = Xm(r)), (o = !0);
			r = r.nextSibling;
		} else (o = !0), t.insertBefore(l, r);
		if (s instanceof Fo) {
			let a = r ? r.previousSibling : t.lastChild;
			Pv(s.contentDOM, s.children, n),
				(r = a ? a.nextSibling : t.firstChild);
		}
	}
	for (; r; ) (r = Xm(r)), (o = !0);
	o && n.trackWrites == t && (n.trackWrites = null);
}
const gs = function (t) {
	t && (this.nodeName = t);
};
gs.prototype = Object.create(null);
const To = [new gs()];
function Wd(t, e, n) {
	if (t.length == 0) return To;
	let r = n ? To[0] : new gs(),
		o = [r];
	for (let i = 0; i < t.length; i++) {
		let s = t[i].type.attrs;
		if (s) {
			s.nodeName && o.push((r = new gs(s.nodeName)));
			for (let l in s) {
				let a = s[l];
				a != null &&
					(n &&
						o.length == 1 &&
						o.push((r = new gs(e.isInline ? "span" : "div"))),
					l == "class"
						? (r.class = (r.class ? r.class + " " : "") + a)
						: l == "style"
						? (r.style = (r.style ? r.style + ";" : "") + a)
						: l != "nodeName" && (r[l] = a));
			}
		}
	}
	return o;
}
function Iv(t, e, n, r) {
	if (n == To && r == To) return e;
	let o = e;
	for (let i = 0; i < r.length; i++) {
		let s = r[i],
			l = n[i];
		if (i) {
			let a;
			(l &&
				l.nodeName == s.nodeName &&
				o != t &&
				(a = o.parentNode) &&
				a.nodeName.toLowerCase() == s.nodeName) ||
				((a = document.createElement(s.nodeName)),
				(a.pmIsDeco = !0),
				a.appendChild(o),
				(l = To[0])),
				(o = a);
		}
		cE(o, l || To[0], s);
	}
	return o;
}
function cE(t, e, n) {
	for (let r in e)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			!(r in n) &&
			t.removeAttribute(r);
	for (let r in n)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			n[r] != e[r] &&
			t.setAttribute(r, n[r]);
	if (e.class != n.class) {
		let r = e.class ? e.class.split(" ").filter(Boolean) : [],
			o = n.class ? n.class.split(" ").filter(Boolean) : [];
		for (let i = 0; i < r.length; i++)
			o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
		for (let i = 0; i < o.length; i++)
			r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
		t.classList.length == 0 && t.removeAttribute("class");
	}
	if (e.style != n.style) {
		if (e.style) {
			let r =
					/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
				o;
			for (; (o = r.exec(e.style)); ) t.style.removeProperty(o[1]);
		}
		n.style && (t.style.cssText += n.style);
	}
}
function Nv(t, e, n) {
	return Iv(t, t, To, Wd(e, n, t.nodeType != 1));
}
function Ud(t, e) {
	if (t.length != e.length) return !1;
	for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
	return !0;
}
function Xm(t) {
	let e = t.nextSibling;
	return t.parentNode.removeChild(t), e;
}
class dE {
	constructor(e, n, r) {
		(this.lock = n),
			(this.view = r),
			(this.index = 0),
			(this.stack = []),
			(this.changed = !1),
			(this.top = e),
			(this.preMatch = fE(e.node.content, e));
	}
	destroyBetween(e, n) {
		if (e != n) {
			for (let r = e; r < n; r++) this.top.children[r].destroy();
			this.top.children.splice(e, n - e), (this.changed = !0);
		}
	}
	destroyRest() {
		this.destroyBetween(this.index, this.top.children.length);
	}
	syncToMarks(e, n, r) {
		let o = 0,
			i = this.stack.length >> 1,
			s = Math.min(i, e.length);
		for (
			;
			o < s &&
			(o == i - 1 ? this.top : this.stack[(o + 1) << 1]).matchesMark(
				e[o]
			) &&
			e[o].type.spec.spanning !== !1;

		)
			o++;
		for (; o < i; )
			this.destroyRest(),
				(this.top.dirty = On),
				(this.index = this.stack.pop()),
				(this.top = this.stack.pop()),
				i--;
		for (; i < e.length; ) {
			this.stack.push(this.top, this.index + 1);
			let l = -1;
			for (
				let a = this.index;
				a < Math.min(this.index + 3, this.top.children.length);
				a++
			) {
				let u = this.top.children[a];
				if (u.matchesMark(e[i]) && !this.isLocked(u.dom)) {
					l = a;
					break;
				}
			}
			if (l > -1)
				l > this.index &&
					((this.changed = !0), this.destroyBetween(this.index, l)),
					(this.top = this.top.children[this.index]);
			else {
				let a = Fo.create(this.top, e[i], n, r);
				this.top.children.splice(this.index, 0, a),
					(this.top = a),
					(this.changed = !0);
			}
			(this.index = 0), i++;
		}
	}
	findNodeMatch(e, n, r, o) {
		let i = -1,
			s;
		if (
			o >= this.preMatch.index &&
			(s = this.preMatch.matches[o - this.preMatch.index]).parent ==
				this.top &&
			s.matchesNode(e, n, r)
		)
			i = this.top.children.indexOf(s, this.index);
		else
			for (
				let l = this.index,
					a = Math.min(this.top.children.length, l + 5);
				l < a;
				l++
			) {
				let u = this.top.children[l];
				if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
					i = l;
					break;
				}
			}
		return i < 0
			? !1
			: (this.destroyBetween(this.index, i), this.index++, !0);
	}
	updateNodeAt(e, n, r, o, i) {
		let s = this.top.children[o];
		return (
			s.dirty == cr && s.dom == s.contentDOM && (s.dirty = Eo),
			s.update(e, n, r, i)
				? (this.destroyBetween(this.index, o), this.index++, !0)
				: !1
		);
	}
	findIndexWithChild(e) {
		for (;;) {
			let n = e.parentNode;
			if (!n) return -1;
			if (n == this.top.contentDOM) {
				let r = e.pmViewDesc;
				if (r) {
					for (let o = this.index; o < this.top.children.length; o++)
						if (this.top.children[o] == r) return o;
				}
				return -1;
			}
			e = n;
		}
	}
	updateNextNode(e, n, r, o, i, s) {
		for (let l = this.index; l < this.top.children.length; l++) {
			let a = this.top.children[l];
			if (a instanceof no) {
				let u = this.preMatch.matched.get(a);
				if (u != null && u != i) return !1;
				let c = a.dom,
					d,
					f =
						this.isLocked(c) &&
						!(
							e.isText &&
							a.node &&
							a.node.isText &&
							a.nodeDOM.nodeValue == e.text &&
							a.dirty != cr &&
							Ud(n, a.outerDeco)
						);
				if (!f && a.update(e, n, r, o))
					return (
						this.destroyBetween(this.index, l),
						a.dom != c && (this.changed = !0),
						this.index++,
						!0
					);
				if (!f && (d = this.recreateWrapper(a, e, n, r, o, s)))
					return (
						(this.top.children[this.index] = d),
						d.contentDOM &&
							((d.dirty = Eo),
							d.updateChildren(o, s + 1),
							(d.dirty = On)),
						(this.changed = !0),
						this.index++,
						!0
					);
				break;
			}
		}
		return !1;
	}
	recreateWrapper(e, n, r, o, i, s) {
		if (
			e.dirty ||
			n.isAtom ||
			!e.children.length ||
			!e.node.content.eq(n.content)
		)
			return null;
		let l = no.create(this.top, n, r, o, i, s);
		if (l.contentDOM) {
			(l.children = e.children), (e.children = []);
			for (let a of l.children) a.parent = l;
		}
		return e.destroy(), l;
	}
	addNode(e, n, r, o, i) {
		let s = no.create(this.top, e, n, r, o, i);
		s.contentDOM && s.updateChildren(o, i + 1),
			this.top.children.splice(this.index++, 0, s),
			(this.changed = !0);
	}
	placeWidget(e, n, r) {
		let o =
			this.index < this.top.children.length
				? this.top.children[this.index]
				: null;
		if (
			o &&
			o.matchesWidget(e) &&
			(e == o.widget || !o.widget.type.toDOM.parentNode)
		)
			this.index++;
		else {
			let i = new Ov(this.top, e, n, r);
			this.top.children.splice(this.index++, 0, i), (this.changed = !0);
		}
	}
	addTextblockHacks() {
		let e = this.top.children[this.index - 1],
			n = this.top;
		for (; e instanceof Fo; )
			(n = e), (e = n.children[n.children.length - 1]);
		(!e ||
			!(e instanceof Uu) ||
			/\n$/.test(e.node.text) ||
			(this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
			((nn || Kt) &&
				e &&
				e.dom.contentEditable == "false" &&
				this.addHackNode("IMG", n),
			this.addHackNode("BR", this.top));
	}
	addHackNode(e, n) {
		if (
			n == this.top &&
			this.index < n.children.length &&
			n.children[this.index].matchesHack(e)
		)
			this.index++;
		else {
			let r = document.createElement(e);
			e == "IMG" &&
				((r.className = "ProseMirror-separator"), (r.alt = "")),
				e == "BR" && (r.className = "ProseMirror-trailingBreak");
			let o = new Rv(this.top, [], r, null);
			n != this.top
				? n.children.push(o)
				: n.children.splice(this.index++, 0, o),
				(this.changed = !0);
		}
	}
	isLocked(e) {
		return (
			this.lock &&
			(e == this.lock ||
				(e.nodeType == 1 && e.contains(this.lock.parentNode)))
		);
	}
}
function fE(t, e) {
	let n = e,
		r = n.children.length,
		o = t.childCount,
		i = new Map(),
		s = [];
	e: for (; o > 0; ) {
		let l;
		for (;;)
			if (r) {
				let u = n.children[r - 1];
				if (u instanceof Fo) (n = u), (r = u.children.length);
				else {
					(l = u), r--;
					break;
				}
			} else {
				if (n == e) break e;
				(r = n.parent.children.indexOf(n)), (n = n.parent);
			}
		let a = l.node;
		if (a) {
			if (a != t.child(o - 1)) break;
			--o, i.set(l, o), s.push(l);
		}
	}
	return { index: o, matched: i, matches: s.reverse() };
}
function hE(t, e) {
	return t.type.side - e.type.side;
}
function pE(t, e, n, r) {
	let o = e.locals(t),
		i = 0;
	if (o.length == 0) {
		for (let u = 0; u < t.childCount; u++) {
			let c = t.child(u);
			r(c, o, e.forChild(i, c), u), (i += c.nodeSize);
		}
		return;
	}
	let s = 0,
		l = [],
		a = null;
	for (let u = 0; ; ) {
		let c, d;
		for (; s < o.length && o[s].to == i; ) {
			let v = o[s++];
			v.widget && (c ? (d || (d = [c])).push(v) : (c = v));
		}
		if (c)
			if (d) {
				d.sort(hE);
				for (let v = 0; v < d.length; v++) n(d[v], u, !!a);
			} else n(c, u, !!a);
		let f, p;
		if (a) (p = -1), (f = a), (a = null);
		else if (u < t.childCount) (p = u), (f = t.child(u++));
		else break;
		for (let v = 0; v < l.length; v++) l[v].to <= i && l.splice(v--, 1);
		for (; s < o.length && o[s].from <= i && o[s].to > i; ) l.push(o[s++]);
		let m = i + f.nodeSize;
		if (f.isText) {
			let v = m;
			s < o.length && o[s].from < v && (v = o[s].from);
			for (let w = 0; w < l.length; w++) l[w].to < v && (v = l[w].to);
			v < m &&
				((a = f.cut(v - i)), (f = f.cut(0, v - i)), (m = v), (p = -1));
		} else for (; s < o.length && o[s].to < m; ) s++;
		let y =
			f.isInline && !f.isLeaf ? l.filter((v) => !v.inline) : l.slice();
		r(f, y, e.forChild(i, f), p), (i = m);
	}
}
function mE(t) {
	if (t.nodeName == "UL" || t.nodeName == "OL") {
		let e = t.style.cssText;
		(t.style.cssText = e + "; list-style: square !important"),
			window.getComputedStyle(t).listStyle,
			(t.style.cssText = e);
	}
}
function gE(t, e) {
	for (;;) {
		if (t.nodeType == 3) return t;
		if (t.nodeType == 1 && e > 0) {
			if (t.childNodes.length > e && t.childNodes[e].nodeType == 3)
				return t.childNodes[e];
			(t = t.childNodes[e - 1]), (e = Zn(t));
		} else if (t.nodeType == 1 && e < t.childNodes.length)
			(t = t.childNodes[e]), (e = 0);
		else return null;
	}
}
function yE(t, e, n, r) {
	for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
		let s = t.child(o++),
			l = i;
		if (((i += s.nodeSize), !s.isText)) continue;
		let a = s.text;
		for (; o < t.childCount; ) {
			let u = t.child(o++);
			if (((i += u.nodeSize), !u.isText)) break;
			a += u.text;
		}
		if (i >= n) {
			if (i >= r && a.slice(r - e.length - l, r - l) == e)
				return r - e.length;
			let u = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
			if (u >= 0 && u + e.length + l >= n) return l + u;
			if (
				n == r &&
				a.length >= r + e.length - l &&
				a.slice(r - l, r - l + e.length) == e
			)
				return r;
		}
	}
	return -1;
}
function Kd(t, e, n, r, o) {
	let i = [];
	for (let s = 0, l = 0; s < t.length; s++) {
		let a = t[s],
			u = l,
			c = (l += a.size);
		u >= n || c <= e
			? i.push(a)
			: (u < e && i.push(a.slice(0, e - u, r)),
			  o && (i.push(o), (o = void 0)),
			  c > n && i.push(a.slice(n - u, a.size, r)));
	}
	return i;
}
function gh(t, e = null) {
	let n = t.domSelectionRange(),
		r = t.state.doc;
	if (!n.focusNode) return null;
	let o = t.docView.nearestDesc(n.focusNode),
		i = o && o.size == 0,
		s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
	if (s < 0) return null;
	let l = r.resolve(s),
		a,
		u;
	if (Wu(n)) {
		for (a = l; o && !o.node; ) o = o.parent;
		let c = o.node;
		if (
			o &&
			c.isAtom &&
			we.isSelectable(c) &&
			o.parent &&
			!(c.isInline && HM(n.focusNode, n.focusOffset, o.dom))
		) {
			let d = o.posBefore;
			u = new we(s == d ? l : r.resolve(d));
		}
	} else {
		let c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
		if (c < 0) return null;
		a = r.resolve(c);
	}
	if (!u) {
		let c =
			e == "pointer" || (t.state.selection.head < l.pos && !i) ? 1 : -1;
		u = yh(t, a, l, c);
	}
	return u;
}
function Dv(t) {
	return t.editable
		? t.hasFocus()
		: Lv(t) &&
				document.activeElement &&
				document.activeElement.contains(t.dom);
}
function Cr(t, e = !1) {
	let n = t.state.selection;
	if ((jv(t, n), !!Dv(t))) {
		if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Kt) {
			let r = t.domSelectionRange(),
				o = t.domObserver.currentSelection;
			if (
				r.anchorNode &&
				o.anchorNode &&
				Ho(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)
			) {
				(t.input.mouseDown.delayedSelectionSync = !0),
					t.domObserver.setCurSelection();
				return;
			}
		}
		if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) bE(t);
		else {
			let { anchor: r, head: o } = n,
				i,
				s;
			Zm &&
				!(n instanceof Se) &&
				(n.$from.parent.inlineContent || (i = eg(t, n.from)),
				!n.empty && !n.$from.parent.inlineContent && (s = eg(t, n.to))),
				t.docView.setSelection(r, o, t.root, e),
				Zm && (i && tg(i), s && tg(s)),
				n.visible
					? t.dom.classList.remove("ProseMirror-hideselection")
					: (t.dom.classList.add("ProseMirror-hideselection"),
					  "onselectionchange" in document && vE(t));
		}
		t.domObserver.setCurSelection(), t.domObserver.connectSelection();
	}
}
const Zm = nn || (Kt && WM < 63);
function eg(t, e) {
	let { node: n, offset: r } = t.docView.domFromPos(e, 0),
		o = r < n.childNodes.length ? n.childNodes[r] : null,
		i = r ? n.childNodes[r - 1] : null;
	if (nn && o && o.contentEditable == "false") return Lc(o);
	if (
		(!o || o.contentEditable == "false") &&
		(!i || i.contentEditable == "false")
	) {
		if (o) return Lc(o);
		if (i) return Lc(i);
	}
}
function Lc(t) {
	return (
		(t.contentEditable = "true"),
		nn && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
		t
	);
}
function tg(t) {
	(t.contentEditable = "false"),
		t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function vE(t) {
	let e = t.dom.ownerDocument;
	e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
	let n = t.domSelectionRange(),
		r = n.anchorNode,
		o = n.anchorOffset;
	e.addEventListener(
		"selectionchange",
		(t.input.hideSelectionGuard = () => {
			(n.anchorNode != r || n.anchorOffset != o) &&
				(e.removeEventListener(
					"selectionchange",
					t.input.hideSelectionGuard
				),
				setTimeout(() => {
					(!Dv(t) || t.state.selection.visible) &&
						t.dom.classList.remove("ProseMirror-hideselection");
				}, 20));
		})
	);
}
function bE(t) {
	let e = t.domSelection(),
		n = document.createRange(),
		r = t.cursorWrapper.dom,
		o = r.nodeName == "IMG";
	o ? n.setEnd(r.parentNode, en(r) + 1) : n.setEnd(r, 0),
		n.collapse(!1),
		e.removeAllRanges(),
		e.addRange(n),
		!o &&
			!t.state.selection.visible &&
			cn &&
			to <= 11 &&
			((r.disabled = !0), (r.disabled = !1));
}
function jv(t, e) {
	if (e instanceof we) {
		let n = t.docView.descAt(e.from);
		n != t.lastSelectedViewDesc &&
			(ng(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
	} else ng(t);
}
function ng(t) {
	t.lastSelectedViewDesc &&
		(t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
		(t.lastSelectedViewDesc = void 0));
}
function yh(t, e, n, r) {
	return (
		t.someProp("createSelectionBetween", (o) => o(t, e, n)) ||
		Se.between(e, n, r)
	);
}
function rg(t) {
	return t.editable && !t.hasFocus() ? !1 : Lv(t);
}
function Lv(t) {
	let e = t.domSelectionRange();
	if (!e.anchorNode) return !1;
	try {
		return (
			t.dom.contains(
				e.anchorNode.nodeType == 3
					? e.anchorNode.parentNode
					: e.anchorNode
			) &&
			(t.editable ||
				t.dom.contains(
					e.focusNode.nodeType == 3
						? e.focusNode.parentNode
						: e.focusNode
				))
		);
	} catch (n) {
		return !1;
	}
}
function wE(t) {
	let e = t.docView.domFromPos(t.state.selection.anchor, 0),
		n = t.domSelectionRange();
	return Ho(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function qd(t, e) {
	let { $anchor: n, $head: r } = t.selection,
		o = e > 0 ? n.max(r) : n.min(r),
		i = o.parent.inlineContent
			? o.depth
				? t.doc.resolve(e > 0 ? o.after() : o.before())
				: null
			: o;
	return i && Me.findFrom(i, e);
}
function Hr(t, e) {
	return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function og(t, e, n) {
	let r = t.state.selection;
	if (r instanceof Se)
		if (n.indexOf("s") > -1) {
			let { $head: o } = r,
				i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
			if (!i || i.isText || !i.isLeaf) return !1;
			let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
			return Hr(t, new Se(r.$anchor, s));
		} else if (r.empty) {
			if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
				let o = qd(t.state, e);
				return o && o instanceof we ? Hr(t, o) : !1;
			} else if (!(Sn && n.indexOf("m") > -1)) {
				let o = r.$head,
					i = o.textOffset
						? null
						: e < 0
						? o.nodeBefore
						: o.nodeAfter,
					s;
				if (!i || i.isText) return !1;
				let l = e < 0 ? o.pos - i.nodeSize : o.pos;
				return i.isAtom || ((s = t.docView.descAt(l)) && !s.contentDOM)
					? we.isSelectable(i)
						? Hr(
								t,
								new we(
									e < 0
										? t.state.doc.resolve(
												o.pos - i.nodeSize
										  )
										: o
								)
						  )
						: nl
						? Hr(
								t,
								new Se(
									t.state.doc.resolve(
										e < 0 ? l : l + i.nodeSize
									)
								)
						  )
						: !1
					: !1;
			}
		} else return !1;
	else {
		if (r instanceof we && r.node.isInline)
			return Hr(t, new Se(e > 0 ? r.$to : r.$from));
		{
			let o = qd(t.state, e);
			return o ? Hr(t, o) : !1;
		}
	}
}
function Ta(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function ys(t, e) {
	let n = t.pmViewDesc;
	return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function Xo(t, e) {
	return e < 0 ? xE(t) : kE(t);
}
function xE(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let o,
		i,
		s = !1;
	for (
		Vn &&
		n.nodeType == 1 &&
		r < Ta(n) &&
		ys(n.childNodes[r], -1) &&
		(s = !0);
		;

	)
		if (r > 0) {
			if (n.nodeType != 1) break;
			{
				let l = n.childNodes[r - 1];
				if (ys(l, -1)) (o = n), (i = --r);
				else if (l.nodeType == 3) (n = l), (r = n.nodeValue.length);
				else break;
			}
		} else {
			if ($v(n)) break;
			{
				let l = n.previousSibling;
				for (; l && ys(l, -1); )
					(o = n.parentNode), (i = en(l)), (l = l.previousSibling);
				if (l) (n = l), (r = Ta(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = 0;
				}
			}
		}
	s ? Jd(t, n, r) : o && Jd(t, o, i);
}
function kE(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let o = Ta(n),
		i,
		s;
	for (;;)
		if (r < o) {
			if (n.nodeType != 1) break;
			let l = n.childNodes[r];
			if (ys(l, 1)) (i = n), (s = ++r);
			else break;
		} else {
			if ($v(n)) break;
			{
				let l = n.nextSibling;
				for (; l && ys(l, 1); )
					(i = l.parentNode), (s = en(l) + 1), (l = l.nextSibling);
				if (l) (n = l), (r = 0), (o = Ta(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = o = 0;
				}
			}
		}
	i && Jd(t, i, s);
}
function $v(t) {
	let e = t.pmViewDesc;
	return e && e.node && e.node.isBlock;
}
function SE(t, e) {
	for (; t && e == t.childNodes.length && !ph(t); )
		(e = en(t) + 1), (t = t.parentNode);
	for (; t && e < t.childNodes.length; ) {
		let n = t.childNodes[e];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = 0);
	}
}
function _E(t, e) {
	for (; t && !e && !ph(t); ) (e = en(t)), (t = t.parentNode);
	for (; t && e; ) {
		let n = t.childNodes[e - 1];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = t.childNodes.length);
	}
}
function Jd(t, e, n) {
	if (e.nodeType != 3) {
		let i, s;
		(s = SE(e, n))
			? ((e = s), (n = 0))
			: (i = _E(e, n)) && ((e = i), (n = i.nodeValue.length));
	}
	let r = t.domSelection();
	if (Wu(r)) {
		let i = document.createRange();
		i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
	} else r.extend && r.extend(e, n);
	t.domObserver.setCurSelection();
	let { state: o } = t;
	setTimeout(() => {
		t.state == o && Cr(t);
	}, 50);
}
function ig(t, e) {
	let n = t.state.doc.resolve(e);
	if (!(Kt || UM) && n.parent.inlineContent) {
		let o = t.coordsAtPos(e);
		if (e > n.start()) {
			let i = t.coordsAtPos(e - 1),
				s = (i.top + i.bottom) / 2;
			if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
				return i.left < o.left ? "ltr" : "rtl";
		}
		if (e < n.end()) {
			let i = t.coordsAtPos(e + 1),
				s = (i.top + i.bottom) / 2;
			if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
				return i.left > o.left ? "ltr" : "rtl";
		}
	}
	return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function sg(t, e, n) {
	let r = t.state.selection;
	if (
		(r instanceof Se && !r.empty) ||
		n.indexOf("s") > -1 ||
		(Sn && n.indexOf("m") > -1)
	)
		return !1;
	let { $from: o, $to: i } = r;
	if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
		let s = qd(t.state, e);
		if (s && s instanceof we) return Hr(t, s);
	}
	if (!o.parent.inlineContent) {
		let s = e < 0 ? o : i,
			l = r instanceof zn ? Me.near(s, e) : Me.findFrom(s, e);
		return l ? Hr(t, l) : !1;
	}
	return !1;
}
function lg(t, e) {
	if (!(t.state.selection instanceof Se)) return !0;
	let { $head: n, $anchor: r, empty: o } = t.state.selection;
	if (!n.sameParent(r)) return !0;
	if (!o) return !1;
	if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
	let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
	if (i && !i.isText) {
		let s = t.state.tr;
		return (
			e < 0
				? s.delete(n.pos - i.nodeSize, n.pos)
				: s.delete(n.pos, n.pos + i.nodeSize),
			t.dispatch(s),
			!0
		);
	}
	return !1;
}
function ag(t, e, n) {
	t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function CE(t) {
	if (!nn || t.state.selection.$head.parentOffset > 0) return !1;
	let { focusNode: e, focusOffset: n } = t.domSelectionRange();
	if (
		e &&
		e.nodeType == 1 &&
		n == 0 &&
		e.firstChild &&
		e.firstChild.contentEditable == "false"
	) {
		let r = e.firstChild;
		ag(t, r, "true"), setTimeout(() => ag(t, r, "false"), 20);
	}
	return !1;
}
function ME(t) {
	let e = "";
	return (
		t.ctrlKey && (e += "c"),
		t.metaKey && (e += "m"),
		t.altKey && (e += "a"),
		t.shiftKey && (e += "s"),
		e
	);
}
function EE(t, e) {
	let n = e.keyCode,
		r = ME(e);
	if (n == 8 || (Sn && n == 72 && r == "c")) return lg(t, -1) || Xo(t, -1);
	if ((n == 46 && !e.shiftKey) || (Sn && n == 68 && r == "c"))
		return lg(t, 1) || Xo(t, 1);
	if (n == 13 || n == 27) return !0;
	if (n == 37 || (Sn && n == 66 && r == "c")) {
		let o =
			n == 37 ? (ig(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
		return og(t, o, r) || Xo(t, o);
	} else if (n == 39 || (Sn && n == 70 && r == "c")) {
		let o = n == 39 ? (ig(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
		return og(t, o, r) || Xo(t, o);
	} else {
		if (n == 38 || (Sn && n == 80 && r == "c"))
			return sg(t, -1, r) || Xo(t, -1);
		if (n == 40 || (Sn && n == 78 && r == "c"))
			return CE(t) || sg(t, 1, r) || Xo(t, 1);
		if (r == (Sn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
			return !0;
	}
	return !1;
}
function Bv(t, e) {
	t.someProp("transformCopied", (p) => {
		e = p(e, t);
	});
	let n = [],
		{ content: r, openStart: o, openEnd: i } = e;
	for (
		;
		o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

	) {
		o--, i--;
		let p = r.firstChild;
		n.push(p.type.name, p.attrs != p.type.defaultAttrs ? p.attrs : null),
			(r = p.content);
	}
	let s = t.someProp("clipboardSerializer") || tr.fromSchema(t.state.schema),
		l = Uv(),
		a = l.createElement("div");
	a.appendChild(s.serializeFragment(r, { document: l }));
	let u = a.firstChild,
		c,
		d = 0;
	for (; u && u.nodeType == 1 && (c = Wv[u.nodeName.toLowerCase()]); ) {
		for (let p = c.length - 1; p >= 0; p--) {
			let m = l.createElement(c[p]);
			for (; a.firstChild; ) m.appendChild(a.firstChild);
			a.appendChild(m), d++;
		}
		u = a.firstChild;
	}
	u &&
		u.nodeType == 1 &&
		u.setAttribute(
			"data-pm-slice",
			`${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`
		);
	let f =
		t.someProp("clipboardTextSerializer", (p) => p(e, t)) ||
		e.content.textBetween(
			0,
			e.content.size,
			`

`
		);
	return { dom: a, text: f };
}
function zv(t, e, n, r, o) {
	let i = o.parent.type.spec.code,
		s,
		l;
	if (!n && !e) return null;
	let a = e && (r || i || !n);
	if (a) {
		if (
			(t.someProp("transformPastedText", (f) => {
				e = f(e, i || r, t);
			}),
			i)
		)
			return e
				? new le(
						J.from(
							t.state.schema.text(
								e.replace(
									/\r\n?/g,
									`
`
								)
							)
						),
						0,
						0
				  )
				: le.empty;
		let d = t.someProp("clipboardTextParser", (f) => f(e, o, r, t));
		if (d) l = d;
		else {
			let f = o.marks(),
				{ schema: p } = t.state,
				m = tr.fromSchema(p);
			(s = document.createElement("div")),
				e.split(/(?:\r\n?|\n)+/).forEach((y) => {
					let v = s.appendChild(document.createElement("p"));
					y && v.appendChild(m.serializeNode(p.text(y, f)));
				});
		}
	} else
		t.someProp("transformPastedHTML", (d) => {
			n = d(n, t);
		}),
			(s = OE(n)),
			nl && RE(s);
	let u = s && s.querySelector("[data-pm-slice]"),
		c =
			u &&
			/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
				u.getAttribute("data-pm-slice") || ""
			);
	if (c && c[3])
		for (let d = +c[3]; d > 0; d--) {
			let f = s.firstChild;
			for (; f && f.nodeType != 1; ) f = f.nextSibling;
			if (!f) break;
			s = f;
		}
	if (
		(l ||
			(l = (
				t.someProp("clipboardParser") ||
				t.someProp("domParser") ||
				zu.fromSchema(t.state.schema)
			).parseSlice(s, {
				preserveWhitespace: !!(a || c),
				context: o,
				ruleFromNode(f) {
					return f.nodeName == "BR" &&
						!f.nextSibling &&
						f.parentNode &&
						!TE.test(f.parentNode.nodeName)
						? { ignore: !0 }
						: null;
				},
			})),
		c)
	)
		l = PE(ug(l, +c[1], +c[2]), c[4]);
	else if (
		((l = le.maxOpen(AE(l.content, o), !0)), l.openStart || l.openEnd)
	) {
		let d = 0,
			f = 0;
		for (
			let p = l.content.firstChild;
			d < l.openStart && !p.type.spec.isolating;
			d++, p = p.firstChild
		);
		for (
			let p = l.content.lastChild;
			f < l.openEnd && !p.type.spec.isolating;
			f++, p = p.lastChild
		);
		l = ug(l, d, f);
	}
	return (
		t.someProp("transformPasted", (d) => {
			l = d(l, t);
		}),
		l
	);
}
const TE =
	/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function AE(t, e) {
	if (t.childCount < 2) return t;
	for (let n = e.depth; n >= 0; n--) {
		let o = e.node(n).contentMatchAt(e.index(n)),
			i,
			s = [];
		if (
			(t.forEach((l) => {
				if (!s) return;
				let a = o.findWrapping(l.type),
					u;
				if (!a) return (s = null);
				if (
					(u =
						s.length && i.length && Fv(a, i, l, s[s.length - 1], 0))
				)
					s[s.length - 1] = u;
				else {
					s.length &&
						(s[s.length - 1] = Vv(s[s.length - 1], i.length));
					let c = Hv(l, a);
					s.push(c), (o = o.matchType(c.type)), (i = a);
				}
			}),
			s)
		)
			return J.from(s);
	}
	return t;
}
function Hv(t, e, n = 0) {
	for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, J.from(t));
	return t;
}
function Fv(t, e, n, r, o) {
	if (o < t.length && o < e.length && t[o] == e[o]) {
		let i = Fv(t, e, n, r.lastChild, o + 1);
		if (i) return r.copy(r.content.replaceChild(r.childCount - 1, i));
		if (
			r
				.contentMatchAt(r.childCount)
				.matchType(o == t.length - 1 ? n.type : t[o + 1])
		)
			return r.copy(r.content.append(J.from(Hv(n, t, o + 1))));
	}
}
function Vv(t, e) {
	if (e == 0) return t;
	let n = t.content.replaceChild(t.childCount - 1, Vv(t.lastChild, e - 1)),
		r = t.contentMatchAt(t.childCount).fillBefore(J.empty, !0);
	return t.copy(n.append(r));
}
function Gd(t, e, n, r, o, i) {
	let s = e < 0 ? t.firstChild : t.lastChild,
		l = s.content;
	return (
		t.childCount > 1 && (i = 0),
		o < r - 1 && (l = Gd(l, e, n, r, o + 1, i)),
		o >= n &&
			(l =
				e < 0
					? s
							.contentMatchAt(0)
							.fillBefore(l, i <= o)
							.append(l)
					: l.append(
							s
								.contentMatchAt(s.childCount)
								.fillBefore(J.empty, !0)
					  )),
		t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(l))
	);
}
function ug(t, e, n) {
	return (
		e < t.openStart &&
			(t = new le(
				Gd(t.content, -1, e, t.openStart, 0, t.openEnd),
				e,
				t.openEnd
			)),
		n < t.openEnd &&
			(t = new le(Gd(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
		t
	);
}
const Wv = {
	thead: ["table"],
	tbody: ["table"],
	tfoot: ["table"],
	caption: ["table"],
	colgroup: ["table"],
	col: ["table", "colgroup"],
	tr: ["table", "tbody"],
	td: ["table", "tbody", "tr"],
	th: ["table", "tbody", "tr"],
};
let cg = null;
function Uv() {
	return cg || (cg = document.implementation.createHTMLDocument("title"));
}
function OE(t) {
	let e = /^(\s*<meta [^>]*>)*/.exec(t);
	e && (t = t.slice(e[0].length));
	let n = Uv().createElement("div"),
		r = /<([a-z][^>\s]+)/i.exec(t),
		o;
	if (
		((o = r && Wv[r[1].toLowerCase()]) &&
			(t =
				o.map((i) => "<" + i + ">").join("") +
				t +
				o
					.map((i) => "</" + i + ">")
					.reverse()
					.join("")),
		(n.innerHTML = t),
		o)
	)
		for (let i = 0; i < o.length; i++) n = n.querySelector(o[i]) || n;
	return n;
}
function RE(t) {
	let e = t.querySelectorAll(
		Kt ? "span:not([class]):not([style])" : "span.Apple-converted-space"
	);
	for (let n = 0; n < e.length; n++) {
		let r = e[n];
		r.childNodes.length == 1 &&
			r.textContent == "" &&
			r.parentNode &&
			r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
	}
}
function PE(t, e) {
	if (!t.size) return t;
	let n = t.content.firstChild.type.schema,
		r;
	try {
		r = JSON.parse(e);
	} catch (l) {
		return t;
	}
	let { content: o, openStart: i, openEnd: s } = t;
	for (let l = r.length - 2; l >= 0; l -= 2) {
		let a = n.nodes[r[l]];
		if (!a || a.hasRequiredAttrs()) break;
		(o = J.from(a.create(r[l + 1], o))), i++, s++;
	}
	return new le(o, i, s);
}
const rn = {},
	on = {},
	IE = { touchstart: !0, touchmove: !0 };
class NE {
	constructor() {
		(this.shiftKey = !1),
			(this.mouseDown = null),
			(this.lastKeyCode = null),
			(this.lastKeyCodeTime = 0),
			(this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
			(this.lastSelectionOrigin = null),
			(this.lastSelectionTime = 0),
			(this.lastIOSEnter = 0),
			(this.lastIOSEnterFallbackTimeout = -1),
			(this.lastFocus = 0),
			(this.lastTouch = 0),
			(this.lastAndroidDelete = 0),
			(this.composing = !1),
			(this.composingTimeout = -1),
			(this.compositionNodes = []),
			(this.compositionEndedAt = -2e8),
			(this.compositionID = 1),
			(this.compositionPendingChanges = 0),
			(this.domChangeCount = 0),
			(this.eventHandlers = Object.create(null)),
			(this.hideSelectionGuard = null);
	}
}
function DE(t) {
	for (let e in rn) {
		let n = rn[e];
		t.dom.addEventListener(
			e,
			(t.input.eventHandlers[e] = (r) => {
				LE(t, r) &&
					!vh(t, r) &&
					(t.editable || !(r.type in on)) &&
					n(t, r);
			}),
			IE[e] ? { passive: !0 } : void 0
		);
	}
	nn && t.dom.addEventListener("input", () => null), Yd(t);
}
function Qr(t, e) {
	(t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function jE(t) {
	t.domObserver.stop();
	for (let e in t.input.eventHandlers)
		t.dom.removeEventListener(e, t.input.eventHandlers[e]);
	clearTimeout(t.input.composingTimeout),
		clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Yd(t) {
	t.someProp("handleDOMEvents", (e) => {
		for (let n in e)
			t.input.eventHandlers[n] ||
				t.dom.addEventListener(
					n,
					(t.input.eventHandlers[n] = (r) => vh(t, r))
				);
	});
}
function vh(t, e) {
	return t.someProp("handleDOMEvents", (n) => {
		let r = n[e.type];
		return r ? r(t, e) || e.defaultPrevented : !1;
	});
}
function LE(t, e) {
	if (!e.bubbles) return !0;
	if (e.defaultPrevented) return !1;
	for (let n = e.target; n != t.dom; n = n.parentNode)
		if (
			!n ||
			n.nodeType == 11 ||
			(n.pmViewDesc && n.pmViewDesc.stopEvent(e))
		)
			return !1;
	return !0;
}
function $E(t, e) {
	!vh(t, e) &&
		rn[e.type] &&
		(t.editable || !(e.type in on)) &&
		rn[e.type](t, e);
}
on.keydown = (t, e) => {
	let n = e;
	if (
		((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
		!qv(t, n) &&
			((t.input.lastKeyCode = n.keyCode),
			(t.input.lastKeyCodeTime = Date.now()),
			!(Dn && Kt && n.keyCode == 13)))
	)
		if (
			(n.keyCode != 229 && t.domObserver.forceFlush(),
			Ni && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
		) {
			let r = Date.now();
			(t.input.lastIOSEnter = r),
				(t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
					t.input.lastIOSEnter == r &&
						(t.someProp("handleKeyDown", (o) =>
							o(t, So(13, "Enter"))
						),
						(t.input.lastIOSEnter = 0));
				}, 200));
		} else
			t.someProp("handleKeyDown", (r) => r(t, n)) || EE(t, n)
				? n.preventDefault()
				: Qr(t, "key");
};
on.keyup = (t, e) => {
	e.keyCode == 16 && (t.input.shiftKey = !1);
};
on.keypress = (t, e) => {
	let n = e;
	if (
		qv(t, n) ||
		!n.charCode ||
		(n.ctrlKey && !n.altKey) ||
		(Sn && n.metaKey)
	)
		return;
	if (t.someProp("handleKeyPress", (o) => o(t, n))) {
		n.preventDefault();
		return;
	}
	let r = t.state.selection;
	if (!(r instanceof Se) || !r.$from.sameParent(r.$to)) {
		let o = String.fromCharCode(n.charCode);
		!/[\r\n]/.test(o) &&
			!t.someProp("handleTextInput", (i) =>
				i(t, r.$from.pos, r.$to.pos, o)
			) &&
			t.dispatch(t.state.tr.insertText(o).scrollIntoView()),
			n.preventDefault();
	}
};
function Ku(t) {
	return { left: t.clientX, top: t.clientY };
}
function BE(t, e) {
	let n = e.x - t.clientX,
		r = e.y - t.clientY;
	return n * n + r * r < 100;
}
function bh(t, e, n, r, o) {
	if (r == -1) return !1;
	let i = t.state.doc.resolve(r);
	for (let s = i.depth + 1; s > 0; s--)
		if (
			t.someProp(e, (l) =>
				s > i.depth
					? l(t, n, i.nodeAfter, i.before(s), o, !0)
					: l(t, n, i.node(s), i.before(s), o, !1)
			)
		)
			return !0;
	return !1;
}
function vi(t, e, n) {
	t.focused || t.focus();
	let r = t.state.tr.setSelection(e);
	n == "pointer" && r.setMeta("pointer", !0), t.dispatch(r);
}
function zE(t, e) {
	if (e == -1) return !1;
	let n = t.state.doc.resolve(e),
		r = n.nodeAfter;
	return r && r.isAtom && we.isSelectable(r)
		? (vi(t, new we(n), "pointer"), !0)
		: !1;
}
function HE(t, e) {
	if (e == -1) return !1;
	let n = t.state.selection,
		r,
		o;
	n instanceof we && (r = n.node);
	let i = t.state.doc.resolve(e);
	for (let s = i.depth + 1; s > 0; s--) {
		let l = s > i.depth ? i.nodeAfter : i.node(s);
		if (we.isSelectable(l)) {
			r &&
			n.$from.depth > 0 &&
			s >= n.$from.depth &&
			i.before(n.$from.depth + 1) == n.$from.pos
				? (o = i.before(n.$from.depth))
				: (o = i.before(s));
			break;
		}
	}
	return o != null ? (vi(t, we.create(t.state.doc, o), "pointer"), !0) : !1;
}
function FE(t, e, n, r, o) {
	return (
		bh(t, "handleClickOn", e, n, r) ||
		t.someProp("handleClick", (i) => i(t, e, r)) ||
		(o ? HE(t, n) : zE(t, n))
	);
}
function VE(t, e, n, r) {
	return (
		bh(t, "handleDoubleClickOn", e, n, r) ||
		t.someProp("handleDoubleClick", (o) => o(t, e, r))
	);
}
function WE(t, e, n, r) {
	return (
		bh(t, "handleTripleClickOn", e, n, r) ||
		t.someProp("handleTripleClick", (o) => o(t, e, r)) ||
		UE(t, n, r)
	);
}
function UE(t, e, n) {
	if (n.button != 0) return !1;
	let r = t.state.doc;
	if (e == -1)
		return r.inlineContent
			? (vi(t, Se.create(r, 0, r.content.size), "pointer"), !0)
			: !1;
	let o = r.resolve(e);
	for (let i = o.depth + 1; i > 0; i--) {
		let s = i > o.depth ? o.nodeAfter : o.node(i),
			l = o.before(i);
		if (s.inlineContent)
			vi(t, Se.create(r, l + 1, l + 1 + s.content.size), "pointer");
		else if (we.isSelectable(s)) vi(t, we.create(r, l), "pointer");
		else continue;
		return !0;
	}
}
function wh(t) {
	return Aa(t);
}
const Kv = Sn ? "metaKey" : "ctrlKey";
rn.mousedown = (t, e) => {
	let n = e;
	t.input.shiftKey = n.shiftKey;
	let r = wh(t),
		o = Date.now(),
		i = "singleClick";
	o - t.input.lastClick.time < 500 &&
		BE(n, t.input.lastClick) &&
		!n[Kv] &&
		(t.input.lastClick.type == "singleClick"
			? (i = "doubleClick")
			: t.input.lastClick.type == "doubleClick" && (i = "tripleClick")),
		(t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i });
	let s = t.posAtCoords(Ku(n));
	s &&
		(i == "singleClick"
			? (t.input.mouseDown && t.input.mouseDown.done(),
			  (t.input.mouseDown = new KE(t, s, n, !!r)))
			: (i == "doubleClick" ? VE : WE)(t, s.pos, s.inside, n)
			? n.preventDefault()
			: Qr(t, "pointer"));
};
class KE {
	constructor(e, n, r, o) {
		(this.view = e),
			(this.pos = n),
			(this.event = r),
			(this.flushed = o),
			(this.delayedSelectionSync = !1),
			(this.mightDrag = null),
			(this.startDoc = e.state.doc),
			(this.selectNode = !!r[Kv]),
			(this.allowDefault = r.shiftKey);
		let i, s;
		if (n.inside > -1) (i = e.state.doc.nodeAt(n.inside)), (s = n.inside);
		else {
			let c = e.state.doc.resolve(n.pos);
			(i = c.parent), (s = c.depth ? c.before() : 0);
		}
		const l = o ? null : r.target,
			a = l ? e.docView.nearestDesc(l, !0) : null;
		this.target = a ? a.dom : null;
		let { selection: u } = e.state;
		((r.button == 0 &&
			i.type.spec.draggable &&
			i.type.spec.selectable !== !1) ||
			(u instanceof we && u.from <= s && u.to > s)) &&
			(this.mightDrag = {
				node: i,
				pos: s,
				addAttr: !!(this.target && !this.target.draggable),
				setUneditable: !!(
					this.target &&
					Vn &&
					!this.target.hasAttribute("contentEditable")
				),
			}),
			this.target &&
				this.mightDrag &&
				(this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr && (this.target.draggable = !0),
				this.mightDrag.setUneditable &&
					setTimeout(() => {
						this.view.input.mouseDown == this &&
							this.target.setAttribute(
								"contentEditable",
								"false"
							);
					}, 20),
				this.view.domObserver.start()),
			e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
			e.root.addEventListener(
				"mousemove",
				(this.move = this.move.bind(this))
			),
			Qr(e, "pointer");
	}
	done() {
		this.view.root.removeEventListener("mouseup", this.up),
			this.view.root.removeEventListener("mousemove", this.move),
			this.mightDrag &&
				this.target &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr &&
					this.target.removeAttribute("draggable"),
				this.mightDrag.setUneditable &&
					this.target.removeAttribute("contentEditable"),
				this.view.domObserver.start()),
			this.delayedSelectionSync && setTimeout(() => Cr(this.view)),
			(this.view.input.mouseDown = null);
	}
	up(e) {
		if ((this.done(), !this.view.dom.contains(e.target))) return;
		let n = this.pos;
		this.view.state.doc != this.startDoc &&
			(n = this.view.posAtCoords(Ku(e))),
			this.updateAllowDefault(e),
			this.allowDefault || !n
				? Qr(this.view, "pointer")
				: FE(this.view, n.pos, n.inside, e, this.selectNode)
				? e.preventDefault()
				: e.button == 0 &&
				  (this.flushed ||
						(nn && this.mightDrag && !this.mightDrag.node.isAtom) ||
						(Kt &&
							!this.view.state.selection.visible &&
							Math.min(
								Math.abs(
									n.pos - this.view.state.selection.from
								),
								Math.abs(n.pos - this.view.state.selection.to)
							) <= 2))
				? (vi(
						this.view,
						Me.near(this.view.state.doc.resolve(n.pos)),
						"pointer"
				  ),
				  e.preventDefault())
				: Qr(this.view, "pointer");
	}
	move(e) {
		this.updateAllowDefault(e),
			Qr(this.view, "pointer"),
			e.buttons == 0 && this.done();
	}
	updateAllowDefault(e) {
		!this.allowDefault &&
			(Math.abs(this.event.x - e.clientX) > 4 ||
				Math.abs(this.event.y - e.clientY) > 4) &&
			(this.allowDefault = !0);
	}
}
rn.touchstart = (t) => {
	(t.input.lastTouch = Date.now()), wh(t), Qr(t, "pointer");
};
rn.touchmove = (t) => {
	(t.input.lastTouch = Date.now()), Qr(t, "pointer");
};
rn.contextmenu = (t) => wh(t);
function qv(t, e) {
	return t.composing
		? !0
		: nn && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
		? ((t.input.compositionEndedAt = -2e8), !0)
		: !1;
}
const qE = Dn ? 5e3 : -1;
on.compositionstart = on.compositionupdate = (t) => {
	if (!t.composing) {
		t.domObserver.flush();
		let { state: e } = t,
			n = e.selection.$from;
		if (
			e.selection.empty &&
			(e.storedMarks ||
				(!n.textOffset &&
					n.parentOffset &&
					n.nodeBefore.marks.some(
						(r) => r.type.spec.inclusive === !1
					)))
		)
			(t.markCursor = t.state.storedMarks || n.marks()),
				Aa(t, !0),
				(t.markCursor = null);
		else if (
			(Aa(t),
			Vn &&
				e.selection.empty &&
				n.parentOffset &&
				!n.textOffset &&
				n.nodeBefore.marks.length)
		) {
			let r = t.domSelectionRange();
			for (
				let o = r.focusNode, i = r.focusOffset;
				o && o.nodeType == 1 && i != 0;

			) {
				let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
				if (!s) break;
				if (s.nodeType == 3) {
					t.domSelection().collapse(s, s.nodeValue.length);
					break;
				} else (o = s), (i = -1);
			}
		}
		t.input.composing = !0;
	}
	Jv(t, qE);
};
on.compositionend = (t, e) => {
	t.composing &&
		((t.input.composing = !1),
		(t.input.compositionEndedAt = e.timeStamp),
		(t.input.compositionPendingChanges = t.domObserver.pendingRecords()
			.length
			? t.input.compositionID
			: 0),
		t.input.compositionPendingChanges &&
			Promise.resolve().then(() => t.domObserver.flush()),
		t.input.compositionID++,
		Jv(t, 20));
};
function Jv(t, e) {
	clearTimeout(t.input.composingTimeout),
		e > -1 && (t.input.composingTimeout = setTimeout(() => Aa(t), e));
}
function Gv(t) {
	for (
		t.composing &&
		((t.input.composing = !1), (t.input.compositionEndedAt = JE()));
		t.input.compositionNodes.length > 0;

	)
		t.input.compositionNodes.pop().markParentsDirty();
}
function JE() {
	let t = document.createEvent("Event");
	return t.initEvent("event", !0, !0), t.timeStamp;
}
function Aa(t, e = !1) {
	if (!(Dn && t.domObserver.flushingSoon >= 0)) {
		if (
			(t.domObserver.forceFlush(),
			Gv(t),
			e || (t.docView && t.docView.dirty))
		) {
			let n = gh(t);
			return (
				n && !n.eq(t.state.selection)
					? t.dispatch(t.state.tr.setSelection(n))
					: t.updateState(t.state),
				!0
			);
		}
		return !1;
	}
}
function GE(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.dom.parentNode.appendChild(document.createElement("div"));
	n.appendChild(e),
		(n.style.cssText = "position: fixed; left: -10000px; top: 10px");
	let r = getSelection(),
		o = document.createRange();
	o.selectNodeContents(e),
		t.dom.blur(),
		r.removeAllRanges(),
		r.addRange(o),
		setTimeout(() => {
			n.parentNode && n.parentNode.removeChild(n), t.focus();
		}, 50);
}
const Ls = (cn && to < 15) || (Ni && KM < 604);
rn.copy = on.cut = (t, e) => {
	let n = e,
		r = t.state.selection,
		o = n.type == "cut";
	if (r.empty) return;
	let i = Ls ? null : n.clipboardData,
		s = r.content(),
		{ dom: l, text: a } = Bv(t, s);
	i
		? (n.preventDefault(),
		  i.clearData(),
		  i.setData("text/html", l.innerHTML),
		  i.setData("text/plain", a))
		: GE(t, l),
		o &&
			t.dispatch(
				t.state.tr
					.deleteSelection()
					.scrollIntoView()
					.setMeta("uiEvent", "cut")
			);
};
function YE(t) {
	return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
		? t.content.firstChild
		: null;
}
function QE(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
		r = t.dom.parentNode.appendChild(
			document.createElement(n ? "textarea" : "div")
		);
	n || (r.contentEditable = "true"),
		(r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
		r.focus();
	let o = t.input.shiftKey && t.input.lastKeyCode != 45;
	setTimeout(() => {
		t.focus(),
			r.parentNode && r.parentNode.removeChild(r),
			n
				? $s(t, r.value, null, o, e)
				: $s(t, r.textContent, r.innerHTML, o, e);
	}, 50);
}
function $s(t, e, n, r, o) {
	let i = zv(t, e, n, r, t.state.selection.$from);
	if (t.someProp("handlePaste", (a) => a(t, o, i || le.empty))) return !0;
	if (!i) return !1;
	let s = YE(i),
		l = s
			? t.state.tr.replaceSelectionWith(s, r)
			: t.state.tr.replaceSelection(i);
	return (
		t.dispatch(
			l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
		),
		!0
	);
}
function Yv(t) {
	let e = t.getData("text/plain") || t.getData("Text");
	if (e) return e;
	let n = t.getData("text/uri-list");
	return n ? n.replace(/\r?\n/g, " ") : "";
}
on.paste = (t, e) => {
	let n = e;
	if (t.composing && !Dn) return;
	let r = Ls ? null : n.clipboardData,
		o = t.input.shiftKey && t.input.lastKeyCode != 45;
	r && $s(t, Yv(r), r.getData("text/html"), o, n)
		? n.preventDefault()
		: QE(t, n);
};
class Qv {
	constructor(e, n, r) {
		(this.slice = e), (this.move = n), (this.node = r);
	}
}
const Xv = Sn ? "altKey" : "ctrlKey";
rn.dragstart = (t, e) => {
	let n = e,
		r = t.input.mouseDown;
	if ((r && r.done(), !n.dataTransfer)) return;
	let o = t.state.selection,
		i = o.empty ? null : t.posAtCoords(Ku(n)),
		s;
	if (
		!(i && i.pos >= o.from && i.pos <= (o instanceof we ? o.to - 1 : o.to))
	) {
		if (r && r.mightDrag) s = we.create(t.state.doc, r.mightDrag.pos);
		else if (n.target && n.target.nodeType == 1) {
			let c = t.docView.nearestDesc(n.target, !0);
			c &&
				c.node.type.spec.draggable &&
				c != t.docView &&
				(s = we.create(t.state.doc, c.posBefore));
		}
	}
	let l = (s || t.state.selection).content(),
		{ dom: a, text: u } = Bv(t, l);
	n.dataTransfer.clearData(),
		n.dataTransfer.setData(Ls ? "Text" : "text/html", a.innerHTML),
		(n.dataTransfer.effectAllowed = "copyMove"),
		Ls || n.dataTransfer.setData("text/plain", u),
		(t.dragging = new Qv(l, !n[Xv], s));
};
rn.dragend = (t) => {
	let e = t.dragging;
	window.setTimeout(() => {
		t.dragging == e && (t.dragging = null);
	}, 50);
};
on.dragover = on.dragenter = (t, e) => e.preventDefault();
on.drop = (t, e) => {
	let n = e,
		r = t.dragging;
	if (((t.dragging = null), !n.dataTransfer)) return;
	let o = t.posAtCoords(Ku(n));
	if (!o) return;
	let i = t.state.doc.resolve(o.pos),
		s = r && r.slice;
	s
		? t.someProp("transformPasted", (m) => {
				s = m(s, t);
		  })
		: (s = zv(
				t,
				Yv(n.dataTransfer),
				Ls ? null : n.dataTransfer.getData("text/html"),
				!1,
				i
		  ));
	let l = !!(r && !n[Xv]);
	if (t.someProp("handleDrop", (m) => m(t, n, s || le.empty, l))) {
		n.preventDefault();
		return;
	}
	if (!s) return;
	n.preventDefault();
	let a = s ? mv(t.state.doc, i.pos, s) : i.pos;
	a == null && (a = i.pos);
	let u = t.state.tr;
	if (l) {
		let { node: m } = r;
		m ? m.replace(u) : u.deleteSelection();
	}
	let c = u.mapping.map(a),
		d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
		f = u.doc;
	if (
		(d
			? u.replaceRangeWith(c, c, s.content.firstChild)
			: u.replaceRange(c, c, s),
		u.doc.eq(f))
	)
		return;
	let p = u.doc.resolve(c);
	if (
		d &&
		we.isSelectable(s.content.firstChild) &&
		p.nodeAfter &&
		p.nodeAfter.sameMarkup(s.content.firstChild)
	)
		u.setSelection(new we(p));
	else {
		let m = u.mapping.map(a);
		u.mapping.maps[u.mapping.maps.length - 1].forEach(
			(y, v, w, S) => (m = S)
		),
			u.setSelection(yh(t, p, u.doc.resolve(m)));
	}
	t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
rn.focus = (t) => {
	(t.input.lastFocus = Date.now()),
		t.focused ||
			(t.domObserver.stop(),
			t.dom.classList.add("ProseMirror-focused"),
			t.domObserver.start(),
			(t.focused = !0),
			setTimeout(() => {
				t.docView &&
					t.hasFocus() &&
					!t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
					Cr(t);
			}, 20));
};
rn.blur = (t, e) => {
	let n = e;
	t.focused &&
		(t.domObserver.stop(),
		t.dom.classList.remove("ProseMirror-focused"),
		t.domObserver.start(),
		n.relatedTarget &&
			t.dom.contains(n.relatedTarget) &&
			t.domObserver.currentSelection.clear(),
		(t.focused = !1));
};
rn.beforeinput = (t, e) => {
	if (Kt && Dn && e.inputType == "deleteContentBackward") {
		t.domObserver.flushSoon();
		let { domChangeCount: r } = t.input;
		setTimeout(() => {
			if (
				t.input.domChangeCount != r ||
				(t.dom.blur(),
				t.focus(),
				t.someProp("handleKeyDown", (i) => i(t, So(8, "Backspace"))))
			)
				return;
			let { $cursor: o } = t.state.selection;
			o &&
				o.pos > 0 &&
				t.dispatch(
					t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView()
				);
		}, 50);
	}
};
for (let t in on) rn[t] = on[t];
function Bs(t, e) {
	if (t == e) return !0;
	for (let n in t) if (t[n] !== e[n]) return !1;
	for (let n in e) if (!(n in t)) return !1;
	return !0;
}
class Oa {
	constructor(e, n) {
		(this.toDOM = e),
			(this.spec = n || jo),
			(this.side = this.spec.side || 0);
	}
	map(e, n, r, o) {
		let { pos: i, deleted: s } = e.mapResult(
			n.from + o,
			this.side < 0 ? -1 : 1
		);
		return s ? null : new qt(i - r, i - r, this);
	}
	valid() {
		return !0;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof Oa &&
				((this.spec.key && this.spec.key == e.spec.key) ||
					(this.toDOM == e.toDOM && Bs(this.spec, e.spec))))
		);
	}
	destroy(e) {
		this.spec.destroy && this.spec.destroy(e);
	}
}
class ro {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || jo);
	}
	map(e, n, r, o) {
		let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r,
			s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
		return i >= s ? null : new qt(i, s, this);
	}
	valid(e, n) {
		return n.from < n.to;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof ro &&
				Bs(this.attrs, e.attrs) &&
				Bs(this.spec, e.spec))
		);
	}
	static is(e) {
		return e.type instanceof ro;
	}
	destroy() {}
}
class xh {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || jo);
	}
	map(e, n, r, o) {
		let i = e.mapResult(n.from + o, 1);
		if (i.deleted) return null;
		let s = e.mapResult(n.to + o, -1);
		return s.deleted || s.pos <= i.pos
			? null
			: new qt(i.pos - r, s.pos - r, this);
	}
	valid(e, n) {
		let { index: r, offset: o } = e.content.findIndex(n.from),
			i;
		return (
			o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to
		);
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof xh &&
				Bs(this.attrs, e.attrs) &&
				Bs(this.spec, e.spec))
		);
	}
	destroy() {}
}
class qt {
	constructor(e, n, r) {
		(this.from = e), (this.to = n), (this.type = r);
	}
	copy(e, n) {
		return new qt(e, n, this.type);
	}
	eq(e, n = 0) {
		return (
			this.type.eq(e.type) &&
			this.from + n == e.from &&
			this.to + n == e.to
		);
	}
	map(e, n, r) {
		return this.type.map(e, this, n, r);
	}
	static widget(e, n, r) {
		return new qt(e, e, new Oa(n, r));
	}
	static inline(e, n, r, o) {
		return new qt(e, n, new ro(r, o));
	}
	static node(e, n, r, o) {
		return new qt(e, n, new xh(r, o));
	}
	get spec() {
		return this.type.spec;
	}
	get inline() {
		return this.type instanceof ro;
	}
	get widget() {
		return this.type instanceof Oa;
	}
}
const ri = [],
	jo = {};
class ft {
	constructor(e, n) {
		(this.local = e.length ? e : ri), (this.children = n.length ? n : ri);
	}
	static create(e, n) {
		return n.length ? Ra(n, e, 0, jo) : Wt;
	}
	find(e, n, r) {
		let o = [];
		return (
			this.findInner(e == null ? 0 : e, n == null ? 1e9 : n, o, 0, r), o
		);
	}
	findInner(e, n, r, o, i) {
		for (let s = 0; s < this.local.length; s++) {
			let l = this.local[s];
			l.from <= n &&
				l.to >= e &&
				(!i || i(l.spec)) &&
				r.push(l.copy(l.from + o, l.to + o));
		}
		for (let s = 0; s < this.children.length; s += 3)
			if (this.children[s] < n && this.children[s + 1] > e) {
				let l = this.children[s] + 1;
				this.children[s + 2].findInner(e - l, n - l, r, o + l, i);
			}
	}
	map(e, n, r) {
		return this == Wt || e.maps.length == 0
			? this
			: this.mapInner(e, n, 0, 0, r || jo);
	}
	mapInner(e, n, r, o, i) {
		let s;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l].map(e, r, o);
			a && a.type.valid(n, a)
				? (s || (s = [])).push(a)
				: i.onRemove && i.onRemove(this.local[l].spec);
		}
		return this.children.length
			? XE(this.children, s || [], e, n, r, o, i)
			: s
			? new ft(s.sort(Lo), ri)
			: Wt;
	}
	add(e, n) {
		return n.length
			? this == Wt
				? ft.create(e, n)
				: this.addInner(e, n, 0)
			: this;
	}
	addInner(e, n, r) {
		let o,
			i = 0;
		e.forEach((l, a) => {
			let u = a + r,
				c;
			if ((c = e2(n, l, u))) {
				for (
					o || (o = this.children.slice());
					i < o.length && o[i] < a;

				)
					i += 3;
				o[i] == a
					? (o[i + 2] = o[i + 2].addInner(l, c, u + 1))
					: o.splice(i, 0, a, a + l.nodeSize, Ra(c, l, u + 1, jo)),
					(i += 3);
			}
		});
		let s = Zv(i ? t2(n) : n, -r);
		for (let l = 0; l < s.length; l++)
			s[l].type.valid(e, s[l]) || s.splice(l--, 1);
		return new ft(
			s.length ? this.local.concat(s).sort(Lo) : this.local,
			o || this.children
		);
	}
	remove(e) {
		return e.length == 0 || this == Wt ? this : this.removeInner(e, 0);
	}
	removeInner(e, n) {
		let r = this.children,
			o = this.local;
		for (let i = 0; i < r.length; i += 3) {
			let s,
				l = r[i] + n,
				a = r[i + 1] + n;
			for (let c = 0, d; c < e.length; c++)
				(d = e[c]) &&
					d.from > l &&
					d.to < a &&
					((e[c] = null), (s || (s = [])).push(d));
			if (!s) continue;
			r == this.children && (r = this.children.slice());
			let u = r[i + 2].removeInner(s, l + 1);
			u != Wt ? (r[i + 2] = u) : (r.splice(i, 3), (i -= 3));
		}
		if (o.length) {
			for (let i = 0, s; i < e.length; i++)
				if ((s = e[i]))
					for (let l = 0; l < o.length; l++)
						o[l].eq(s, n) &&
							(o == this.local && (o = this.local.slice()),
							o.splice(l--, 1));
		}
		return r == this.children && o == this.local
			? this
			: o.length || r.length
			? new ft(o, r)
			: Wt;
	}
	forChild(e, n) {
		if (this == Wt) return this;
		if (n.isLeaf) return ft.empty;
		let r, o;
		for (let l = 0; l < this.children.length; l += 3)
			if (this.children[l] >= e) {
				this.children[l] == e && (r = this.children[l + 2]);
				break;
			}
		let i = e + 1,
			s = i + n.content.size;
		for (let l = 0; l < this.local.length; l++) {
			let a = this.local[l];
			if (a.from < s && a.to > i && a.type instanceof ro) {
				let u = Math.max(i, a.from) - i,
					c = Math.min(s, a.to) - i;
				u < c && (o || (o = [])).push(a.copy(u, c));
			}
		}
		if (o) {
			let l = new ft(o.sort(Lo), ri);
			return r ? new Ur([l, r]) : l;
		}
		return r || Wt;
	}
	eq(e) {
		if (this == e) return !0;
		if (
			!(e instanceof ft) ||
			this.local.length != e.local.length ||
			this.children.length != e.children.length
		)
			return !1;
		for (let n = 0; n < this.local.length; n++)
			if (!this.local[n].eq(e.local[n])) return !1;
		for (let n = 0; n < this.children.length; n += 3)
			if (
				this.children[n] != e.children[n] ||
				this.children[n + 1] != e.children[n + 1] ||
				!this.children[n + 2].eq(e.children[n + 2])
			)
				return !1;
		return !0;
	}
	locals(e) {
		return kh(this.localsInner(e));
	}
	localsInner(e) {
		if (this == Wt) return ri;
		if (e.inlineContent || !this.local.some(ro.is)) return this.local;
		let n = [];
		for (let r = 0; r < this.local.length; r++)
			this.local[r].type instanceof ro || n.push(this.local[r]);
		return n;
	}
}
ft.empty = new ft([], []);
ft.removeOverlap = kh;
const Wt = ft.empty;
class Ur {
	constructor(e) {
		this.members = e;
	}
	map(e, n) {
		const r = this.members.map((o) => o.map(e, n, jo));
		return Ur.from(r);
	}
	forChild(e, n) {
		if (n.isLeaf) return ft.empty;
		let r = [];
		for (let o = 0; o < this.members.length; o++) {
			let i = this.members[o].forChild(e, n);
			i != Wt &&
				(i instanceof Ur ? (r = r.concat(i.members)) : r.push(i));
		}
		return Ur.from(r);
	}
	eq(e) {
		if (!(e instanceof Ur) || e.members.length != this.members.length)
			return !1;
		for (let n = 0; n < this.members.length; n++)
			if (!this.members[n].eq(e.members[n])) return !1;
		return !0;
	}
	locals(e) {
		let n,
			r = !0;
		for (let o = 0; o < this.members.length; o++) {
			let i = this.members[o].localsInner(e);
			if (i.length)
				if (!n) n = i;
				else {
					r && ((n = n.slice()), (r = !1));
					for (let s = 0; s < i.length; s++) n.push(i[s]);
				}
		}
		return n ? kh(r ? n : n.sort(Lo)) : ri;
	}
	static from(e) {
		switch (e.length) {
			case 0:
				return Wt;
			case 1:
				return e[0];
			default:
				return new Ur(
					e.every((n) => n instanceof ft)
						? e
						: e.reduce(
								(n, r) =>
									n.concat(r instanceof ft ? r : r.members),
								[]
						  )
				);
		}
	}
}
function XE(t, e, n, r, o, i, s) {
	let l = t.slice();
	for (let u = 0, c = i; u < n.maps.length; u++) {
		let d = 0;
		n.maps[u].forEach((f, p, m, y) => {
			let v = y - m - (p - f);
			for (let w = 0; w < l.length; w += 3) {
				let S = l[w + 1];
				if (S < 0 || f > S + c - d) continue;
				let E = l[w] + c - d;
				p >= E
					? (l[w + 1] = f <= E ? -2 : -1)
					: f >= c && v && ((l[w] += v), (l[w + 1] += v));
			}
			d += v;
		}),
			(c = n.maps[u].map(c, -1));
	}
	let a = !1;
	for (let u = 0; u < l.length; u += 3)
		if (l[u + 1] < 0) {
			if (l[u + 1] == -2) {
				(a = !0), (l[u + 1] = -1);
				continue;
			}
			let c = n.map(t[u] + i),
				d = c - o;
			if (d < 0 || d >= r.content.size) {
				a = !0;
				continue;
			}
			let f = n.map(t[u + 1] + i, -1),
				p = f - o,
				{ index: m, offset: y } = r.content.findIndex(d),
				v = r.maybeChild(m);
			if (v && y == d && y + v.nodeSize == p) {
				let w = l[u + 2].mapInner(n, v, c + 1, t[u] + i + 1, s);
				w != Wt
					? ((l[u] = d), (l[u + 1] = p), (l[u + 2] = w))
					: ((l[u + 1] = -2), (a = !0));
			} else a = !0;
		}
	if (a) {
		let u = ZE(l, t, e, n, o, i, s),
			c = Ra(u, r, 0, s);
		e = c.local;
		for (let d = 0; d < l.length; d += 3)
			l[d + 1] < 0 && (l.splice(d, 3), (d -= 3));
		for (let d = 0, f = 0; d < c.children.length; d += 3) {
			let p = c.children[d];
			for (; f < l.length && l[f] < p; ) f += 3;
			l.splice(f, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
		}
	}
	return new ft(e.sort(Lo), l);
}
function Zv(t, e) {
	if (!e || !t.length) return t;
	let n = [];
	for (let r = 0; r < t.length; r++) {
		let o = t[r];
		n.push(new qt(o.from + e, o.to + e, o.type));
	}
	return n;
}
function ZE(t, e, n, r, o, i, s) {
	function l(a, u) {
		for (let c = 0; c < a.local.length; c++) {
			let d = a.local[c].map(r, o, u);
			d ? n.push(d) : s.onRemove && s.onRemove(a.local[c].spec);
		}
		for (let c = 0; c < a.children.length; c += 3)
			l(a.children[c + 2], a.children[c] + u + 1);
	}
	for (let a = 0; a < t.length; a += 3)
		t[a + 1] == -1 && l(t[a + 2], e[a] + i + 1);
	return n;
}
function e2(t, e, n) {
	if (e.isLeaf) return null;
	let r = n + e.nodeSize,
		o = null;
	for (let i = 0, s; i < t.length; i++)
		(s = t[i]) &&
			s.from > n &&
			s.to < r &&
			((o || (o = [])).push(s), (t[i] = null));
	return o;
}
function t2(t) {
	let e = [];
	for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
	return e;
}
function Ra(t, e, n, r) {
	let o = [],
		i = !1;
	e.forEach((l, a) => {
		let u = e2(t, l, a + n);
		if (u) {
			i = !0;
			let c = Ra(u, l, n + a + 1, r);
			c != Wt && o.push(a, a + l.nodeSize, c);
		}
	});
	let s = Zv(i ? t2(t) : t, -n).sort(Lo);
	for (let l = 0; l < s.length; l++)
		s[l].type.valid(e, s[l]) ||
			(r.onRemove && r.onRemove(s[l].spec), s.splice(l--, 1));
	return s.length || o.length ? new ft(s, o) : Wt;
}
function Lo(t, e) {
	return t.from - e.from || t.to - e.to;
}
function kh(t) {
	let e = t;
	for (let n = 0; n < e.length - 1; n++) {
		let r = e[n];
		if (r.from != r.to)
			for (let o = n + 1; o < e.length; o++) {
				let i = e[o];
				if (i.from == r.from) {
					i.to != r.to &&
						(e == t && (e = t.slice()),
						(e[o] = i.copy(i.from, r.to)),
						dg(e, o + 1, i.copy(r.to, i.to)));
					continue;
				} else {
					i.from < r.to &&
						(e == t && (e = t.slice()),
						(e[n] = r.copy(r.from, i.from)),
						dg(e, o, r.copy(i.from, r.to)));
					break;
				}
			}
	}
	return e;
}
function dg(t, e, n) {
	for (; e < t.length && Lo(n, t[e]) > 0; ) e++;
	t.splice(e, 0, n);
}
function $c(t) {
	let e = [];
	return (
		t.someProp("decorations", (n) => {
			let r = n(t.state);
			r && r != Wt && e.push(r);
		}),
		t.cursorWrapper &&
			e.push(ft.create(t.state.doc, [t.cursorWrapper.deco])),
		Ur.from(e)
	);
}
const eT = {
		childList: !0,
		characterData: !0,
		characterDataOldValue: !0,
		attributes: !0,
		attributeOldValue: !0,
		subtree: !0,
	},
	tT = cn && to <= 11;
class nT {
	constructor() {
		(this.anchorNode = null),
			(this.anchorOffset = 0),
			(this.focusNode = null),
			(this.focusOffset = 0);
	}
	set(e) {
		(this.anchorNode = e.anchorNode),
			(this.anchorOffset = e.anchorOffset),
			(this.focusNode = e.focusNode),
			(this.focusOffset = e.focusOffset);
	}
	clear() {
		this.anchorNode = this.focusNode = null;
	}
	eq(e) {
		return (
			e.anchorNode == this.anchorNode &&
			e.anchorOffset == this.anchorOffset &&
			e.focusNode == this.focusNode &&
			e.focusOffset == this.focusOffset
		);
	}
}
class rT {
	constructor(e, n) {
		(this.view = e),
			(this.handleDOMChange = n),
			(this.queue = []),
			(this.flushingSoon = -1),
			(this.observer = null),
			(this.currentSelection = new nT()),
			(this.onCharData = null),
			(this.suppressingSelectionUpdates = !1),
			(this.observer =
				window.MutationObserver &&
				new window.MutationObserver((r) => {
					for (let o = 0; o < r.length; o++) this.queue.push(r[o]);
					cn &&
					to <= 11 &&
					r.some(
						(o) =>
							(o.type == "childList" && o.removedNodes.length) ||
							(o.type == "characterData" &&
								o.oldValue.length > o.target.nodeValue.length)
					)
						? this.flushSoon()
						: this.flush();
				})),
			tT &&
				(this.onCharData = (r) => {
					this.queue.push({
						target: r.target,
						type: "characterData",
						oldValue: r.prevValue,
					}),
						this.flushSoon();
				}),
			(this.onSelectionChange = this.onSelectionChange.bind(this));
	}
	flushSoon() {
		this.flushingSoon < 0 &&
			(this.flushingSoon = window.setTimeout(() => {
				(this.flushingSoon = -1), this.flush();
			}, 20));
	}
	forceFlush() {
		this.flushingSoon > -1 &&
			(window.clearTimeout(this.flushingSoon),
			(this.flushingSoon = -1),
			this.flush());
	}
	start() {
		this.observer &&
			(this.observer.takeRecords(),
			this.observer.observe(this.view.dom, eT)),
			this.onCharData &&
				this.view.dom.addEventListener(
					"DOMCharacterDataModified",
					this.onCharData
				),
			this.connectSelection();
	}
	stop() {
		if (this.observer) {
			let e = this.observer.takeRecords();
			if (e.length) {
				for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
				window.setTimeout(() => this.flush(), 20);
			}
			this.observer.disconnect();
		}
		this.onCharData &&
			this.view.dom.removeEventListener(
				"DOMCharacterDataModified",
				this.onCharData
			),
			this.disconnectSelection();
	}
	connectSelection() {
		this.view.dom.ownerDocument.addEventListener(
			"selectionchange",
			this.onSelectionChange
		);
	}
	disconnectSelection() {
		this.view.dom.ownerDocument.removeEventListener(
			"selectionchange",
			this.onSelectionChange
		);
	}
	suppressSelectionUpdates() {
		(this.suppressingSelectionUpdates = !0),
			setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
	}
	onSelectionChange() {
		if (rg(this.view)) {
			if (this.suppressingSelectionUpdates) return Cr(this.view);
			if (cn && to <= 11 && !this.view.state.selection.empty) {
				let e = this.view.domSelectionRange();
				if (
					e.focusNode &&
					Ho(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
				)
					return this.flushSoon();
			}
			this.flush();
		}
	}
	setCurSelection() {
		this.currentSelection.set(this.view.domSelectionRange());
	}
	ignoreSelectionChange(e) {
		if (!e.focusNode) return !0;
		let n = new Set(),
			r;
		for (let i = e.focusNode; i; i = js(i)) n.add(i);
		for (let i = e.anchorNode; i; i = js(i))
			if (n.has(i)) {
				r = i;
				break;
			}
		let o = r && this.view.docView.nearestDesc(r);
		if (
			o &&
			o.ignoreMutation({
				type: "selection",
				target: r.nodeType == 3 ? r.parentNode : r,
			})
		)
			return this.setCurSelection(), !0;
	}
	pendingRecords() {
		if (this.observer)
			for (let e of this.observer.takeRecords()) this.queue.push(e);
		return this.queue;
	}
	flush() {
		let { view: e } = this;
		if (!e.docView || this.flushingSoon > -1) return;
		let n = this.pendingRecords();
		n.length && (this.queue = []);
		let r = e.domSelectionRange(),
			o =
				!this.suppressingSelectionUpdates &&
				!this.currentSelection.eq(r) &&
				rg(e) &&
				!this.ignoreSelectionChange(r),
			i = -1,
			s = -1,
			l = !1,
			a = [];
		if (e.editable)
			for (let c = 0; c < n.length; c++) {
				let d = this.registerMutation(n[c], a);
				d &&
					((i = i < 0 ? d.from : Math.min(d.from, i)),
					(s = s < 0 ? d.to : Math.max(d.to, s)),
					d.typeOver && (l = !0));
			}
		if (Vn && a.length > 1) {
			let c = a.filter((d) => d.nodeName == "BR");
			if (c.length == 2) {
				let d = c[0],
					f = c[1];
				d.parentNode && d.parentNode.parentNode == f.parentNode
					? f.remove()
					: d.remove();
			}
		}
		let u = null;
		i < 0 &&
		o &&
		e.input.lastFocus > Date.now() - 200 &&
		Math.max(e.input.lastTouch, e.input.lastClick.time) <
			Date.now() - 300 &&
		Wu(r) &&
		(u = gh(e)) &&
		u.eq(Me.near(e.state.doc.resolve(0), 1))
			? ((e.input.lastFocus = 0),
			  Cr(e),
			  this.currentSelection.set(r),
			  e.scrollToSelection())
			: (i > -1 || o) &&
			  (i > -1 && (e.docView.markDirty(i, s), oT(e)),
			  this.handleDOMChange(i, s, l, a),
			  e.docView && e.docView.dirty
					? e.updateState(e.state)
					: this.currentSelection.eq(r) || Cr(e),
			  this.currentSelection.set(r));
	}
	registerMutation(e, n) {
		if (n.indexOf(e.target) > -1) return null;
		let r = this.view.docView.nearestDesc(e.target);
		if (
			(e.type == "attributes" &&
				(r == this.view.docView ||
					e.attributeName == "contenteditable" ||
					(e.attributeName == "style" &&
						!e.oldValue &&
						!e.target.getAttribute("style")))) ||
			!r ||
			r.ignoreMutation(e)
		)
			return null;
		if (e.type == "childList") {
			for (let c = 0; c < e.addedNodes.length; c++)
				n.push(e.addedNodes[c]);
			if (
				r.contentDOM &&
				r.contentDOM != r.dom &&
				!r.contentDOM.contains(e.target)
			)
				return { from: r.posBefore, to: r.posAfter };
			let o = e.previousSibling,
				i = e.nextSibling;
			if (cn && to <= 11 && e.addedNodes.length)
				for (let c = 0; c < e.addedNodes.length; c++) {
					let { previousSibling: d, nextSibling: f } =
						e.addedNodes[c];
					(!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) &&
						(o = d),
						(!f ||
							Array.prototype.indexOf.call(e.addedNodes, f) <
								0) &&
							(i = f);
				}
			let s = o && o.parentNode == e.target ? en(o) + 1 : 0,
				l = r.localPosFromDOM(e.target, s, -1),
				a =
					i && i.parentNode == e.target
						? en(i)
						: e.target.childNodes.length,
				u = r.localPosFromDOM(e.target, a, 1);
			return { from: l, to: u };
		} else
			return e.type == "attributes"
				? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
				: {
						from: r.posAtStart,
						to: r.posAtEnd,
						typeOver: e.target.nodeValue == e.oldValue,
				  };
	}
}
let fg = new WeakMap(),
	hg = !1;
function oT(t) {
	if (
		!fg.has(t) &&
		(fg.set(t, null),
		["normal", "nowrap", "pre-line"].indexOf(
			getComputedStyle(t.dom).whiteSpace
		) !== -1)
	) {
		if (((t.requiresGeckoHackNode = Vn), hg)) return;
		console.warn(
			"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
		),
			(hg = !0);
	}
}
function iT(t) {
	let e;
	function n(a) {
		a.preventDefault(),
			a.stopImmediatePropagation(),
			(e = a.getTargetRanges()[0]);
	}
	t.dom.addEventListener("beforeinput", n, !0),
		document.execCommand("indent"),
		t.dom.removeEventListener("beforeinput", n, !0);
	let r = e.startContainer,
		o = e.startOffset,
		i = e.endContainer,
		s = e.endOffset,
		l = t.domAtPos(t.state.selection.anchor);
	return (
		Ho(l.node, l.offset, i, s) && ([r, o, i, s] = [i, s, r, o]),
		{ anchorNode: r, anchorOffset: o, focusNode: i, focusOffset: s }
	);
}
function sT(t, e, n) {
	let {
			node: r,
			fromOffset: o,
			toOffset: i,
			from: s,
			to: l,
		} = t.docView.parseRange(e, n),
		a = t.domSelectionRange(),
		u,
		c = a.anchorNode;
	if (
		(c &&
			t.dom.contains(c.nodeType == 1 ? c : c.parentNode) &&
			((u = [{ node: c, offset: a.anchorOffset }]),
			Wu(a) || u.push({ node: a.focusNode, offset: a.focusOffset })),
		Kt && t.input.lastKeyCode === 8)
	)
		for (let v = i; v > o; v--) {
			let w = r.childNodes[v - 1],
				S = w.pmViewDesc;
			if (w.nodeName == "BR" && !S) {
				i = v;
				break;
			}
			if (!S || S.size) break;
		}
	let d = t.state.doc,
		f = t.someProp("domParser") || zu.fromSchema(t.state.schema),
		p = d.resolve(s),
		m = null,
		y = f.parse(r, {
			topNode: p.parent,
			topMatch: p.parent.contentMatchAt(p.index()),
			topOpen: !0,
			from: o,
			to: i,
			preserveWhitespace: p.parent.type.whitespace == "pre" ? "full" : !0,
			findPositions: u,
			ruleFromNode: lT,
			context: p,
		});
	if (u && u[0].pos != null) {
		let v = u[0].pos,
			w = u[1] && u[1].pos;
		w == null && (w = v), (m = { anchor: v + s, head: w + s });
	}
	return { doc: y, sel: m, from: s, to: l };
}
function lT(t) {
	let e = t.pmViewDesc;
	if (e) return e.parseRule();
	if (t.nodeName == "BR" && t.parentNode) {
		if (nn && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
			let n = document.createElement("div");
			return n.appendChild(document.createElement("li")), { skip: n };
		} else if (
			t.parentNode.lastChild == t ||
			(nn && /^(tr|table)$/i.test(t.parentNode.nodeName))
		)
			return { ignore: !0 };
	} else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
		return { ignore: !0 };
	return null;
}
const aT =
	/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function uT(t, e, n, r, o) {
	let i =
		t.input.compositionPendingChanges ||
		(t.composing ? t.input.compositionID : 0);
	if (((t.input.compositionPendingChanges = 0), e < 0)) {
		let C =
				t.input.lastSelectionTime > Date.now() - 50
					? t.input.lastSelectionOrigin
					: null,
			_ = gh(t, C);
		if (_ && !t.state.selection.eq(_)) {
			if (
				Kt &&
				Dn &&
				t.input.lastKeyCode === 13 &&
				Date.now() - 100 < t.input.lastKeyCodeTime &&
				t.someProp("handleKeyDown", (R) => R(t, So(13, "Enter")))
			)
				return;
			let T = t.state.tr.setSelection(_);
			C == "pointer"
				? T.setMeta("pointer", !0)
				: C == "key" && T.scrollIntoView(),
				i && T.setMeta("composition", i),
				t.dispatch(T);
		}
		return;
	}
	let s = t.state.doc.resolve(e),
		l = s.sharedDepth(n);
	(e = s.before(l + 1)), (n = t.state.doc.resolve(n).after(l + 1));
	let a = t.state.selection,
		u = sT(t, e, n),
		c = t.state.doc,
		d = c.slice(u.from, u.to),
		f,
		p;
	t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
		? ((f = t.state.selection.to), (p = "end"))
		: ((f = t.state.selection.from), (p = "start")),
		(t.input.lastKeyCode = null);
	let m = fT(d.content, u.doc.content, u.from, f, p);
	if (
		((Ni && t.input.lastIOSEnter > Date.now() - 225) || Dn) &&
		o.some((C) => C.nodeType == 1 && !aT.test(C.nodeName)) &&
		(!m || m.endA >= m.endB) &&
		t.someProp("handleKeyDown", (C) => C(t, So(13, "Enter")))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (!m)
		if (
			r &&
			a instanceof Se &&
			!a.empty &&
			a.$head.sameParent(a.$anchor) &&
			!t.composing &&
			!(u.sel && u.sel.anchor != u.sel.head)
		)
			m = { start: a.from, endA: a.to, endB: a.to };
		else {
			if (u.sel) {
				let C = pg(t, t.state.doc, u.sel);
				if (C && !C.eq(t.state.selection)) {
					let _ = t.state.tr.setSelection(C);
					i && _.setMeta("composition", i), t.dispatch(_);
				}
			}
			return;
		}
	if (
		Kt &&
		t.cursorWrapper &&
		u.sel &&
		u.sel.anchor == t.cursorWrapper.deco.from &&
		u.sel.head == u.sel.anchor
	) {
		let C = m.endB - m.start;
		u.sel = { anchor: u.sel.anchor + C, head: u.sel.anchor + C };
	}
	t.input.domChangeCount++,
		t.state.selection.from < t.state.selection.to &&
			m.start == m.endB &&
			t.state.selection instanceof Se &&
			(m.start > t.state.selection.from &&
			m.start <= t.state.selection.from + 2 &&
			t.state.selection.from >= u.from
				? (m.start = t.state.selection.from)
				: m.endA < t.state.selection.to &&
				  m.endA >= t.state.selection.to - 2 &&
				  t.state.selection.to <= u.to &&
				  ((m.endB += t.state.selection.to - m.endA),
				  (m.endA = t.state.selection.to))),
		cn &&
			to <= 11 &&
			m.endB == m.start + 1 &&
			m.endA == m.start &&
			m.start > u.from &&
			u.doc.textBetween(m.start - u.from - 1, m.start - u.from + 1) ==
				" " &&
			(m.start--, m.endA--, m.endB--);
	let y = u.doc.resolveNoCache(m.start - u.from),
		v = u.doc.resolveNoCache(m.endB - u.from),
		w = c.resolve(m.start),
		S = y.sameParent(v) && y.parent.inlineContent && w.end() >= m.endA,
		E;
	if (
		((Ni &&
			t.input.lastIOSEnter > Date.now() - 225 &&
			(!S || o.some((C) => C.nodeName == "DIV" || C.nodeName == "P"))) ||
			(!S &&
				y.pos < u.doc.content.size &&
				!y.sameParent(v) &&
				(E = Me.findFrom(u.doc.resolve(y.pos + 1), 1, !0)) &&
				E.head == v.pos)) &&
		t.someProp("handleKeyDown", (C) => C(t, So(13, "Enter")))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (
		t.state.selection.anchor > m.start &&
		dT(c, m.start, m.endA, y, v) &&
		t.someProp("handleKeyDown", (C) => C(t, So(8, "Backspace")))
	) {
		Dn && Kt && t.domObserver.suppressSelectionUpdates();
		return;
	}
	Kt && Dn && m.endB == m.start && (t.input.lastAndroidDelete = Date.now()),
		Dn &&
			!S &&
			y.start() != v.start() &&
			v.parentOffset == 0 &&
			y.depth == v.depth &&
			u.sel &&
			u.sel.anchor == u.sel.head &&
			u.sel.head == m.endA &&
			((m.endB -= 2),
			(v = u.doc.resolveNoCache(m.endB - u.from)),
			setTimeout(() => {
				t.someProp("handleKeyDown", function (C) {
					return C(t, So(13, "Enter"));
				});
			}, 20));
	let h = m.start,
		b = m.endA,
		g,
		x,
		k;
	if (S) {
		if (y.pos == v.pos)
			cn &&
				to <= 11 &&
				y.parentOffset == 0 &&
				(t.domObserver.suppressSelectionUpdates(),
				setTimeout(() => Cr(t), 20)),
				(g = t.state.tr.delete(h, b)),
				(x = c.resolve(m.start).marksAcross(c.resolve(m.endA)));
		else if (
			m.endA == m.endB &&
			(k = cT(
				y.parent.content.cut(y.parentOffset, v.parentOffset),
				w.parent.content.cut(w.parentOffset, m.endA - w.start())
			))
		)
			(g = t.state.tr),
				k.type == "add"
					? g.addMark(h, b, k.mark)
					: g.removeMark(h, b, k.mark);
		else if (
			y.parent.child(y.index()).isText &&
			y.index() == v.index() - (v.textOffset ? 0 : 1)
		) {
			let C = y.parent.textBetween(y.parentOffset, v.parentOffset);
			if (t.someProp("handleTextInput", (_) => _(t, h, b, C))) return;
			g = t.state.tr.insertText(C, h, b);
		}
	}
	if (
		(g ||
			(g = t.state.tr.replace(
				h,
				b,
				u.doc.slice(m.start - u.from, m.endB - u.from)
			)),
		u.sel)
	) {
		let C = pg(t, g.doc, u.sel);
		C &&
			!(
				(Kt &&
					Dn &&
					t.composing &&
					C.empty &&
					(m.start != m.endB ||
						t.input.lastAndroidDelete < Date.now() - 100) &&
					(C.head == h || C.head == g.mapping.map(b) - 1)) ||
				(cn && C.empty && C.head == h)
			) &&
			g.setSelection(C);
	}
	x && g.ensureMarks(x),
		i && g.setMeta("composition", i),
		t.dispatch(g.scrollIntoView());
}
function pg(t, e, n) {
	return Math.max(n.anchor, n.head) > e.content.size
		? null
		: yh(t, e.resolve(n.anchor), e.resolve(n.head));
}
function cT(t, e) {
	let n = t.firstChild.marks,
		r = e.firstChild.marks,
		o = n,
		i = r,
		s,
		l,
		a;
	for (let c = 0; c < r.length; c++) o = r[c].removeFromSet(o);
	for (let c = 0; c < n.length; c++) i = n[c].removeFromSet(i);
	if (o.length == 1 && i.length == 0)
		(l = o[0]), (s = "add"), (a = (c) => c.mark(l.addToSet(c.marks)));
	else if (o.length == 0 && i.length == 1)
		(l = i[0]),
			(s = "remove"),
			(a = (c) => c.mark(l.removeFromSet(c.marks)));
	else return null;
	let u = [];
	for (let c = 0; c < e.childCount; c++) u.push(a(e.child(c)));
	if (J.from(u).eq(t)) return { mark: l, type: s };
}
function dT(t, e, n, r, o) {
	if (
		!r.parent.isTextblock ||
		n - e <= o.pos - r.pos ||
		Bc(r, !0, !1) < o.pos
	)
		return !1;
	let i = t.resolve(e);
	if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
		return !1;
	let s = t.resolve(Bc(i, !0, !0));
	return !s.parent.isTextblock || s.pos > n || Bc(s, !0, !1) < n
		? !1
		: r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Bc(t, e, n) {
	let r = t.depth,
		o = e ? t.end() : t.pos;
	for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
		r--, o++, (e = !1);
	if (n) {
		let i = t.node(r).maybeChild(t.indexAfter(r));
		for (; i && !i.isLeaf; ) (i = i.firstChild), o++;
	}
	return o;
}
function fT(t, e, n, r, o) {
	let i = t.findDiffStart(e, n);
	if (i == null) return null;
	let { a: s, b: l } = t.findDiffEnd(e, n + t.size, n + e.size);
	if (o == "end") {
		let a = Math.max(0, i - Math.min(s, l));
		r -= s + a - i;
	}
	if (s < i && t.size < e.size) {
		let a = r <= i && r >= s ? i - r : 0;
		(i -= a),
			i &&
				i < e.size &&
				mg(e.textBetween(i - 1, i + 1)) &&
				(i += a ? 1 : -1),
			(l = i + (l - s)),
			(s = i);
	} else if (l < i) {
		let a = r <= i && r >= l ? i - r : 0;
		(i -= a),
			i &&
				i < t.size &&
				mg(t.textBetween(i - 1, i + 1)) &&
				(i += a ? 1 : -1),
			(s = i + (s - l)),
			(l = i);
	}
	return { start: i, endA: s, endB: l };
}
function mg(t) {
	if (t.length != 2) return !1;
	let e = t.charCodeAt(0),
		n = t.charCodeAt(1);
	return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class hT {
	constructor(e, n) {
		(this._root = null),
			(this.focused = !1),
			(this.trackWrites = null),
			(this.mounted = !1),
			(this.markCursor = null),
			(this.cursorWrapper = null),
			(this.lastSelectedViewDesc = void 0),
			(this.input = new NE()),
			(this.prevDirectPlugins = []),
			(this.pluginViews = []),
			(this.requiresGeckoHackNode = !1),
			(this.dragging = null),
			(this._props = n),
			(this.state = n.state),
			(this.directPlugins = n.plugins || []),
			this.directPlugins.forEach(wg),
			(this.dispatch = this.dispatch.bind(this)),
			(this.dom = (e && e.mount) || document.createElement("div")),
			e &&
				(e.appendChild
					? e.appendChild(this.dom)
					: typeof e == "function"
					? e(this.dom)
					: e.mount && (this.mounted = !0)),
			(this.editable = vg(this)),
			yg(this),
			(this.nodeViews = bg(this)),
			(this.docView = Qm(
				this.state.doc,
				gg(this),
				$c(this),
				this.dom,
				this
			)),
			(this.domObserver = new rT(this, (r, o, i, s) =>
				uT(this, r, o, i, s)
			)),
			this.domObserver.start(),
			DE(this),
			this.updatePluginViews();
	}
	get composing() {
		return this.input.composing;
	}
	get props() {
		if (this._props.state != this.state) {
			let e = this._props;
			this._props = {};
			for (let n in e) this._props[n] = e[n];
			this._props.state = this.state;
		}
		return this._props;
	}
	update(e) {
		e.handleDOMEvents != this._props.handleDOMEvents && Yd(this);
		let n = this._props;
		(this._props = e),
			e.plugins &&
				(e.plugins.forEach(wg), (this.directPlugins = e.plugins)),
			this.updateStateInner(e.state, n);
	}
	setProps(e) {
		let n = {};
		for (let r in this._props) n[r] = this._props[r];
		n.state = this.state;
		for (let r in e) n[r] = e[r];
		this.update(n);
	}
	updateState(e) {
		this.updateStateInner(e, this._props);
	}
	updateStateInner(e, n) {
		var r;
		let o = this.state,
			i = !1,
			s = !1;
		e.storedMarks && this.composing && (Gv(this), (s = !0)),
			(this.state = e);
		let l = o.plugins != e.plugins || this._props.plugins != n.plugins;
		if (
			l ||
			this._props.plugins != n.plugins ||
			this._props.nodeViews != n.nodeViews
		) {
			let p = bg(this);
			mT(p, this.nodeViews) && ((this.nodeViews = p), (i = !0));
		}
		(l || n.handleDOMEvents != this._props.handleDOMEvents) && Yd(this),
			(this.editable = vg(this)),
			yg(this);
		let a = $c(this),
			u = gg(this),
			c =
				o.plugins != e.plugins && !o.doc.eq(e.doc)
					? "reset"
					: e.scrollToSelection > o.scrollToSelection
					? "to selection"
					: "preserve",
			d = i || !this.docView.matchesNode(e.doc, u, a);
		(d || !e.selection.eq(o.selection)) && (s = !0);
		let f =
			c == "preserve" &&
			s &&
			this.dom.style.overflowAnchor == null &&
			GM(this);
		if (s) {
			this.domObserver.stop();
			let p =
				d &&
				(cn || Kt) &&
				!this.composing &&
				!o.selection.empty &&
				!e.selection.empty &&
				pT(o.selection, e.selection);
			if (d) {
				let m = Kt
					? (this.trackWrites = this.domSelectionRange().focusNode)
					: null;
				(i || !this.docView.update(e.doc, u, a, this)) &&
					(this.docView.updateOuterDeco([]),
					this.docView.destroy(),
					(this.docView = Qm(e.doc, u, a, this.dom, this))),
					m && !this.trackWrites && (p = !0);
			}
			p ||
			!(
				this.input.mouseDown &&
				this.domObserver.currentSelection.eq(
					this.domSelectionRange()
				) &&
				wE(this)
			)
				? Cr(this, p)
				: (jv(this, e.selection), this.domObserver.setCurSelection()),
				this.domObserver.start();
		}
		this.updatePluginViews(o),
			!((r = this.dragging) === null || r === void 0) &&
				r.node &&
				!o.doc.eq(e.doc) &&
				this.updateDraggedNode(this.dragging, o),
			c == "reset"
				? (this.dom.scrollTop = 0)
				: c == "to selection"
				? this.scrollToSelection()
				: f && YM(f);
	}
	scrollToSelection() {
		let e = this.domSelectionRange().focusNode;
		if (!this.someProp("handleScrollToSelection", (n) => n(this)))
			if (this.state.selection instanceof we) {
				let n = this.docView.domAfterPos(this.state.selection.from);
				n.nodeType == 1 && Um(this, n.getBoundingClientRect(), e);
			} else Um(this, this.coordsAtPos(this.state.selection.head, 1), e);
	}
	destroyPluginViews() {
		let e;
		for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
	}
	updatePluginViews(e) {
		if (
			!e ||
			e.plugins != this.state.plugins ||
			this.directPlugins != this.prevDirectPlugins
		) {
			(this.prevDirectPlugins = this.directPlugins),
				this.destroyPluginViews();
			for (let n = 0; n < this.directPlugins.length; n++) {
				let r = this.directPlugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
			for (let n = 0; n < this.state.plugins.length; n++) {
				let r = this.state.plugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
		} else
			for (let n = 0; n < this.pluginViews.length; n++) {
				let r = this.pluginViews[n];
				r.update && r.update(this, e);
			}
	}
	updateDraggedNode(e, n) {
		let r = e.node,
			o = -1;
		if (this.state.doc.nodeAt(r.from) == r.node) o = r.from;
		else {
			let i = r.from + (this.state.doc.content.size - n.doc.content.size);
			(i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
		}
		this.dragging = new Qv(
			e.slice,
			e.move,
			o < 0 ? void 0 : we.create(this.state.doc, o)
		);
	}
	someProp(e, n) {
		let r = this._props && this._props[e],
			o;
		if (r != null && (o = n ? n(r) : r)) return o;
		for (let s = 0; s < this.directPlugins.length; s++) {
			let l = this.directPlugins[s].props[e];
			if (l != null && (o = n ? n(l) : l)) return o;
		}
		let i = this.state.plugins;
		if (i)
			for (let s = 0; s < i.length; s++) {
				let l = i[s].props[e];
				if (l != null && (o = n ? n(l) : l)) return o;
			}
	}
	hasFocus() {
		if (cn) {
			let e = this.root.activeElement;
			if (e == this.dom) return !0;
			if (!e || !this.dom.contains(e)) return !1;
			for (; e && this.dom != e && this.dom.contains(e); ) {
				if (e.contentEditable == "false") return !1;
				e = e.parentElement;
			}
			return !0;
		}
		return this.root.activeElement == this.dom;
	}
	focus() {
		this.domObserver.stop(),
			this.editable && QM(this.dom),
			Cr(this),
			this.domObserver.start();
	}
	get root() {
		let e = this._root;
		if (e == null) {
			for (let n = this.dom.parentNode; n; n = n.parentNode)
				if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
					return (
						n.getSelection ||
							(Object.getPrototypeOf(n).getSelection = () =>
								n.ownerDocument.getSelection()),
						(this._root = n)
					);
		}
		return e || document;
	}
	updateRoot() {
		this._root = null;
	}
	posAtCoords(e) {
		return nE(this, e);
	}
	coordsAtPos(e, n = 1) {
		return Tv(this, e, n);
	}
	domAtPos(e, n = 0) {
		return this.docView.domFromPos(e, n);
	}
	nodeDOM(e) {
		let n = this.docView.descAt(e);
		return n ? n.nodeDOM : null;
	}
	posAtDOM(e, n, r = -1) {
		let o = this.docView.posFromDOM(e, n, r);
		if (o == null)
			throw new RangeError("DOM position not inside the editor");
		return o;
	}
	endOfTextblock(e, n) {
		return lE(this, n || this.state, e);
	}
	pasteHTML(e, n) {
		return $s(this, "", e, !1, n || new ClipboardEvent("paste"));
	}
	pasteText(e, n) {
		return $s(this, e, null, !0, n || new ClipboardEvent("paste"));
	}
	destroy() {
		this.docView &&
			(jE(this),
			this.destroyPluginViews(),
			this.mounted
				? (this.docView.update(this.state.doc, [], $c(this), this),
				  (this.dom.textContent = ""))
				: this.dom.parentNode &&
				  this.dom.parentNode.removeChild(this.dom),
			this.docView.destroy(),
			(this.docView = null));
	}
	get isDestroyed() {
		return this.docView == null;
	}
	dispatchEvent(e) {
		return $E(this, e);
	}
	dispatch(e) {
		let n = this._props.dispatchTransaction;
		n ? n.call(this, e) : this.updateState(this.state.apply(e));
	}
	domSelectionRange() {
		return nn &&
			this.root.nodeType === 11 &&
			FM(this.dom.ownerDocument) == this.dom
			? iT(this)
			: this.domSelection();
	}
	domSelection() {
		return this.root.getSelection();
	}
}
function gg(t) {
	let e = Object.create(null);
	return (
		(e.class = "ProseMirror"),
		(e.contenteditable = String(t.editable)),
		t.someProp("attributes", (n) => {
			if ((typeof n == "function" && (n = n(t.state)), n))
				for (let r in n)
					r == "class"
						? (e.class += " " + n[r])
						: r == "style"
						? (e.style = (e.style ? e.style + ";" : "") + n[r])
						: !e[r] &&
						  r != "contenteditable" &&
						  r != "nodeName" &&
						  (e[r] = String(n[r]));
		}),
		e.translate || (e.translate = "no"),
		[qt.node(0, t.state.doc.content.size, e)]
	);
}
function yg(t) {
	if (t.markCursor) {
		let e = document.createElement("img");
		(e.className = "ProseMirror-separator"),
			e.setAttribute("mark-placeholder", "true"),
			e.setAttribute("alt", ""),
			(t.cursorWrapper = {
				dom: e,
				deco: qt.widget(t.state.selection.head, e, {
					raw: !0,
					marks: t.markCursor,
				}),
			});
	} else t.cursorWrapper = null;
}
function vg(t) {
	return !t.someProp("editable", (e) => e(t.state) === !1);
}
function pT(t, e) {
	let n = Math.min(
		t.$anchor.sharedDepth(t.head),
		e.$anchor.sharedDepth(e.head)
	);
	return t.$anchor.start(n) != e.$anchor.start(n);
}
function bg(t) {
	let e = Object.create(null);
	function n(r) {
		for (let o in r)
			Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
	}
	return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function mT(t, e) {
	let n = 0,
		r = 0;
	for (let o in t) {
		if (t[o] != e[o]) return !0;
		n++;
	}
	for (let o in e) r++;
	return n != r;
}
function wg(t) {
	if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
		throw new RangeError(
			"Plugins passed directly to the view must not have a state component"
		);
}
var io = {
		8: "Backspace",
		9: "Tab",
		10: "Enter",
		12: "NumLock",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		44: "PrintScreen",
		45: "Insert",
		46: "Delete",
		59: ";",
		61: "=",
		91: "Meta",
		92: "Meta",
		106: "*",
		107: "+",
		108: ",",
		109: "-",
		110: ".",
		111: "/",
		144: "NumLock",
		145: "ScrollLock",
		160: "Shift",
		161: "Shift",
		162: "Control",
		163: "Control",
		164: "Alt",
		165: "Alt",
		173: "-",
		186: ";",
		187: "=",
		188: ",",
		189: "-",
		190: ".",
		191: "/",
		192: "`",
		219: "[",
		220: "\\",
		221: "]",
		222: "'",
	},
	Pa = {
		48: ")",
		49: "!",
		50: "@",
		51: "#",
		52: "$",
		53: "%",
		54: "^",
		55: "&",
		56: "*",
		57: "(",
		59: ":",
		61: "+",
		173: "_",
		186: ":",
		187: "+",
		188: "<",
		189: "_",
		190: ">",
		191: "?",
		192: "~",
		219: "{",
		220: "|",
		221: "}",
		222: '"',
	},
	gT = typeof navigator != "undefined" && /Mac/.test(navigator.platform),
	yT =
		typeof navigator != "undefined" &&
		/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
			navigator.userAgent
		);
for (var Vt = 0; Vt < 10; Vt++) io[48 + Vt] = io[96 + Vt] = String(Vt);
for (var Vt = 1; Vt <= 24; Vt++) io[Vt + 111] = "F" + Vt;
for (var Vt = 65; Vt <= 90; Vt++)
	(io[Vt] = String.fromCharCode(Vt + 32)), (Pa[Vt] = String.fromCharCode(Vt));
for (var zc in io) Pa.hasOwnProperty(zc) || (Pa[zc] = io[zc]);
function vT(t) {
	var e =
			(gT && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
			(yT && t.shiftKey && t.key && t.key.length == 1) ||
			t.key == "Unidentified",
		n =
			(!e && t.key) ||
			(t.shiftKey ? Pa : io)[t.keyCode] ||
			t.key ||
			"Unidentified";
	return (
		n == "Esc" && (n = "Escape"),
		n == "Del" && (n = "Delete"),
		n == "Left" && (n = "ArrowLeft"),
		n == "Up" && (n = "ArrowUp"),
		n == "Right" && (n = "ArrowRight"),
		n == "Down" && (n = "ArrowDown"),
		n
	);
}
const bT =
	typeof navigator != "undefined"
		? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
		: !1;
function wT(t) {
	let e = t.split(/-(?!$)/),
		n = e[e.length - 1];
	n == "Space" && (n = " ");
	let r, o, i, s;
	for (let l = 0; l < e.length - 1; l++) {
		let a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) s = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) o = !0;
		else if (/^s(hift)?$/i.test(a)) i = !0;
		else if (/^mod$/i.test(a)) bT ? (s = !0) : (o = !0);
		else throw new Error("Unrecognized modifier name: " + a);
	}
	return (
		r && (n = "Alt-" + n),
		o && (n = "Ctrl-" + n),
		s && (n = "Meta-" + n),
		i && (n = "Shift-" + n),
		n
	);
}
function xT(t) {
	let e = Object.create(null);
	for (let n in t) e[wT(n)] = t[n];
	return e;
}
function Hc(t, e, n = !0) {
	return (
		e.altKey && (t = "Alt-" + t),
		e.ctrlKey && (t = "Ctrl-" + t),
		e.metaKey && (t = "Meta-" + t),
		n && e.shiftKey && (t = "Shift-" + t),
		t
	);
}
function kT(t) {
	return new kt({ props: { handleKeyDown: Sh(t) } });
}
function Sh(t) {
	let e = xT(t);
	return function (n, r) {
		let o = vT(r),
			i,
			s = e[Hc(o, r)];
		if (s && s(n.state, n.dispatch, n)) return !0;
		if (o.length == 1 && o != " ") {
			if (r.shiftKey) {
				let l = e[Hc(o, r, !1)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
			if (
				(r.shiftKey ||
					r.altKey ||
					r.metaKey ||
					o.charCodeAt(0) > 127) &&
				(i = io[r.keyCode]) &&
				i != o
			) {
				let l = e[Hc(i, r)];
				if (l && l(n.state, n.dispatch, n)) return !0;
			}
		}
		return !1;
	};
}
const ST = (t, e) =>
	t.selection.empty
		? !1
		: (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function n2(t, e) {
	let { $cursor: n } = t.selection;
	return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
		? null
		: n;
}
const _T = (t, e, n) => {
		let r = n2(t, n);
		if (!r) return !1;
		let o = _h(r);
		if (!o) {
			let s = r.blockRange(),
				l = s && Hi(s);
			return l == null
				? !1
				: (e && e(t.tr.lift(s, l).scrollIntoView()), !0);
		}
		let i = o.nodeBefore;
		if (!i.type.spec.isolating && s2(t, o, e)) return !0;
		if (
			r.parent.content.size == 0 &&
			(Di(i, "end") || we.isSelectable(i))
		) {
			let s = Fu(t.doc, r.before(), r.after(), le.empty);
			if (s && s.slice.size < s.to - s.from) {
				if (e) {
					let l = t.tr.step(s);
					l.setSelection(
						Di(i, "end")
							? Me.findFrom(
									l.doc.resolve(l.mapping.map(o.pos, -1)),
									-1
							  )
							: we.create(l.doc, o.pos - i.nodeSize)
					),
						e(l.scrollIntoView());
				}
				return !0;
			}
		}
		return i.isAtom && o.depth == r.depth - 1
			? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()),
			  !0)
			: !1;
	},
	CT = (t, e, n) => {
		let r = n2(t, n);
		if (!r) return !1;
		let o = _h(r);
		return o ? r2(t, o, e) : !1;
	},
	MT = (t, e, n) => {
		let r = o2(t, n);
		if (!r) return !1;
		let o = Ch(r);
		return o ? r2(t, o, e) : !1;
	};
function r2(t, e, n) {
	let r = e.nodeBefore,
		o = r,
		i = e.pos - 1;
	for (; !o.isTextblock; i--) {
		if (o.type.spec.isolating) return !1;
		let c = o.lastChild;
		if (!c) return !1;
		o = c;
	}
	let s = e.nodeAfter,
		l = s,
		a = e.pos + 1;
	for (; !l.isTextblock; a++) {
		if (l.type.spec.isolating) return !1;
		let c = l.firstChild;
		if (!c) return !1;
		l = c;
	}
	let u = Fu(t.doc, i, a, le.empty);
	if (!u || u.from != i || (u instanceof jt && u.slice.size >= a - i))
		return !1;
	if (n) {
		let c = t.tr.step(u);
		c.setSelection(Se.create(c.doc, i)), n(c.scrollIntoView());
	}
	return !0;
}
function Di(t, e, n = !1) {
	for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
		if (r.isTextblock) return !0;
		if (n && r.childCount != 1) return !1;
	}
	return !1;
}
const ET = (t, e, n) => {
	let { $head: r, empty: o } = t.selection,
		i = r;
	if (!o) return !1;
	if (r.parent.isTextblock) {
		if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
			return !1;
		i = _h(r);
	}
	let s = i && i.nodeBefore;
	return !s || !we.isSelectable(s)
		? !1
		: (e &&
				e(
					t.tr
						.setSelection(we.create(t.doc, i.pos - s.nodeSize))
						.scrollIntoView()
				),
		  !0);
};
function _h(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
			if (t.node(e).type.spec.isolating) break;
		}
	return null;
}
function o2(t, e) {
	let { $cursor: n } = t.selection;
	return !n ||
		(e
			? !e.endOfTextblock("forward", t)
			: n.parentOffset < n.parent.content.size)
		? null
		: n;
}
const TT = (t, e, n) => {
		let r = o2(t, n);
		if (!r) return !1;
		let o = Ch(r);
		if (!o) return !1;
		let i = o.nodeAfter;
		if (s2(t, o, e)) return !0;
		if (
			r.parent.content.size == 0 &&
			(Di(i, "start") || we.isSelectable(i))
		) {
			let s = Fu(t.doc, r.before(), r.after(), le.empty);
			if (s && s.slice.size < s.to - s.from) {
				if (e) {
					let l = t.tr.step(s);
					l.setSelection(
						Di(i, "start")
							? Me.findFrom(
									l.doc.resolve(l.mapping.map(o.pos)),
									1
							  )
							: we.create(l.doc, l.mapping.map(o.pos))
					),
						e(l.scrollIntoView());
				}
				return !0;
			}
		}
		return i.isAtom && o.depth == r.depth - 1
			? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()),
			  !0)
			: !1;
	},
	AT = (t, e, n) => {
		let { $head: r, empty: o } = t.selection,
			i = r;
		if (!o) return !1;
		if (r.parent.isTextblock) {
			if (
				n
					? !n.endOfTextblock("forward", t)
					: r.parentOffset < r.parent.content.size
			)
				return !1;
			i = Ch(r);
		}
		let s = i && i.nodeAfter;
		return !s || !we.isSelectable(s)
			? !1
			: (e &&
					e(
						t.tr
							.setSelection(we.create(t.doc, i.pos))
							.scrollIntoView()
					),
			  !0);
	};
function Ch(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			let n = t.node(e);
			if (t.index(e) + 1 < n.childCount)
				return t.doc.resolve(t.after(e + 1));
			if (n.type.spec.isolating) break;
		}
	return null;
}
const OT = (t, e) => {
		let n = t.selection,
			r = n instanceof we,
			o;
		if (r) {
			if (n.node.isTextblock || !fo(t.doc, n.from)) return !1;
			o = n.from;
		} else if (((o = Hu(t.doc, n.from, -1)), o == null)) return !1;
		if (e) {
			let i = t.tr.join(o);
			r &&
				i.setSelection(
					we.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)
				),
				e(i.scrollIntoView());
		}
		return !0;
	},
	RT = (t, e) => {
		let n = t.selection,
			r;
		if (n instanceof we) {
			if (n.node.isTextblock || !fo(t.doc, n.to)) return !1;
			r = n.to;
		} else if (((r = Hu(t.doc, n.to, 1)), r == null)) return !1;
		return e && e(t.tr.join(r).scrollIntoView()), !0;
	},
	PT = (t, e) => {
		let { $from: n, $to: r } = t.selection,
			o = n.blockRange(r),
			i = o && Hi(o);
		return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
	},
	IT = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		return !n.parent.type.spec.code || !n.sameParent(r)
			? !1
			: (e &&
					e(
						t.tr
							.insertText(
								`
`
							)
							.scrollIntoView()
					),
			  !0);
	};
function i2(t) {
	for (let e = 0; e < t.edgeCount; e++) {
		let { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
const NT = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		if (!n.parent.type.spec.code || !n.sameParent(r)) return !1;
		let o = n.node(-1),
			i = n.indexAfter(-1),
			s = i2(o.contentMatchAt(i));
		if (!s || !o.canReplaceWith(i, i, s)) return !1;
		if (e) {
			let l = n.after(),
				a = t.tr.replaceWith(l, l, s.createAndFill());
			a.setSelection(Me.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
		}
		return !0;
	},
	DT = (t, e) => {
		let n = t.selection,
			{ $from: r, $to: o } = n;
		if (n instanceof zn || r.parent.inlineContent || o.parent.inlineContent)
			return !1;
		let i = i2(o.parent.contentMatchAt(o.indexAfter()));
		if (!i || !i.isTextblock) return !1;
		if (e) {
			let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o)
					.pos,
				l = t.tr.insert(s, i.createAndFill());
			l.setSelection(Se.create(l.doc, s + 1)), e(l.scrollIntoView());
		}
		return !0;
	},
	jT = (t, e) => {
		let { $cursor: n } = t.selection;
		if (!n || n.parent.content.size) return !1;
		if (n.depth > 1 && n.after() != n.end(-1)) {
			let i = n.before();
			if (gi(t.doc, i)) return e && e(t.tr.split(i).scrollIntoView()), !0;
		}
		let r = n.blockRange(),
			o = r && Hi(r);
		return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
	},
	LT = (t, e) => {
		let { $from: n, to: r } = t.selection,
			o,
			i = n.sharedDepth(r);
		return i == 0
			? !1
			: ((o = n.before(i)),
			  e && e(t.tr.setSelection(we.create(t.doc, o))),
			  !0);
	};
function $T(t, e, n) {
	let r = e.nodeBefore,
		o = e.nodeAfter,
		i = e.index();
	return !r || !o || !r.type.compatibleContent(o.type)
		? !1
		: !r.content.size && e.parent.canReplace(i - 1, i)
		? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0)
		: !e.parent.canReplace(i, i + 1) || !(o.isTextblock || fo(t.doc, e.pos))
		? !1
		: (n &&
				n(
					t.tr
						.clearIncompatible(
							e.pos,
							r.type,
							r.contentMatchAt(r.childCount)
						)
						.join(e.pos)
						.scrollIntoView()
				),
		  !0);
}
function s2(t, e, n) {
	let r = e.nodeBefore,
		o = e.nodeAfter,
		i,
		s;
	if (r.type.spec.isolating || o.type.spec.isolating) return !1;
	if ($T(t, e, n)) return !0;
	let l = e.parent.canReplace(e.index(), e.index() + 1);
	if (
		l &&
		(i = (s = r.contentMatchAt(r.childCount)).findWrapping(o.type)) &&
		s.matchType(i[0] || o.type).validEnd
	) {
		if (n) {
			let d = e.pos + o.nodeSize,
				f = J.empty;
			for (let y = i.length - 1; y >= 0; y--)
				f = J.from(i[y].create(null, f));
			f = J.from(r.copy(f));
			let p = t.tr.step(
					new $t(
						e.pos - 1,
						d,
						e.pos,
						d,
						new le(f, 1, 0),
						i.length,
						!0
					)
				),
				m = d + 2 * i.length;
			fo(p.doc, m) && p.join(m), n(p.scrollIntoView());
		}
		return !0;
	}
	let a = Me.findFrom(e, 1),
		u = a && a.$from.blockRange(a.$to),
		c = u && Hi(u);
	if (c != null && c >= e.depth)
		return n && n(t.tr.lift(u, c).scrollIntoView()), !0;
	if (l && Di(o, "start", !0) && Di(r, "end")) {
		let d = r,
			f = [];
		for (; f.push(d), !d.isTextblock; ) d = d.lastChild;
		let p = o,
			m = 1;
		for (; !p.isTextblock; p = p.firstChild) m++;
		if (d.canReplace(d.childCount, d.childCount, p.content)) {
			if (n) {
				let y = J.empty;
				for (let w = f.length - 1; w >= 0; w--)
					y = J.from(f[w].copy(y));
				let v = t.tr.step(
					new $t(
						e.pos - f.length,
						e.pos + o.nodeSize,
						e.pos + m,
						e.pos + o.nodeSize - m,
						new le(y, f.length, 0),
						0,
						!0
					)
				);
				n(v.scrollIntoView());
			}
			return !0;
		}
	}
	return !1;
}
function l2(t) {
	return function (e, n) {
		let r = e.selection,
			o = t < 0 ? r.$from : r.$to,
			i = o.depth;
		for (; o.node(i).isInline; ) {
			if (!i) return !1;
			i--;
		}
		return o.node(i).isTextblock
			? (n &&
					n(
						e.tr.setSelection(
							Se.create(e.doc, t < 0 ? o.start(i) : o.end(i))
						)
					),
			  !0)
			: !1;
	};
}
const BT = l2(-1),
	zT = l2(1);
function HT(t, e = null) {
	return function (n, r) {
		let { $from: o, $to: i } = n.selection,
			s = o.blockRange(i),
			l = s && dh(s, t, e);
		return l ? (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) : !1;
	};
}
function xg(t, e = null) {
	return function (n, r) {
		let o = !1;
		for (let i = 0; i < n.selection.ranges.length && !o; i++) {
			let {
				$from: { pos: s },
				$to: { pos: l },
			} = n.selection.ranges[i];
			n.doc.nodesBetween(s, l, (a, u) => {
				if (o) return !1;
				if (!(!a.isTextblock || a.hasMarkup(t, e)))
					if (a.type == t) o = !0;
					else {
						let c = n.doc.resolve(u),
							d = c.index();
						o = c.parent.canReplaceWith(d, d + 1, t);
					}
			});
		}
		if (!o) return !1;
		if (r) {
			let i = n.tr;
			for (let s = 0; s < n.selection.ranges.length; s++) {
				let {
					$from: { pos: l },
					$to: { pos: a },
				} = n.selection.ranges[s];
				i.setBlockType(l, a, t, e);
			}
			r(i.scrollIntoView());
		}
		return !0;
	};
}
typeof navigator != "undefined"
	? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
	: typeof os != "undefined" && os.platform && os.platform() == "darwin";
function FT(t, e = null) {
	return function (n, r) {
		let { $from: o, $to: i } = n.selection,
			s = o.blockRange(i),
			l = !1,
			a = s;
		if (!s) return !1;
		if (
			s.depth >= 2 &&
			o.node(s.depth - 1).type.compatibleContent(t) &&
			s.startIndex == 0
		) {
			if (o.index(s.depth - 1) == 0) return !1;
			let c = n.doc.resolve(s.start - 2);
			(a = new _a(c, c, s.depth)),
				s.endIndex < s.parent.childCount &&
					(s = new _a(o, n.doc.resolve(i.end(s.depth)), s.depth)),
				(l = !0);
		}
		let u = dh(a, t, e, s);
		return u ? (r && r(VT(n.tr, s, u, l, t).scrollIntoView()), !0) : !1;
	};
}
function VT(t, e, n, r, o) {
	let i = J.empty;
	for (let c = n.length - 1; c >= 0; c--)
		i = J.from(n[c].type.create(n[c].attrs, i));
	t.step(
		new $t(
			e.start - (r ? 2 : 0),
			e.end,
			e.start,
			e.end,
			new le(i, 0, 0),
			n.length,
			!0
		)
	);
	let s = 0;
	for (let c = 0; c < n.length; c++) n[c].type == o && (s = c + 1);
	let l = n.length - s,
		a = e.start + n.length - (r ? 2 : 0),
		u = e.parent;
	for (let c = e.startIndex, d = e.endIndex, f = !0; c < d; c++, f = !1)
		!f && gi(t.doc, a, l) && (t.split(a, l), (a += 2 * l)),
			(a += u.child(c).nodeSize);
	return t;
}
function WT(t) {
	return function (e, n) {
		let { $from: r, $to: o } = e.selection,
			i = r.blockRange(
				o,
				(s) => s.childCount > 0 && s.firstChild.type == t
			);
		return i
			? n
				? r.node(i.depth - 1).type == t
					? UT(e, n, t, i)
					: KT(e, n, i)
				: !0
			: !1;
	};
}
function UT(t, e, n, r) {
	let o = t.tr,
		i = r.end,
		s = r.$to.end(r.depth);
	i < s &&
		(o.step(
			new $t(
				i - 1,
				s,
				i,
				s,
				new le(J.from(n.create(null, r.parent.copy())), 1, 0),
				1,
				!0
			)
		),
		(r = new _a(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth)));
	const l = Hi(r);
	if (l == null) return !1;
	o.lift(r, l);
	let a = o.mapping.map(i, -1) - 1;
	return fo(o.doc, a) && o.join(a), e(o.scrollIntoView()), !0;
}
function KT(t, e, n) {
	let r = t.tr,
		o = n.parent;
	for (let p = n.end, m = n.endIndex - 1, y = n.startIndex; m > y; m--)
		(p -= o.child(m).nodeSize), r.delete(p - 1, p + 1);
	let i = r.doc.resolve(n.start),
		s = i.nodeAfter;
	if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize) return !1;
	let l = n.startIndex == 0,
		a = n.endIndex == o.childCount,
		u = i.node(-1),
		c = i.index(-1);
	if (
		!u.canReplace(
			c + (l ? 0 : 1),
			c + 1,
			s.content.append(a ? J.empty : J.from(o))
		)
	)
		return !1;
	let d = i.pos,
		f = d + s.nodeSize;
	return (
		r.step(
			new $t(
				d - (l ? 1 : 0),
				f + (a ? 1 : 0),
				d + 1,
				f - 1,
				new le(
					(l ? J.empty : J.from(o.copy(J.empty))).append(
						a ? J.empty : J.from(o.copy(J.empty))
					),
					l ? 0 : 1,
					a ? 0 : 1
				),
				l ? 0 : 1
			)
		),
		e(r.scrollIntoView()),
		!0
	);
}
function qT(t) {
	return function (e, n) {
		let { $from: r, $to: o } = e.selection,
			i = r.blockRange(
				o,
				(u) => u.childCount > 0 && u.firstChild.type == t
			);
		if (!i) return !1;
		let s = i.startIndex;
		if (s == 0) return !1;
		let l = i.parent,
			a = l.child(s - 1);
		if (a.type != t) return !1;
		if (n) {
			let u = a.lastChild && a.lastChild.type == l.type,
				c = J.from(u ? t.create() : null),
				d = new le(
					J.from(t.create(null, J.from(l.type.create(null, c)))),
					u ? 3 : 1,
					0
				),
				f = i.start,
				p = i.end;
			n(
				e.tr
					.step(new $t(f - (u ? 3 : 1), p, f, p, d, 1, !0))
					.scrollIntoView()
			);
		}
		return !0;
	};
}
function qu(t) {
	const { state: e, transaction: n } = t;
	let { selection: r } = n,
		{ doc: o } = n,
		{ storedMarks: i } = n;
	return ge(B({}, e), {
		apply: e.apply.bind(e),
		applyTransaction: e.applyTransaction.bind(e),
		plugins: e.plugins,
		schema: e.schema,
		reconfigure: e.reconfigure.bind(e),
		toJSON: e.toJSON.bind(e),
		get storedMarks() {
			return i;
		},
		get selection() {
			return r;
		},
		get doc() {
			return o;
		},
		get tr() {
			return (r = n.selection), (o = n.doc), (i = n.storedMarks), n;
		},
	});
}
class Ju {
	constructor(e) {
		(this.editor = e.editor),
			(this.rawCommands = this.editor.extensionManager.commands),
			(this.customState = e.state);
	}
	get hasCustomState() {
		return !!this.customState;
	}
	get state() {
		return this.customState || this.editor.state;
	}
	get commands() {
		const { rawCommands: e, editor: n, state: r } = this,
			{ view: o } = n,
			{ tr: i } = r,
			s = this.buildProps(i);
		return Object.fromEntries(
			Object.entries(e).map(([l, a]) => [
				l,
				(...c) => {
					const d = a(...c)(s);
					return (
						!i.getMeta("preventDispatch") &&
							!this.hasCustomState &&
							o.dispatch(i),
						d
					);
				},
			])
		);
	}
	get chain() {
		return () => this.createChain();
	}
	get can() {
		return () => this.createCan();
	}
	createChain(e, n = !0) {
		const { rawCommands: r, editor: o, state: i } = this,
			{ view: s } = o,
			l = [],
			a = !!e,
			u = e || i.tr,
			c = () => (
				!a &&
					n &&
					!u.getMeta("preventDispatch") &&
					!this.hasCustomState &&
					s.dispatch(u),
				l.every((f) => f === !0)
			),
			d = ge(
				B(
					{},
					Object.fromEntries(
						Object.entries(r).map(([f, p]) => [
							f,
							(...y) => {
								const v = this.buildProps(u, n),
									w = p(...y)(v);
								return l.push(w), d;
							},
						])
					)
				),
				{ run: c }
			);
		return d;
	}
	createCan(e) {
		const { rawCommands: n, state: r } = this,
			o = !1,
			i = e || r.tr,
			s = this.buildProps(i, o),
			l = Object.fromEntries(
				Object.entries(n).map(([a, u]) => [
					a,
					(...c) => u(...c)(ge(B({}, s), { dispatch: void 0 })),
				])
			);
		return ge(B({}, l), { chain: () => this.createChain(i, o) });
	}
	buildProps(e, n = !0) {
		const { rawCommands: r, editor: o, state: i } = this,
			{ view: s } = o,
			l = {
				tr: e,
				editor: o,
				view: s,
				state: qu({ state: i, transaction: e }),
				dispatch: n ? () => {} : void 0,
				chain: () => this.createChain(e, n),
				can: () => this.createCan(e),
				get commands() {
					return Object.fromEntries(
						Object.entries(r).map(([a, u]) => [
							a,
							(...c) => u(...c)(l),
						])
					);
				},
			};
		return l;
	}
}
class JT {
	constructor() {
		this.callbacks = {};
	}
	on(e, n) {
		return (
			this.callbacks[e] || (this.callbacks[e] = []),
			this.callbacks[e].push(n),
			this
		);
	}
	emit(e, ...n) {
		const r = this.callbacks[e];
		return r && r.forEach((o) => o.apply(this, n)), this;
	}
	off(e, n) {
		const r = this.callbacks[e];
		return (
			r &&
				(n
					? (this.callbacks[e] = r.filter((o) => o !== n))
					: delete this.callbacks[e]),
			this
		);
	}
	removeAllListeners() {
		this.callbacks = {};
	}
}
function fe(t, e, n) {
	return t.config[e] === void 0 && t.parent
		? fe(t.parent, e, n)
		: typeof t.config[e] == "function"
		? t.config[e].bind(
				ge(B({}, n), { parent: t.parent ? fe(t.parent, e, n) : null })
		  )
		: t.config[e];
}
function Gu(t) {
	const e = t.filter((o) => o.type === "extension"),
		n = t.filter((o) => o.type === "node"),
		r = t.filter((o) => o.type === "mark");
	return { baseExtensions: e, nodeExtensions: n, markExtensions: r };
}
function a2(t) {
	const e = [],
		{ nodeExtensions: n, markExtensions: r } = Gu(t),
		o = [...n, ...r],
		i = {
			default: null,
			rendered: !0,
			renderHTML: null,
			parseHTML: null,
			keepOnSplit: !0,
			isRequired: !1,
		};
	return (
		t.forEach((s) => {
			const l = { name: s.name, options: s.options, storage: s.storage },
				a = fe(s, "addGlobalAttributes", l);
			if (!a) return;
			a().forEach((c) => {
				c.types.forEach((d) => {
					Object.entries(c.attributes).forEach(([f, p]) => {
						e.push({ type: d, name: f, attribute: B(B({}, i), p) });
					});
				});
			});
		}),
		o.forEach((s) => {
			const l = { name: s.name, options: s.options, storage: s.storage },
				a = fe(s, "addAttributes", l);
			if (!a) return;
			const u = a();
			Object.entries(u).forEach(([c, d]) => {
				const f = B(B({}, i), d);
				typeof (f == null ? void 0 : f.default) == "function" &&
					(f.default = f.default()),
					f != null &&
						f.isRequired &&
						(f == null ? void 0 : f.default) === void 0 &&
						delete f.default,
					e.push({ type: s.name, name: c, attribute: f });
			});
		}),
		e
	);
}
function Ht(t, e) {
	if (typeof t == "string") {
		if (!e.nodes[t])
			throw Error(
				`There is no node type named '${t}'. Maybe you forgot to add the extension?`
			);
		return e.nodes[t];
	}
	return t;
}
function et(...t) {
	return t
		.filter((e) => !!e)
		.reduce((e, n) => {
			const r = B({}, e);
			return (
				Object.entries(n).forEach(([o, i]) => {
					if (!r[o]) {
						r[o] = i;
						return;
					}
					if (o === "class") {
						const l = i ? i.split(" ") : [],
							a = r[o] ? r[o].split(" ") : [],
							u = l.filter((c) => !a.includes(c));
						r[o] = [...a, ...u].join(" ");
					} else
						o === "style"
							? (r[o] = [r[o], i].join("; "))
							: (r[o] = i);
				}),
				r
			);
		}, {});
}
function Qd(t, e) {
	return e
		.filter((n) => n.attribute.rendered)
		.map((n) =>
			n.attribute.renderHTML
				? n.attribute.renderHTML(t.attrs) || {}
				: { [n.name]: t.attrs[n.name] }
		)
		.reduce((n, r) => et(n, r), {});
}
function u2(t) {
	return typeof t == "function";
}
function Be(t, e = void 0, ...n) {
	return u2(t) ? (e ? t.bind(e)(...n) : t(...n)) : t;
}
function GT(t = {}) {
	return Object.keys(t).length === 0 && t.constructor === Object;
}
function YT(t) {
	return typeof t != "string"
		? t
		: t.match(/^[+-]?(?:\d*\.)?\d+$/)
		? Number(t)
		: t === "true"
		? !0
		: t === "false"
		? !1
		: t;
}
function kg(t, e) {
	return t.style
		? t
		: ge(B({}, t), {
				getAttrs: (n) => {
					const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
					if (r === !1) return !1;
					const o = e.reduce((i, s) => {
						const l = s.attribute.parseHTML
							? s.attribute.parseHTML(n)
							: YT(n.getAttribute(s.name));
						return l == null ? i : ge(B({}, i), { [s.name]: l });
					}, {});
					return B(B({}, r), o);
				},
		  });
}
function Sg(t) {
	return Object.fromEntries(
		Object.entries(t).filter(([e, n]) =>
			e === "attrs" && GT(n) ? !1 : n != null
		)
	);
}
function QT(t, e) {
	var n;
	const r = a2(t),
		{ nodeExtensions: o, markExtensions: i } = Gu(t),
		s =
			(n = o.find((u) => fe(u, "topNode"))) === null || n === void 0
				? void 0
				: n.name,
		l = Object.fromEntries(
			o.map((u) => {
				const c = r.filter((w) => w.type === u.name),
					d = {
						name: u.name,
						options: u.options,
						storage: u.storage,
						editor: e,
					},
					f = t.reduce((w, S) => {
						const E = fe(S, "extendNodeSchema", d);
						return B(B({}, w), E ? E(u) : {});
					}, {}),
					p = Sg(
						ge(B({}, f), {
							content: Be(fe(u, "content", d)),
							marks: Be(fe(u, "marks", d)),
							group: Be(fe(u, "group", d)),
							inline: Be(fe(u, "inline", d)),
							atom: Be(fe(u, "atom", d)),
							selectable: Be(fe(u, "selectable", d)),
							draggable: Be(fe(u, "draggable", d)),
							code: Be(fe(u, "code", d)),
							defining: Be(fe(u, "defining", d)),
							isolating: Be(fe(u, "isolating", d)),
							attrs: Object.fromEntries(
								c.map((w) => {
									var S;
									return [
										w.name,
										{
											default:
												(S =
													w == null
														? void 0
														: w.attribute) ===
													null || S === void 0
													? void 0
													: S.default,
										},
									];
								})
							),
						})
					),
					m = Be(fe(u, "parseHTML", d));
				m && (p.parseDOM = m.map((w) => kg(w, c)));
				const y = fe(u, "renderHTML", d);
				y &&
					(p.toDOM = (w) => y({ node: w, HTMLAttributes: Qd(w, c) }));
				const v = fe(u, "renderText", d);
				return v && (p.toText = v), [u.name, p];
			})
		),
		a = Object.fromEntries(
			i.map((u) => {
				const c = r.filter((v) => v.type === u.name),
					d = {
						name: u.name,
						options: u.options,
						storage: u.storage,
						editor: e,
					},
					f = t.reduce((v, w) => {
						const S = fe(w, "extendMarkSchema", d);
						return B(B({}, v), S ? S(u) : {});
					}, {}),
					p = Sg(
						ge(B({}, f), {
							inclusive: Be(fe(u, "inclusive", d)),
							excludes: Be(fe(u, "excludes", d)),
							group: Be(fe(u, "group", d)),
							spanning: Be(fe(u, "spanning", d)),
							code: Be(fe(u, "code", d)),
							attrs: Object.fromEntries(
								c.map((v) => {
									var w;
									return [
										v.name,
										{
											default:
												(w =
													v == null
														? void 0
														: v.attribute) ===
													null || w === void 0
													? void 0
													: w.default,
										},
									];
								})
							),
						})
					),
					m = Be(fe(u, "parseHTML", d));
				m && (p.parseDOM = m.map((v) => kg(v, c)));
				const y = fe(u, "renderHTML", d);
				return (
					y &&
						(p.toDOM = (v) =>
							y({ mark: v, HTMLAttributes: Qd(v, c) })),
					[u.name, p]
				);
			})
		);
	return new aM({ topNode: s, nodes: l, marks: a });
}
function Fc(t, e) {
	return e.nodes[t] || e.marks[t] || null;
}
function _g(t, e) {
	return Array.isArray(e)
		? e.some((n) => (typeof n == "string" ? n : n.name) === t.name)
		: e;
}
const XT = (t, e = 500) => {
	let n = "";
	const r = t.parentOffset;
	return (
		t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, l) => {
			var a, u;
			const c =
				((u = (a = o.type.spec).toText) === null || u === void 0
					? void 0
					: u.call(a, { node: o, pos: i, parent: s, index: l })) ||
				o.textContent ||
				"%leaf%";
			n += c.slice(0, Math.max(0, r - i));
		}),
		n
	);
};
function Mh(t) {
	return Object.prototype.toString.call(t) === "[object RegExp]";
}
class ol {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const ZT = (t, e) => {
	if (Mh(e)) return e.exec(t);
	const n = e(t);
	if (!n) return null;
	const r = [n.text];
	return (
		(r.index = n.index),
		(r.input = t),
		(r.data = n.data),
		n.replaceWith &&
			(n.text.includes(n.replaceWith) ||
				console.warn(
					'[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
				),
			r.push(n.replaceWith)),
		r
	);
};
function Vc(t) {
	var e;
	const { editor: n, from: r, to: o, text: i, rules: s, plugin: l } = t,
		{ view: a } = n;
	if (a.composing) return !1;
	const u = a.state.doc.resolve(r);
	if (
		u.parent.type.spec.code ||
		(!((e = u.nodeBefore || u.nodeAfter) === null || e === void 0) &&
			e.marks.find((f) => f.type.spec.code))
	)
		return !1;
	let c = !1;
	const d = XT(u) + i;
	return (
		s.forEach((f) => {
			if (c) return;
			const p = ZT(d, f.find);
			if (!p) return;
			const m = a.state.tr,
				y = qu({ state: a.state, transaction: m }),
				v = { from: r - (p[0].length - i.length), to: o },
				{
					commands: w,
					chain: S,
					can: E,
				} = new Ju({ editor: n, state: y });
			f.handler({
				state: y,
				range: v,
				match: p,
				commands: w,
				chain: S,
				can: E,
			}) === null ||
				!m.steps.length ||
				(m.setMeta(l, { transform: m, from: r, to: o, text: i }),
				a.dispatch(m),
				(c = !0));
		}),
		c
	);
}
function e4(t) {
	const { editor: e, rules: n } = t,
		r = new kt({
			state: {
				init() {
					return null;
				},
				apply(o, i) {
					const s = o.getMeta(r);
					return s || (o.selectionSet || o.docChanged ? null : i);
				},
			},
			props: {
				handleTextInput(o, i, s, l) {
					return Vc({
						editor: e,
						from: i,
						to: s,
						text: l,
						rules: n,
						plugin: r,
					});
				},
				handleDOMEvents: {
					compositionend: (o) => (
						setTimeout(() => {
							const { $cursor: i } = o.state.selection;
							i &&
								Vc({
									editor: e,
									from: i.pos,
									to: i.pos,
									text: "",
									rules: n,
									plugin: r,
								});
						}),
						!1
					),
				},
				handleKeyDown(o, i) {
					if (i.key !== "Enter") return !1;
					const { $cursor: s } = o.state.selection;
					return s
						? Vc({
								editor: e,
								from: s.pos,
								to: s.pos,
								text: `
`,
								rules: n,
								plugin: r,
						  })
						: !1;
				},
			},
			isInputRules: !0,
		});
	return r;
}
function t4(t) {
	return typeof t == "number";
}
class n4 {
	constructor(e) {
		(this.find = e.find), (this.handler = e.handler);
	}
}
const r4 = (t, e, n) => {
	if (Mh(e)) return [...t.matchAll(e)];
	const r = e(t, n);
	return r
		? r.map((o) => {
				const i = [o.text];
				return (
					(i.index = o.index),
					(i.input = t),
					(i.data = o.data),
					o.replaceWith &&
						(o.text.includes(o.replaceWith) ||
							console.warn(
								'[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
							),
						i.push(o.replaceWith)),
					i
				);
		  })
		: [];
};
function o4(t) {
	const {
			editor: e,
			state: n,
			from: r,
			to: o,
			rule: i,
			pasteEvent: s,
			dropEvent: l,
		} = t,
		{ commands: a, chain: u, can: c } = new Ju({ editor: e, state: n }),
		d = [];
	return (
		n.doc.nodesBetween(r, o, (p, m) => {
			if (!p.isTextblock || p.type.spec.code) return;
			const y = Math.max(r, m),
				v = Math.min(o, m + p.content.size),
				w = p.textBetween(y - m, v - m, void 0, "");
			r4(w, i.find, s).forEach((E) => {
				if (E.index === void 0) return;
				const h = y + E.index + 1,
					b = h + E[0].length,
					g = { from: n.tr.mapping.map(h), to: n.tr.mapping.map(b) },
					x = i.handler({
						state: n,
						range: g,
						match: E,
						commands: a,
						chain: u,
						can: c,
						pasteEvent: s,
						dropEvent: l,
					});
				d.push(x);
			});
		}),
		d.every((p) => p !== null)
	);
}
function i4(t) {
	const { editor: e, rules: n } = t;
	let r = null,
		o = !1,
		i = !1,
		s = new ClipboardEvent("paste"),
		l = new DragEvent("drop");
	return n.map(
		(u) =>
			new kt({
				view(c) {
					const d = (f) => {
						var p;
						r =
							!(
								(p = c.dom.parentElement) === null ||
								p === void 0
							) && p.contains(f.target)
								? c.dom.parentElement
								: null;
					};
					return (
						window.addEventListener("dragstart", d),
						{
							destroy() {
								window.removeEventListener("dragstart", d);
							},
						}
					);
				},
				props: {
					handleDOMEvents: {
						drop: (c, d) => (
							(i = r === c.dom.parentElement), (l = d), !1
						),
						paste: (c, d) => {
							var f;
							const p =
								(f = d.clipboardData) === null || f === void 0
									? void 0
									: f.getData("text/html");
							return (
								(s = d),
								(o = !!(
									p != null && p.includes("data-pm-slice")
								)),
								!1
							);
						},
					},
				},
				appendTransaction: (c, d, f) => {
					const p = c[0],
						m = p.getMeta("uiEvent") === "paste" && !o,
						y = p.getMeta("uiEvent") === "drop" && !i;
					if (!m && !y) return;
					const v = d.doc.content.findDiffStart(f.doc.content),
						w = d.doc.content.findDiffEnd(f.doc.content);
					if (!t4(v) || !w || v === w.b) return;
					const S = f.tr,
						E = qu({ state: f, transaction: S });
					if (
						!(
							!o4({
								editor: e,
								state: E,
								from: Math.max(v - 1, 0),
								to: w.b - 1,
								rule: u,
								pasteEvent: s,
								dropEvent: l,
							}) || !S.steps.length
						)
					)
						return (
							(l = new DragEvent("drop")),
							(s = new ClipboardEvent("paste")),
							S
						);
				},
			})
	);
}
function s4(t) {
	const e = t.filter((n, r) => t.indexOf(n) !== r);
	return [...new Set(e)];
}
class ui {
	constructor(e, n) {
		(this.splittableMarks = []),
			(this.editor = n),
			(this.extensions = ui.resolve(e)),
			(this.schema = QT(this.extensions, n)),
			this.extensions.forEach((r) => {
				var o;
				this.editor.extensionStorage[r.name] = r.storage;
				const i = {
					name: r.name,
					options: r.options,
					storage: r.storage,
					editor: this.editor,
					type: Fc(r.name, this.schema),
				};
				r.type === "mark" &&
					(!(
						(o = Be(fe(r, "keepOnSplit", i))) !== null &&
						o !== void 0
					) ||
						o) &&
					this.splittableMarks.push(r.name);
				const s = fe(r, "onBeforeCreate", i);
				s && this.editor.on("beforeCreate", s);
				const l = fe(r, "onCreate", i);
				l && this.editor.on("create", l);
				const a = fe(r, "onUpdate", i);
				a && this.editor.on("update", a);
				const u = fe(r, "onSelectionUpdate", i);
				u && this.editor.on("selectionUpdate", u);
				const c = fe(r, "onTransaction", i);
				c && this.editor.on("transaction", c);
				const d = fe(r, "onFocus", i);
				d && this.editor.on("focus", d);
				const f = fe(r, "onBlur", i);
				f && this.editor.on("blur", f);
				const p = fe(r, "onDestroy", i);
				p && this.editor.on("destroy", p);
			});
	}
	static resolve(e) {
		const n = ui.sort(ui.flatten(e)),
			r = s4(n.map((o) => o.name));
		return (
			r.length &&
				console.warn(
					`[tiptap warn]: Duplicate extension names found: [${r
						.map((o) => `'${o}'`)
						.join(", ")}]. This can lead to issues.`
				),
			n
		);
	}
	static flatten(e) {
		return e
			.map((n) => {
				const r = {
						name: n.name,
						options: n.options,
						storage: n.storage,
					},
					o = fe(n, "addExtensions", r);
				return o ? [n, ...this.flatten(o())] : n;
			})
			.flat(10);
	}
	static sort(e) {
		return e.sort((r, o) => {
			const i = fe(r, "priority") || 100,
				s = fe(o, "priority") || 100;
			return i > s ? -1 : i < s ? 1 : 0;
		});
	}
	get commands() {
		return this.extensions.reduce((e, n) => {
			const r = {
					name: n.name,
					options: n.options,
					storage: n.storage,
					editor: this.editor,
					type: Fc(n.name, this.schema),
				},
				o = fe(n, "addCommands", r);
			return o ? B(B({}, e), o()) : e;
		}, {});
	}
	get plugins() {
		const { editor: e } = this,
			n = ui.sort([...this.extensions].reverse()),
			r = [],
			o = [],
			i = n
				.map((s) => {
					const l = {
							name: s.name,
							options: s.options,
							storage: s.storage,
							editor: e,
							type: Fc(s.name, this.schema),
						},
						a = [],
						u = fe(s, "addKeyboardShortcuts", l);
					let c = {};
					if (
						(s.type === "mark" &&
							s.config.exitable &&
							(c.ArrowRight = () =>
								vn.handleExit({ editor: e, mark: s })),
						u)
					) {
						const y = Object.fromEntries(
							Object.entries(u()).map(([v, w]) => [
								v,
								() => w({ editor: e }),
							])
						);
						c = B(B({}, c), y);
					}
					const d = kT(c);
					a.push(d);
					const f = fe(s, "addInputRules", l);
					_g(s, e.options.enableInputRules) && f && r.push(...f());
					const p = fe(s, "addPasteRules", l);
					_g(s, e.options.enablePasteRules) && p && o.push(...p());
					const m = fe(s, "addProseMirrorPlugins", l);
					if (m) {
						const y = m();
						a.push(...y);
					}
					return a;
				})
				.flat();
		return [
			e4({ editor: e, rules: r }),
			...i4({ editor: e, rules: o }),
			...i,
		];
	}
	get attributes() {
		return a2(this.extensions);
	}
	get nodeViews() {
		const { editor: e } = this,
			{ nodeExtensions: n } = Gu(this.extensions);
		return Object.fromEntries(
			n
				.filter((r) => !!fe(r, "addNodeView"))
				.map((r) => {
					const o = this.attributes.filter((a) => a.type === r.name),
						i = {
							name: r.name,
							options: r.options,
							storage: r.storage,
							editor: e,
							type: Ht(r.name, this.schema),
						},
						s = fe(r, "addNodeView", i);
					if (!s) return [];
					const l = (a, u, c, d) => {
						const f = Qd(a, o);
						return s()({
							editor: e,
							node: a,
							getPos: c,
							decorations: d,
							HTMLAttributes: f,
							extension: r,
						});
					};
					return [r.name, l];
				})
		);
	}
}
function l4(t) {
	return Object.prototype.toString.call(t).slice(8, -1);
}
function Wc(t) {
	return l4(t) !== "Object"
		? !1
		: t.constructor === Object &&
				Object.getPrototypeOf(t) === Object.prototype;
}
function Yu(t, e) {
	const n = B({}, t);
	return (
		Wc(t) &&
			Wc(e) &&
			Object.keys(e).forEach((r) => {
				Wc(e[r])
					? r in t
						? (n[r] = Yu(t[r], e[r]))
						: Object.assign(n, { [r]: e[r] })
					: Object.assign(n, { [r]: e[r] });
			}),
		n
	);
}
class Nt {
	constructor(e = {}) {
		(this.type = "extension"),
			(this.name = "extension"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = B(B({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Be(
					fe(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Be(
					fe(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new Nt(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Yu(this.options, e)),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new Nt(B(B({}, this.config), e));
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Be(fe(n, "addOptions", { name: n.name }))),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
}
function c2(t, e, n) {
	const { from: r, to: o } = e,
		{
			blockSeparator: i = `

`,
			textSerializers: s = {},
		} = n || {};
	let l = "",
		a = !0;
	return (
		t.nodesBetween(r, o, (u, c, d, f) => {
			var p;
			const m = s == null ? void 0 : s[u.type.name];
			m
				? (u.isBlock && !a && ((l += i), (a = !0)),
				  d &&
						(l += m({
							node: u,
							pos: c,
							parent: d,
							index: f,
							range: e,
						})))
				: u.isText
				? ((l +=
						(p = u == null ? void 0 : u.text) === null ||
						p === void 0
							? void 0
							: p.slice(Math.max(r, c) - c, o - c)),
				  (a = !1))
				: u.isBlock && !a && ((l += i), (a = !0));
		}),
		l
	);
}
function d2(t) {
	return Object.fromEntries(
		Object.entries(t.nodes)
			.filter(([, e]) => e.spec.toText)
			.map(([e, n]) => [e, n.spec.toText])
	);
}
const a4 = Nt.create({
		name: "clipboardTextSerializer",
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("clipboardTextSerializer"),
					props: {
						clipboardTextSerializer: () => {
							const { editor: t } = this,
								{ state: e, schema: n } = t,
								{ doc: r, selection: o } = e,
								{ ranges: i } = o,
								s = Math.min(...i.map((c) => c.$from.pos)),
								l = Math.max(...i.map((c) => c.$to.pos)),
								a = d2(n);
							return c2(
								r,
								{ from: s, to: l },
								{ textSerializers: a }
							);
						},
					},
				}),
			];
		},
	}),
	u4 =
		() =>
		({ editor: t, view: e }) => (
			requestAnimationFrame(() => {
				var n;
				t.isDestroyed ||
					(e.dom.blur(),
					(n = window == null ? void 0 : window.getSelection()) ===
						null ||
						n === void 0 ||
						n.removeAllRanges());
			}),
			!0
		),
	c4 =
		(t = !1) =>
		({ commands: e }) =>
			e.setContent("", t),
	d4 =
		() =>
		({ state: t, tr: e, dispatch: n }) => {
			const { selection: r } = e,
				{ ranges: o } = r;
			return (
				n &&
					o.forEach(({ $from: i, $to: s }) => {
						t.doc.nodesBetween(i.pos, s.pos, (l, a) => {
							if (l.type.isText) return;
							const { doc: u, mapping: c } = e,
								d = u.resolve(c.map(a)),
								f = u.resolve(c.map(a + l.nodeSize)),
								p = d.blockRange(f);
							if (!p) return;
							const m = Hi(p);
							if (l.type.isTextblock) {
								const { defaultType: y } =
									d.parent.contentMatchAt(d.index());
								e.setNodeMarkup(p.start, y);
							}
							(m || m === 0) && e.lift(p, m);
						});
					}),
				!0
			);
		},
	f4 = (t) => (e) => t(e),
	h4 =
		() =>
		({ state: t, dispatch: e }) =>
			DT(t, e),
	p4 =
		(t, e) =>
		({ editor: n, tr: r }) => {
			const { state: o } = n,
				i = o.doc.slice(t.from, t.to);
			r.deleteRange(t.from, t.to);
			const s = r.mapping.map(e);
			return (
				r.insert(s, i.content),
				r.setSelection(new Se(r.doc.resolve(s - 1))),
				!0
			);
		},
	m4 =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				r = n.$anchor.node();
			if (r.content.size > 0) return !1;
			const o = t.selection.$anchor;
			for (let i = o.depth; i > 0; i -= 1)
				if (o.node(i).type === r.type) {
					if (e) {
						const l = o.before(i),
							a = o.after(i);
						t.delete(l, a).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	g4 =
		(t) =>
		({ tr: e, state: n, dispatch: r }) => {
			const o = Ht(t, n.schema),
				i = e.selection.$anchor;
			for (let s = i.depth; s > 0; s -= 1)
				if (i.node(s).type === o) {
					if (r) {
						const a = i.before(s),
							u = i.after(s);
						e.delete(a, u).scrollIntoView();
					}
					return !0;
				}
			return !1;
		},
	y4 =
		(t) =>
		({ tr: e, dispatch: n }) => {
			const { from: r, to: o } = t;
			return n && e.delete(r, o), !0;
		},
	v4 =
		() =>
		({ state: t, dispatch: e }) =>
			ST(t, e),
	b4 =
		() =>
		({ commands: t }) =>
			t.keyboardShortcut("Enter"),
	w4 =
		() =>
		({ state: t, dispatch: e }) =>
			NT(t, e);
function Ia(t, e, n = { strict: !0 }) {
	const r = Object.keys(e);
	return r.length
		? r.every((o) =>
				n.strict
					? e[o] === t[o]
					: Mh(e[o])
					? e[o].test(t[o])
					: e[o] === t[o]
		  )
		: !0;
}
function Xd(t, e, n = {}) {
	return t.find((r) => r.type === e && Ia(r.attrs, n));
}
function x4(t, e, n = {}) {
	return !!Xd(t, e, n);
}
function Eh(t, e, n = {}) {
	if (!t || !e) return;
	let r = t.parent.childAfter(t.parentOffset);
	if (
		(t.parentOffset === r.offset &&
			r.offset !== 0 &&
			(r = t.parent.childBefore(t.parentOffset)),
		!r.node)
	)
		return;
	const o = Xd([...r.node.marks], e, n);
	if (!o) return;
	let i = r.index,
		s = t.start() + r.offset,
		l = i + 1,
		a = s + r.node.nodeSize;
	for (
		Xd([...r.node.marks], e, n);
		i > 0 && o.isInSet(t.parent.child(i - 1).marks);

	)
		(i -= 1), (s -= t.parent.child(i).nodeSize);
	for (; l < t.parent.childCount && x4([...t.parent.child(l).marks], e, n); )
		(a += t.parent.child(l).nodeSize), (l += 1);
	return { from: s, to: a };
}
function po(t, e) {
	if (typeof t == "string") {
		if (!e.marks[t])
			throw Error(
				`There is no mark type named '${t}'. Maybe you forgot to add the extension?`
			);
		return e.marks[t];
	}
	return t;
}
const k4 =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			const i = po(t, r.schema),
				{ doc: s, selection: l } = n,
				{ $from: a, from: u, to: c } = l;
			if (o) {
				const d = Eh(a, i, e);
				if (d && d.from <= u && d.to >= c) {
					const f = Se.create(s, d.from, d.to);
					n.setSelection(f);
				}
			}
			return !0;
		},
	S4 = (t) => (e) => {
		const n = typeof t == "function" ? t(e) : t;
		for (let r = 0; r < n.length; r += 1) if (n[r](e)) return !0;
		return !1;
	};
function Th(t) {
	return t instanceof Se;
}
function kr(t = 0, e = 0, n = 0) {
	return Math.min(Math.max(t, e), n);
}
function f2(t, e = null) {
	if (!e) return null;
	const n = Me.atStart(t),
		r = Me.atEnd(t);
	if (e === "start" || e === !0) return n;
	if (e === "end") return r;
	const o = n.from,
		i = r.to;
	return e === "all"
		? Se.create(t, kr(0, o, i), kr(t.content.size, o, i))
		: Se.create(t, kr(e, o, i), kr(e, o, i));
}
function Ah() {
	return (
		[
			"iPad Simulator",
			"iPhone Simulator",
			"iPod Simulator",
			"iPad",
			"iPhone",
			"iPod",
		].includes(navigator.platform) ||
		(navigator.userAgent.includes("Mac") && "ontouchend" in document)
	);
}
const _4 =
		(t = null, e = {}) =>
		({ editor: n, view: r, tr: o, dispatch: i }) => {
			e = B({ scrollIntoView: !0 }, e);
			const s = () => {
				Ah() && r.dom.focus(),
					requestAnimationFrame(() => {
						n.isDestroyed ||
							(r.focus(),
							e != null &&
								e.scrollIntoView &&
								n.commands.scrollIntoView());
					});
			};
			if ((r.hasFocus() && t === null) || t === !1) return !0;
			if (i && t === null && !Th(n.state.selection)) return s(), !0;
			const l = f2(o.doc, t) || n.state.selection,
				a = n.state.selection.eq(l);
			return (
				i &&
					(a || o.setSelection(l),
					a && o.storedMarks && o.setStoredMarks(o.storedMarks),
					s()),
				!0
			);
		},
	C4 = (t, e) => (n) => t.every((r, o) => e(r, ge(B({}, n), { index: o }))),
	M4 =
		(t, e) =>
		({ tr: n, commands: r }) =>
			r.insertContentAt(
				{ from: n.selection.from, to: n.selection.to },
				t,
				e
			),
	h2 = (t) => {
		const e = t.childNodes;
		for (let n = e.length - 1; n >= 0; n -= 1) {
			const r = e[n];
			r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue)
				? t.removeChild(r)
				: r.nodeType === 1 && h2(r);
		}
		return t;
	};
function Cg(t) {
	const e = `<body>${t}</body>`,
		n = new window.DOMParser().parseFromString(e, "text/html").body;
	return h2(n);
}
function Na(t, e, n) {
	if (
		((n = B({ slice: !0, parseOptions: {} }, n)),
		typeof t == "object" && t !== null)
	)
		try {
			return Array.isArray(t) && t.length > 0
				? J.fromArray(t.map((r) => e.nodeFromJSON(r)))
				: e.nodeFromJSON(t);
		} catch (r) {
			return (
				console.warn(
					"[tiptap warn]: Invalid content.",
					"Passed value:",
					t,
					"Error:",
					r
				),
				Na("", e, n)
			);
		}
	if (typeof t == "string") {
		const r = zu.fromSchema(e);
		return n.slice
			? r.parseSlice(Cg(t), n.parseOptions).content
			: r.parse(Cg(t), n.parseOptions);
	}
	return Na("", e, n);
}
function E4(t, e, n) {
	const r = t.steps.length - 1;
	if (r < e) return;
	const o = t.steps[r];
	if (!(o instanceof jt || o instanceof $t)) return;
	const i = t.mapping.maps[r];
	let s = 0;
	i.forEach((l, a, u, c) => {
		s === 0 && (s = c);
	}),
		t.setSelection(Me.near(t.doc.resolve(s), n));
}
const T4 = (t) => t.toString().startsWith("<"),
	A4 =
		(t, e, n) =>
		({ tr: r, dispatch: o, editor: i }) => {
			if (o) {
				n = B({ parseOptions: {}, updateSelection: !0 }, n);
				const s = Na(e, i.schema, {
					parseOptions: B(
						{ preserveWhitespace: "full" },
						n.parseOptions
					),
				});
				if (s.toString() === "<>") return !0;
				let { from: l, to: a } =
						typeof t == "number"
							? { from: t, to: t }
							: { from: t.from, to: t.to },
					u = !0,
					c = !0;
				if (
					((T4(s) ? s : [s]).forEach((f) => {
						f.check(),
							(u = u ? f.isText && f.marks.length === 0 : !1),
							(c = c ? f.isBlock : !1);
					}),
					l === a && c)
				) {
					const { parent: f } = r.doc.resolve(l);
					f.isTextblock &&
						!f.type.spec.code &&
						!f.childCount &&
						((l -= 1), (a += 1));
				}
				u
					? Array.isArray(e)
						? r.insertText(
								e.map((f) => f.text || "").join(""),
								l,
								a
						  )
						: typeof e == "object" && e && e.text
						? r.insertText(e.text, l, a)
						: r.insertText(e, l, a)
					: r.replaceWith(l, a, s),
					n.updateSelection && E4(r, r.steps.length - 1, -1);
			}
			return !0;
		},
	O4 =
		() =>
		({ state: t, dispatch: e }) =>
			OT(t, e),
	R4 =
		() =>
		({ state: t, dispatch: e }) =>
			RT(t, e),
	P4 =
		() =>
		({ state: t, dispatch: e }) =>
			_T(t, e),
	I4 =
		() =>
		({ state: t, dispatch: e }) =>
			TT(t, e),
	N4 =
		() =>
		({ tr: t, state: e, dispatch: n }) => {
			try {
				const r = Hu(e.doc, e.selection.$from.pos, -1);
				return r == null ? !1 : (t.join(r, 2), n && n(t), !0);
			} catch (r) {
				return !1;
			}
		},
	D4 =
		() =>
		({ state: t, dispatch: e, tr: n }) => {
			try {
				const r = Hu(t.doc, t.selection.$from.pos, 1);
				return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
			} catch (r) {
				return !1;
			}
		},
	j4 =
		() =>
		({ state: t, dispatch: e }) =>
			CT(t, e),
	L4 =
		() =>
		({ state: t, dispatch: e }) =>
			MT(t, e);
function Oh() {
	return typeof navigator != "undefined"
		? /Mac/.test(navigator.platform)
		: !1;
}
function $4(t) {
	const e = t.split(/-(?!$)/);
	let n = e[e.length - 1];
	n === "Space" && (n = " ");
	let r, o, i, s;
	for (let l = 0; l < e.length - 1; l += 1) {
		const a = e[l];
		if (/^(cmd|meta|m)$/i.test(a)) s = !0;
		else if (/^a(lt)?$/i.test(a)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(a)) o = !0;
		else if (/^s(hift)?$/i.test(a)) i = !0;
		else if (/^mod$/i.test(a)) Ah() || Oh() ? (s = !0) : (o = !0);
		else throw new Error(`Unrecognized modifier name: ${a}`);
	}
	return (
		r && (n = `Alt-${n}`),
		o && (n = `Ctrl-${n}`),
		s && (n = `Meta-${n}`),
		i && (n = `Shift-${n}`),
		n
	);
}
const B4 =
	(t) =>
	({ editor: e, view: n, tr: r, dispatch: o }) => {
		const i = $4(t).split(/-(?!$)/),
			s = i.find((u) => !["Alt", "Ctrl", "Meta", "Shift"].includes(u)),
			l = new KeyboardEvent("keydown", {
				key: s === "Space" ? " " : s,
				altKey: i.includes("Alt"),
				ctrlKey: i.includes("Ctrl"),
				metaKey: i.includes("Meta"),
				shiftKey: i.includes("Shift"),
				bubbles: !0,
				cancelable: !0,
			}),
			a = e.captureTransaction(() => {
				n.someProp("handleKeyDown", (u) => u(n, l));
			});
		return (
			a == null ||
				a.steps.forEach((u) => {
					const c = u.map(r.mapping);
					c && o && r.maybeStep(c);
				}),
			!0
		);
	};
function zs(t, e, n = {}) {
	const { from: r, to: o, empty: i } = t.selection,
		s = e ? Ht(e, t.schema) : null,
		l = [];
	t.doc.nodesBetween(r, o, (d, f) => {
		if (d.isText) return;
		const p = Math.max(r, f),
			m = Math.min(o, f + d.nodeSize);
		l.push({ node: d, from: p, to: m });
	});
	const a = o - r,
		u = l
			.filter((d) => (s ? s.name === d.node.type.name : !0))
			.filter((d) => Ia(d.node.attrs, n, { strict: !1 }));
	return i ? !!u.length : u.reduce((d, f) => d + f.to - f.from, 0) >= a;
}
const z4 =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = Ht(t, n.schema);
			return zs(n, o, e) ? PT(n, r) : !1;
		},
	H4 =
		() =>
		({ state: t, dispatch: e }) =>
			jT(t, e),
	F4 =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = Ht(t, e.schema);
			return WT(r)(e, n);
		},
	V4 =
		() =>
		({ state: t, dispatch: e }) =>
			IT(t, e);
function Qu(t, e) {
	return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Mg(t, e) {
	const n = typeof e == "string" ? [e] : e;
	return Object.keys(t).reduce(
		(r, o) => (n.includes(o) || (r[o] = t[o]), r),
		{}
	);
}
const W4 =
		(t, e) =>
		({ tr: n, state: r, dispatch: o }) => {
			let i = null,
				s = null;
			const l = Qu(typeof t == "string" ? t : t.name, r.schema);
			return l
				? (l === "node" && (i = Ht(t, r.schema)),
				  l === "mark" && (s = po(t, r.schema)),
				  o &&
						n.selection.ranges.forEach((a) => {
							r.doc.nodesBetween(
								a.$from.pos,
								a.$to.pos,
								(u, c) => {
									i &&
										i === u.type &&
										n.setNodeMarkup(
											c,
											void 0,
											Mg(u.attrs, e)
										),
										s &&
											u.marks.length &&
											u.marks.forEach((d) => {
												s === d.type &&
													n.addMark(
														c,
														c + u.nodeSize,
														s.create(Mg(d.attrs, e))
													);
											});
								}
							);
						}),
				  !0)
				: !1;
		},
	U4 =
		() =>
		({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0),
	K4 =
		() =>
		({ tr: t, commands: e }) =>
			e.setTextSelection({ from: 0, to: t.doc.content.size }),
	q4 =
		() =>
		({ state: t, dispatch: e }) =>
			ET(t, e),
	J4 =
		() =>
		({ state: t, dispatch: e }) =>
			AT(t, e),
	G4 =
		() =>
		({ state: t, dispatch: e }) =>
			LT(t, e),
	Y4 =
		() =>
		({ state: t, dispatch: e }) =>
			zT(t, e),
	Q4 =
		() =>
		({ state: t, dispatch: e }) =>
			BT(t, e);
function p2(t, e, n = {}) {
	return Na(t, e, { slice: !1, parseOptions: n });
}
const X4 =
	(t, e = !1, n = {}) =>
	({ tr: r, editor: o, dispatch: i }) => {
		const { doc: s } = r,
			l = p2(t, o.schema, n);
		return (
			i &&
				r
					.replaceWith(0, s.content.size, l)
					.setMeta("preventUpdate", !e),
			!0
		);
	};
function il(t, e) {
	const n = po(e, t.schema),
		{ from: r, to: o, empty: i } = t.selection,
		s = [];
	i
		? (t.storedMarks && s.push(...t.storedMarks),
		  s.push(...t.selection.$head.marks()))
		: t.doc.nodesBetween(r, o, (a) => {
				s.push(...a.marks);
		  });
	const l = s.find((a) => a.type.name === n.name);
	return l ? B({}, l.attrs) : {};
}
function Z4(t, e) {
	const n = new fh(t);
	return (
		e.forEach((r) => {
			r.steps.forEach((o) => {
				n.step(o);
			});
		}),
		n
	);
}
function eA(t) {
	for (let e = 0; e < t.edgeCount; e += 1) {
		const { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
function tA(t, e, n) {
	const r = [];
	return (
		t.nodesBetween(e.from, e.to, (o, i) => {
			n(o) && r.push({ node: o, pos: i });
		}),
		r
	);
}
function m2(t, e) {
	for (let n = t.depth; n > 0; n -= 1) {
		const r = t.node(n);
		if (e(r))
			return {
				pos: n > 0 ? t.before(n) : 0,
				start: t.start(n),
				depth: n,
				node: r,
			};
	}
}
function Rh(t) {
	return (e) => m2(e.$from, t);
}
function nA(t, e) {
	const n = tr.fromSchema(e).serializeFragment(t),
		o = document.implementation.createHTMLDocument().createElement("div");
	return o.appendChild(n), o.innerHTML;
}
function rA(t, e) {
	const n = { from: 0, to: t.content.size };
	return c2(t, n, e);
}
function oA(t, e) {
	const n = Ht(e, t.schema),
		{ from: r, to: o } = t.selection,
		i = [];
	t.doc.nodesBetween(r, o, (l) => {
		i.push(l);
	});
	const s = i.reverse().find((l) => l.type.name === n.name);
	return s ? B({}, s.attrs) : {};
}
function g2(t, e) {
	const n = Qu(typeof e == "string" ? e : e.name, t.schema);
	return n === "node" ? oA(t, e) : n === "mark" ? il(t, e) : {};
}
function iA(t, e = JSON.stringify) {
	const n = {};
	return t.filter((r) => {
		const o = e(r);
		return Object.prototype.hasOwnProperty.call(n, o) ? !1 : (n[o] = !0);
	});
}
function sA(t) {
	const e = iA(t);
	return e.length === 1
		? e
		: e.filter(
				(n, r) =>
					!e
						.filter((i, s) => s !== r)
						.some(
							(i) =>
								n.oldRange.from >= i.oldRange.from &&
								n.oldRange.to <= i.oldRange.to &&
								n.newRange.from >= i.newRange.from &&
								n.newRange.to <= i.newRange.to
						)
		  );
}
function lA(t) {
	const { mapping: e, steps: n } = t,
		r = [];
	return (
		e.maps.forEach((o, i) => {
			const s = [];
			if (o.ranges.length)
				o.forEach((l, a) => {
					s.push({ from: l, to: a });
				});
			else {
				const { from: l, to: a } = n[i];
				if (l === void 0 || a === void 0) return;
				s.push({ from: l, to: a });
			}
			s.forEach(({ from: l, to: a }) => {
				const u = e.slice(i).map(l, -1),
					c = e.slice(i).map(a),
					d = e.invert().map(u, -1),
					f = e.invert().map(c);
				r.push({
					oldRange: { from: d, to: f },
					newRange: { from: u, to: c },
				});
			});
		}),
		sA(r)
	);
}
function Ph(t, e, n) {
	const r = [];
	return (
		t === e
			? n
					.resolve(t)
					.marks()
					.forEach((o) => {
						const i = n.resolve(t - 1),
							s = Eh(i, o.type);
						s && r.push(B({ mark: o }, s));
					})
			: n.nodesBetween(t, e, (o, i) => {
					!o ||
						(o == null ? void 0 : o.nodeSize) === void 0 ||
						r.push(
							...o.marks.map((s) => ({
								from: i,
								to: i + o.nodeSize,
								mark: s,
							}))
						);
			  }),
		r
	);
}
function Jl(t, e, n) {
	return Object.fromEntries(
		Object.entries(n).filter(([r]) => {
			const o = t.find((i) => i.type === e && i.name === r);
			return o ? o.attribute.keepOnSplit : !1;
		})
	);
}
function Zd(t, e, n = {}) {
	const { empty: r, ranges: o } = t.selection,
		i = e ? po(e, t.schema) : null;
	if (r)
		return !!(t.storedMarks || t.selection.$from.marks())
			.filter((d) => (i ? i.name === d.type.name : !0))
			.find((d) => Ia(d.attrs, n, { strict: !1 }));
	let s = 0;
	const l = [];
	if (
		(o.forEach(({ $from: d, $to: f }) => {
			const p = d.pos,
				m = f.pos;
			t.doc.nodesBetween(p, m, (y, v) => {
				if (!y.isText && !y.marks.length) return;
				const w = Math.max(p, v),
					S = Math.min(m, v + y.nodeSize),
					E = S - w;
				(s += E),
					l.push(
						...y.marks.map((h) => ({ mark: h, from: w, to: S }))
					);
			});
		}),
		s === 0)
	)
		return !1;
	const a = l
			.filter((d) => (i ? i.name === d.mark.type.name : !0))
			.filter((d) => Ia(d.mark.attrs, n, { strict: !1 }))
			.reduce((d, f) => d + f.to - f.from, 0),
		u = l
			.filter((d) =>
				i ? d.mark.type !== i && d.mark.type.excludes(i) : !0
			)
			.reduce((d, f) => d + f.to - f.from, 0);
	return (a > 0 ? a + u : a) >= s;
}
function aA(t, e, n = {}) {
	if (!e) return zs(t, null, n) || Zd(t, null, n);
	const r = Qu(e, t.schema);
	return r === "node" ? zs(t, e, n) : r === "mark" ? Zd(t, e, n) : !1;
}
function Eg(t, e) {
	const { nodeExtensions: n } = Gu(e),
		r = n.find((s) => s.name === t);
	if (!r) return !1;
	const o = { name: r.name, options: r.options, storage: r.storage },
		i = Be(fe(r, "group", o));
	return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function uA(t) {
	var e;
	const n =
			(e = t.type.createAndFill()) === null || e === void 0
				? void 0
				: e.toJSON(),
		r = t.toJSON();
	return JSON.stringify(n) === JSON.stringify(r);
}
function cA(t) {
	return t instanceof we;
}
function y2(t, e, n) {
	const o = t.state.doc.content.size,
		i = kr(e, 0, o),
		s = kr(n, 0, o),
		l = t.coordsAtPos(i),
		a = t.coordsAtPos(s, -1),
		u = Math.min(l.top, a.top),
		c = Math.max(l.bottom, a.bottom),
		d = Math.min(l.left, a.left),
		f = Math.max(l.right, a.right),
		p = f - d,
		m = c - u,
		w = {
			top: u,
			bottom: c,
			left: d,
			right: f,
			width: p,
			height: m,
			x: d,
			y: u,
		};
	return ge(B({}, w), { toJSON: () => w });
}
function dA(t, e, n) {
	var r;
	const { selection: o } = e;
	let i = null;
	if ((Th(o) && (i = o.$cursor), i)) {
		const l = (r = t.storedMarks) !== null && r !== void 0 ? r : i.marks();
		return !!n.isInSet(l) || !l.some((a) => a.type.excludes(n));
	}
	const { ranges: s } = o;
	return s.some(({ $from: l, $to: a }) => {
		let u =
			l.depth === 0
				? t.doc.inlineContent && t.doc.type.allowsMarkType(n)
				: !1;
		return (
			t.doc.nodesBetween(l.pos, a.pos, (c, d, f) => {
				if (u) return !1;
				if (c.isInline) {
					const p = !f || f.type.allowsMarkType(n),
						m =
							!!n.isInSet(c.marks) ||
							!c.marks.some((y) => y.type.excludes(n));
					u = p && m;
				}
				return !u;
			}),
			u
		);
	});
}
const fA =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			const { selection: i } = n,
				{ empty: s, ranges: l } = i,
				a = po(t, r.schema);
			if (o)
				if (s) {
					const u = il(r, a);
					n.addStoredMark(a.create(B(B({}, u), e)));
				} else
					l.forEach((u) => {
						const c = u.$from.pos,
							d = u.$to.pos;
						r.doc.nodesBetween(c, d, (f, p) => {
							const m = Math.max(p, c),
								y = Math.min(p + f.nodeSize, d);
							f.marks.find((w) => w.type === a)
								? f.marks.forEach((w) => {
										a === w.type &&
											n.addMark(
												m,
												y,
												a.create(B(B({}, w.attrs), e))
											);
								  })
								: n.addMark(m, y, a.create(e));
						});
					});
			return dA(r, n, a);
		},
	hA =
		(t, e) =>
		({ tr: n }) => (n.setMeta(t, e), !0),
	pA =
		(t, e = {}) =>
		({ state: n, dispatch: r, chain: o }) => {
			const i = Ht(t, n.schema);
			return i.isTextblock
				? o()
						.command(({ commands: s }) =>
							xg(i, e)(n) ? !0 : s.clearNodes()
						)
						.command(({ state: s }) => xg(i, e)(s, r))
						.run()
				: (console.warn(
						'[tiptap warn]: Currently "setNode()" only supports text block nodes.'
				  ),
				  !1);
		},
	mA =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					o = kr(t, 0, r.content.size),
					i = we.create(r, o);
				e.setSelection(i);
			}
			return !0;
		},
	gA =
		(t) =>
		({ tr: e, dispatch: n }) => {
			if (n) {
				const { doc: r } = e,
					{ from: o, to: i } =
						typeof t == "number" ? { from: t, to: t } : t,
					s = Se.atStart(r).from,
					l = Se.atEnd(r).to,
					a = kr(o, s, l),
					u = kr(i, s, l),
					c = Se.create(r, a, u);
				e.setSelection(c);
			}
			return !0;
		},
	yA =
		(t) =>
		({ state: e, dispatch: n }) => {
			const r = Ht(t, e.schema);
			return qT(r)(e, n);
		};
function Tg(t, e) {
	const n =
		t.storedMarks ||
		(t.selection.$to.parentOffset && t.selection.$from.marks());
	if (n) {
		const r = n.filter((o) =>
			e == null ? void 0 : e.includes(o.type.name)
		);
		t.tr.ensureMarks(r);
	}
}
const vA =
		({ keepMarks: t = !0 } = {}) =>
		({ tr: e, state: n, dispatch: r, editor: o }) => {
			const { selection: i, doc: s } = e,
				{ $from: l, $to: a } = i,
				u = o.extensionManager.attributes,
				c = Jl(u, l.node().type.name, l.node().attrs);
			if (i instanceof we && i.node.isBlock)
				return !l.parentOffset || !gi(s, l.pos)
					? !1
					: (r &&
							(t && Tg(n, o.extensionManager.splittableMarks),
							e.split(l.pos).scrollIntoView()),
					  !0);
			if (!l.parent.isBlock) return !1;
			if (r) {
				const d = a.parentOffset === a.parent.content.size;
				i instanceof Se && e.deleteSelection();
				const f =
					l.depth === 0
						? void 0
						: eA(l.node(-1).contentMatchAt(l.indexAfter(-1)));
				let p = d && f ? [{ type: f, attrs: c }] : void 0,
					m = gi(e.doc, e.mapping.map(l.pos), 1, p);
				if (
					(!p &&
						!m &&
						gi(
							e.doc,
							e.mapping.map(l.pos),
							1,
							f ? [{ type: f }] : void 0
						) &&
						((m = !0), (p = f ? [{ type: f, attrs: c }] : void 0)),
					m &&
						(e.split(e.mapping.map(l.pos), 1, p),
						f && !d && !l.parentOffset && l.parent.type !== f))
				) {
					const y = e.mapping.map(l.before()),
						v = e.doc.resolve(y);
					l.node(-1).canReplaceWith(v.index(), v.index() + 1, f) &&
						e.setNodeMarkup(e.mapping.map(l.before()), f);
				}
				t && Tg(n, o.extensionManager.splittableMarks),
					e.scrollIntoView();
			}
			return !0;
		},
	bA =
		(t) =>
		({ tr: e, state: n, dispatch: r, editor: o }) => {
			var i;
			const s = Ht(t, n.schema),
				{ $from: l, $to: a } = n.selection,
				u = n.selection.node;
			if ((u && u.isBlock) || l.depth < 2 || !l.sameParent(a)) return !1;
			const c = l.node(-1);
			if (c.type !== s) return !1;
			const d = o.extensionManager.attributes;
			if (
				l.parent.content.size === 0 &&
				l.node(-1).childCount === l.indexAfter(-1)
			) {
				if (
					l.depth === 2 ||
					l.node(-3).type !== s ||
					l.index(-2) !== l.node(-2).childCount - 1
				)
					return !1;
				if (r) {
					let v = J.empty;
					const w = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
					for (let x = l.depth - w; x >= l.depth - 3; x -= 1)
						v = J.from(l.node(x).copy(v));
					const S =
							l.indexAfter(-1) < l.node(-2).childCount
								? 1
								: l.indexAfter(-2) < l.node(-3).childCount
								? 2
								: 3,
						E = Jl(d, l.node().type.name, l.node().attrs),
						h =
							((i = s.contentMatch.defaultType) === null ||
							i === void 0
								? void 0
								: i.createAndFill(E)) || void 0;
					v = v.append(J.from(s.createAndFill(null, h) || void 0));
					const b = l.before(l.depth - (w - 1));
					e.replace(b, l.after(-S), new le(v, 4 - w, 0));
					let g = -1;
					e.doc.nodesBetween(b, e.doc.content.size, (x, k) => {
						if (g > -1) return !1;
						x.isTextblock && x.content.size === 0 && (g = k + 1);
					}),
						g > -1 && e.setSelection(Se.near(e.doc.resolve(g))),
						e.scrollIntoView();
				}
				return !0;
			}
			const f =
					a.pos === l.end() ? c.contentMatchAt(0).defaultType : null,
				p = Jl(d, c.type.name, c.attrs),
				m = Jl(d, l.node().type.name, l.node().attrs);
			e.delete(l.pos, a.pos);
			const y = f
				? [
						{ type: s, attrs: p },
						{ type: f, attrs: m },
				  ]
				: [{ type: s, attrs: p }];
			if (!gi(e.doc, l.pos, 2)) return !1;
			if (r) {
				const { selection: v, storedMarks: w } = n,
					{ splittableMarks: S } = o.extensionManager,
					E = w || (v.$to.parentOffset && v.$from.marks());
				if ((e.split(l.pos, 2, y).scrollIntoView(), !E || !r))
					return !0;
				const h = E.filter((b) => S.includes(b.type.name));
				e.ensureMarks(h);
			}
			return !0;
		},
	Uc = (t, e) => {
		const n = Rh((s) => s.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
		if (r === void 0) return !0;
		const o = t.doc.nodeAt(r);
		return (
			n.node.type === (o == null ? void 0 : o.type) &&
				fo(t.doc, n.pos) &&
				t.join(n.pos),
			!0
		);
	},
	Kc = (t, e) => {
		const n = Rh((s) => s.type === e)(t.selection);
		if (!n) return !0;
		const r = t.doc.resolve(n.start).after(n.depth);
		if (r === void 0) return !0;
		const o = t.doc.nodeAt(r);
		return (
			n.node.type === (o == null ? void 0 : o.type) &&
				fo(t.doc, r) &&
				t.join(r),
			!0
		);
	},
	wA =
		(t, e, n, r = {}) =>
		({
			editor: o,
			tr: i,
			state: s,
			dispatch: l,
			chain: a,
			commands: u,
			can: c,
		}) => {
			const { extensions: d, splittableMarks: f } = o.extensionManager,
				p = Ht(t, s.schema),
				m = Ht(e, s.schema),
				{ selection: y, storedMarks: v } = s,
				{ $from: w, $to: S } = y,
				E = w.blockRange(S),
				h = v || (y.$to.parentOffset && y.$from.marks());
			if (!E) return !1;
			const b = Rh((g) => Eg(g.type.name, d))(y);
			if (E.depth >= 1 && b && E.depth - b.depth <= 1) {
				if (b.node.type === p) return u.liftListItem(m);
				if (
					Eg(b.node.type.name, d) &&
					p.validContent(b.node.content) &&
					l
				)
					return a()
						.command(() => (i.setNodeMarkup(b.pos, p), !0))
						.command(() => Uc(i, p))
						.command(() => Kc(i, p))
						.run();
			}
			return !n || !h || !l
				? a()
						.command(() =>
							c().wrapInList(p, r) ? !0 : u.clearNodes()
						)
						.wrapInList(p, r)
						.command(() => Uc(i, p))
						.command(() => Kc(i, p))
						.run()
				: a()
						.command(() => {
							const g = c().wrapInList(p, r),
								x = h.filter((k) => f.includes(k.type.name));
							return i.ensureMarks(x), g ? !0 : u.clearNodes();
						})
						.wrapInList(p, r)
						.command(() => Uc(i, p))
						.command(() => Kc(i, p))
						.run();
		},
	xA =
		(t, e = {}, n = {}) =>
		({ state: r, commands: o }) => {
			const { extendEmptyMarkRange: i = !1 } = n,
				s = po(t, r.schema);
			return Zd(r, s, e)
				? o.unsetMark(s, { extendEmptyMarkRange: i })
				: o.setMark(s, e);
		},
	kA =
		(t, e, n = {}) =>
		({ state: r, commands: o }) => {
			const i = Ht(t, r.schema),
				s = Ht(e, r.schema);
			return zs(r, i, n) ? o.setNode(s) : o.setNode(i, n);
		},
	SA =
		(t, e = {}) =>
		({ state: n, commands: r }) => {
			const o = Ht(t, n.schema);
			return zs(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
		},
	_A =
		() =>
		({ state: t, dispatch: e }) => {
			const n = t.plugins;
			for (let r = 0; r < n.length; r += 1) {
				const o = n[r];
				let i;
				if (o.spec.isInputRules && (i = o.getState(t))) {
					if (e) {
						const s = t.tr,
							l = i.transform;
						for (let a = l.steps.length - 1; a >= 0; a -= 1)
							s.step(l.steps[a].invert(l.docs[a]));
						if (i.text) {
							const a = s.doc.resolve(i.from).marks();
							s.replaceWith(
								i.from,
								i.to,
								t.schema.text(i.text, a)
							);
						} else s.delete(i.from, i.to);
					}
					return !0;
				}
			}
			return !1;
		},
	CA =
		() =>
		({ tr: t, dispatch: e }) => {
			const { selection: n } = t,
				{ empty: r, ranges: o } = n;
			return (
				r ||
					(e &&
						o.forEach((i) => {
							t.removeMark(i.$from.pos, i.$to.pos);
						})),
				!0
			);
		},
	MA =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			var i;
			const { extendEmptyMarkRange: s = !1 } = e,
				{ selection: l } = n,
				a = po(t, r.schema),
				{ $from: u, empty: c, ranges: d } = l;
			if (!o) return !0;
			if (c && s) {
				let { from: f, to: p } = l;
				const m =
						(i = u.marks().find((v) => v.type === a)) === null ||
						i === void 0
							? void 0
							: i.attrs,
					y = Eh(u, a, m);
				y && ((f = y.from), (p = y.to)), n.removeMark(f, p, a);
			} else
				d.forEach((f) => {
					n.removeMark(f.$from.pos, f.$to.pos, a);
				});
			return n.removeStoredMark(a), !0;
		},
	EA =
		(t, e = {}) =>
		({ tr: n, state: r, dispatch: o }) => {
			let i = null,
				s = null;
			const l = Qu(typeof t == "string" ? t : t.name, r.schema);
			return l
				? (l === "node" && (i = Ht(t, r.schema)),
				  l === "mark" && (s = po(t, r.schema)),
				  o &&
						n.selection.ranges.forEach((a) => {
							const u = a.$from.pos,
								c = a.$to.pos;
							r.doc.nodesBetween(u, c, (d, f) => {
								i &&
									i === d.type &&
									n.setNodeMarkup(
										f,
										void 0,
										B(B({}, d.attrs), e)
									),
									s &&
										d.marks.length &&
										d.marks.forEach((p) => {
											if (s === p.type) {
												const m = Math.max(f, u),
													y = Math.min(
														f + d.nodeSize,
														c
													);
												n.addMark(
													m,
													y,
													s.create(
														B(B({}, p.attrs), e)
													)
												);
											}
										});
							});
						}),
				  !0)
				: !1;
		},
	TA =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = Ht(t, n.schema);
			return HT(o, e)(n, r);
		},
	AA =
		(t, e = {}) =>
		({ state: n, dispatch: r }) => {
			const o = Ht(t, n.schema);
			return FT(o, e)(n, r);
		};
var OA = Object.freeze({
	__proto__: null,
	blur: u4,
	clearContent: c4,
	clearNodes: d4,
	command: f4,
	createParagraphNear: h4,
	cut: p4,
	deleteCurrentNode: m4,
	deleteNode: g4,
	deleteRange: y4,
	deleteSelection: v4,
	enter: b4,
	exitCode: w4,
	extendMarkRange: k4,
	first: S4,
	focus: _4,
	forEach: C4,
	insertContent: M4,
	insertContentAt: A4,
	joinUp: O4,
	joinDown: R4,
	joinBackward: P4,
	joinForward: I4,
	joinItemBackward: N4,
	joinItemForward: D4,
	joinTextblockBackward: j4,
	joinTextblockForward: L4,
	keyboardShortcut: B4,
	lift: z4,
	liftEmptyBlock: H4,
	liftListItem: F4,
	newlineInCode: V4,
	resetAttributes: W4,
	scrollIntoView: U4,
	selectAll: K4,
	selectNodeBackward: q4,
	selectNodeForward: J4,
	selectParentNode: G4,
	selectTextblockEnd: Y4,
	selectTextblockStart: Q4,
	setContent: X4,
	setMark: fA,
	setMeta: hA,
	setNode: pA,
	setNodeSelection: mA,
	setTextSelection: gA,
	sinkListItem: yA,
	splitBlock: vA,
	splitListItem: bA,
	toggleList: wA,
	toggleMark: xA,
	toggleNode: kA,
	toggleWrap: SA,
	undoInputRule: _A,
	unsetAllMarks: CA,
	unsetMark: MA,
	updateAttributes: EA,
	wrapIn: TA,
	wrapInList: AA,
});
const RA = Nt.create({
		name: "commands",
		addCommands() {
			return B({}, OA);
		},
	}),
	PA = Nt.create({
		name: "editable",
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("editable"),
					props: { editable: () => this.editor.options.editable },
				}),
			];
		},
	}),
	IA = Nt.create({
		name: "focusEvents",
		addProseMirrorPlugins() {
			const { editor: t } = this;
			return [
				new kt({
					key: new Dt("focusEvents"),
					props: {
						handleDOMEvents: {
							focus: (e, n) => {
								t.isFocused = !0;
								const r = t.state.tr
									.setMeta("focus", { event: n })
									.setMeta("addToHistory", !1);
								return e.dispatch(r), !1;
							},
							blur: (e, n) => {
								t.isFocused = !1;
								const r = t.state.tr
									.setMeta("blur", { event: n })
									.setMeta("addToHistory", !1);
								return e.dispatch(r), !1;
							},
						},
					},
				}),
			];
		},
	}),
	NA = Nt.create({
		name: "keymap",
		addKeyboardShortcuts() {
			const t = () =>
					this.editor.commands.first(({ commands: s }) => [
						() => s.undoInputRule(),
						() =>
							s.command(({ tr: l }) => {
								const { selection: a, doc: u } = l,
									{ empty: c, $anchor: d } = a,
									{ pos: f, parent: p } = d,
									m = d.parent.isTextblock
										? l.doc.resolve(f - 1)
										: d,
									y = m.parent.type.spec.isolating,
									v = d.pos - d.parentOffset,
									w =
										y && m.parent.childCount === 1
											? v === d.pos
											: Me.atStart(u).from === f;
								return !c ||
									!w ||
									!p.type.isTextblock ||
									p.textContent.length
									? !1
									: s.clearNodes();
							}),
						() => s.deleteSelection(),
						() => s.joinBackward(),
						() => s.selectNodeBackward(),
					]),
				e = () =>
					this.editor.commands.first(({ commands: s }) => [
						() => s.deleteSelection(),
						() => s.deleteCurrentNode(),
						() => s.joinForward(),
						() => s.selectNodeForward(),
					]),
				r = {
					Enter: () =>
						this.editor.commands.first(({ commands: s }) => [
							() => s.newlineInCode(),
							() => s.createParagraphNear(),
							() => s.liftEmptyBlock(),
							() => s.splitBlock(),
						]),
					"Mod-Enter": () => this.editor.commands.exitCode(),
					Backspace: t,
					"Mod-Backspace": t,
					"Shift-Backspace": t,
					Delete: e,
					"Mod-Delete": e,
					"Mod-a": () => this.editor.commands.selectAll(),
				},
				o = B({}, r),
				i = ge(B({}, r), {
					"Ctrl-h": t,
					"Alt-Backspace": t,
					"Ctrl-d": e,
					"Ctrl-Alt-Backspace": e,
					"Alt-Delete": e,
					"Alt-d": e,
					"Ctrl-a": () => this.editor.commands.selectTextblockStart(),
					"Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
				});
			return Ah() || Oh() ? i : o;
		},
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("clearDocument"),
					appendTransaction: (t, e, n) => {
						if (!(t.some((m) => m.docChanged) && !e.doc.eq(n.doc)))
							return;
						const { empty: o, from: i, to: s } = e.selection,
							l = Me.atStart(e.doc).from,
							a = Me.atEnd(e.doc).to;
						if (
							o ||
							!(i === l && s === a) ||
							!(
								n.doc.textBetween(
									0,
									n.doc.content.size,
									" ",
									" "
								).length === 0
							)
						)
							return;
						const d = n.tr,
							f = qu({ state: n, transaction: d }),
							{ commands: p } = new Ju({
								editor: this.editor,
								state: f,
							});
						if ((p.clearNodes(), !!d.steps.length)) return d;
					},
				}),
			];
		},
	}),
	DA = Nt.create({
		name: "tabindex",
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("tabindex"),
					props: {
						attributes: this.editor.isEditable
							? { tabindex: "0" }
							: {},
					},
				}),
			];
		},
	});
var jA = Object.freeze({
	__proto__: null,
	ClipboardTextSerializer: a4,
	Commands: RA,
	Editable: PA,
	FocusEvents: IA,
	Keymap: NA,
	Tabindex: DA,
});
class _o {
	constructor(e, n, r = !1, o = null) {
		(this.currentNode = null),
			(this.actualDepth = null),
			(this.isBlock = r),
			(this.resolvedPos = e),
			(this.editor = n),
			(this.currentNode = o);
	}
	get name() {
		return this.node.type.name;
	}
	get node() {
		return this.currentNode || this.resolvedPos.node();
	}
	get element() {
		return this.editor.view.domAtPos(this.pos).node;
	}
	get depth() {
		var e;
		return (e = this.actualDepth) !== null && e !== void 0
			? e
			: this.resolvedPos.depth;
	}
	get pos() {
		return this.resolvedPos.pos;
	}
	get content() {
		return this.node.content;
	}
	set content(e) {
		let n = this.from,
			r = this.to;
		if (this.isBlock) {
			if (this.content.size === 0) {
				console.error(
					`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`
				);
				return;
			}
			(n = this.from + 1), (r = this.to - 1);
		}
		this.editor.commands.insertContentAt({ from: n, to: r }, e);
	}
	get attributes() {
		return this.node.attrs;
	}
	get textContent() {
		return this.node.textContent;
	}
	get size() {
		return this.node.nodeSize;
	}
	get from() {
		return this.isBlock
			? this.pos
			: this.resolvedPos.start(this.resolvedPos.depth);
	}
	get range() {
		return { from: this.from, to: this.to };
	}
	get to() {
		return this.isBlock
			? this.pos + this.size
			: this.resolvedPos.end(this.resolvedPos.depth) +
					(this.node.isText ? 0 : 1);
	}
	get parent() {
		if (this.depth === 0) return null;
		const e = this.resolvedPos.start(this.resolvedPos.depth - 1),
			n = this.resolvedPos.doc.resolve(e);
		return new _o(n, this.editor);
	}
	get before() {
		let e = this.resolvedPos.doc.resolve(
			this.from - (this.isBlock ? 1 : 2)
		);
		return (
			e.depth !== this.depth &&
				(e = this.resolvedPos.doc.resolve(this.from - 3)),
			new _o(e, this.editor)
		);
	}
	get after() {
		let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
		return (
			e.depth !== this.depth &&
				(e = this.resolvedPos.doc.resolve(this.to + 3)),
			new _o(e, this.editor)
		);
	}
	get children() {
		const e = [];
		return (
			this.node.content.forEach((n, r) => {
				const o = n.isBlock && !n.isTextblock,
					i = this.pos + r + (o ? 0 : 1),
					s = this.resolvedPos.doc.resolve(i);
				if (!o && s.depth <= this.depth) return;
				const l = new _o(s, this.editor, o, o ? n : null);
				o && (l.actualDepth = this.depth + 1),
					e.push(new _o(s, this.editor, o, o ? n : null));
			}),
			e
		);
	}
	get firstChild() {
		return this.children[0] || null;
	}
	get lastChild() {
		const e = this.children;
		return e[e.length - 1] || null;
	}
	closest(e, n = {}) {
		let r = null,
			o = this.parent;
		for (; o && !r; ) {
			if (o.node.type.name === e)
				if (Object.keys(n).length > 0) {
					const i = o.node.attrs,
						s = Object.keys(n);
					for (let l = 0; l < s.length; l += 1) {
						const a = s[l];
						if (i[a] !== n[a]) break;
					}
				} else r = o;
			o = o.parent;
		}
		return r;
	}
	querySelector(e, n = {}) {
		return this.querySelectorAll(e, n, !0)[0] || null;
	}
	querySelectorAll(e, n = {}, r = !1) {
		let o = [];
		return (
			this.isBlock ||
				!this.children ||
				this.children.length === 0 ||
				this.children.forEach((i) => {
					if (i.node.type.name === e) {
						if (Object.keys(n).length > 0) {
							const s = i.node.attrs,
								l = Object.keys(n);
							for (let a = 0; a < l.length; a += 1) {
								const u = l[a];
								if (s[u] !== n[u]) return;
							}
						}
						if ((o.push(i), r)) return;
					}
					o = o.concat(i.querySelectorAll(e));
				}),
			o
		);
	}
	setAttribute(e) {
		const n = this.editor.state.selection;
		this.editor
			.chain()
			.setTextSelection(this.from)
			.updateAttributes(this.node.type.name, e)
			.setTextSelection(n.from)
			.run();
	}
}
const LA = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function $A(t, e, n) {
	const r = document.querySelector(
		`style[data-tiptap-style${n ? `-${n}` : ""}]`
	);
	if (r !== null) return r;
	const o = document.createElement("style");
	return (
		e && o.setAttribute("nonce", e),
		o.setAttribute(`data-tiptap-style${n ? `-${n}` : ""}`, ""),
		(o.innerHTML = t),
		document.getElementsByTagName("head")[0].appendChild(o),
		o
	);
}
let BA = class extends JT {
	constructor(e = {}) {
		super(),
			(this.isFocused = !1),
			(this.extensionStorage = {}),
			(this.options = {
				element: document.createElement("div"),
				content: "",
				injectCSS: !0,
				injectNonce: void 0,
				extensions: [],
				autofocus: !1,
				editable: !0,
				editorProps: {},
				parseOptions: {},
				enableInputRules: !0,
				enablePasteRules: !0,
				enableCoreExtensions: !0,
				onBeforeCreate: () => null,
				onCreate: () => null,
				onUpdate: () => null,
				onSelectionUpdate: () => null,
				onTransaction: () => null,
				onFocus: () => null,
				onBlur: () => null,
				onDestroy: () => null,
			}),
			(this.isCapturingTransaction = !1),
			(this.capturedTransaction = null),
			this.setOptions(e),
			this.createExtensionManager(),
			this.createCommandManager(),
			this.createSchema(),
			this.on("beforeCreate", this.options.onBeforeCreate),
			this.emit("beforeCreate", { editor: this }),
			this.createView(),
			this.injectCSS(),
			this.on("create", this.options.onCreate),
			this.on("update", this.options.onUpdate),
			this.on("selectionUpdate", this.options.onSelectionUpdate),
			this.on("transaction", this.options.onTransaction),
			this.on("focus", this.options.onFocus),
			this.on("blur", this.options.onBlur),
			this.on("destroy", this.options.onDestroy),
			window.setTimeout(() => {
				this.isDestroyed ||
					(this.commands.focus(this.options.autofocus),
					this.emit("create", { editor: this }));
			}, 0);
	}
	get storage() {
		return this.extensionStorage;
	}
	get commands() {
		return this.commandManager.commands;
	}
	chain() {
		return this.commandManager.chain();
	}
	can() {
		return this.commandManager.can();
	}
	injectCSS() {
		this.options.injectCSS &&
			document &&
			(this.css = $A(LA, this.options.injectNonce));
	}
	setOptions(e = {}) {
		(this.options = B(B({}, this.options), e)),
			!(!this.view || !this.state || this.isDestroyed) &&
				(this.options.editorProps &&
					this.view.setProps(this.options.editorProps),
				this.view.updateState(this.state));
	}
	setEditable(e, n = !0) {
		this.setOptions({ editable: e }),
			n &&
				this.emit("update", {
					editor: this,
					transaction: this.state.tr,
				});
	}
	get isEditable() {
		return this.options.editable && this.view && this.view.editable;
	}
	get state() {
		return this.view.state;
	}
	registerPlugin(e, n) {
		const r = u2(n)
				? n(e, [...this.state.plugins])
				: [...this.state.plugins, e],
			o = this.state.reconfigure({ plugins: r });
		this.view.updateState(o);
	}
	unregisterPlugin(e) {
		if (this.isDestroyed) return;
		const n = typeof e == "string" ? `${e}$` : e.key,
			r = this.state.reconfigure({
				plugins: this.state.plugins.filter((o) => !o.key.startsWith(n)),
			});
		this.view.updateState(r);
	}
	createExtensionManager() {
		const n = [
			...(this.options.enableCoreExtensions ? Object.values(jA) : []),
			...this.options.extensions,
		].filter((r) =>
			["extension", "node", "mark"].includes(r == null ? void 0 : r.type)
		);
		this.extensionManager = new ui(n, this);
	}
	createCommandManager() {
		this.commandManager = new Ju({ editor: this });
	}
	createSchema() {
		this.schema = this.extensionManager.schema;
	}
	createView() {
		const e = p2(
				this.options.content,
				this.schema,
				this.options.parseOptions
			),
			n = f2(e, this.options.autofocus);
		this.view = new hT(
			this.options.element,
			ge(B({}, this.options.editorProps), {
				dispatchTransaction: this.dispatchTransaction.bind(this),
				state: ai.create({ doc: e, selection: n || void 0 }),
			})
		);
		const r = this.state.reconfigure({
			plugins: this.extensionManager.plugins,
		});
		this.view.updateState(r), this.createNodeViews(), this.prependClass();
		const o = this.view.dom;
		o.editor = this;
	}
	createNodeViews() {
		this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
	}
	prependClass() {
		this.view.dom.className = `tiptap ${this.view.dom.className}`;
	}
	captureTransaction(e) {
		(this.isCapturingTransaction = !0),
			e(),
			(this.isCapturingTransaction = !1);
		const n = this.capturedTransaction;
		return (this.capturedTransaction = null), n;
	}
	dispatchTransaction(e) {
		if (this.view.isDestroyed) return;
		if (this.isCapturingTransaction) {
			if (!this.capturedTransaction) {
				this.capturedTransaction = e;
				return;
			}
			e.steps.forEach((s) => {
				var l;
				return (l = this.capturedTransaction) === null || l === void 0
					? void 0
					: l.step(s);
			});
			return;
		}
		const n = this.state.apply(e),
			r = !this.state.selection.eq(n.selection);
		this.view.updateState(n),
			this.emit("transaction", { editor: this, transaction: e }),
			r && this.emit("selectionUpdate", { editor: this, transaction: e });
		const o = e.getMeta("focus"),
			i = e.getMeta("blur");
		o &&
			this.emit("focus", {
				editor: this,
				event: o.event,
				transaction: e,
			}),
			i &&
				this.emit("blur", {
					editor: this,
					event: i.event,
					transaction: e,
				}),
			!(!e.docChanged || e.getMeta("preventUpdate")) &&
				this.emit("update", { editor: this, transaction: e });
	}
	getAttributes(e) {
		return g2(this.state, e);
	}
	isActive(e, n) {
		const r = typeof e == "string" ? e : null,
			o = typeof e == "string" ? n : e;
		return aA(this.state, r, o);
	}
	getJSON() {
		return this.state.doc.toJSON();
	}
	getHTML() {
		return nA(this.state.doc.content, this.schema);
	}
	getText(e) {
		const {
			blockSeparator: n = `

`,
			textSerializers: r = {},
		} = e || {};
		return rA(this.state.doc, {
			blockSeparator: n,
			textSerializers: B(B({}, d2(this.schema)), r),
		});
	}
	get isEmpty() {
		return uA(this.state.doc);
	}
	getCharacterCount() {
		return (
			console.warn(
				'[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
			),
			this.state.doc.content.size - 2
		);
	}
	destroy() {
		this.emit("destroy"),
			this.view && this.view.destroy(),
			this.removeAllListeners();
	}
	get isDestroyed() {
		var e;
		return !(!((e = this.view) === null || e === void 0) && e.docView);
	}
	$node(e, n) {
		var r;
		return (
			((r = this.$doc) === null || r === void 0
				? void 0
				: r.querySelector(e, n)) || null
		);
	}
	$nodes(e, n) {
		var r;
		return (
			((r = this.$doc) === null || r === void 0
				? void 0
				: r.querySelectorAll(e, n)) || null
		);
	}
	$pos(e) {
		const n = this.state.doc.resolve(e);
		return new _o(n, this);
	}
	get $doc() {
		return this.$pos(0);
	}
};
function Vo(t) {
	return new ol({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = Be(t.getAttributes, void 0, r);
			if (o === !1 || o === null) return null;
			const { tr: i } = e,
				s = r[r.length - 1],
				l = r[0];
			if (s) {
				const a = l.search(/\S/),
					u = n.from + l.indexOf(s),
					c = u + s.length;
				if (
					Ph(n.from, n.to, e.doc)
						.filter((p) =>
							p.mark.type.excluded.find(
								(y) => y === t.type && y !== p.mark.type
							)
						)
						.filter((p) => p.to > u).length
				)
					return null;
				c < n.to && i.delete(c, n.to),
					u > n.from && i.delete(n.from + a, u);
				const f = n.from + a + s.length;
				i.addMark(n.from + a, f, t.type.create(o || {})),
					i.removeStoredMark(t.type);
			}
		},
	});
}
function v2(t) {
	return new ol({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = Be(t.getAttributes, void 0, r) || {},
				{ tr: i } = e,
				s = n.from;
			let l = n.to;
			const a = t.type.create(o);
			if (r[1]) {
				const u = r[0].lastIndexOf(r[1]);
				let c = s + u;
				c > l ? (c = l) : (l = c + r[1].length);
				const d = r[0][r[0].length - 1];
				i.insertText(d, s + r[0].length - 1), i.replaceWith(c, l, a);
			} else
				r[0] &&
					i
						.insert(s - 1, t.type.create(o))
						.delete(i.mapping.map(s), i.mapping.map(l));
			i.scrollIntoView();
		},
	});
}
function ef(t) {
	return new ol({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			const o = e.doc.resolve(n.from),
				i = Be(t.getAttributes, void 0, r) || {};
			if (
				!o
					.node(-1)
					.canReplaceWith(o.index(-1), o.indexAfter(-1), t.type)
			)
				return null;
			e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
		},
	});
}
function St(t) {
	return new ol({
		find: t.find,
		handler: ({ state: e, range: n, match: r }) => {
			let o = t.replace,
				i = n.from;
			const s = n.to;
			if (r[1]) {
				const l = r[0].lastIndexOf(r[1]);
				(o += r[0].slice(l + r[1].length)), (i += l);
				const a = i - s;
				a > 0 && ((o = r[0].slice(l - a, l) + o), (i = s));
			}
			e.tr.insertText(o, i, s);
		},
	});
}
function Hs(t) {
	return new ol({
		find: t.find,
		handler: ({ state: e, range: n, match: r, chain: o }) => {
			const i = Be(t.getAttributes, void 0, r) || {},
				s = e.tr.delete(n.from, n.to),
				a = s.doc.resolve(n.from).blockRange(),
				u = a && dh(a, t.type, i);
			if (!u) return null;
			if ((s.wrap(a, u), t.keepMarks && t.editor)) {
				const { selection: d, storedMarks: f } = e,
					{ splittableMarks: p } = t.editor.extensionManager,
					m = f || (d.$to.parentOffset && d.$from.marks());
				if (m) {
					const y = m.filter((v) => p.includes(v.type.name));
					s.ensureMarks(y);
				}
			}
			if (t.keepAttributes) {
				const d =
					t.type.name === "bulletList" ||
					t.type.name === "orderedList"
						? "listItem"
						: "taskList";
				o().updateAttributes(d, i).run();
			}
			const c = s.doc.resolve(n.from - 1).nodeBefore;
			c &&
				c.type === t.type &&
				fo(s.doc, n.from - 1) &&
				(!t.joinPredicate || t.joinPredicate(r, c)) &&
				s.join(n.from - 1);
		},
	});
}
class vn {
	constructor(e = {}) {
		(this.type = "mark"),
			(this.name = "mark"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = B(B({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Be(
					fe(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Be(
					fe(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new vn(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Yu(this.options, e)),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new vn(B(B({}, this.config), e));
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Be(fe(n, "addOptions", { name: n.name }))),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	static handleExit({ editor: e, mark: n }) {
		const { tr: r } = e.state,
			o = e.state.selection.$from;
		if (o.pos === o.end()) {
			const s = o.marks();
			if (!!!s.find((u) => (u == null ? void 0 : u.type.name) === n.name))
				return !1;
			const a = s.find(
				(u) => (u == null ? void 0 : u.type.name) === n.name
			);
			return (
				a && r.removeStoredMark(a),
				r.insertText(" ", o.pos),
				e.view.dispatch(r),
				!0
			);
		}
		return !1;
	}
}
let Pt = class tf {
	constructor(e = {}) {
		(this.type = "node"),
			(this.name = "node"),
			(this.parent = null),
			(this.child = null),
			(this.config = { name: this.name, defaultOptions: {} }),
			(this.config = B(B({}, this.config), e)),
			(this.name = this.config.name),
			e.defaultOptions &&
				Object.keys(e.defaultOptions).length > 0 &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
				),
			(this.options = this.config.defaultOptions),
			this.config.addOptions &&
				(this.options = Be(
					fe(this, "addOptions", { name: this.name })
				)),
			(this.storage =
				Be(
					fe(this, "addStorage", {
						name: this.name,
						options: this.options,
					})
				) || {});
	}
	static create(e = {}) {
		return new tf(e);
	}
	configure(e = {}) {
		const n = this.extend();
		return (
			(n.options = Yu(this.options, e)),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
	extend(e = {}) {
		const n = new tf(B(B({}, this.config), e));
		return (
			(n.parent = this),
			(this.child = n),
			(n.name = e.name ? e.name : n.parent.name),
			e.defaultOptions &&
				console.warn(
					`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${n.name}".`
				),
			(n.options = Be(fe(n, "addOptions", { name: n.name }))),
			(n.storage = Be(
				fe(n, "addStorage", { name: n.name, options: n.options })
			)),
			n
		);
	}
};
function so(t) {
	return new n4({
		find: t.find,
		handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
			const i = Be(t.getAttributes, void 0, r, o);
			if (i === !1 || i === null) return null;
			const { tr: s } = e,
				l = r[r.length - 1],
				a = r[0];
			let u = n.to;
			if (l) {
				const c = a.search(/\S/),
					d = n.from + a.indexOf(l),
					f = d + l.length;
				if (
					Ph(n.from, n.to, e.doc)
						.filter((m) =>
							m.mark.type.excluded.find(
								(v) => v === t.type && v !== m.mark.type
							)
						)
						.filter((m) => m.to > d).length
				)
					return null;
				f < n.to && s.delete(f, n.to),
					d > n.from && s.delete(n.from + c, d),
					(u = n.from + c + l.length),
					s.addMark(n.from + c, u, t.type.create(i || {})),
					s.removeStoredMark(t.type);
			}
		},
	});
}
function zA(t) {
	return t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var HA = "tippy-box",
	b2 = "tippy-content",
	FA = "tippy-backdrop",
	w2 = "tippy-arrow",
	x2 = "tippy-svg-arrow",
	wo = { passive: !0, capture: !0 },
	k2 = function () {
		return document.body;
	};
function qc(t, e, n) {
	if (Array.isArray(t)) {
		var r = t[e];
		return r == null ? (Array.isArray(n) ? n[e] : n) : r;
	}
	return t;
}
function Ih(t, e) {
	var n = {}.toString.call(t);
	return n.indexOf("[object") === 0 && n.indexOf(e + "]") > -1;
}
function S2(t, e) {
	return typeof t == "function" ? t.apply(void 0, e) : t;
}
function Ag(t, e) {
	if (e === 0) return t;
	var n;
	return function (r) {
		clearTimeout(n),
			(n = setTimeout(function () {
				t(r);
			}, e));
	};
}
function VA(t) {
	return t.split(/\s+/).filter(Boolean);
}
function oi(t) {
	return [].concat(t);
}
function Og(t, e) {
	t.indexOf(e) === -1 && t.push(e);
}
function WA(t) {
	return t.filter(function (e, n) {
		return t.indexOf(e) === n;
	});
}
function UA(t) {
	return t.split("-")[0];
}
function Da(t) {
	return [].slice.call(t);
}
function Rg(t) {
	return Object.keys(t).reduce(function (e, n) {
		return t[n] !== void 0 && (e[n] = t[n]), e;
	}, {});
}
function vs() {
	return document.createElement("div");
}
function Xu(t) {
	return ["Element", "Fragment"].some(function (e) {
		return Ih(t, e);
	});
}
function KA(t) {
	return Ih(t, "NodeList");
}
function qA(t) {
	return Ih(t, "MouseEvent");
}
function JA(t) {
	return !!(t && t._tippy && t._tippy.reference === t);
}
function GA(t) {
	return Xu(t)
		? [t]
		: KA(t)
		? Da(t)
		: Array.isArray(t)
		? t
		: Da(document.querySelectorAll(t));
}
function Jc(t, e) {
	t.forEach(function (n) {
		n && (n.style.transitionDuration = e + "ms");
	});
}
function Pg(t, e) {
	t.forEach(function (n) {
		n && n.setAttribute("data-state", e);
	});
}
function YA(t) {
	var e,
		n = oi(t),
		r = n[0];
	return r != null && (e = r.ownerDocument) != null && e.body
		? r.ownerDocument
		: document;
}
function QA(t, e) {
	var n = e.clientX,
		r = e.clientY;
	return t.every(function (o) {
		var i = o.popperRect,
			s = o.popperState,
			l = o.props,
			a = l.interactiveBorder,
			u = UA(s.placement),
			c = s.modifiersData.offset;
		if (!c) return !0;
		var d = u === "bottom" ? c.top.y : 0,
			f = u === "top" ? c.bottom.y : 0,
			p = u === "right" ? c.left.x : 0,
			m = u === "left" ? c.right.x : 0,
			y = i.top - r + d > a,
			v = r - i.bottom - f > a,
			w = i.left - n + p > a,
			S = n - i.right - m > a;
		return y || v || w || S;
	});
}
function Gc(t, e, n) {
	var r = e + "EventListener";
	["transitionend", "webkitTransitionEnd"].forEach(function (o) {
		t[r](o, n);
	});
}
function Ig(t, e) {
	for (var n = e; n; ) {
		var r;
		if (t.contains(n)) return !0;
		n =
			n.getRootNode == null || (r = n.getRootNode()) == null
				? void 0
				: r.host;
	}
	return !1;
}
var Qn = { isTouch: !1 },
	Ng = 0;
function XA() {
	Qn.isTouch ||
		((Qn.isTouch = !0),
		window.performance && document.addEventListener("mousemove", _2));
}
function _2() {
	var t = performance.now();
	t - Ng < 20 &&
		((Qn.isTouch = !1), document.removeEventListener("mousemove", _2)),
		(Ng = t);
}
function ZA() {
	var t = document.activeElement;
	if (JA(t)) {
		var e = t._tippy;
		t.blur && !e.state.isVisible && t.blur();
	}
}
function eO() {
	document.addEventListener("touchstart", XA, wo),
		window.addEventListener("blur", ZA);
}
var tO = typeof window != "undefined" && typeof document != "undefined",
	nO = tO ? !!window.msCrypto : !1,
	rO = {
		animateFill: !1,
		followCursor: !1,
		inlinePositioning: !1,
		sticky: !1,
	},
	oO = {
		allowHTML: !1,
		animation: "fade",
		arrow: !0,
		content: "",
		inertia: !1,
		maxWidth: 350,
		role: "tooltip",
		theme: "",
		zIndex: 9999,
	},
	$n = Object.assign(
		{
			appendTo: k2,
			aria: { content: "auto", expanded: "auto" },
			delay: 0,
			duration: [300, 250],
			getReferenceClientRect: null,
			hideOnClick: !0,
			ignoreAttributes: !1,
			interactive: !1,
			interactiveBorder: 2,
			interactiveDebounce: 0,
			moveTransition: "",
			offset: [0, 10],
			onAfterUpdate: function () {},
			onBeforeUpdate: function () {},
			onCreate: function () {},
			onDestroy: function () {},
			onHidden: function () {},
			onHide: function () {},
			onMount: function () {},
			onShow: function () {},
			onShown: function () {},
			onTrigger: function () {},
			onUntrigger: function () {},
			onClickOutside: function () {},
			placement: "top",
			plugins: [],
			popperOptions: {},
			render: null,
			showOnCreate: !1,
			touch: !0,
			trigger: "mouseenter focus",
			triggerTarget: null,
		},
		rO,
		oO
	),
	iO = Object.keys($n),
	sO = function (e) {
		var n = Object.keys(e);
		n.forEach(function (r) {
			$n[r] = e[r];
		});
	};
function C2(t) {
	var e = t.plugins || [],
		n = e.reduce(function (r, o) {
			var i = o.name,
				s = o.defaultValue;
			if (i) {
				var l;
				r[i] = t[i] !== void 0 ? t[i] : (l = $n[i]) != null ? l : s;
			}
			return r;
		}, {});
	return Object.assign({}, t, n);
}
function lO(t, e) {
	var n = e ? Object.keys(C2(Object.assign({}, $n, { plugins: e }))) : iO,
		r = n.reduce(function (o, i) {
			var s = (t.getAttribute("data-tippy-" + i) || "").trim();
			if (!s) return o;
			if (i === "content") o[i] = s;
			else
				try {
					o[i] = JSON.parse(s);
				} catch (l) {
					o[i] = s;
				}
			return o;
		}, {});
	return r;
}
function Dg(t, e) {
	var n = Object.assign(
		{},
		e,
		{ content: S2(e.content, [t]) },
		e.ignoreAttributes ? {} : lO(t, e.plugins)
	);
	return (
		(n.aria = Object.assign({}, $n.aria, n.aria)),
		(n.aria = {
			expanded:
				n.aria.expanded === "auto" ? e.interactive : n.aria.expanded,
			content:
				n.aria.content === "auto"
					? e.interactive
						? null
						: "describedby"
					: n.aria.content,
		}),
		n
	);
}
var aO = function () {
	return "innerHTML";
};
function nf(t, e) {
	t[aO()] = e;
}
function jg(t) {
	var e = vs();
	return (
		t === !0
			? (e.className = w2)
			: ((e.className = x2), Xu(t) ? e.appendChild(t) : nf(e, t)),
		e
	);
}
function Lg(t, e) {
	Xu(e.content)
		? (nf(t, ""), t.appendChild(e.content))
		: typeof e.content != "function" &&
		  (e.allowHTML ? nf(t, e.content) : (t.textContent = e.content));
}
function rf(t) {
	var e = t.firstElementChild,
		n = Da(e.children);
	return {
		box: e,
		content: n.find(function (r) {
			return r.classList.contains(b2);
		}),
		arrow: n.find(function (r) {
			return r.classList.contains(w2) || r.classList.contains(x2);
		}),
		backdrop: n.find(function (r) {
			return r.classList.contains(FA);
		}),
	};
}
function M2(t) {
	var e = vs(),
		n = vs();
	(n.className = HA),
		n.setAttribute("data-state", "hidden"),
		n.setAttribute("tabindex", "-1");
	var r = vs();
	(r.className = b2),
		r.setAttribute("data-state", "hidden"),
		Lg(r, t.props),
		e.appendChild(n),
		n.appendChild(r),
		o(t.props, t.props);
	function o(i, s) {
		var l = rf(e),
			a = l.box,
			u = l.content,
			c = l.arrow;
		s.theme
			? a.setAttribute("data-theme", s.theme)
			: a.removeAttribute("data-theme"),
			typeof s.animation == "string"
				? a.setAttribute("data-animation", s.animation)
				: a.removeAttribute("data-animation"),
			s.inertia
				? a.setAttribute("data-inertia", "")
				: a.removeAttribute("data-inertia"),
			(a.style.maxWidth =
				typeof s.maxWidth == "number" ? s.maxWidth + "px" : s.maxWidth),
			s.role ? a.setAttribute("role", s.role) : a.removeAttribute("role"),
			(i.content !== s.content || i.allowHTML !== s.allowHTML) &&
				Lg(u, t.props),
			s.arrow
				? c
					? i.arrow !== s.arrow &&
					  (a.removeChild(c), a.appendChild(jg(s.arrow)))
					: a.appendChild(jg(s.arrow))
				: c && a.removeChild(c);
	}
	return { popper: e, onUpdate: o };
}
M2.$$tippy = !0;
var uO = 1,
	Al = [],
	Yc = [];
function cO(t, e) {
	var n = Dg(t, Object.assign({}, $n, C2(Rg(e)))),
		r,
		o,
		i,
		s = !1,
		l = !1,
		a = !1,
		u = !1,
		c,
		d,
		f,
		p = [],
		m = Ag(O, n.interactiveDebounce),
		y,
		v = uO++,
		w = null,
		S = WA(n.plugins),
		E = {
			isEnabled: !0,
			isVisible: !1,
			isDestroyed: !1,
			isMounted: !1,
			isShown: !1,
		},
		h = {
			id: v,
			reference: t,
			popper: vs(),
			popperInstance: w,
			props: n,
			state: E,
			plugins: S,
			clearDelayTimeouts: _e,
			setProps: $e,
			setContent: Qe,
			show: st,
			hide: Ct,
			hideWithInteractivity: hn,
			enable: ye,
			disable: me,
			unmount: Ar,
			destroy: sl,
		};
	if (!n.render) return h;
	var b = n.render(h),
		g = b.popper,
		x = b.onUpdate;
	g.setAttribute("data-tippy-root", ""),
		(g.id = "tippy-" + h.id),
		(h.popper = g),
		(t._tippy = h),
		(g._tippy = h);
	var k = S.map(function (F) {
			return F.fn(h);
		}),
		C = t.hasAttribute("aria-expanded");
	return (
		He(),
		ie(),
		I(),
		$("onCreate", [h]),
		n.showOnCreate && G(),
		g.addEventListener("mouseenter", function () {
			h.props.interactive && h.state.isVisible && h.clearDelayTimeouts();
		}),
		g.addEventListener("mouseleave", function () {
			h.props.interactive &&
				h.props.trigger.indexOf("mouseenter") >= 0 &&
				D().addEventListener("mousemove", m);
		}),
		h
	);
	function _() {
		var F = h.props.touch;
		return Array.isArray(F) ? F : [F, 0];
	}
	function T() {
		return _()[0] === "hold";
	}
	function R() {
		var F;
		return !!((F = h.props.render) != null && F.$$tippy);
	}
	function P() {
		return y || t;
	}
	function D() {
		var F = P().parentNode;
		return F ? YA(F) : document;
	}
	function j() {
		return rf(g);
	}
	function M(F) {
		return (h.state.isMounted && !h.state.isVisible) ||
			Qn.isTouch ||
			(c && c.type === "focus")
			? 0
			: qc(h.props.delay, F ? 0 : 1, $n.delay);
	}
	function I(F) {
		F === void 0 && (F = !1),
			(g.style.pointerEvents = h.props.interactive && !F ? "" : "none"),
			(g.style.zIndex = "" + h.props.zIndex);
	}
	function $(F, he, pe) {
		if (
			(pe === void 0 && (pe = !0),
			k.forEach(function (Ue) {
				Ue[F] && Ue[F].apply(Ue, he);
			}),
			pe)
		) {
			var Fe;
			(Fe = h.props)[F].apply(Fe, he);
		}
	}
	function K() {
		var F = h.props.aria;
		if (F.content) {
			var he = "aria-" + F.content,
				pe = g.id,
				Fe = oi(h.props.triggerTarget || t);
			Fe.forEach(function (Ue) {
				var Xt = Ue.getAttribute(he);
				if (h.state.isVisible)
					Ue.setAttribute(he, Xt ? Xt + " " + pe : pe);
				else {
					var bn = Xt && Xt.replace(pe, "").trim();
					bn ? Ue.setAttribute(he, bn) : Ue.removeAttribute(he);
				}
			});
		}
	}
	function ie() {
		if (!(C || !h.props.aria.expanded)) {
			var F = oi(h.props.triggerTarget || t);
			F.forEach(function (he) {
				h.props.interactive
					? he.setAttribute(
							"aria-expanded",
							h.state.isVisible && he === P() ? "true" : "false"
					  )
					: he.removeAttribute("aria-expanded");
			});
		}
	}
	function X() {
		D().removeEventListener("mousemove", m),
			(Al = Al.filter(function (F) {
				return F !== m;
			}));
	}
	function de(F) {
		if (!(Qn.isTouch && (a || F.type === "mousedown"))) {
			var he = (F.composedPath && F.composedPath()[0]) || F.target;
			if (!(h.props.interactive && Ig(g, he))) {
				if (
					oi(h.props.triggerTarget || t).some(function (pe) {
						return Ig(pe, he);
					})
				) {
					if (
						Qn.isTouch ||
						(h.state.isVisible &&
							h.props.trigger.indexOf("click") >= 0)
					)
						return;
				} else $("onClickOutside", [h, F]);
				h.props.hideOnClick === !0 &&
					(h.clearDelayTimeouts(),
					h.hide(),
					(l = !0),
					setTimeout(function () {
						l = !1;
					}),
					h.state.isMounted || De());
			}
		}
	}
	function ze() {
		a = !0;
	}
	function Ee() {
		a = !1;
	}
	function Pe() {
		var F = D();
		F.addEventListener("mousedown", de, !0),
			F.addEventListener("touchend", de, wo),
			F.addEventListener("touchstart", Ee, wo),
			F.addEventListener("touchmove", ze, wo);
	}
	function De() {
		var F = D();
		F.removeEventListener("mousedown", de, !0),
			F.removeEventListener("touchend", de, wo),
			F.removeEventListener("touchstart", Ee, wo),
			F.removeEventListener("touchmove", ze, wo);
	}
	function H(F, he) {
		oe(F, function () {
			!h.state.isVisible &&
				g.parentNode &&
				g.parentNode.contains(g) &&
				he();
		});
	}
	function Z(F, he) {
		oe(F, he);
	}
	function oe(F, he) {
		var pe = j().box;
		function Fe(Ue) {
			Ue.target === pe && (Gc(pe, "remove", Fe), he());
		}
		if (F === 0) return he();
		Gc(pe, "remove", d), Gc(pe, "add", Fe), (d = Fe);
	}
	function ce(F, he, pe) {
		pe === void 0 && (pe = !1);
		var Fe = oi(h.props.triggerTarget || t);
		Fe.forEach(function (Ue) {
			Ue.addEventListener(F, he, pe),
				p.push({ node: Ue, eventType: F, handler: he, options: pe });
		});
	}
	function He() {
		T() &&
			(ce("touchstart", A, { passive: !0 }),
			ce("touchend", L, { passive: !0 })),
			VA(h.props.trigger).forEach(function (F) {
				if (F !== "manual")
					switch ((ce(F, A), F)) {
						case "mouseenter":
							ce("mouseleave", L);
							break;
						case "focus":
							ce(nO ? "focusout" : "blur", q);
							break;
						case "focusin":
							ce("focusout", q);
							break;
					}
			});
	}
	function Ye() {
		p.forEach(function (F) {
			var he = F.node,
				pe = F.eventType,
				Fe = F.handler,
				Ue = F.options;
			he.removeEventListener(pe, Fe, Ue);
		}),
			(p = []);
	}
	function A(F) {
		var he,
			pe = !1;
		if (!(!h.state.isEnabled || U(F) || l)) {
			var Fe = ((he = c) == null ? void 0 : he.type) === "focus";
			(c = F),
				(y = F.currentTarget),
				ie(),
				!h.state.isVisible &&
					qA(F) &&
					Al.forEach(function (Ue) {
						return Ue(F);
					}),
				F.type === "click" &&
				(h.props.trigger.indexOf("mouseenter") < 0 || s) &&
				h.props.hideOnClick !== !1 &&
				h.state.isVisible
					? (pe = !0)
					: G(F),
				F.type === "click" && (s = !pe),
				pe && !Fe && ue(F);
		}
	}
	function O(F) {
		var he = F.target,
			pe = P().contains(he) || g.contains(he);
		if (!(F.type === "mousemove" && pe)) {
			var Fe = te()
				.concat(g)
				.map(function (Ue) {
					var Xt,
						bn = Ue._tippy,
						Jo =
							(Xt = bn.popperInstance) == null
								? void 0
								: Xt.state;
					return Jo
						? {
								popperRect: Ue.getBoundingClientRect(),
								popperState: Jo,
								props: n,
						  }
						: null;
				})
				.filter(Boolean);
			QA(Fe, F) && (X(), ue(F));
		}
	}
	function L(F) {
		var he = U(F) || (h.props.trigger.indexOf("click") >= 0 && s);
		if (!he) {
			if (h.props.interactive) {
				h.hideWithInteractivity(F);
				return;
			}
			ue(F);
		}
	}
	function q(F) {
		(h.props.trigger.indexOf("focusin") < 0 && F.target !== P()) ||
			(h.props.interactive &&
				F.relatedTarget &&
				g.contains(F.relatedTarget)) ||
			ue(F);
	}
	function U(F) {
		return Qn.isTouch ? T() !== F.type.indexOf("touch") >= 0 : !1;
	}
	function ee() {
		ae();
		var F = h.props,
			he = F.popperOptions,
			pe = F.placement,
			Fe = F.offset,
			Ue = F.getReferenceClientRect,
			Xt = F.moveTransition,
			bn = R() ? rf(g).arrow : null,
			Jo = Ue
				? {
						getBoundingClientRect: Ue,
						contextElement: Ue.contextElement || P(),
				  }
				: t,
			ep = {
				name: "$$tippy",
				enabled: !0,
				phase: "beforeWrite",
				requires: ["computeStyles"],
				fn: function (ll) {
					var Go = ll.state;
					if (R()) {
						var pb = j(),
							oc = pb.box;
						["placement", "reference-hidden", "escaped"].forEach(
							function (al) {
								al === "placement"
									? oc.setAttribute(
											"data-placement",
											Go.placement
									  )
									: Go.attributes.popper["data-popper-" + al]
									? oc.setAttribute("data-" + al, "")
									: oc.removeAttribute("data-" + al);
							}
						),
							(Go.attributes.popper = {});
					}
				},
			},
			mo = [
				{ name: "offset", options: { offset: Fe } },
				{
					name: "preventOverflow",
					options: {
						padding: { top: 2, bottom: 2, left: 5, right: 5 },
					},
				},
				{ name: "flip", options: { padding: 5 } },
				{ name: "computeStyles", options: { adaptive: !Xt } },
				ep,
			];
		R() &&
			bn &&
			mo.push({ name: "arrow", options: { element: bn, padding: 3 } }),
			mo.push.apply(mo, (he == null ? void 0 : he.modifiers) || []),
			(h.popperInstance = Ly(
				Jo,
				g,
				Object.assign({}, he, {
					placement: pe,
					onFirstUpdate: f,
					modifiers: mo,
				})
			));
	}
	function ae() {
		h.popperInstance &&
			(h.popperInstance.destroy(), (h.popperInstance = null));
	}
	function Y() {
		var F = h.props.appendTo,
			he,
			pe = P();
		(h.props.interactive && F === k2) || F === "parent"
			? (he = pe.parentNode)
			: (he = S2(F, [pe])),
			he.contains(g) || he.appendChild(g),
			(h.state.isMounted = !0),
			ee();
	}
	function te() {
		return Da(g.querySelectorAll("[data-tippy-root]"));
	}
	function G(F) {
		h.clearDelayTimeouts(), F && $("onTrigger", [h, F]), Pe();
		var he = M(!0),
			pe = _(),
			Fe = pe[0],
			Ue = pe[1];
		Qn.isTouch && Fe === "hold" && Ue && (he = Ue),
			he
				? (r = setTimeout(function () {
						h.show();
				  }, he))
				: h.show();
	}
	function ue(F) {
		if (
			(h.clearDelayTimeouts(),
			$("onUntrigger", [h, F]),
			!h.state.isVisible)
		) {
			De();
			return;
		}
		if (
			!(
				h.props.trigger.indexOf("mouseenter") >= 0 &&
				h.props.trigger.indexOf("click") >= 0 &&
				["mouseleave", "mousemove"].indexOf(F.type) >= 0 &&
				s
			)
		) {
			var he = M(!1);
			he
				? (o = setTimeout(function () {
						h.state.isVisible && h.hide();
				  }, he))
				: (i = requestAnimationFrame(function () {
						h.hide();
				  }));
		}
	}
	function ye() {
		h.state.isEnabled = !0;
	}
	function me() {
		h.hide(), (h.state.isEnabled = !1);
	}
	function _e() {
		clearTimeout(r), clearTimeout(o), cancelAnimationFrame(i);
	}
	function $e(F) {
		if (!h.state.isDestroyed) {
			$("onBeforeUpdate", [h, F]), Ye();
			var he = h.props,
				pe = Dg(
					t,
					Object.assign({}, he, Rg(F), { ignoreAttributes: !0 })
				);
			(h.props = pe),
				He(),
				he.interactiveDebounce !== pe.interactiveDebounce &&
					(X(), (m = Ag(O, pe.interactiveDebounce))),
				he.triggerTarget && !pe.triggerTarget
					? oi(he.triggerTarget).forEach(function (Fe) {
							Fe.removeAttribute("aria-expanded");
					  })
					: pe.triggerTarget && t.removeAttribute("aria-expanded"),
				ie(),
				I(),
				x && x(he, pe),
				h.popperInstance &&
					(ee(),
					te().forEach(function (Fe) {
						requestAnimationFrame(
							Fe._tippy.popperInstance.forceUpdate
						);
					})),
				$("onAfterUpdate", [h, F]);
		}
	}
	function Qe(F) {
		h.setProps({ content: F });
	}
	function st() {
		var F = h.state.isVisible,
			he = h.state.isDestroyed,
			pe = !h.state.isEnabled,
			Fe = Qn.isTouch && !h.props.touch,
			Ue = qc(h.props.duration, 0, $n.duration);
		if (
			!(F || he || pe || Fe) &&
			!P().hasAttribute("disabled") &&
			($("onShow", [h], !1), h.props.onShow(h) !== !1)
		) {
			if (
				((h.state.isVisible = !0),
				R() && (g.style.visibility = "visible"),
				I(),
				Pe(),
				h.state.isMounted || (g.style.transition = "none"),
				R())
			) {
				var Xt = j(),
					bn = Xt.box,
					Jo = Xt.content;
				Jc([bn, Jo], 0);
			}
			(f = function () {
				var mo;
				if (!(!h.state.isVisible || u)) {
					if (
						((u = !0),
						g.offsetHeight,
						(g.style.transition = h.props.moveTransition),
						R() && h.props.animation)
					) {
						var rc = j(),
							ll = rc.box,
							Go = rc.content;
						Jc([ll, Go], Ue), Pg([ll, Go], "visible");
					}
					K(),
						ie(),
						Og(Yc, h),
						(mo = h.popperInstance) == null || mo.forceUpdate(),
						$("onMount", [h]),
						h.props.animation &&
							R() &&
							Z(Ue, function () {
								(h.state.isShown = !0), $("onShown", [h]);
							});
				}
			}),
				Y();
		}
	}
	function Ct() {
		var F = !h.state.isVisible,
			he = h.state.isDestroyed,
			pe = !h.state.isEnabled,
			Fe = qc(h.props.duration, 1, $n.duration);
		if (
			!(F || he || pe) &&
			($("onHide", [h], !1), h.props.onHide(h) !== !1)
		) {
			if (
				((h.state.isVisible = !1),
				(h.state.isShown = !1),
				(u = !1),
				(s = !1),
				R() && (g.style.visibility = "hidden"),
				X(),
				De(),
				I(!0),
				R())
			) {
				var Ue = j(),
					Xt = Ue.box,
					bn = Ue.content;
				h.props.animation && (Jc([Xt, bn], Fe), Pg([Xt, bn], "hidden"));
			}
			K(),
				ie(),
				h.props.animation ? R() && H(Fe, h.unmount) : h.unmount();
		}
	}
	function hn(F) {
		D().addEventListener("mousemove", m), Og(Al, m), m(F);
	}
	function Ar() {
		h.state.isVisible && h.hide(),
			h.state.isMounted &&
				(ae(),
				te().forEach(function (F) {
					F._tippy.unmount();
				}),
				g.parentNode && g.parentNode.removeChild(g),
				(Yc = Yc.filter(function (F) {
					return F !== h;
				})),
				(h.state.isMounted = !1),
				$("onHidden", [h]));
	}
	function sl() {
		h.state.isDestroyed ||
			(h.clearDelayTimeouts(),
			h.unmount(),
			Ye(),
			delete t._tippy,
			(h.state.isDestroyed = !0),
			$("onDestroy", [h]));
	}
}
function qo(t, e) {
	e === void 0 && (e = {});
	var n = $n.plugins.concat(e.plugins || []);
	eO();
	var r = Object.assign({}, e, { plugins: n }),
		o = GA(t),
		i = o.reduce(function (s, l) {
			var a = l && cO(l, r);
			return a && s.push(a), s;
		}, []);
	return Xu(t) ? i[0] : i;
}
qo.defaultProps = $n;
qo.setDefaultProps = sO;
qo.currentInput = Qn;
Object.assign({}, Ay, {
	effect: function (e) {
		var n = e.state,
			r = {
				popper: {
					position: n.options.strategy,
					left: "0",
					top: "0",
					margin: "0",
				},
				arrow: { position: "absolute" },
				reference: {},
			};
		Object.assign(n.elements.popper.style, r.popper),
			(n.styles = r),
			n.elements.arrow && Object.assign(n.elements.arrow.style, r.arrow);
	},
});
qo.setDefaultProps({ render: M2 });
class dO {
	constructor({
		editor: e,
		element: n,
		view: r,
		tippyOptions: o = {},
		updateDelay: i = 250,
		shouldShow: s,
	}) {
		(this.preventHide = !1),
			(this.shouldShow = ({ view: l, state: a, from: u, to: c }) => {
				const { doc: d, selection: f } = a,
					{ empty: p } = f,
					m = !d.textBetween(u, c).length && Th(a.selection),
					y = this.element.contains(document.activeElement);
				return !(
					!(l.hasFocus() || y) ||
					p ||
					m ||
					!this.editor.isEditable
				);
			}),
			(this.mousedownHandler = () => {
				this.preventHide = !0;
			}),
			(this.dragstartHandler = () => {
				this.hide();
			}),
			(this.focusHandler = () => {
				setTimeout(() => this.update(this.editor.view));
			}),
			(this.blurHandler = ({ event: l }) => {
				var a;
				if (this.preventHide) {
					this.preventHide = !1;
					return;
				}
				(l != null &&
					l.relatedTarget &&
					!((a = this.element.parentNode) === null || a === void 0) &&
					a.contains(l.relatedTarget)) ||
					this.hide();
			}),
			(this.tippyBlurHandler = (l) => {
				this.blurHandler({ event: l });
			}),
			(this.handleDebouncedUpdate = (l, a) => {
				const u = !(a != null && a.selection.eq(l.state.selection)),
					c = !(a != null && a.doc.eq(l.state.doc));
				(!u && !c) ||
					(this.updateDebounceTimer &&
						clearTimeout(this.updateDebounceTimer),
					(this.updateDebounceTimer = window.setTimeout(() => {
						this.updateHandler(l, u, c, a);
					}, this.updateDelay)));
			}),
			(this.updateHandler = (l, a, u, c) => {
				var d, f, p;
				const { state: m, composing: y } = l,
					{ selection: v } = m;
				if (y || (!a && !u)) return;
				this.createTooltip();
				const { ranges: S } = v,
					E = Math.min(...S.map((g) => g.$from.pos)),
					h = Math.max(...S.map((g) => g.$to.pos));
				if (
					!((d = this.shouldShow) === null || d === void 0
						? void 0
						: d.call(this, {
								editor: this.editor,
								view: l,
								state: m,
								oldState: c,
								from: E,
								to: h,
						  }))
				) {
					this.hide();
					return;
				}
				(f = this.tippy) === null ||
					f === void 0 ||
					f.setProps({
						getReferenceClientRect:
							((p = this.tippyOptions) === null || p === void 0
								? void 0
								: p.getReferenceClientRect) ||
							(() => {
								if (cA(m.selection)) {
									let g = l.nodeDOM(E);
									const x = g.dataset.nodeViewWrapper
										? g
										: g.querySelector(
												"[data-node-view-wrapper]"
										  );
									if ((x && (g = x.firstChild), g))
										return g.getBoundingClientRect();
								}
								return y2(l, E, h);
							}),
					}),
					this.show();
			}),
			(this.editor = e),
			(this.element = n),
			(this.view = r),
			(this.updateDelay = i),
			s && (this.shouldShow = s),
			this.element.addEventListener("mousedown", this.mousedownHandler, {
				capture: !0,
			}),
			this.view.dom.addEventListener("dragstart", this.dragstartHandler),
			this.editor.on("focus", this.focusHandler),
			this.editor.on("blur", this.blurHandler),
			(this.tippyOptions = o),
			this.element.remove(),
			(this.element.style.visibility = "visible");
	}
	createTooltip() {
		const { element: e } = this.editor.options,
			n = !!e.parentElement;
		this.tippy ||
			!n ||
			((this.tippy = qo(
				e,
				B(
					{
						duration: 0,
						getReferenceClientRect: null,
						content: this.element,
						interactive: !0,
						trigger: "manual",
						placement: "top",
						hideOnClick: "toggle",
					},
					this.tippyOptions
				)
			)),
			this.tippy.popper.firstChild &&
				this.tippy.popper.firstChild.addEventListener(
					"blur",
					this.tippyBlurHandler
				));
	}
	update(e, n) {
		const { state: r } = e,
			o = r.selection.$from.pos !== r.selection.$to.pos;
		if (this.updateDelay > 0 && o) {
			this.handleDebouncedUpdate(e, n);
			return;
		}
		const i = !(n != null && n.selection.eq(e.state.selection)),
			s = !(n != null && n.doc.eq(e.state.doc));
		this.updateHandler(e, i, s, n);
	}
	show() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.show();
	}
	hide() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.hide();
	}
	destroy() {
		var e, n;
		!((e = this.tippy) === null || e === void 0) &&
			e.popper.firstChild &&
			this.tippy.popper.firstChild.removeEventListener(
				"blur",
				this.tippyBlurHandler
			),
			(n = this.tippy) === null || n === void 0 || n.destroy(),
			this.element.removeEventListener(
				"mousedown",
				this.mousedownHandler,
				{ capture: !0 }
			),
			this.view.dom.removeEventListener(
				"dragstart",
				this.dragstartHandler
			),
			this.editor.off("focus", this.focusHandler),
			this.editor.off("blur", this.blurHandler);
	}
}
const E2 = (t) =>
	new kt({
		key: typeof t.pluginKey == "string" ? new Dt(t.pluginKey) : t.pluginKey,
		view: (e) => new dO(B({ view: e }, t)),
	});
Nt.create({
	name: "bubbleMenu",
	addOptions() {
		return {
			element: null,
			tippyOptions: {},
			pluginKey: "bubbleMenu",
			updateDelay: void 0,
			shouldShow: null,
		};
	},
	addProseMirrorPlugins() {
		return this.options.element
			? [
					E2({
						pluginKey: this.options.pluginKey,
						editor: this.editor,
						element: this.options.element,
						tippyOptions: this.options.tippyOptions,
						updateDelay: this.options.updateDelay,
						shouldShow: this.options.shouldShow,
					}),
			  ]
			: [];
	},
});
class fO {
	constructor({
		editor: e,
		element: n,
		view: r,
		tippyOptions: o = {},
		shouldShow: i,
	}) {
		(this.preventHide = !1),
			(this.shouldShow = ({ view: s, state: l }) => {
				const { selection: a } = l,
					{ $anchor: u, empty: c } = a,
					d = u.depth === 1,
					f =
						u.parent.isTextblock &&
						!u.parent.type.spec.code &&
						!u.parent.textContent;
				return !(
					!s.hasFocus() ||
					!c ||
					!d ||
					!f ||
					!this.editor.isEditable
				);
			}),
			(this.mousedownHandler = () => {
				this.preventHide = !0;
			}),
			(this.focusHandler = () => {
				setTimeout(() => this.update(this.editor.view));
			}),
			(this.blurHandler = ({ event: s }) => {
				var l;
				if (this.preventHide) {
					this.preventHide = !1;
					return;
				}
				(s != null &&
					s.relatedTarget &&
					!((l = this.element.parentNode) === null || l === void 0) &&
					l.contains(s.relatedTarget)) ||
					this.hide();
			}),
			(this.tippyBlurHandler = (s) => {
				this.blurHandler({ event: s });
			}),
			(this.editor = e),
			(this.element = n),
			(this.view = r),
			i && (this.shouldShow = i),
			this.element.addEventListener("mousedown", this.mousedownHandler, {
				capture: !0,
			}),
			this.editor.on("focus", this.focusHandler),
			this.editor.on("blur", this.blurHandler),
			(this.tippyOptions = o),
			this.element.remove(),
			(this.element.style.visibility = "visible");
	}
	createTooltip() {
		const { element: e } = this.editor.options,
			n = !!e.parentElement;
		this.tippy ||
			!n ||
			((this.tippy = qo(
				e,
				B(
					{
						duration: 0,
						getReferenceClientRect: null,
						content: this.element,
						interactive: !0,
						trigger: "manual",
						placement: "right",
						hideOnClick: "toggle",
					},
					this.tippyOptions
				)
			)),
			this.tippy.popper.firstChild &&
				this.tippy.popper.firstChild.addEventListener(
					"blur",
					this.tippyBlurHandler
				));
	}
	update(e, n) {
		var r, o, i;
		const { state: s } = e,
			{ doc: l, selection: a } = s,
			{ from: u, to: c } = a;
		if (n && n.doc.eq(l) && n.selection.eq(a)) return;
		if (
			(this.createTooltip(),
			!((r = this.shouldShow) === null || r === void 0
				? void 0
				: r.call(this, {
						editor: this.editor,
						view: e,
						state: s,
						oldState: n,
				  })))
		) {
			this.hide();
			return;
		}
		(o = this.tippy) === null ||
			o === void 0 ||
			o.setProps({
				getReferenceClientRect:
					((i = this.tippyOptions) === null || i === void 0
						? void 0
						: i.getReferenceClientRect) || (() => y2(e, u, c)),
			}),
			this.show();
	}
	show() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.show();
	}
	hide() {
		var e;
		(e = this.tippy) === null || e === void 0 || e.hide();
	}
	destroy() {
		var e, n;
		!((e = this.tippy) === null || e === void 0) &&
			e.popper.firstChild &&
			this.tippy.popper.firstChild.removeEventListener(
				"blur",
				this.tippyBlurHandler
			),
			(n = this.tippy) === null || n === void 0 || n.destroy(),
			this.element.removeEventListener(
				"mousedown",
				this.mousedownHandler,
				{ capture: !0 }
			),
			this.editor.off("focus", this.focusHandler),
			this.editor.off("blur", this.blurHandler);
	}
}
const T2 = (t) =>
	new kt({
		key: typeof t.pluginKey == "string" ? new Dt(t.pluginKey) : t.pluginKey,
		view: (e) => new fO(B({ view: e }, t)),
	});
Nt.create({
	name: "floatingMenu",
	addOptions() {
		return {
			element: null,
			tippyOptions: {},
			pluginKey: "floatingMenu",
			shouldShow: null,
		};
	},
	addProseMirrorPlugins() {
		return this.options.element
			? [
					T2({
						pluginKey: this.options.pluginKey,
						editor: this.editor,
						element: this.options.element,
						tippyOptions: this.options.tippyOptions,
						shouldShow: this.options.shouldShow,
					}),
			  ]
			: [];
	},
});
const hO = Oe({
	name: "BubbleMenu",
	props: {
		pluginKey: { type: [String, Object], default: "bubbleMenu" },
		editor: { type: Object, required: !0 },
		updateDelay: { type: Number, default: void 0 },
		tippyOptions: { type: Object, default: () => ({}) },
		shouldShow: { type: Function, default: null },
	},
	setup(t, { slots: e }) {
		const n = Q(null);
		return (
			Ze(() => {
				const {
					updateDelay: r,
					editor: o,
					pluginKey: i,
					shouldShow: s,
					tippyOptions: l,
				} = t;
				o.registerPlugin(
					E2({
						updateDelay: r,
						editor: o,
						element: n.value,
						pluginKey: i,
						shouldShow: s,
						tippyOptions: l,
					})
				);
			}),
			qs(() => {
				const { pluginKey: r, editor: o } = t;
				o.unregisterPlugin(r);
			}),
			() => {
				var r;
				return Ke(
					"div",
					{ ref: n },
					(r = e.default) === null || r === void 0
						? void 0
						: r.call(e)
				);
			}
		);
	},
});
function $g(t) {
	return e0((e, n) => ({
		get() {
			return e(), t;
		},
		set(r) {
			(t = r),
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						n();
					});
				});
		},
	}));
}
class pO extends BA {
	constructor(e = {}) {
		return (
			super(e),
			(this.vueRenderers = Yt(new Map())),
			(this.contentComponent = null),
			(this.reactiveState = $g(this.view.state)),
			(this.reactiveExtensionStorage = $g(this.extensionStorage)),
			this.on("transaction", () => {
				(this.reactiveState.value = this.view.state),
					(this.reactiveExtensionStorage.value =
						this.extensionStorage);
			}),
			vu(this)
		);
	}
	get state() {
		return this.reactiveState ? this.reactiveState.value : this.view.state;
	}
	get storage() {
		return this.reactiveExtensionStorage
			? this.reactiveExtensionStorage.value
			: super.storage;
	}
	registerPlugin(e, n) {
		super.registerPlugin(e, n),
			(this.reactiveState.value = this.view.state);
	}
	unregisterPlugin(e) {
		super.unregisterPlugin(e), (this.reactiveState.value = this.view.state);
	}
}
const mO = Oe({
		name: "EditorContent",
		props: { editor: { default: null, type: Object } },
		setup(t) {
			const e = Q(),
				n = uo();
			return (
				xt(() => {
					const r = t.editor;
					r &&
						r.options.element &&
						e.value &&
						bt(() => {
							if (!e.value || !r.options.element.firstChild)
								return;
							const o = ne(e.value);
							e.value.append(...r.options.element.childNodes),
								(r.contentComponent = n.ctx._),
								r.setOptions({ element: o }),
								r.createNodeViews();
						});
				}),
				qs(() => {
					const r = t.editor;
					if (
						!r ||
						(r.isDestroyed || r.view.setProps({ nodeViews: {} }),
						(r.contentComponent = null),
						!r.options.element.firstChild)
					)
						return;
					const o = document.createElement("div");
					o.append(...r.options.element.childNodes),
						r.setOptions({ element: o });
				}),
				{ rootEl: e }
			);
		},
		render() {
			const t = [];
			return (
				this.editor &&
					this.editor.vueRenderers.forEach((e) => {
						const n = Ke(
							_u,
							{ to: e.teleportElement, key: e.id },
							Ke(e.component, B({ ref: e.id }, e.props))
						);
						t.push(n);
					}),
				Ke(
					"div",
					{
						ref: (e) => {
							this.rootEl = e;
						},
					},
					...t
				)
			);
		},
	}),
	gO = Oe({
		name: "FloatingMenu",
		props: {
			pluginKey: { type: null, default: "floatingMenu" },
			editor: { type: Object, required: !0 },
			tippyOptions: { type: Object, default: () => ({}) },
			shouldShow: { type: Function, default: null },
		},
		setup(t, { slots: e }) {
			const n = Q(null);
			return (
				Ze(() => {
					const {
						pluginKey: r,
						editor: o,
						tippyOptions: i,
						shouldShow: s,
					} = t;
					o.registerPlugin(
						T2({
							pluginKey: r,
							editor: o,
							element: n.value,
							tippyOptions: i,
							shouldShow: s,
						})
					);
				}),
				qs(() => {
					const { pluginKey: r, editor: o } = t;
					o.unregisterPlugin(r);
				}),
				() => {
					var r;
					return Ke(
						"div",
						{ ref: n },
						(r = e.default) === null || r === void 0
							? void 0
							: r.call(e)
					);
				}
			);
		},
	});
class yO {
	constructor(e, { props: n = {}, editor: r }) {
		if (
			((this.id = Math.floor(Math.random() * 4294967295).toString()),
			(this.editor = r),
			(this.component = vu(e)),
			(this.teleportElement = document.createElement("div")),
			(this.element = this.teleportElement),
			(this.props = Yt(n)),
			this.editor.vueRenderers.set(this.id, this),
			this.editor.contentComponent)
		) {
			if (
				(this.editor.contentComponent.update(),
				this.teleportElement.children.length !== 1)
			)
				throw Error(
					"VueRenderer doesnt support multiple child elements."
				);
			this.element = this.teleportElement.firstElementChild;
		}
	}
	get ref() {
		var e;
		return (e = this.editor.contentComponent) === null || e === void 0
			? void 0
			: e.refs[this.id];
	}
	updateProps(e = {}) {
		Object.entries(e).forEach(([n, r]) => {
			this.props[n] = r;
		});
	}
	destroy() {
		this.editor.vueRenderers.delete(this.id);
	}
}
const vO = /^\s*>\s$/,
	bO = Pt.create({
		name: "blockquote",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		group: "block",
		defining: !0,
		parseHTML() {
			return [{ tag: "blockquote" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["blockquote", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBlockquote:
					() =>
					({ commands: t }) =>
						t.wrapIn(this.name),
				toggleBlockquote:
					() =>
					({ commands: t }) =>
						t.toggleWrap(this.name),
				unsetBlockquote:
					() =>
					({ commands: t }) =>
						t.lift(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-b": () => this.editor.commands.toggleBlockquote(),
			};
		},
		addInputRules() {
			return [Hs({ find: vO, type: this.type })];
		},
	}),
	wO = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,
	xO = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,
	kO = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,
	SO = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g,
	_O = vn.create({
		name: "bold",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "strong" },
				{
					tag: "b",
					getAttrs: (t) => t.style.fontWeight !== "normal" && null,
				},
				{
					style: "font-weight",
					getAttrs: (t) =>
						/^(bold(er)?|[5-9]\d{2,})$/.test(t) && null,
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["strong", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setBold:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleBold:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetBold:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-b": () => this.editor.commands.toggleBold(),
				"Mod-B": () => this.editor.commands.toggleBold(),
			};
		},
		addInputRules() {
			return [
				Vo({ find: wO, type: this.type }),
				Vo({ find: kO, type: this.type }),
			];
		},
		addPasteRules() {
			return [
				so({ find: xO, type: this.type }),
				so({ find: SO, type: this.type }),
			];
		},
	}),
	CO = Pt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", et(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	Bg = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = il(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	zg = /^\s*([-+*])\s$/,
	MO = Pt.create({
		name: "bulletList",
		addOptions() {
			return {
				itemTypeName: "listItem",
				HTMLAttributes: {},
				keepMarks: !1,
				keepAttributes: !1,
			};
		},
		group: "block list",
		content() {
			return `${this.options.itemTypeName}+`;
		},
		parseHTML() {
			return [{ tag: "ul" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["ul", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleBulletList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(
										this.name,
										this.options.itemTypeName,
										this.options.keepMarks
									)
									.updateAttributes(
										CO.name,
										this.editor.getAttributes(Bg.name)
									)
									.run()
							: t.toggleList(
									this.name,
									this.options.itemTypeName,
									this.options.keepMarks
							  ),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-8": () => this.editor.commands.toggleBulletList(),
			};
		},
		addInputRules() {
			let t = Hs({ find: zg, type: this.type });
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Hs({
						find: zg,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: () => this.editor.getAttributes(Bg.name),
						editor: this.editor,
					})),
				[t]
			);
		},
	}),
	EO = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/,
	TO = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g,
	AO = vn.create({
		name: "code",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		excludes: "_",
		code: !0,
		exitable: !0,
		parseHTML() {
			return [{ tag: "code" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["code", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setCode:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleCode:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetCode:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return { "Mod-e": () => this.editor.commands.toggleCode() };
		},
		addInputRules() {
			return [Vo({ find: EO, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: TO, type: this.type })];
		},
	}),
	OO = /^```([a-z]+)?[\s\n]$/,
	RO = /^~~~([a-z]+)?[\s\n]$/,
	PO = Pt.create({
		name: "codeBlock",
		addOptions() {
			return {
				languageClassPrefix: "language-",
				exitOnTripleEnter: !0,
				exitOnArrowDown: !0,
				HTMLAttributes: {},
			};
		},
		content: "text*",
		marks: "",
		group: "block",
		code: !0,
		defining: !0,
		addAttributes() {
			return {
				language: {
					default: null,
					parseHTML: (t) => {
						var e;
						const { languageClassPrefix: n } = this.options,
							i = [
								...(((e = t.firstElementChild) === null ||
								e === void 0
									? void 0
									: e.classList) || []),
							]
								.filter((s) => s.startsWith(n))
								.map((s) => s.replace(n, ""))[0];
						return i || null;
					},
					rendered: !1,
				},
			};
		},
		parseHTML() {
			return [{ tag: "pre", preserveWhitespace: "full" }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				"pre",
				et(this.options.HTMLAttributes, e),
				[
					"code",
					{
						class: t.attrs.language
							? this.options.languageClassPrefix +
							  t.attrs.language
							: null,
					},
					0,
				],
			];
		},
		addCommands() {
			return {
				setCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.setNode(this.name, t),
				toggleCodeBlock:
					(t) =>
					({ commands: e }) =>
						e.toggleNode(this.name, "paragraph", t),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
				Backspace: () => {
					const { empty: t, $anchor: e } =
							this.editor.state.selection,
						n = e.pos === 1;
					return !t || e.parent.type.name !== this.name
						? !1
						: n || !e.parent.textContent.length
						? this.editor.commands.clearNodes()
						: !1;
				},
				Enter: ({ editor: t }) => {
					if (!this.options.exitOnTripleEnter) return !1;
					const { state: e } = t,
						{ selection: n } = e,
						{ $from: r, empty: o } = n;
					if (!o || r.parent.type !== this.type) return !1;
					const i = r.parentOffset === r.parent.nodeSize - 2,
						s = r.parent.textContent.endsWith(`

`);
					return !i || !s
						? !1
						: t
								.chain()
								.command(
									({ tr: l }) => (
										l.delete(r.pos - 2, r.pos), !0
									)
								)
								.exitCode()
								.run();
				},
				ArrowDown: ({ editor: t }) => {
					if (!this.options.exitOnArrowDown) return !1;
					const { state: e } = t,
						{ selection: n, doc: r } = e,
						{ $from: o, empty: i } = n;
					if (
						!i ||
						o.parent.type !== this.type ||
						!(o.parentOffset === o.parent.nodeSize - 2)
					)
						return !1;
					const l = o.after();
					return l === void 0 || r.nodeAt(l)
						? !1
						: t.commands.exitCode();
				},
			};
		},
		addInputRules() {
			return [
				ef({
					find: OO,
					type: this.type,
					getAttributes: (t) => ({ language: t[1] }),
				}),
				ef({
					find: RO,
					type: this.type,
					getAttributes: (t) => ({ language: t[1] }),
				}),
			];
		},
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("codeBlockVSCodeHandler"),
					props: {
						handlePaste: (t, e) => {
							if (
								!e.clipboardData ||
								this.editor.isActive(this.type.name)
							)
								return !1;
							const n = e.clipboardData.getData("text/plain"),
								r =
									e.clipboardData.getData(
										"vscode-editor-data"
									),
								o = r ? JSON.parse(r) : void 0,
								i = o == null ? void 0 : o.mode;
							if (!n || !i) return !1;
							const { tr: s } = t.state;
							return (
								s.replaceSelectionWith(
									this.type.create({ language: i })
								),
								s.setSelection(
									Se.near(
										s.doc.resolve(
											Math.max(0, s.selection.from - 2)
										)
									)
								),
								s.insertText(
									n.replace(
										/\r\n?/g,
										`
`
									)
								),
								s.setMeta("paste", !0),
								t.dispatch(s),
								!0
							);
						},
					},
				}),
			];
		},
	}),
	IO = Pt.create({ name: "doc", topNode: !0, content: "block+" });
function NO(t = {}) {
	return new kt({
		view(e) {
			return new DO(e, t);
		},
	});
}
class DO {
	constructor(e, n) {
		var r;
		(this.editorView = e),
			(this.cursorPos = null),
			(this.element = null),
			(this.timeout = -1),
			(this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
			(this.color = n.color === !1 ? void 0 : n.color || "black"),
			(this.class = n.class),
			(this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(
				(o) => {
					let i = (s) => {
						this[o](s);
					};
					return (
						e.dom.addEventListener(o, i), { name: o, handler: i }
					);
				}
			));
	}
	destroy() {
		this.handlers.forEach(({ name: e, handler: n }) =>
			this.editorView.dom.removeEventListener(e, n)
		);
	}
	update(e, n) {
		this.cursorPos != null &&
			n.doc != e.state.doc &&
			(this.cursorPos > e.state.doc.content.size
				? this.setCursor(null)
				: this.updateOverlay());
	}
	setCursor(e) {
		e != this.cursorPos &&
			((this.cursorPos = e),
			e == null
				? (this.element.parentNode.removeChild(this.element),
				  (this.element = null))
				: this.updateOverlay());
	}
	updateOverlay() {
		let e = this.editorView.state.doc.resolve(this.cursorPos),
			n = !e.parent.inlineContent,
			r;
		if (n) {
			let l = e.nodeBefore,
				a = e.nodeAfter;
			if (l || a) {
				let u = this.editorView.nodeDOM(
					this.cursorPos - (l ? l.nodeSize : 0)
				);
				if (u) {
					let c = u.getBoundingClientRect(),
						d = l ? c.bottom : c.top;
					l &&
						a &&
						(d =
							(d +
								this.editorView
									.nodeDOM(this.cursorPos)
									.getBoundingClientRect().top) /
							2),
						(r = {
							left: c.left,
							right: c.right,
							top: d - this.width / 2,
							bottom: d + this.width / 2,
						});
				}
			}
		}
		if (!r) {
			let l = this.editorView.coordsAtPos(this.cursorPos);
			r = {
				left: l.left - this.width / 2,
				right: l.left + this.width / 2,
				top: l.top,
				bottom: l.bottom,
			};
		}
		let o = this.editorView.dom.offsetParent;
		this.element ||
			((this.element = o.appendChild(document.createElement("div"))),
			this.class && (this.element.className = this.class),
			(this.element.style.cssText =
				"position: absolute; z-index: 50; pointer-events: none;"),
			this.color && (this.element.style.backgroundColor = this.color)),
			this.element.classList.toggle("prosemirror-dropcursor-block", n),
			this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
		let i, s;
		if (
			!o ||
			(o == document.body && getComputedStyle(o).position == "static")
		)
			(i = -pageXOffset), (s = -pageYOffset);
		else {
			let l = o.getBoundingClientRect();
			(i = l.left - o.scrollLeft), (s = l.top - o.scrollTop);
		}
		(this.element.style.left = r.left - i + "px"),
			(this.element.style.top = r.top - s + "px"),
			(this.element.style.width = r.right - r.left + "px"),
			(this.element.style.height = r.bottom - r.top + "px");
	}
	scheduleRemoval(e) {
		clearTimeout(this.timeout),
			(this.timeout = setTimeout(() => this.setCursor(null), e));
	}
	dragover(e) {
		if (!this.editorView.editable) return;
		let n = this.editorView.posAtCoords({
				left: e.clientX,
				top: e.clientY,
			}),
			r =
				n &&
				n.inside >= 0 &&
				this.editorView.state.doc.nodeAt(n.inside),
			o = r && r.type.spec.disableDropCursor,
			i = typeof o == "function" ? o(this.editorView, n, e) : o;
		if (n && !i) {
			let s = n.pos;
			if (this.editorView.dragging && this.editorView.dragging.slice) {
				let l = mv(
					this.editorView.state.doc,
					s,
					this.editorView.dragging.slice
				);
				l != null && (s = l);
			}
			this.setCursor(s), this.scheduleRemoval(5e3);
		}
	}
	dragend() {
		this.scheduleRemoval(20);
	}
	drop() {
		this.scheduleRemoval(20);
	}
	dragleave(e) {
		(e.target == this.editorView.dom ||
			!this.editorView.dom.contains(e.relatedTarget)) &&
			this.setCursor(null);
	}
}
const jO = Nt.create({
	name: "dropCursor",
	addOptions() {
		return { color: "currentColor", width: 1, class: void 0 };
	},
	addProseMirrorPlugins() {
		return [NO(this.options)];
	},
});
class yt extends Me {
	constructor(e) {
		super(e, e);
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		return yt.valid(r) ? new yt(r) : Me.near(r);
	}
	content() {
		return le.empty;
	}
	eq(e) {
		return e instanceof yt && e.head == this.head;
	}
	toJSON() {
		return { type: "gapcursor", pos: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for GapCursor.fromJSON");
		return new yt(e.resolve(n.pos));
	}
	getBookmark() {
		return new Nh(this.anchor);
	}
	static valid(e) {
		let n = e.parent;
		if (n.isTextblock || !LO(e) || !$O(e)) return !1;
		let r = n.type.spec.allowGapCursor;
		if (r != null) return r;
		let o = n.contentMatchAt(e.index()).defaultType;
		return o && o.isTextblock;
	}
	static findGapCursorFrom(e, n, r = !1) {
		e: for (;;) {
			if (!r && yt.valid(e)) return e;
			let o = e.pos,
				i = null;
			for (let s = e.depth; ; s--) {
				let l = e.node(s);
				if (n > 0 ? e.indexAfter(s) < l.childCount : e.index(s) > 0) {
					i = l.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
					break;
				} else if (s == 0) return null;
				o += n;
				let a = e.doc.resolve(o);
				if (yt.valid(a)) return a;
			}
			for (;;) {
				let s = n > 0 ? i.firstChild : i.lastChild;
				if (!s) {
					if (i.isAtom && !i.isText && !we.isSelectable(i)) {
						(e = e.doc.resolve(o + i.nodeSize * n)), (r = !1);
						continue e;
					}
					break;
				}
				(i = s), (o += n);
				let l = e.doc.resolve(o);
				if (yt.valid(l)) return l;
			}
			return null;
		}
	}
}
yt.prototype.visible = !1;
yt.findFrom = yt.findGapCursorFrom;
Me.jsonID("gapcursor", yt);
class Nh {
	constructor(e) {
		this.pos = e;
	}
	map(e) {
		return new Nh(e.map(this.pos));
	}
	resolve(e) {
		let n = e.resolve(this.pos);
		return yt.valid(n) ? new yt(n) : Me.near(n);
	}
}
function LO(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.index(e),
			r = t.node(e);
		if (n == 0) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let o = r.child(n - 1); ; o = o.lastChild) {
			if (
				(o.childCount == 0 && !o.inlineContent) ||
				o.isAtom ||
				o.type.spec.isolating
			)
				return !0;
			if (o.inlineContent) return !1;
		}
	}
	return !0;
}
function $O(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.indexAfter(e),
			r = t.node(e);
		if (n == r.childCount) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let o = r.child(n); ; o = o.firstChild) {
			if (
				(o.childCount == 0 && !o.inlineContent) ||
				o.isAtom ||
				o.type.spec.isolating
			)
				return !0;
			if (o.inlineContent) return !1;
		}
	}
	return !0;
}
function BO() {
	return new kt({
		props: {
			decorations: VO,
			createSelectionBetween(t, e, n) {
				return e.pos == n.pos && yt.valid(n) ? new yt(n) : null;
			},
			handleClick: HO,
			handleKeyDown: zO,
			handleDOMEvents: { beforeinput: FO },
		},
	});
}
const zO = Sh({
	ArrowLeft: Ol("horiz", -1),
	ArrowRight: Ol("horiz", 1),
	ArrowUp: Ol("vert", -1),
	ArrowDown: Ol("vert", 1),
});
function Ol(t, e) {
	const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
	return function (r, o, i) {
		let s = r.selection,
			l = e > 0 ? s.$to : s.$from,
			a = s.empty;
		if (s instanceof Se) {
			if (!i.endOfTextblock(n) || l.depth == 0) return !1;
			(a = !1), (l = r.doc.resolve(e > 0 ? l.after() : l.before()));
		}
		let u = yt.findGapCursorFrom(l, e, a);
		return u ? (o && o(r.tr.setSelection(new yt(u))), !0) : !1;
	};
}
function HO(t, e, n) {
	if (!t || !t.editable) return !1;
	let r = t.state.doc.resolve(e);
	if (!yt.valid(r)) return !1;
	let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
	return o && o.inside > -1 && we.isSelectable(t.state.doc.nodeAt(o.inside))
		? !1
		: (t.dispatch(t.state.tr.setSelection(new yt(r))), !0);
}
function FO(t, e) {
	if (
		e.inputType != "insertCompositionText" ||
		!(t.state.selection instanceof yt)
	)
		return !1;
	let { $from: n } = t.state.selection,
		r = n.parent
			.contentMatchAt(n.index())
			.findWrapping(t.state.schema.nodes.text);
	if (!r) return !1;
	let o = J.empty;
	for (let s = r.length - 1; s >= 0; s--)
		o = J.from(r[s].createAndFill(null, o));
	let i = t.state.tr.replace(n.pos, n.pos, new le(o, 0, 0));
	return i.setSelection(Se.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function VO(t) {
	if (!(t.selection instanceof yt)) return null;
	let e = document.createElement("div");
	return (
		(e.className = "ProseMirror-gapcursor"),
		ft.create(t.doc, [qt.widget(t.selection.head, e, { key: "gapcursor" })])
	);
}
const WO = Nt.create({
		name: "gapCursor",
		addProseMirrorPlugins() {
			return [BO()];
		},
		extendNodeSchema(t) {
			var e;
			const n = { name: t.name, options: t.options, storage: t.storage };
			return {
				allowGapCursor:
					(e = Be(fe(t, "allowGapCursor", n))) !== null &&
					e !== void 0
						? e
						: null,
			};
		},
	}),
	UO = Pt.create({
		name: "hardBreak",
		addOptions() {
			return { keepMarks: !0, HTMLAttributes: {} };
		},
		inline: !0,
		group: "inline",
		selectable: !1,
		parseHTML() {
			return [{ tag: "br" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["br", et(this.options.HTMLAttributes, t)];
		},
		renderText() {
			return `
`;
		},
		addCommands() {
			return {
				setHardBreak:
					() =>
					({ commands: t, chain: e, state: n, editor: r }) =>
						t.first([
							() => t.exitCode(),
							() =>
								t.command(() => {
									const { selection: o, storedMarks: i } = n;
									if (o.$from.parent.type.spec.isolating)
										return !1;
									const { keepMarks: s } = this.options,
										{ splittableMarks: l } =
											r.extensionManager,
										a =
											i ||
											(o.$to.parentOffset &&
												o.$from.marks());
									return e()
										.insertContent({ type: this.name })
										.command(({ tr: u, dispatch: c }) => {
											if (c && a && s) {
												const d = a.filter((f) =>
													l.includes(f.type.name)
												);
												u.ensureMarks(d);
											}
											return !0;
										})
										.run();
								}),
						]),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Enter": () => this.editor.commands.setHardBreak(),
				"Shift-Enter": () => this.editor.commands.setHardBreak(),
			};
		},
	}),
	KO = Pt.create({
		name: "heading",
		addOptions() {
			return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} };
		},
		content: "inline*",
		group: "block",
		defining: !0,
		addAttributes() {
			return { level: { default: 1, rendered: !1 } };
		},
		parseHTML() {
			return this.options.levels.map((t) => ({
				tag: `h${t}`,
				attrs: { level: t },
			}));
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			return [
				`h${
					this.options.levels.includes(t.attrs.level)
						? t.attrs.level
						: this.options.levels[0]
				}`,
				et(this.options.HTMLAttributes, e),
				0,
			];
		},
		addCommands() {
			return {
				setHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level)
							? e.setNode(this.name, t)
							: !1,
				toggleHeading:
					(t) =>
					({ commands: e }) =>
						this.options.levels.includes(t.level)
							? e.toggleNode(this.name, "paragraph", t)
							: !1,
			};
		},
		addKeyboardShortcuts() {
			return this.options.levels.reduce(
				(t, e) =>
					ge(B({}, t), {
						[`Mod-Alt-${e}`]: () =>
							this.editor.commands.toggleHeading({ level: e }),
					}),
				{}
			);
		},
		addInputRules() {
			return this.options.levels.map((t) =>
				ef({
					find: new RegExp(`^(#{1,${t}})\\s$`),
					type: this.type,
					getAttributes: { level: t },
				})
			);
		},
	});
var ja = 200,
	Bt = function () {};
Bt.prototype.append = function (e) {
	return e.length
		? ((e = Bt.from(e)),
		  (!this.length && e) ||
				(e.length < ja && this.leafAppend(e)) ||
				(this.length < ja && e.leafPrepend(this)) ||
				this.appendInner(e))
		: this;
};
Bt.prototype.prepend = function (e) {
	return e.length ? Bt.from(e).append(this) : this;
};
Bt.prototype.appendInner = function (e) {
	return new qO(this, e);
};
Bt.prototype.slice = function (e, n) {
	return (
		e === void 0 && (e = 0),
		n === void 0 && (n = this.length),
		e >= n
			? Bt.empty
			: this.sliceInner(Math.max(0, e), Math.min(this.length, n))
	);
};
Bt.prototype.get = function (e) {
	if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
Bt.prototype.forEach = function (e, n, r) {
	n === void 0 && (n = 0),
		r === void 0 && (r = this.length),
		n <= r
			? this.forEachInner(e, n, r, 0)
			: this.forEachInvertedInner(e, n, r, 0);
};
Bt.prototype.map = function (e, n, r) {
	n === void 0 && (n = 0), r === void 0 && (r = this.length);
	var o = [];
	return (
		this.forEach(
			function (i, s) {
				return o.push(e(i, s));
			},
			n,
			r
		),
		o
	);
};
Bt.from = function (e) {
	return e instanceof Bt ? e : e && e.length ? new A2(e) : Bt.empty;
};
var A2 = (function (t) {
	function e(r) {
		t.call(this), (this.values = r);
	}
	t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e);
	var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
	return (
		(e.prototype.flatten = function () {
			return this.values;
		}),
		(e.prototype.sliceInner = function (o, i) {
			return o == 0 && i == this.length
				? this
				: new e(this.values.slice(o, i));
		}),
		(e.prototype.getInner = function (o) {
			return this.values[o];
		}),
		(e.prototype.forEachInner = function (o, i, s, l) {
			for (var a = i; a < s; a++)
				if (o(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.forEachInvertedInner = function (o, i, s, l) {
			for (var a = i - 1; a >= s; a--)
				if (o(this.values[a], l + a) === !1) return !1;
		}),
		(e.prototype.leafAppend = function (o) {
			if (this.length + o.length <= ja)
				return new e(this.values.concat(o.flatten()));
		}),
		(e.prototype.leafPrepend = function (o) {
			if (this.length + o.length <= ja)
				return new e(o.flatten().concat(this.values));
		}),
		(n.length.get = function () {
			return this.values.length;
		}),
		(n.depth.get = function () {
			return 0;
		}),
		Object.defineProperties(e.prototype, n),
		e
	);
})(Bt);
Bt.empty = new A2([]);
var qO = (function (t) {
	function e(n, r) {
		t.call(this),
			(this.left = n),
			(this.right = r),
			(this.length = n.length + r.length),
			(this.depth = Math.max(n.depth, r.depth) + 1);
	}
	return (
		t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e),
		(e.prototype.flatten = function () {
			return this.left.flatten().concat(this.right.flatten());
		}),
		(e.prototype.getInner = function (r) {
			return r < this.left.length
				? this.left.get(r)
				: this.right.get(r - this.left.length);
		}),
		(e.prototype.forEachInner = function (r, o, i, s) {
			var l = this.left.length;
			if (
				(o < l &&
					this.left.forEachInner(r, o, Math.min(i, l), s) === !1) ||
				(i > l &&
					this.right.forEachInner(
						r,
						Math.max(o - l, 0),
						Math.min(this.length, i) - l,
						s + l
					) === !1)
			)
				return !1;
		}),
		(e.prototype.forEachInvertedInner = function (r, o, i, s) {
			var l = this.left.length;
			if (
				(o > l &&
					this.right.forEachInvertedInner(
						r,
						o - l,
						Math.max(i, l) - l,
						s + l
					) === !1) ||
				(i < l &&
					this.left.forEachInvertedInner(r, Math.min(o, l), i, s) ===
						!1)
			)
				return !1;
		}),
		(e.prototype.sliceInner = function (r, o) {
			if (r == 0 && o == this.length) return this;
			var i = this.left.length;
			return o <= i
				? this.left.slice(r, o)
				: r >= i
				? this.right.slice(r - i, o - i)
				: this.left.slice(r, i).append(this.right.slice(0, o - i));
		}),
		(e.prototype.leafAppend = function (r) {
			var o = this.right.leafAppend(r);
			if (o) return new e(this.left, o);
		}),
		(e.prototype.leafPrepend = function (r) {
			var o = this.left.leafPrepend(r);
			if (o) return new e(o, this.right);
		}),
		(e.prototype.appendInner = function (r) {
			return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
				? new e(this.left, new e(this.right, r))
				: new e(this, r);
		}),
		e
	);
})(Bt);
const JO = 500;
class jn {
	constructor(e, n) {
		(this.items = e), (this.eventCount = n);
	}
	popEvent(e, n) {
		if (this.eventCount == 0) return null;
		let r = this.items.length;
		for (; ; r--)
			if (this.items.get(r - 1).selection) {
				--r;
				break;
			}
		let o, i;
		n && ((o = this.remapping(r, this.items.length)), (i = o.maps.length));
		let s = e.tr,
			l,
			a,
			u = [],
			c = [];
		return (
			this.items.forEach(
				(d, f) => {
					if (!d.step) {
						o ||
							((o = this.remapping(r, f + 1)),
							(i = o.maps.length)),
							i--,
							c.push(d);
						return;
					}
					if (o) {
						c.push(new Kn(d.map));
						let p = d.step.map(o.slice(i)),
							m;
						p &&
							s.maybeStep(p).doc &&
							((m = s.mapping.maps[s.mapping.maps.length - 1]),
							u.push(
								new Kn(m, void 0, void 0, u.length + c.length)
							)),
							i--,
							m && o.appendMap(m, i);
					} else s.maybeStep(d.step);
					if (d.selection)
						return (
							(l = o ? d.selection.map(o.slice(i)) : d.selection),
							(a = new jn(
								this.items
									.slice(0, r)
									.append(c.reverse().concat(u)),
								this.eventCount - 1
							)),
							!1
						);
				},
				this.items.length,
				0
			),
			{ remaining: a, transform: s, selection: l }
		);
	}
	addTransform(e, n, r, o) {
		let i = [],
			s = this.eventCount,
			l = this.items,
			a = !o && l.length ? l.get(l.length - 1) : null;
		for (let c = 0; c < e.steps.length; c++) {
			let d = e.steps[c].invert(e.docs[c]),
				f = new Kn(e.mapping.maps[c], d, n),
				p;
			(p = a && a.merge(f)) &&
				((f = p), c ? i.pop() : (l = l.slice(0, l.length - 1))),
				i.push(f),
				n && (s++, (n = void 0)),
				o || (a = f);
		}
		let u = s - r.depth;
		return u > YO && ((l = GO(l, u)), (s -= u)), new jn(l.append(i), s);
	}
	remapping(e, n) {
		let r = new mi();
		return (
			this.items.forEach(
				(o, i) => {
					let s =
						o.mirrorOffset != null && i - o.mirrorOffset >= e
							? r.maps.length - o.mirrorOffset
							: void 0;
					r.appendMap(o.map, s);
				},
				e,
				n
			),
			r
		);
	}
	addMaps(e) {
		return this.eventCount == 0
			? this
			: new jn(
					this.items.append(e.map((n) => new Kn(n))),
					this.eventCount
			  );
	}
	rebased(e, n) {
		if (!this.eventCount) return this;
		let r = [],
			o = Math.max(0, this.items.length - n),
			i = e.mapping,
			s = e.steps.length,
			l = this.eventCount;
		this.items.forEach((f) => {
			f.selection && l--;
		}, o);
		let a = n;
		this.items.forEach((f) => {
			let p = i.getMirror(--a);
			if (p == null) return;
			s = Math.min(s, p);
			let m = i.maps[p];
			if (f.step) {
				let y = e.steps[p].invert(e.docs[p]),
					v = f.selection && f.selection.map(i.slice(a + 1, p));
				v && l++, r.push(new Kn(m, y, v));
			} else r.push(new Kn(m));
		}, o);
		let u = [];
		for (let f = n; f < s; f++) u.push(new Kn(i.maps[f]));
		let c = this.items.slice(0, o).append(u).append(r),
			d = new jn(c, l);
		return (
			d.emptyItemCount() > JO &&
				(d = d.compress(this.items.length - r.length)),
			d
		);
	}
	emptyItemCount() {
		let e = 0;
		return (
			this.items.forEach((n) => {
				n.step || e++;
			}),
			e
		);
	}
	compress(e = this.items.length) {
		let n = this.remapping(0, e),
			r = n.maps.length,
			o = [],
			i = 0;
		return (
			this.items.forEach(
				(s, l) => {
					if (l >= e) o.push(s), s.selection && i++;
					else if (s.step) {
						let a = s.step.map(n.slice(r)),
							u = a && a.getMap();
						if ((r--, u && n.appendMap(u, r), a)) {
							let c = s.selection && s.selection.map(n.slice(r));
							c && i++;
							let d = new Kn(u.invert(), a, c),
								f,
								p = o.length - 1;
							(f = o.length && o[p].merge(d))
								? (o[p] = f)
								: o.push(d);
						}
					} else s.map && r--;
				},
				this.items.length,
				0
			),
			new jn(Bt.from(o.reverse()), i)
		);
	}
}
jn.empty = new jn(Bt.empty, 0);
function GO(t, e) {
	let n;
	return (
		t.forEach((r, o) => {
			if (r.selection && e-- == 0) return (n = o), !1;
		}),
		t.slice(n)
	);
}
class Kn {
	constructor(e, n, r, o) {
		(this.map = e),
			(this.step = n),
			(this.selection = r),
			(this.mirrorOffset = o);
	}
	merge(e) {
		if (this.step && e.step && !e.selection) {
			let n = e.step.merge(this.step);
			if (n) return new Kn(n.getMap().invert(), n, this.selection);
		}
	}
}
class Fr {
	constructor(e, n, r, o, i) {
		(this.done = e),
			(this.undone = n),
			(this.prevRanges = r),
			(this.prevTime = o),
			(this.prevComposition = i);
	}
}
const YO = 20;
function QO(t, e, n, r) {
	let o = n.getMeta(oo),
		i;
	if (o) return o.historyState;
	n.getMeta(ZO) && (t = new Fr(t.done, t.undone, null, 0, -1));
	let s = n.getMeta("appendedTransaction");
	if (n.steps.length == 0) return t;
	if (s && s.getMeta(oo))
		return s.getMeta(oo).redo
			? new Fr(
					t.done.addTransform(n, void 0, r, Gl(e)),
					t.undone,
					Hg(n.mapping.maps[n.steps.length - 1]),
					t.prevTime,
					t.prevComposition
			  )
			: new Fr(
					t.done,
					t.undone.addTransform(n, void 0, r, Gl(e)),
					null,
					t.prevTime,
					t.prevComposition
			  );
	if (
		n.getMeta("addToHistory") !== !1 &&
		!(s && s.getMeta("addToHistory") === !1)
	) {
		let l = n.getMeta("composition"),
			a =
				t.prevTime == 0 ||
				(!s &&
					t.prevComposition != l &&
					(t.prevTime < (n.time || 0) - r.newGroupDelay ||
						!XO(n, t.prevRanges))),
			u = s
				? Qc(t.prevRanges, n.mapping)
				: Hg(n.mapping.maps[n.steps.length - 1]);
		return new Fr(
			t.done.addTransform(
				n,
				a ? e.selection.getBookmark() : void 0,
				r,
				Gl(e)
			),
			jn.empty,
			u,
			n.time,
			l == null ? t.prevComposition : l
		);
	} else
		return (i = n.getMeta("rebased"))
			? new Fr(
					t.done.rebased(n, i),
					t.undone.rebased(n, i),
					Qc(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
			  )
			: new Fr(
					t.done.addMaps(n.mapping.maps),
					t.undone.addMaps(n.mapping.maps),
					Qc(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition
			  );
}
function XO(t, e) {
	if (!e) return !1;
	if (!t.docChanged) return !0;
	let n = !1;
	return (
		t.mapping.maps[0].forEach((r, o) => {
			for (let i = 0; i < e.length; i += 2)
				r <= e[i + 1] && o >= e[i] && (n = !0);
		}),
		n
	);
}
function Hg(t) {
	let e = [];
	return t.forEach((n, r, o, i) => e.push(o, i)), e;
}
function Qc(t, e) {
	if (!t) return null;
	let n = [];
	for (let r = 0; r < t.length; r += 2) {
		let o = e.map(t[r], 1),
			i = e.map(t[r + 1], -1);
		o <= i && n.push(o, i);
	}
	return n;
}
function O2(t, e, n, r) {
	let o = Gl(e),
		i = oo.get(e).spec.config,
		s = (r ? t.undone : t.done).popEvent(e, o);
	if (!s) return;
	let l = s.selection.resolve(s.transform.doc),
		a = (r ? t.done : t.undone).addTransform(
			s.transform,
			e.selection.getBookmark(),
			i,
			o
		),
		u = new Fr(r ? a : s.remaining, r ? s.remaining : a, null, 0, -1);
	n(
		s.transform
			.setSelection(l)
			.setMeta(oo, { redo: r, historyState: u })
			.scrollIntoView()
	);
}
let Xc = !1,
	Fg = null;
function Gl(t) {
	let e = t.plugins;
	if (Fg != e) {
		(Xc = !1), (Fg = e);
		for (let n = 0; n < e.length; n++)
			if (e[n].spec.historyPreserveItems) {
				Xc = !0;
				break;
			}
	}
	return Xc;
}
const oo = new Dt("history"),
	ZO = new Dt("closeHistory");
function e5(t = {}) {
	return (
		(t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
		new kt({
			key: oo,
			state: {
				init() {
					return new Fr(jn.empty, jn.empty, null, 0, -1);
				},
				apply(e, n, r) {
					return QO(n, r, e, t);
				},
			},
			config: t,
			props: {
				handleDOMEvents: {
					beforeinput(e, n) {
						let r = n.inputType,
							o =
								r == "historyUndo"
									? R2
									: r == "historyRedo"
									? P2
									: null;
						return o
							? (n.preventDefault(), o(e.state, e.dispatch))
							: !1;
					},
				},
			},
		})
	);
}
const R2 = (t, e) => {
		let n = oo.getState(t);
		return !n || n.done.eventCount == 0 ? !1 : (e && O2(n, t, e, !1), !0);
	},
	P2 = (t, e) => {
		let n = oo.getState(t);
		return !n || n.undone.eventCount == 0 ? !1 : (e && O2(n, t, e, !0), !0);
	},
	t5 = Nt.create({
		name: "history",
		addOptions() {
			return { depth: 100, newGroupDelay: 500 };
		},
		addCommands() {
			return {
				undo:
					() =>
					({ state: t, dispatch: e }) =>
						R2(t, e),
				redo:
					() =>
					({ state: t, dispatch: e }) =>
						P2(t, e),
			};
		},
		addProseMirrorPlugins() {
			return [e5(this.options)];
		},
		addKeyboardShortcuts() {
			return {
				"Mod-z": () => this.editor.commands.undo(),
				"Shift-Mod-z": () => this.editor.commands.redo(),
				"Mod-y": () => this.editor.commands.redo(),
				"Mod-": () => this.editor.commands.undo(),
				"Shift-Mod-": () => this.editor.commands.redo(),
			};
		},
	}),
	n5 = Pt.create({
		name: "horizontalRule",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: "block",
		parseHTML() {
			return [{ tag: "hr" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["hr", et(this.options.HTMLAttributes, t)];
		},
		addCommands() {
			return {
				setHorizontalRule:
					() =>
					({ chain: t, state: e }) => {
						const { $to: n } = e.selection,
							r = t();
						return (
							n.parentOffset === 0
								? r.insertContentAt(Math.max(n.pos - 2, 0), {
										type: this.name,
								  })
								: r.insertContent({ type: this.name }),
							r
								.command(({ tr: o, dispatch: i }) => {
									var s;
									if (i) {
										const { $to: l } = o.selection,
											a = l.end();
										if (l.nodeAfter)
											l.nodeAfter.isTextblock
												? o.setSelection(
														Se.create(
															o.doc,
															l.pos + 1
														)
												  )
												: l.nodeAfter.isBlock
												? o.setSelection(
														we.create(o.doc, l.pos)
												  )
												: o.setSelection(
														Se.create(o.doc, l.pos)
												  );
										else {
											const u =
												(s =
													l.parent.type.contentMatch
														.defaultType) ===
													null || s === void 0
													? void 0
													: s.create();
											u &&
												(o.insert(a, u),
												o.setSelection(
													Se.create(o.doc, a + 1)
												));
										}
										o.scrollIntoView();
									}
									return !0;
								})
								.run()
						);
					},
			};
		},
		addInputRules() {
			return [
				v2({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type }),
			];
		},
	}),
	r5 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,
	o5 = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,
	i5 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,
	s5 = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g,
	l5 = vn.create({
		name: "italic",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "em" },
				{
					tag: "i",
					getAttrs: (t) => t.style.fontStyle !== "normal" && null,
				},
				{ style: "font-style=italic" },
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["em", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setItalic:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleItalic:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetItalic:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-i": () => this.editor.commands.toggleItalic(),
				"Mod-I": () => this.editor.commands.toggleItalic(),
			};
		},
		addInputRules() {
			return [
				Vo({ find: r5, type: this.type }),
				Vo({ find: i5, type: this.type }),
			];
		},
		addPasteRules() {
			return [
				so({ find: o5, type: this.type }),
				so({ find: s5, type: this.type }),
			];
		},
	}),
	a5 = Pt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", et(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	u5 = Pt.create({
		name: "listItem",
		addOptions() {
			return {
				HTMLAttributes: {},
				bulletListTypeName: "bulletList",
				orderedListTypeName: "orderedList",
			};
		},
		content: "paragraph block*",
		defining: !0,
		parseHTML() {
			return [{ tag: "li" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["li", et(this.options.HTMLAttributes, t), 0];
		},
		addKeyboardShortcuts() {
			return {
				Enter: () => this.editor.commands.splitListItem(this.name),
				Tab: () => this.editor.commands.sinkListItem(this.name),
				"Shift-Tab": () => this.editor.commands.liftListItem(this.name),
			};
		},
	}),
	Vg = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = il(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	Wg = /^(\d+)\.\s$/,
	c5 = Pt.create({
		name: "orderedList",
		addOptions() {
			return {
				itemTypeName: "listItem",
				HTMLAttributes: {},
				keepMarks: !1,
				keepAttributes: !1,
			};
		},
		group: "block list",
		content() {
			return `${this.options.itemTypeName}+`;
		},
		addAttributes() {
			return {
				start: {
					default: 1,
					parseHTML: (t) =>
						t.hasAttribute("start")
							? parseInt(t.getAttribute("start") || "", 10)
							: 1,
				},
			};
		},
		parseHTML() {
			return [{ tag: "ol" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			const r = t,
				{ start: e } = r,
				n = tt(r, ["start"]);
			return e === 1
				? ["ol", et(this.options.HTMLAttributes, n), 0]
				: ["ol", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				toggleOrderedList:
					() =>
					({ commands: t, chain: e }) =>
						this.options.keepAttributes
							? e()
									.toggleList(
										this.name,
										this.options.itemTypeName,
										this.options.keepMarks
									)
									.updateAttributes(
										u5.name,
										this.editor.getAttributes(Vg.name)
									)
									.run()
							: t.toggleList(
									this.name,
									this.options.itemTypeName,
									this.options.keepMarks
							  ),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
			};
		},
		addInputRules() {
			let t = Hs({
				find: Wg,
				type: this.type,
				getAttributes: (e) => ({ start: +e[1] }),
				joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
			});
			return (
				(this.options.keepMarks || this.options.keepAttributes) &&
					(t = Hs({
						find: Wg,
						type: this.type,
						keepMarks: this.options.keepMarks,
						keepAttributes: this.options.keepAttributes,
						getAttributes: (e) =>
							B(
								{ start: +e[1] },
								this.editor.getAttributes(Vg.name)
							),
						joinPredicate: (e, n) =>
							n.childCount + n.attrs.start === +e[1],
						editor: this.editor,
					})),
				[t]
			);
		},
	}),
	d5 = Pt.create({
		name: "paragraph",
		priority: 1e3,
		addOptions() {
			return { HTMLAttributes: {} };
		},
		group: "block",
		content: "inline*",
		parseHTML() {
			return [{ tag: "p" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["p", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setParagraph:
					() =>
					({ commands: t }) =>
						t.setNode(this.name),
			};
		},
		addKeyboardShortcuts() {
			return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
		},
	}),
	f5 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,
	h5 = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g,
	p5 = vn.create({
		name: "strike",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{ tag: "s" },
				{ tag: "del" },
				{ tag: "strike" },
				{
					style: "text-decoration",
					consuming: !1,
					getAttrs: (t) => (t.includes("line-through") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["s", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setStrike:
					() =>
					({ commands: t }) =>
						t.setMark(this.name),
				toggleStrike:
					() =>
					({ commands: t }) =>
						t.toggleMark(this.name),
				unsetStrike:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			const t = {};
			return (
				Oh()
					? (t["Mod-Shift-s"] = () =>
							this.editor.commands.toggleStrike())
					: (t["Ctrl-Shift-s"] = () =>
							this.editor.commands.toggleStrike()),
				t
			);
		},
		addInputRules() {
			return [Vo({ find: f5, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: h5, type: this.type })];
		},
	}),
	m5 = Pt.create({ name: "text", group: "inline" }),
	g5 = Nt.create({
		name: "starterKit",
		addExtensions() {
			var t, e, n, r, o, i, s, l, a, u, c, d, f, p, m, y, v, w;
			const S = [];
			return (
				this.options.blockquote !== !1 &&
					S.push(
						bO.configure(
							(t = this.options) === null || t === void 0
								? void 0
								: t.blockquote
						)
					),
				this.options.bold !== !1 &&
					S.push(
						_O.configure(
							(e = this.options) === null || e === void 0
								? void 0
								: e.bold
						)
					),
				this.options.bulletList !== !1 &&
					S.push(
						MO.configure(
							(n = this.options) === null || n === void 0
								? void 0
								: n.bulletList
						)
					),
				this.options.code !== !1 &&
					S.push(
						AO.configure(
							(r = this.options) === null || r === void 0
								? void 0
								: r.code
						)
					),
				this.options.codeBlock !== !1 &&
					S.push(
						PO.configure(
							(o = this.options) === null || o === void 0
								? void 0
								: o.codeBlock
						)
					),
				this.options.document !== !1 &&
					S.push(
						IO.configure(
							(i = this.options) === null || i === void 0
								? void 0
								: i.document
						)
					),
				this.options.dropcursor !== !1 &&
					S.push(
						jO.configure(
							(s = this.options) === null || s === void 0
								? void 0
								: s.dropcursor
						)
					),
				this.options.gapcursor !== !1 &&
					S.push(
						WO.configure(
							(l = this.options) === null || l === void 0
								? void 0
								: l.gapcursor
						)
					),
				this.options.hardBreak !== !1 &&
					S.push(
						UO.configure(
							(a = this.options) === null || a === void 0
								? void 0
								: a.hardBreak
						)
					),
				this.options.heading !== !1 &&
					S.push(
						KO.configure(
							(u = this.options) === null || u === void 0
								? void 0
								: u.heading
						)
					),
				this.options.history !== !1 &&
					S.push(
						t5.configure(
							(c = this.options) === null || c === void 0
								? void 0
								: c.history
						)
					),
				this.options.horizontalRule !== !1 &&
					S.push(
						n5.configure(
							(d = this.options) === null || d === void 0
								? void 0
								: d.horizontalRule
						)
					),
				this.options.italic !== !1 &&
					S.push(
						l5.configure(
							(f = this.options) === null || f === void 0
								? void 0
								: f.italic
						)
					),
				this.options.listItem !== !1 &&
					S.push(
						a5.configure(
							(p = this.options) === null || p === void 0
								? void 0
								: p.listItem
						)
					),
				this.options.orderedList !== !1 &&
					S.push(
						c5.configure(
							(m = this.options) === null || m === void 0
								? void 0
								: m.orderedList
						)
					),
				this.options.paragraph !== !1 &&
					S.push(
						d5.configure(
							(y = this.options) === null || y === void 0
								? void 0
								: y.paragraph
						)
					),
				this.options.strike !== !1 &&
					S.push(
						p5.configure(
							(v = this.options) === null || v === void 0
								? void 0
								: v.strike
						)
					),
				this.options.text !== !1 &&
					S.push(
						m5.configure(
							(w = this.options) === null || w === void 0
								? void 0
								: w.text
						)
					),
				S
			);
		},
	}),
	y5 = Nt.create({
		name: "placeholder",
		addOptions() {
			return {
				emptyEditorClass: "is-editor-empty",
				emptyNodeClass: "is-empty",
				placeholder: "Write something ",
				showOnlyWhenEditable: !0,
				considerAnyAsEmpty: !1,
				showOnlyCurrent: !0,
				includeChildren: !1,
			};
		},
		addProseMirrorPlugins() {
			return [
				new kt({
					key: new Dt("placeholder"),
					props: {
						decorations: ({ doc: t, selection: e }) => {
							var n;
							const r =
									this.editor.isEditable ||
									!this.options.showOnlyWhenEditable,
								{ anchor: o } = e,
								i = [];
							if (!r) return null;
							const { firstChild: s } = t.content,
								l = s && s.type.isLeaf,
								a = s && s.isAtom,
								u = this.options.considerAnyAsEmpty
									? !0
									: s &&
									  s.type.name ===
											((n =
												t.type.contentMatch
													.defaultType) === null ||
											n === void 0
												? void 0
												: n.name),
								c =
									t.content.childCount <= 1 &&
									s &&
									u &&
									s.nodeSize <= 2 &&
									(!l || !a);
							return (
								t.descendants((d, f) => {
									const p = o >= f && o <= f + d.nodeSize,
										m = !d.isLeaf && !d.childCount;
									if (
										(p || !this.options.showOnlyCurrent) &&
										m
									) {
										const y = [this.options.emptyNodeClass];
										c &&
											y.push(
												this.options.emptyEditorClass
											);
										const v = qt.node(f, f + d.nodeSize, {
											class: y.join(" "),
											"data-placeholder":
												typeof this.options
													.placeholder == "function"
													? this.options.placeholder({
															editor: this.editor,
															node: d,
															pos: f,
															hasAnchor: p,
													  })
													: this.options.placeholder,
										});
										i.push(v);
									}
									return this.options.includeChildren;
								}),
								ft.create(t, i)
							);
						},
					},
				}),
			];
		},
	}),
	v5 = Nt.create({
		name: "textAlign",
		addOptions() {
			return {
				types: [],
				alignments: ["left", "center", "right", "justify"],
				defaultAlignment: "left",
			};
		},
		addGlobalAttributes() {
			return [
				{
					types: this.options.types,
					attributes: {
						textAlign: {
							default: this.options.defaultAlignment,
							parseHTML: (t) =>
								t.style.textAlign ||
								this.options.defaultAlignment,
							renderHTML: (t) =>
								t.textAlign === this.options.defaultAlignment
									? {}
									: { style: `text-align: ${t.textAlign}` },
						},
					},
				},
			];
		},
		addCommands() {
			return {
				setTextAlign:
					(t) =>
					({ commands: e }) =>
						this.options.alignments.includes(t)
							? this.options.types.every((n) =>
									e.updateAttributes(n, { textAlign: t })
							  )
							: !1,
				unsetTextAlign:
					() =>
					({ commands: t }) =>
						this.options.types.every((e) =>
							t.resetAttributes(e, "textAlign")
						),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
				"Mod-Shift-e": () =>
					this.editor.commands.setTextAlign("center"),
				"Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
				"Mod-Shift-j": () =>
					this.editor.commands.setTextAlign("justify"),
			};
		},
	});
var of, sf;
if (typeof WeakMap != "undefined") {
	let t = new WeakMap();
	(of = (e) => t.get(e)), (sf = (e, n) => (t.set(e, n), n));
} else {
	const t = [];
	let n = 0;
	(of = (r) => {
		for (let o = 0; o < t.length; o += 2) if (t[o] == r) return t[o + 1];
	}),
		(sf = (r, o) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = o)));
}
var vt = class {
	constructor(t, e, n, r) {
		(this.width = t),
			(this.height = e),
			(this.map = n),
			(this.problems = r);
	}
	findCell(t) {
		for (let e = 0; e < this.map.length; e++) {
			const n = this.map[e];
			if (n != t) continue;
			const r = e % this.width,
				o = (e / this.width) | 0;
			let i = r + 1,
				s = o + 1;
			for (let l = 1; i < this.width && this.map[e + l] == n; l++) i++;
			for (
				let l = 1;
				s < this.height && this.map[e + this.width * l] == n;
				l++
			)
				s++;
			return { left: r, top: o, right: i, bottom: s };
		}
		throw new RangeError(`No cell with offset ${t} found`);
	}
	colCount(t) {
		for (let e = 0; e < this.map.length; e++)
			if (this.map[e] == t) return e % this.width;
		throw new RangeError(`No cell with offset ${t} found`);
	}
	nextCell(t, e, n) {
		const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
		return e == "horiz"
			? (n < 0 ? r == 0 : o == this.width)
				? null
				: this.map[i * this.width + (n < 0 ? r - 1 : o)]
			: (n < 0 ? i == 0 : s == this.height)
			? null
			: this.map[r + this.width * (n < 0 ? i - 1 : s)];
	}
	rectBetween(t, e) {
		const { left: n, right: r, top: o, bottom: i } = this.findCell(t),
			{ left: s, right: l, top: a, bottom: u } = this.findCell(e);
		return {
			left: Math.min(n, s),
			top: Math.min(o, a),
			right: Math.max(r, l),
			bottom: Math.max(i, u),
		};
	}
	cellsInRect(t) {
		const e = [],
			n = {};
		for (let r = t.top; r < t.bottom; r++)
			for (let o = t.left; o < t.right; o++) {
				const i = r * this.width + o,
					s = this.map[i];
				n[s] ||
					((n[s] = !0),
					!(
						(o == t.left && o && this.map[i - 1] == s) ||
						(r == t.top && r && this.map[i - this.width] == s)
					) && e.push(s));
			}
		return e;
	}
	positionAt(t, e, n) {
		for (let r = 0, o = 0; ; r++) {
			const i = o + n.child(r).nodeSize;
			if (r == t) {
				let s = e + t * this.width;
				const l = (t + 1) * this.width;
				for (; s < l && this.map[s] < o; ) s++;
				return s == l ? i - 1 : this.map[s];
			}
			o = i;
		}
	}
	static get(t) {
		return of(t) || sf(t, b5(t));
	}
};
function b5(t) {
	if (t.type.spec.tableRole != "table")
		throw new RangeError("Not a table node: " + t.type.name);
	const e = w5(t),
		n = t.childCount,
		r = [];
	let o = 0,
		i = null;
	const s = [];
	for (let u = 0, c = e * n; u < c; u++) r[u] = 0;
	for (let u = 0, c = 0; u < n; u++) {
		const d = t.child(u);
		c++;
		for (let m = 0; ; m++) {
			for (; o < r.length && r[o] != 0; ) o++;
			if (m == d.childCount) break;
			const y = d.child(m),
				{ colspan: v, rowspan: w, colwidth: S } = y.attrs;
			for (let E = 0; E < w; E++) {
				if (E + u >= n) {
					(i || (i = [])).push({
						type: "overlong_rowspan",
						pos: c,
						n: w - E,
					});
					break;
				}
				const h = o + E * e;
				for (let b = 0; b < v; b++) {
					r[h + b] == 0
						? (r[h + b] = c)
						: (i || (i = [])).push({
								type: "collision",
								row: u,
								pos: c,
								n: v - b,
						  });
					const g = S && S[b];
					if (g) {
						const x = ((h + b) % e) * 2,
							k = s[x];
						k == null || (k != g && s[x + 1] == 1)
							? ((s[x] = g), (s[x + 1] = 1))
							: k == g && s[x + 1]++;
					}
				}
			}
			(o += v), (c += y.nodeSize);
		}
		const f = (u + 1) * e;
		let p = 0;
		for (; o < f; ) r[o++] == 0 && p++;
		p && (i || (i = [])).push({ type: "missing", row: u, n: p }), c++;
	}
	const l = new vt(e, n, r, i);
	let a = !1;
	for (let u = 0; !a && u < s.length; u += 2)
		s[u] != null && s[u + 1] < n && (a = !0);
	return a && x5(l, s, t), l;
}
function w5(t) {
	let e = -1,
		n = !1;
	for (let r = 0; r < t.childCount; r++) {
		const o = t.child(r);
		let i = 0;
		if (n)
			for (let s = 0; s < r; s++) {
				const l = t.child(s);
				for (let a = 0; a < l.childCount; a++) {
					const u = l.child(a);
					s + u.attrs.rowspan > r && (i += u.attrs.colspan);
				}
			}
		for (let s = 0; s < o.childCount; s++) {
			const l = o.child(s);
			(i += l.attrs.colspan), l.attrs.rowspan > 1 && (n = !0);
		}
		e == -1 ? (e = i) : e != i && (e = Math.max(e, i));
	}
	return e;
}
function x5(t, e, n) {
	t.problems || (t.problems = []);
	const r = {};
	for (let o = 0; o < t.map.length; o++) {
		const i = t.map[o];
		if (r[i]) continue;
		r[i] = !0;
		const s = n.nodeAt(i);
		if (!s) throw new RangeError(`No cell with offset ${i} found`);
		let l = null;
		const a = s.attrs;
		for (let u = 0; u < a.colspan; u++) {
			const c = (o + u) % t.width,
				d = e[c * 2];
			d != null &&
				(!a.colwidth || a.colwidth[u] != d) &&
				((l || (l = k5(a)))[u] = d);
		}
		l &&
			t.problems.unshift({
				type: "colwidth mismatch",
				pos: i,
				colwidth: l,
			});
	}
}
function k5(t) {
	if (t.colwidth) return t.colwidth.slice();
	const e = [];
	for (let n = 0; n < t.colspan; n++) e.push(0);
	return e;
}
function Gt(t) {
	let e = t.cached.tableNodeTypes;
	if (!e) {
		e = t.cached.tableNodeTypes = {};
		for (const n in t.nodes) {
			const r = t.nodes[n],
				o = r.spec.tableRole;
			o && (e[o] = r);
		}
	}
	return e;
}
var Kr = new Dt("selectingCells");
function Fi(t) {
	for (let e = t.depth - 1; e > 0; e--)
		if (t.node(e).type.spec.tableRole == "row")
			return t.node(0).resolve(t.before(e + 1));
	return null;
}
function S5(t) {
	for (let e = t.depth; e > 0; e--) {
		const n = t.node(e).type.spec.tableRole;
		if (n === "cell" || n === "header_cell") return t.node(e);
	}
	return null;
}
function Wn(t) {
	const e = t.selection.$head;
	for (let n = e.depth; n > 0; n--)
		if (e.node(n).type.spec.tableRole == "row") return !0;
	return !1;
}
function Zu(t) {
	const e = t.selection;
	if ("$anchorCell" in e && e.$anchorCell)
		return e.$anchorCell.pos > e.$headCell.pos
			? e.$anchorCell
			: e.$headCell;
	if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
		return e.$anchor;
	const n = Fi(e.$head) || _5(e.$head);
	if (n) return n;
	throw new RangeError(`No cell found around position ${e.head}`);
}
function _5(t) {
	for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
	}
	for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell")
			return t.doc.resolve(n - e.nodeSize);
	}
}
function lf(t) {
	return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function C5(t) {
	return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Dh(t, e) {
	return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function I2(t, e, n) {
	const r = t.node(-1),
		o = vt.get(r),
		i = t.start(-1),
		s = o.nextCell(t.pos - i, e, n);
	return s == null ? null : t.node(0).resolve(i + s);
}
function Wo(t, e, n = 1) {
	const r = ge(B({}, t), { colspan: t.colspan - n });
	return (
		r.colwidth &&
			((r.colwidth = r.colwidth.slice()),
			r.colwidth.splice(e, n),
			r.colwidth.some((o) => o > 0) || (r.colwidth = null)),
		r
	);
}
function N2(t, e, n = 1) {
	const r = ge(B({}, t), { colspan: t.colspan + n });
	if (r.colwidth) {
		r.colwidth = r.colwidth.slice();
		for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
	}
	return r;
}
function M5(t, e, n) {
	const r = Gt(e.type.schema).header_cell;
	for (let o = 0; o < t.height; o++)
		if (e.nodeAt(t.map[n + o * t.width]).type != r) return !1;
	return !0;
}
var ut = class vr extends Me {
	constructor(e, n = e) {
		const r = e.node(-1),
			o = vt.get(r),
			i = e.start(-1),
			s = o.rectBetween(e.pos - i, n.pos - i),
			l = e.node(0),
			a = o.cellsInRect(s).filter((c) => c != n.pos - i);
		a.unshift(n.pos - i);
		const u = a.map((c) => {
			const d = r.nodeAt(c);
			if (!d) throw RangeError(`No cell with offset ${c} found`);
			const f = i + c + 1;
			return new wv(l.resolve(f), l.resolve(f + d.content.size));
		});
		super(u[0].$from, u[0].$to, u),
			(this.$anchorCell = e),
			(this.$headCell = n);
	}
	map(e, n) {
		const r = e.resolve(n.map(this.$anchorCell.pos)),
			o = e.resolve(n.map(this.$headCell.pos));
		if (lf(r) && lf(o) && Dh(r, o)) {
			const i = this.$anchorCell.node(-1) != r.node(-1);
			return i && this.isRowSelection()
				? vr.rowSelection(r, o)
				: i && this.isColSelection()
				? vr.colSelection(r, o)
				: new vr(r, o);
		}
		return Se.between(r, o);
	}
	content() {
		const e = this.$anchorCell.node(-1),
			n = vt.get(e),
			r = this.$anchorCell.start(-1),
			o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
			i = {},
			s = [];
		for (let a = o.top; a < o.bottom; a++) {
			const u = [];
			for (
				let c = a * n.width + o.left, d = o.left;
				d < o.right;
				d++, c++
			) {
				const f = n.map[c];
				if (i[f]) continue;
				i[f] = !0;
				const p = n.findCell(f);
				let m = e.nodeAt(f);
				if (!m) throw RangeError(`No cell with offset ${f} found`);
				const y = o.left - p.left,
					v = p.right - o.right;
				if (y > 0 || v > 0) {
					let w = m.attrs;
					if (
						(y > 0 && (w = Wo(w, 0, y)),
						v > 0 && (w = Wo(w, w.colspan - v, v)),
						p.left < o.left)
					) {
						if (((m = m.type.createAndFill(w)), !m))
							throw RangeError(
								`Could not create cell with attrs ${JSON.stringify(
									w
								)}`
							);
					} else m = m.type.create(w, m.content);
				}
				if (p.top < o.top || p.bottom > o.bottom) {
					const w = ge(B({}, m.attrs), {
						rowspan:
							Math.min(p.bottom, o.bottom) -
							Math.max(p.top, o.top),
					});
					p.top < o.top
						? (m = m.type.createAndFill(w))
						: (m = m.type.create(w, m.content));
				}
				u.push(m);
			}
			s.push(e.child(a).copy(J.from(u)));
		}
		const l = this.isColSelection() && this.isRowSelection() ? e : s;
		return new le(J.from(l), 1, 1);
	}
	replace(e, n = le.empty) {
		const r = e.steps.length,
			o = this.ranges;
		for (let s = 0; s < o.length; s++) {
			const { $from: l, $to: a } = o[s],
				u = e.mapping.slice(r);
			e.replace(u.map(l.pos), u.map(a.pos), s ? le.empty : n);
		}
		const i = Me.findFrom(
			e.doc.resolve(e.mapping.slice(r).map(this.to)),
			-1
		);
		i && e.setSelection(i);
	}
	replaceWith(e, n) {
		this.replace(e, new le(J.from(n), 0, 0));
	}
	forEachCell(e) {
		const n = this.$anchorCell.node(-1),
			r = vt.get(n),
			o = this.$anchorCell.start(-1),
			i = r.cellsInRect(
				r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o)
			);
		for (let s = 0; s < i.length; s++) e(n.nodeAt(i[s]), o + i[s]);
	}
	isColSelection() {
		const e = this.$anchorCell.index(-1),
			n = this.$headCell.index(-1);
		if (Math.min(e, n) > 0) return !1;
		const r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
			o = n + this.$headCell.nodeAfter.attrs.rowspan;
		return Math.max(r, o) == this.$headCell.node(-1).childCount;
	}
	static colSelection(e, n = e) {
		const r = e.node(-1),
			o = vt.get(r),
			i = e.start(-1),
			s = o.findCell(e.pos - i),
			l = o.findCell(n.pos - i),
			a = e.node(0);
		return (
			s.top <= l.top
				? (s.top > 0 && (e = a.resolve(i + o.map[s.left])),
				  l.bottom < o.height &&
						(n = a.resolve(
							i + o.map[o.width * (o.height - 1) + l.right - 1]
						)))
				: (l.top > 0 && (n = a.resolve(i + o.map[l.left])),
				  s.bottom < o.height &&
						(e = a.resolve(
							i + o.map[o.width * (o.height - 1) + s.right - 1]
						))),
			new vr(e, n)
		);
	}
	isRowSelection() {
		const e = this.$anchorCell.node(-1),
			n = vt.get(e),
			r = this.$anchorCell.start(-1),
			o = n.colCount(this.$anchorCell.pos - r),
			i = n.colCount(this.$headCell.pos - r);
		if (Math.min(o, i) > 0) return !1;
		const s = o + this.$anchorCell.nodeAfter.attrs.colspan,
			l = i + this.$headCell.nodeAfter.attrs.colspan;
		return Math.max(s, l) == n.width;
	}
	eq(e) {
		return (
			e instanceof vr &&
			e.$anchorCell.pos == this.$anchorCell.pos &&
			e.$headCell.pos == this.$headCell.pos
		);
	}
	static rowSelection(e, n = e) {
		const r = e.node(-1),
			o = vt.get(r),
			i = e.start(-1),
			s = o.findCell(e.pos - i),
			l = o.findCell(n.pos - i),
			a = e.node(0);
		return (
			s.left <= l.left
				? (s.left > 0 && (e = a.resolve(i + o.map[s.top * o.width])),
				  l.right < o.width &&
						(n = a.resolve(i + o.map[o.width * (l.top + 1) - 1])))
				: (l.left > 0 && (n = a.resolve(i + o.map[l.top * o.width])),
				  s.right < o.width &&
						(e = a.resolve(i + o.map[o.width * (s.top + 1) - 1]))),
			new vr(e, n)
		);
	}
	toJSON() {
		return {
			type: "cell",
			anchor: this.$anchorCell.pos,
			head: this.$headCell.pos,
		};
	}
	static fromJSON(e, n) {
		return new vr(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		return new vr(e.resolve(n), e.resolve(r));
	}
	getBookmark() {
		return new E5(this.$anchorCell.pos, this.$headCell.pos);
	}
};
ut.prototype.visible = !1;
Me.jsonID("cell", ut);
var E5 = class D2 {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new D2(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		const n = e.resolve(this.anchor),
			r = e.resolve(this.head);
		return n.parent.type.spec.tableRole == "row" &&
			r.parent.type.spec.tableRole == "row" &&
			n.index() < n.parent.childCount &&
			r.index() < r.parent.childCount &&
			Dh(n, r)
			? new ut(n, r)
			: Me.near(r, 1);
	}
};
function T5(t) {
	if (!(t.selection instanceof ut)) return null;
	const e = [];
	return (
		t.selection.forEachCell((n, r) => {
			e.push(qt.node(r, r + n.nodeSize, { class: "selectedCell" }));
		}),
		ft.create(t.doc, e)
	);
}
function A5({ $from: t, $to: e }) {
	if (t.pos == e.pos || t.pos < t.pos - 6) return !1;
	let n = t.pos,
		r = e.pos,
		o = t.depth;
	for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++);
	for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--);
	return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
}
function O5({ $from: t, $to: e }) {
	let n, r;
	for (let o = t.depth; o > 0; o--) {
		const i = t.node(o);
		if (
			i.type.spec.tableRole === "cell" ||
			i.type.spec.tableRole === "header_cell"
		) {
			n = i;
			break;
		}
	}
	for (let o = e.depth; o > 0; o--) {
		const i = e.node(o);
		if (
			i.type.spec.tableRole === "cell" ||
			i.type.spec.tableRole === "header_cell"
		) {
			r = i;
			break;
		}
	}
	return n !== r && e.parentOffset === 0;
}
function R5(t, e, n) {
	const r = (e || t).selection,
		o = (e || t).doc;
	let i, s;
	if (r instanceof we && (s = r.node.type.spec.tableRole)) {
		if (s == "cell" || s == "header_cell") i = ut.create(o, r.from);
		else if (s == "row") {
			const l = o.resolve(r.from + 1);
			i = ut.rowSelection(l, l);
		} else if (!n) {
			const l = vt.get(r.node),
				a = r.from + 1,
				u = a + l.map[l.width * l.height - 1];
			i = ut.create(o, a + 1, u);
		}
	} else
		r instanceof Se && A5(r)
			? (i = Se.create(o, r.from))
			: r instanceof Se &&
			  O5(r) &&
			  (i = Se.create(o, r.$from.start(), r.$from.end()));
	return i && (e || (e = t.tr)).setSelection(i), e;
}
var P5 = new Dt("fix-tables");
function j2(t, e, n, r) {
	const o = t.childCount,
		i = e.childCount;
	e: for (let s = 0, l = 0; s < i; s++) {
		const a = e.child(s);
		for (let u = l, c = Math.min(o, s + 3); u < c; u++)
			if (t.child(u) == a) {
				(l = u + 1), (n += a.nodeSize);
				continue e;
			}
		r(a, n),
			l < o && t.child(l).sameMarkup(a)
				? j2(t.child(l), a, n + 1, r)
				: a.nodesBetween(0, a.content.size, r, n + 1),
			(n += a.nodeSize);
	}
}
function L2(t, e) {
	let n;
	const r = (o, i) => {
		o.type.spec.tableRole == "table" && (n = I5(t, o, i, n));
	};
	return (
		e ? e.doc != t.doc && j2(e.doc, t.doc, 0, r) : t.doc.descendants(r), n
	);
}
function I5(t, e, n, r) {
	const o = vt.get(e);
	if (!o.problems) return r;
	r || (r = t.tr);
	const i = [];
	for (let a = 0; a < o.height; a++) i.push(0);
	for (let a = 0; a < o.problems.length; a++) {
		const u = o.problems[a];
		if (u.type == "collision") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			const d = c.attrs;
			for (let f = 0; f < d.rowspan; f++) i[u.row + f] += u.n;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				Wo(d, d.colspan - u.n, u.n)
			);
		} else if (u.type == "missing") i[u.row] += u.n;
		else if (u.type == "overlong_rowspan") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				ge(B({}, c.attrs), { rowspan: c.attrs.rowspan - u.n })
			);
		} else if (u.type == "colwidth mismatch") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				ge(B({}, c.attrs), { colwidth: u.colwidth })
			);
		}
	}
	let s, l;
	for (let a = 0; a < i.length; a++) i[a] && (s == null && (s = a), (l = a));
	for (let a = 0, u = n + 1; a < o.height; a++) {
		const c = e.child(a),
			d = u + c.nodeSize,
			f = i[a];
		if (f > 0) {
			let p = "cell";
			c.firstChild && (p = c.firstChild.type.spec.tableRole);
			const m = [];
			for (let v = 0; v < f; v++) {
				const w = Gt(t.schema)[p].createAndFill();
				w && m.push(w);
			}
			const y = (a == 0 || s == a - 1) && l == a ? u + 1 : d - 1;
			r.insert(r.mapping.map(y), m);
		}
		u = d;
	}
	return r.setMeta(P5, { fixTables: !0 });
}
function N5(t) {
	if (!t.size) return null;
	let { content: e, openStart: n, openEnd: r } = t;
	for (
		;
		e.childCount == 1 &&
		((n > 0 && r > 0) || e.child(0).type.spec.tableRole == "table");

	)
		n--, r--, (e = e.child(0).content);
	const o = e.child(0),
		i = o.type.spec.tableRole,
		s = o.type.schema,
		l = [];
	if (i == "row")
		for (let a = 0; a < e.childCount; a++) {
			let u = e.child(a).content;
			const c = a ? 0 : Math.max(0, n - 1),
				d = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
			(c || d) && (u = af(Gt(s).row, new le(u, c, d)).content), l.push(u);
		}
	else if (i == "cell" || i == "header_cell")
		l.push(n || r ? af(Gt(s).row, new le(e, n, r)).content : e);
	else return null;
	return D5(s, l);
}
function D5(t, e) {
	const n = [];
	for (let o = 0; o < e.length; o++) {
		const i = e[o];
		for (let s = i.childCount - 1; s >= 0; s--) {
			const { rowspan: l, colspan: a } = i.child(s).attrs;
			for (let u = o; u < o + l; u++) n[u] = (n[u] || 0) + a;
		}
	}
	let r = 0;
	for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
	for (let o = 0; o < n.length; o++)
		if ((o >= e.length && e.push(J.empty), n[o] < r)) {
			const i = Gt(t).cell.createAndFill(),
				s = [];
			for (let l = n[o]; l < r; l++) s.push(i);
			e[o] = e[o].append(J.from(s));
		}
	return { height: e.length, width: r, rows: e };
}
function af(t, e) {
	const n = t.createAndFill();
	return new fh(n).replace(0, n.content.size, e).doc;
}
function j5({ width: t, height: e, rows: n }, r, o) {
	if (t != r) {
		const i = [],
			s = [];
		for (let l = 0; l < n.length; l++) {
			const a = n[l],
				u = [];
			for (let c = i[l] || 0, d = 0; c < r; d++) {
				let f = a.child(d % a.childCount);
				c + f.attrs.colspan > r &&
					(f = f.type.createChecked(
						Wo(f.attrs, f.attrs.colspan, c + f.attrs.colspan - r),
						f.content
					)),
					u.push(f),
					(c += f.attrs.colspan);
				for (let p = 1; p < f.attrs.rowspan; p++)
					i[l + p] = (i[l + p] || 0) + f.attrs.colspan;
			}
			s.push(J.from(u));
		}
		(n = s), (t = r);
	}
	if (e != o) {
		const i = [];
		for (let s = 0, l = 0; s < o; s++, l++) {
			const a = [],
				u = n[l % e];
			for (let c = 0; c < u.childCount; c++) {
				let d = u.child(c);
				s + d.attrs.rowspan > o &&
					(d = d.type.create(
						ge(B({}, d.attrs), {
							rowspan: Math.max(1, o - d.attrs.rowspan),
						}),
						d.content
					)),
					a.push(d);
			}
			i.push(J.from(a));
		}
		(n = i), (e = o);
	}
	return { width: t, height: e, rows: n };
}
function L5(t, e, n, r, o, i, s) {
	const l = t.doc.type.schema,
		a = Gt(l);
	let u, c;
	if (o > e.width)
		for (let d = 0, f = 0; d < e.height; d++) {
			const p = n.child(d);
			f += p.nodeSize;
			const m = [];
			let y;
			p.lastChild == null || p.lastChild.type == a.cell
				? (y = u || (u = a.cell.createAndFill()))
				: (y = c || (c = a.header_cell.createAndFill()));
			for (let v = e.width; v < o; v++) m.push(y);
			t.insert(t.mapping.slice(s).map(f - 1 + r), m);
		}
	if (i > e.height) {
		const d = [];
		for (
			let m = 0, y = (e.height - 1) * e.width;
			m < Math.max(e.width, o);
			m++
		) {
			const v =
				m >= e.width
					? !1
					: n.nodeAt(e.map[y + m]).type == a.header_cell;
			d.push(
				v
					? c || (c = a.header_cell.createAndFill())
					: u || (u = a.cell.createAndFill())
			);
		}
		const f = a.row.create(null, J.from(d)),
			p = [];
		for (let m = e.height; m < i; m++) p.push(f);
		t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), p);
	}
	return !!(u || c);
}
function Ug(t, e, n, r, o, i, s, l) {
	if (s == 0 || s == e.height) return !1;
	let a = !1;
	for (let u = o; u < i; u++) {
		const c = s * e.width + u,
			d = e.map[c];
		if (e.map[c - e.width] == d) {
			a = !0;
			const f = n.nodeAt(d),
				{ top: p, left: m } = e.findCell(d);
			t.setNodeMarkup(
				t.mapping.slice(l).map(d + r),
				null,
				ge(B({}, f.attrs), { rowspan: s - p })
			),
				t.insert(
					t.mapping.slice(l).map(e.positionAt(s, m, n)),
					f.type.createAndFill(
						ge(B({}, f.attrs), { rowspan: p + f.attrs.rowspan - s })
					)
				),
				(u += f.attrs.colspan - 1);
		}
	}
	return a;
}
function Kg(t, e, n, r, o, i, s, l) {
	if (s == 0 || s == e.width) return !1;
	let a = !1;
	for (let u = o; u < i; u++) {
		const c = u * e.width + s,
			d = e.map[c];
		if (e.map[c - 1] == d) {
			a = !0;
			const f = n.nodeAt(d),
				p = e.colCount(d),
				m = t.mapping.slice(l).map(d + r);
			t.setNodeMarkup(
				m,
				null,
				Wo(f.attrs, s - p, f.attrs.colspan - (s - p))
			),
				t.insert(
					m + f.nodeSize,
					f.type.createAndFill(Wo(f.attrs, 0, s - p))
				),
				(u += f.attrs.rowspan - 1);
		}
	}
	return a;
}
function qg(t, e, n, r, o) {
	let i = n ? t.doc.nodeAt(n - 1) : t.doc;
	if (!i) throw new Error("No table found");
	let s = vt.get(i);
	const { top: l, left: a } = r,
		u = a + o.width,
		c = l + o.height,
		d = t.tr;
	let f = 0;
	function p() {
		if (((i = n ? d.doc.nodeAt(n - 1) : d.doc), !i))
			throw new Error("No table found");
		(s = vt.get(i)), (f = d.mapping.maps.length);
	}
	L5(d, s, i, n, u, c, f) && p(),
		Ug(d, s, i, n, a, u, l, f) && p(),
		Ug(d, s, i, n, a, u, c, f) && p(),
		Kg(d, s, i, n, l, c, a, f) && p(),
		Kg(d, s, i, n, l, c, u, f) && p();
	for (let m = l; m < c; m++) {
		const y = s.positionAt(m, a, i),
			v = s.positionAt(m, u, i);
		d.replace(
			d.mapping.slice(f).map(y + n),
			d.mapping.slice(f).map(v + n),
			new le(o.rows[m - l], 0, 0)
		);
	}
	p(),
		d.setSelection(
			new ut(
				d.doc.resolve(n + s.positionAt(l, a, i)),
				d.doc.resolve(n + s.positionAt(c - 1, u - 1, i))
			)
		),
		e(d);
}
var $5 = Sh({
	ArrowLeft: Rl("horiz", -1),
	ArrowRight: Rl("horiz", 1),
	ArrowUp: Rl("vert", -1),
	ArrowDown: Rl("vert", 1),
	"Shift-ArrowLeft": Pl("horiz", -1),
	"Shift-ArrowRight": Pl("horiz", 1),
	"Shift-ArrowUp": Pl("vert", -1),
	"Shift-ArrowDown": Pl("vert", 1),
	Backspace: Il,
	"Mod-Backspace": Il,
	Delete: Il,
	"Mod-Delete": Il,
});
function Yl(t, e, n) {
	return n.eq(t.selection)
		? !1
		: (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Rl(t, e) {
	return (n, r, o) => {
		if (!o) return !1;
		const i = n.selection;
		if (i instanceof ut) return Yl(n, r, Me.near(i.$headCell, e));
		if (t != "horiz" && !i.empty) return !1;
		const s = $2(o, t, e);
		if (s == null) return !1;
		if (t == "horiz")
			return Yl(n, r, Me.near(n.doc.resolve(i.head + e), e));
		{
			const l = n.doc.resolve(s),
				a = I2(l, t, e);
			let u;
			return (
				a
					? (u = Me.near(a, 1))
					: e < 0
					? (u = Me.near(n.doc.resolve(l.before(-1)), -1))
					: (u = Me.near(n.doc.resolve(l.after(-1)), 1)),
				Yl(n, r, u)
			);
		}
	};
}
function Pl(t, e) {
	return (n, r, o) => {
		if (!o) return !1;
		const i = n.selection;
		let s;
		if (i instanceof ut) s = i;
		else {
			const a = $2(o, t, e);
			if (a == null) return !1;
			s = new ut(n.doc.resolve(a));
		}
		const l = I2(s.$headCell, t, e);
		return l ? Yl(n, r, new ut(s.$anchorCell, l)) : !1;
	};
}
function Il(t, e) {
	const n = t.selection;
	if (!(n instanceof ut)) return !1;
	if (e) {
		const r = t.tr,
			o = Gt(t.schema).cell.createAndFill().content;
		n.forEachCell((i, s) => {
			i.content.eq(o) ||
				r.replace(
					r.mapping.map(s + 1),
					r.mapping.map(s + i.nodeSize - 1),
					new le(o, 0, 0)
				);
		}),
			r.docChanged && e(r);
	}
	return !0;
}
function B5(t, e) {
	const n = t.state.doc,
		r = Fi(n.resolve(e));
	return r ? (t.dispatch(t.state.tr.setSelection(new ut(r))), !0) : !1;
}
function z5(t, e, n) {
	if (!Wn(t.state)) return !1;
	let r = N5(n);
	const o = t.state.selection;
	if (o instanceof ut) {
		r ||
			(r = {
				width: 1,
				height: 1,
				rows: [J.from(af(Gt(t.state.schema).cell, n))],
			});
		const i = o.$anchorCell.node(-1),
			s = o.$anchorCell.start(-1),
			l = vt
				.get(i)
				.rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
		return (
			(r = j5(r, l.right - l.left, l.bottom - l.top)),
			qg(t.state, t.dispatch, s, l, r),
			!0
		);
	} else if (r) {
		const i = Zu(t.state),
			s = i.start(-1);
		return (
			qg(
				t.state,
				t.dispatch,
				s,
				vt.get(i.node(-1)).findCell(i.pos - s),
				r
			),
			!0
		);
	} else return !1;
}
function H5(t, e) {
	var n;
	if (e.ctrlKey || e.metaKey) return;
	const r = Jg(t, e.target);
	let o;
	if (e.shiftKey && t.state.selection instanceof ut)
		i(t.state.selection.$anchorCell, e), e.preventDefault();
	else if (
		e.shiftKey &&
		r &&
		(o = Fi(t.state.selection.$anchor)) != null &&
		((n = Zc(t, e)) == null ? void 0 : n.pos) != o.pos
	)
		i(o, e), e.preventDefault();
	else if (!r) return;
	function i(a, u) {
		let c = Zc(t, u);
		const d = Kr.getState(t.state) == null;
		if (!c || !Dh(a, c))
			if (d) c = a;
			else return;
		const f = new ut(a, c);
		if (d || !t.state.selection.eq(f)) {
			const p = t.state.tr.setSelection(f);
			d && p.setMeta(Kr, a.pos), t.dispatch(p);
		}
	}
	function s() {
		t.root.removeEventListener("mouseup", s),
			t.root.removeEventListener("dragstart", s),
			t.root.removeEventListener("mousemove", l),
			Kr.getState(t.state) != null &&
				t.dispatch(t.state.tr.setMeta(Kr, -1));
	}
	function l(a) {
		const u = a,
			c = Kr.getState(t.state);
		let d;
		if (c != null) d = t.state.doc.resolve(c);
		else if (Jg(t, u.target) != r && ((d = Zc(t, e)), !d)) return s();
		d && i(d, u);
	}
	t.root.addEventListener("mouseup", s),
		t.root.addEventListener("dragstart", s),
		t.root.addEventListener("mousemove", l);
}
function $2(t, e, n) {
	if (!(t.state.selection instanceof Se)) return null;
	const { $head: r } = t.state.selection;
	for (let o = r.depth - 1; o >= 0; o--) {
		const i = r.node(o);
		if (
			(n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)
		)
			return null;
		if (
			i.type.spec.tableRole == "cell" ||
			i.type.spec.tableRole == "header_cell"
		) {
			const l = r.before(o),
				a =
					e == "vert"
						? n > 0
							? "down"
							: "up"
						: n > 0
						? "right"
						: "left";
			return t.endOfTextblock(a) ? l : null;
		}
	}
	return null;
}
function Jg(t, e) {
	for (; e && e != t.dom; e = e.parentNode)
		if (e.nodeName == "TD" || e.nodeName == "TH") return e;
	return null;
}
function Zc(t, e) {
	const n = t.posAtCoords({ left: e.clientX, top: e.clientY });
	return n && n ? Fi(t.state.doc.resolve(n.pos)) : null;
}
var F5 = class {
	constructor(e, n) {
		(this.node = e),
			(this.cellMinWidth = n),
			(this.dom = document.createElement("div")),
			(this.dom.className = "tableWrapper"),
			(this.table = this.dom.appendChild(
				document.createElement("table")
			)),
			(this.colgroup = this.table.appendChild(
				document.createElement("colgroup")
			)),
			uf(e, this.colgroup, this.table, n),
			(this.contentDOM = this.table.appendChild(
				document.createElement("tbody")
			));
	}
	update(e) {
		return e.type != this.node.type
			? !1
			: ((this.node = e),
			  uf(e, this.colgroup, this.table, this.cellMinWidth),
			  !0);
	}
	ignoreMutation(e) {
		return (
			e.type == "attributes" &&
			(e.target == this.table || this.colgroup.contains(e.target))
		);
	}
};
function uf(t, e, n, r, o, i) {
	var s;
	let l = 0,
		a = !0,
		u = e.firstChild;
	const c = t.firstChild;
	if (c) {
		for (let d = 0, f = 0; d < c.childCount; d++) {
			const { colspan: p, colwidth: m } = c.child(d).attrs;
			for (let y = 0; y < p; y++, f++) {
				const v = o == f ? i : m && m[y],
					w = v ? v + "px" : "";
				(l += v || r),
					v || (a = !1),
					u
						? (u.style.width != w && (u.style.width = w),
						  (u = u.nextSibling))
						: (e.appendChild(
								document.createElement("col")
						  ).style.width = w);
			}
		}
		for (; u; ) {
			const d = u.nextSibling;
			(s = u.parentNode) == null || s.removeChild(u), (u = d);
		}
		a
			? ((n.style.width = l + "px"), (n.style.minWidth = ""))
			: ((n.style.width = ""), (n.style.minWidth = l + "px"));
	}
}
var Cn = new Dt("tableColumnResizing");
function V5({
	handleWidth: t = 5,
	cellMinWidth: e = 25,
	View: n = F5,
	lastColumnResizable: r = !0,
} = {}) {
	const o = new kt({
		key: Cn,
		state: {
			init(i, s) {
				return (
					(o.spec.props.nodeViews[Gt(s.schema).table.name] = (l, a) =>
						new n(l, e, a)),
					new W5(-1, !1)
				);
			},
			apply(i, s) {
				return s.apply(i);
			},
		},
		props: {
			attributes: (i) => {
				const s = Cn.getState(i);
				return s && s.activeHandle > -1
					? { class: "resize-cursor" }
					: {};
			},
			handleDOMEvents: {
				mousemove: (i, s) => {
					U5(i, s, t, e, r);
				},
				mouseleave: (i) => {
					K5(i);
				},
				mousedown: (i, s) => {
					q5(i, s, e);
				},
			},
			decorations: (i) => {
				const s = Cn.getState(i);
				if (s && s.activeHandle > -1) return Z5(i, s.activeHandle);
			},
			nodeViews: {},
		},
	});
	return o;
}
var W5 = class Ql {
	constructor(e, n) {
		(this.activeHandle = e), (this.dragging = n);
	}
	apply(e) {
		const n = this,
			r = e.getMeta(Cn);
		if (r && r.setHandle != null) return new Ql(r.setHandle, !1);
		if (r && r.setDragging !== void 0)
			return new Ql(n.activeHandle, r.setDragging);
		if (n.activeHandle > -1 && e.docChanged) {
			let o = e.mapping.map(n.activeHandle, -1);
			return lf(e.doc.resolve(o)) || (o = -1), new Ql(o, n.dragging);
		}
		return n;
	}
};
function U5(t, e, n, r, o) {
	const i = Cn.getState(t.state);
	if (i && !i.dragging) {
		const s = G5(e.target);
		let l = -1;
		if (s) {
			const { left: a, right: u } = s.getBoundingClientRect();
			e.clientX - a <= n
				? (l = Gg(t, e, "left", n))
				: u - e.clientX <= n && (l = Gg(t, e, "right", n));
		}
		if (l != i.activeHandle) {
			if (!o && l !== -1) {
				const a = t.state.doc.resolve(l),
					u = a.node(-1),
					c = vt.get(u),
					d = a.start(-1);
				if (
					c.colCount(a.pos - d) + a.nodeAfter.attrs.colspan - 1 ==
					c.width - 1
				)
					return;
			}
			B2(t, l);
		}
	}
}
function K5(t) {
	const e = Cn.getState(t.state);
	e && e.activeHandle > -1 && !e.dragging && B2(t, -1);
}
function q5(t, e, n) {
	const r = Cn.getState(t.state);
	if (!r || r.activeHandle == -1 || r.dragging) return !1;
	const o = t.state.doc.nodeAt(r.activeHandle),
		i = J5(t, r.activeHandle, o.attrs);
	t.dispatch(
		t.state.tr.setMeta(Cn, {
			setDragging: { startX: e.clientX, startWidth: i },
		})
	);
	function s(a) {
		window.removeEventListener("mouseup", s),
			window.removeEventListener("mousemove", l);
		const u = Cn.getState(t.state);
		u != null &&
			u.dragging &&
			(Y5(t, u.activeHandle, Yg(u.dragging, a, n)),
			t.dispatch(t.state.tr.setMeta(Cn, { setDragging: null })));
	}
	function l(a) {
		if (!a.which) return s(a);
		const u = Cn.getState(t.state);
		if (u && u.dragging) {
			const c = Yg(u.dragging, a, n);
			Q5(t, u.activeHandle, c, n);
		}
	}
	return (
		window.addEventListener("mouseup", s),
		window.addEventListener("mousemove", l),
		e.preventDefault(),
		!0
	);
}
function J5(t, e, { colspan: n, colwidth: r }) {
	const o = r && r[r.length - 1];
	if (o) return o;
	const i = t.domAtPos(e);
	let l = i.node.childNodes[i.offset].offsetWidth,
		a = n;
	if (r) for (let u = 0; u < n; u++) r[u] && ((l -= r[u]), a--);
	return l / a;
}
function G5(t) {
	for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
		t =
			t.classList && t.classList.contains("ProseMirror")
				? null
				: t.parentNode;
	return t;
}
function Gg(t, e, n, r) {
	const o = n == "right" ? -r : r,
		i = t.posAtCoords({ left: e.clientX + o, top: e.clientY });
	if (!i) return -1;
	const { pos: s } = i,
		l = Fi(t.state.doc.resolve(s));
	if (!l) return -1;
	if (n == "right") return l.pos;
	const a = vt.get(l.node(-1)),
		u = l.start(-1),
		c = a.map.indexOf(l.pos - u);
	return c % a.width == 0 ? -1 : u + a.map[c - 1];
}
function Yg(t, e, n) {
	const r = e.clientX - t.startX;
	return Math.max(n, t.startWidth + r);
}
function B2(t, e) {
	t.dispatch(t.state.tr.setMeta(Cn, { setHandle: e }));
}
function Y5(t, e, n) {
	const r = t.state.doc.resolve(e),
		o = r.node(-1),
		i = vt.get(o),
		s = r.start(-1),
		l = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1,
		a = t.state.tr;
	for (let u = 0; u < i.height; u++) {
		const c = u * i.width + l;
		if (u && i.map[c] == i.map[c - i.width]) continue;
		const d = i.map[c],
			f = o.nodeAt(d).attrs,
			p = f.colspan == 1 ? 0 : l - i.colCount(d);
		if (f.colwidth && f.colwidth[p] == n) continue;
		const m = f.colwidth ? f.colwidth.slice() : X5(f.colspan);
		(m[p] = n), a.setNodeMarkup(s + d, null, ge(B({}, f), { colwidth: m }));
	}
	a.docChanged && t.dispatch(a);
}
function Q5(t, e, n, r) {
	const o = t.state.doc.resolve(e),
		i = o.node(-1),
		s = o.start(-1),
		l = vt.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
	let a = t.domAtPos(o.start(-1)).node;
	for (; a && a.nodeName != "TABLE"; ) a = a.parentNode;
	a && uf(i, a.firstChild, a, r, l, n);
}
function X5(t) {
	return Array(t).fill(0);
}
function Z5(t, e) {
	const n = [],
		r = t.doc.resolve(e),
		o = r.node(-1);
	if (!o) return ft.empty;
	const i = vt.get(o),
		s = r.start(-1),
		l = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan;
	for (let a = 0; a < i.height; a++) {
		const u = l + a * i.width - 1;
		if (
			(l == i.width || i.map[u] != i.map[u + 1]) &&
			(a == 0 || i.map[u] != i.map[u - i.width])
		) {
			const c = i.map[u],
				d = s + c + o.nodeAt(c).nodeSize - 1,
				f = document.createElement("div");
			(f.className = "column-resize-handle"), n.push(qt.widget(d, f));
		}
	}
	return ft.create(t.doc, n);
}
function hr(t) {
	const e = t.selection,
		n = Zu(t),
		r = n.node(-1),
		o = n.start(-1),
		i = vt.get(r),
		s =
			e instanceof ut
				? i.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o)
				: i.findCell(n.pos - o);
	return ge(B({}, s), { tableStart: o, map: i, table: r });
}
function z2(t, { map: e, tableStart: n, table: r }, o) {
	let i = o > 0 ? -1 : 0;
	M5(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
	for (let s = 0; s < e.height; s++) {
		const l = s * e.width + o;
		if (o > 0 && o < e.width && e.map[l - 1] == e.map[l]) {
			const a = e.map[l],
				u = r.nodeAt(a);
			t.setNodeMarkup(
				t.mapping.map(n + a),
				null,
				N2(u.attrs, o - e.colCount(a))
			),
				(s += u.attrs.rowspan - 1);
		} else {
			const a =
					i == null
						? Gt(r.type.schema).cell
						: r.nodeAt(e.map[l + i]).type,
				u = e.positionAt(s, o, r);
			t.insert(t.mapping.map(n + u), a.createAndFill());
		}
	}
	return t;
}
function e6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t);
		e(z2(t.tr, n, n.left));
	}
	return !0;
}
function t6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t);
		e(z2(t.tr, n, n.right));
	}
	return !0;
}
function n6(t, { map: e, table: n, tableStart: r }, o) {
	const i = t.mapping.maps.length;
	for (let s = 0; s < e.height; ) {
		const l = s * e.width + o,
			a = e.map[l],
			u = n.nodeAt(a),
			c = u.attrs;
		if (
			(o > 0 && e.map[l - 1] == a) ||
			(o < e.width - 1 && e.map[l + 1] == a)
		)
			t.setNodeMarkup(
				t.mapping.slice(i).map(r + a),
				null,
				Wo(c, o - e.colCount(a))
			);
		else {
			const d = t.mapping.slice(i).map(r + a);
			t.delete(d, d + u.nodeSize);
		}
		s += c.rowspan;
	}
}
function r6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t),
			r = t.tr;
		if (n.left == 0 && n.right == n.map.width) return !1;
		for (let o = n.right - 1; n6(r, n, o), o != n.left; o--) {
			const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!i) throw RangeError("No table found");
			(n.table = i), (n.map = vt.get(i));
		}
		e(r);
	}
	return !0;
}
function o6(t, e, n) {
	var r;
	const o = Gt(e.type.schema).header_cell;
	for (let i = 0; i < t.width; i++)
		if (
			((r = e.nodeAt(t.map[i + n * t.width])) == null
				? void 0
				: r.type) != o
		)
			return !1;
	return !0;
}
function H2(t, { map: e, tableStart: n, table: r }, o) {
	var i;
	let s = n;
	for (let u = 0; u < o; u++) s += r.child(u).nodeSize;
	const l = [];
	let a = o > 0 ? -1 : 0;
	o6(e, r, o + a) && (a = o == 0 || o == e.height ? null : 0);
	for (let u = 0, c = e.width * o; u < e.width; u++, c++)
		if (o > 0 && o < e.height && e.map[c] == e.map[c - e.width]) {
			const d = e.map[c],
				f = r.nodeAt(d).attrs;
			t.setNodeMarkup(
				n + d,
				null,
				ge(B({}, f), { rowspan: f.rowspan + 1 })
			),
				(u += f.colspan - 1);
		} else {
			const d =
					a == null
						? Gt(r.type.schema).cell
						: (i = r.nodeAt(e.map[c + a * e.width])) == null
						? void 0
						: i.type,
				f = d == null ? void 0 : d.createAndFill();
			f && l.push(f);
		}
	return t.insert(s, Gt(r.type.schema).row.create(null, l)), t;
}
function i6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t);
		e(H2(t.tr, n, n.top));
	}
	return !0;
}
function s6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t);
		e(H2(t.tr, n, n.bottom));
	}
	return !0;
}
function l6(t, { map: e, table: n, tableStart: r }, o) {
	let i = 0;
	for (let u = 0; u < o; u++) i += n.child(u).nodeSize;
	const s = i + n.child(o).nodeSize,
		l = t.mapping.maps.length;
	t.delete(i + r, s + r);
	const a = new Set();
	for (let u = 0, c = o * e.width; u < e.width; u++, c++) {
		const d = e.map[c];
		if (!a.has(d)) {
			if ((a.add(d), o > 0 && d == e.map[c - e.width])) {
				const f = n.nodeAt(d).attrs;
				t.setNodeMarkup(
					t.mapping.slice(l).map(d + r),
					null,
					ge(B({}, f), { rowspan: f.rowspan - 1 })
				),
					(u += f.colspan - 1);
			} else if (o < e.height && d == e.map[c + e.width]) {
				const f = n.nodeAt(d),
					p = f.attrs,
					m = f.type.create(
						ge(B({}, p), { rowspan: f.attrs.rowspan - 1 }),
						f.content
					),
					y = e.positionAt(o + 1, u, n);
				t.insert(t.mapping.slice(l).map(r + y), m),
					(u += p.colspan - 1);
			}
		}
	}
}
function a6(t, e) {
	if (!Wn(t)) return !1;
	if (e) {
		const n = hr(t),
			r = t.tr;
		if (n.top == 0 && n.bottom == n.map.height) return !1;
		for (let o = n.bottom - 1; l6(r, n, o), o != n.top; o--) {
			const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!i) throw RangeError("No table found");
			(n.table = i), (n.map = vt.get(n.table));
		}
		e(r);
	}
	return !0;
}
function Qg(t) {
	const e = t.content;
	return (
		e.childCount == 1 &&
		e.child(0).isTextblock &&
		e.child(0).childCount == 0
	);
}
function u6({ width: t, height: e, map: n }, r) {
	let o = r.top * t + r.left,
		i = o,
		s = (r.bottom - 1) * t + r.left,
		l = o + (r.right - r.left - 1);
	for (let a = r.top; a < r.bottom; a++) {
		if (
			(r.left > 0 && n[i] == n[i - 1]) ||
			(r.right < t && n[l] == n[l + 1])
		)
			return !0;
		(i += t), (l += t);
	}
	for (let a = r.left; a < r.right; a++) {
		if (
			(r.top > 0 && n[o] == n[o - t]) ||
			(r.bottom < e && n[s] == n[s + t])
		)
			return !0;
		o++, s++;
	}
	return !1;
}
function Xg(t, e) {
	const n = t.selection;
	if (!(n instanceof ut) || n.$anchorCell.pos == n.$headCell.pos) return !1;
	const r = hr(t),
		{ map: o } = r;
	if (u6(o, r)) return !1;
	if (e) {
		const i = t.tr,
			s = {};
		let l = J.empty,
			a,
			u;
		for (let c = r.top; c < r.bottom; c++)
			for (let d = r.left; d < r.right; d++) {
				const f = o.map[c * o.width + d],
					p = r.table.nodeAt(f);
				if (!(s[f] || !p))
					if (((s[f] = !0), a == null)) (a = f), (u = p);
					else {
						Qg(p) || (l = l.append(p.content));
						const m = i.mapping.map(f + r.tableStart);
						i.delete(m, m + p.nodeSize);
					}
			}
		if (a == null || u == null) return !0;
		if (
			(i.setNodeMarkup(
				a + r.tableStart,
				null,
				ge(
					B(
						{},
						N2(
							u.attrs,
							u.attrs.colspan,
							r.right - r.left - u.attrs.colspan
						)
					),
					{ rowspan: r.bottom - r.top }
				)
			),
			l.size)
		) {
			const c = a + 1 + u.content.size,
				d = Qg(u) ? a + 1 : c;
			i.replaceWith(d + r.tableStart, c + r.tableStart, l);
		}
		i.setSelection(new ut(i.doc.resolve(a + r.tableStart))), e(i);
	}
	return !0;
}
function Zg(t, e) {
	const n = Gt(t.schema);
	return c6(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function c6(t) {
	return (e, n) => {
		var r;
		const o = e.selection;
		let i, s;
		if (o instanceof ut) {
			if (o.$anchorCell.pos != o.$headCell.pos) return !1;
			(i = o.$anchorCell.nodeAfter), (s = o.$anchorCell.pos);
		} else {
			if (((i = S5(o.$from)), !i)) return !1;
			s = (r = Fi(o.$from)) == null ? void 0 : r.pos;
		}
		if (
			i == null ||
			s == null ||
			(i.attrs.colspan == 1 && i.attrs.rowspan == 1)
		)
			return !1;
		if (n) {
			let l = i.attrs;
			const a = [],
				u = l.colwidth;
			l.rowspan > 1 && (l = ge(B({}, l), { rowspan: 1 })),
				l.colspan > 1 && (l = ge(B({}, l), { colspan: 1 }));
			const c = hr(e),
				d = e.tr;
			for (let p = 0; p < c.right - c.left; p++)
				a.push(
					u
						? ge(B({}, l), { colwidth: u && u[p] ? [u[p]] : null })
						: l
				);
			let f;
			for (let p = c.top; p < c.bottom; p++) {
				let m = c.map.positionAt(p, c.left, c.table);
				p == c.top && (m += i.nodeSize);
				for (let y = c.left, v = 0; y < c.right; y++, v++)
					(y == c.left && p == c.top) ||
						d.insert(
							(f = d.mapping.map(m + c.tableStart, 1)),
							t({ node: i, row: p, col: y }).createAndFill(a[v])
						);
			}
			d.setNodeMarkup(s, t({ node: i, row: c.top, col: c.left }), a[0]),
				o instanceof ut &&
					d.setSelection(
						new ut(
							d.doc.resolve(o.$anchorCell.pos),
							f ? d.doc.resolve(f) : void 0
						)
					),
				n(d);
		}
		return !0;
	};
}
function d6(t, e) {
	return function (n, r) {
		if (!Wn(n)) return !1;
		const o = Zu(n);
		if (o.nodeAfter.attrs[t] === e) return !1;
		if (r) {
			const i = n.tr;
			n.selection instanceof ut
				? n.selection.forEachCell((s, l) => {
						s.attrs[t] !== e &&
							i.setNodeMarkup(
								l,
								null,
								ge(B({}, s.attrs), { [t]: e })
							);
				  })
				: i.setNodeMarkup(
						o.pos,
						null,
						ge(B({}, o.nodeAfter.attrs), { [t]: e })
				  ),
				r(i);
		}
		return !0;
	};
}
function f6(t) {
	return function (e, n) {
		if (!Wn(e)) return !1;
		if (n) {
			const r = Gt(e.schema),
				o = hr(e),
				i = e.tr,
				s = o.map.cellsInRect(
					t == "column"
						? {
								left: o.left,
								top: 0,
								right: o.right,
								bottom: o.map.height,
						  }
						: t == "row"
						? {
								left: 0,
								top: o.top,
								right: o.map.width,
								bottom: o.bottom,
						  }
						: o
				),
				l = s.map((a) => o.table.nodeAt(a));
			for (let a = 0; a < s.length; a++)
				l[a].type == r.header_cell &&
					i.setNodeMarkup(o.tableStart + s[a], r.cell, l[a].attrs);
			if (i.steps.length == 0)
				for (let a = 0; a < s.length; a++)
					i.setNodeMarkup(
						o.tableStart + s[a],
						r.header_cell,
						l[a].attrs
					);
			n(i);
		}
		return !0;
	};
}
function e1(t, e, n) {
	const r = e.map.cellsInRect({
		left: 0,
		top: 0,
		right: t == "row" ? e.map.width : 1,
		bottom: t == "column" ? e.map.height : 1,
	});
	for (let o = 0; o < r.length; o++) {
		const i = e.table.nodeAt(r[o]);
		if (i && i.type !== n.header_cell) return !1;
	}
	return !0;
}
function Fs(t, e) {
	return (
		(e = e || { useDeprecatedLogic: !1 }),
		e.useDeprecatedLogic
			? f6(t)
			: function (n, r) {
					if (!Wn(n)) return !1;
					if (r) {
						const o = Gt(n.schema),
							i = hr(n),
							s = n.tr,
							l = e1("row", i, o),
							a = e1("column", i, o),
							c = (t === "column" ? l : t === "row" ? a : !1)
								? 1
								: 0,
							d =
								t == "column"
									? {
											left: 0,
											top: c,
											right: 1,
											bottom: i.map.height,
									  }
									: t == "row"
									? {
											left: c,
											top: 0,
											right: i.map.width,
											bottom: 1,
									  }
									: i,
							f =
								t == "column"
									? a
										? o.cell
										: o.header_cell
									: t == "row"
									? l
										? o.cell
										: o.header_cell
									: o.cell;
						i.map.cellsInRect(d).forEach((p) => {
							const m = p + i.tableStart,
								y = s.doc.nodeAt(m);
							y && s.setNodeMarkup(m, f, y.attrs);
						}),
							r(s);
					}
					return !0;
			  }
	);
}
Fs("row", { useDeprecatedLogic: !0 });
Fs("column", { useDeprecatedLogic: !0 });
var h6 = Fs("cell", { useDeprecatedLogic: !0 });
function p6(t, e) {
	if (e < 0) {
		const n = t.nodeBefore;
		if (n) return t.pos - n.nodeSize;
		for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
			const i = t.node(-1).child(r),
				s = i.lastChild;
			if (s) return o - 1 - s.nodeSize;
			o -= i.nodeSize;
		}
	} else {
		if (t.index() < t.parent.childCount - 1)
			return t.pos + t.nodeAfter.nodeSize;
		const n = t.node(-1);
		for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
			const i = n.child(r);
			if (i.childCount) return o + 1;
			o += i.nodeSize;
		}
	}
	return null;
}
function t1(t) {
	return function (e, n) {
		if (!Wn(e)) return !1;
		const r = p6(Zu(e), t);
		if (r == null) return !1;
		if (n) {
			const o = e.doc.resolve(r);
			n(e.tr.setSelection(Se.between(o, C5(o))).scrollIntoView());
		}
		return !0;
	};
}
function m6(t, e) {
	const n = t.selection.$anchor;
	for (let r = n.depth; r > 0; r--)
		if (n.node(r).type.spec.tableRole == "table")
			return (
				e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()),
				!0
			);
	return !1;
}
function g6({ allowTableNodeSelection: t = !1 } = {}) {
	return new kt({
		key: Kr,
		state: {
			init() {
				return null;
			},
			apply(e, n) {
				const r = e.getMeta(Kr);
				if (r != null) return r == -1 ? null : r;
				if (n == null || !e.docChanged) return n;
				const { deleted: o, pos: i } = e.mapping.mapResult(n);
				return o ? null : i;
			},
		},
		props: {
			decorations: T5,
			handleDOMEvents: { mousedown: H5 },
			createSelectionBetween(e) {
				return Kr.getState(e.state) != null ? e.state.selection : null;
			},
			handleTripleClick: B5,
			handleKeyDown: $5,
			handlePaste: z5,
		},
		appendTransaction(e, n, r) {
			return R5(r, L2(r, n), t);
		},
	});
}
function n1(t, e, n, r, o, i) {
	let s = 0,
		l = !0,
		a = e.firstChild;
	const u = t.firstChild;
	for (let c = 0, d = 0; c < u.childCount; c += 1) {
		const { colspan: f, colwidth: p } = u.child(c).attrs;
		for (let m = 0; m < f; m += 1, d += 1) {
			const y = o === d ? i : p && p[m],
				v = y ? `${y}px` : "";
			(s += y || r),
				y || (l = !1),
				a
					? (a.style.width !== v && (a.style.width = v),
					  (a = a.nextSibling))
					: (e.appendChild(
							document.createElement("col")
					  ).style.width = v);
		}
	}
	for (; a; ) {
		const c = a.nextSibling;
		a.parentNode.removeChild(a), (a = c);
	}
	l
		? ((n.style.width = `${s}px`), (n.style.minWidth = ""))
		: ((n.style.width = ""), (n.style.minWidth = `${s}px`));
}
class y6 {
	constructor(e, n) {
		(this.node = e),
			(this.cellMinWidth = n),
			(this.dom = document.createElement("div")),
			(this.dom.className = "tableWrapper"),
			(this.table = this.dom.appendChild(
				document.createElement("table")
			)),
			(this.colgroup = this.table.appendChild(
				document.createElement("colgroup")
			)),
			n1(e, this.colgroup, this.table, n),
			(this.contentDOM = this.table.appendChild(
				document.createElement("tbody")
			));
	}
	update(e) {
		return e.type !== this.node.type
			? !1
			: ((this.node = e),
			  n1(e, this.colgroup, this.table, this.cellMinWidth),
			  !0);
	}
	ignoreMutation(e) {
		return (
			e.type === "attributes" &&
			(e.target === this.table || this.colgroup.contains(e.target))
		);
	}
}
function v6(t, e, n, r) {
	let o = 0,
		i = !0;
	const s = [],
		l = t.firstChild;
	if (!l) return {};
	for (let d = 0, f = 0; d < l.childCount; d += 1) {
		const { colspan: p, colwidth: m } = l.child(d).attrs;
		for (let y = 0; y < p; y += 1, f += 1) {
			const v = n === f ? r : m && m[y],
				w = v ? `${v}px` : "";
			(o += v || e),
				v || (i = !1),
				s.push(["col", w ? { style: `width: ${w}` } : {}]);
		}
	}
	const a = i ? `${o}px` : "",
		u = i ? "" : `${o}px`;
	return {
		colgroup: ["colgroup", {}, ...s],
		tableWidth: a,
		tableMinWidth: u,
	};
}
function r1(t, e) {
	return e ? t.createChecked(null, e) : t.createAndFill();
}
function b6(t) {
	if (t.cached.tableNodeTypes) return t.cached.tableNodeTypes;
	const e = {};
	return (
		Object.keys(t.nodes).forEach((n) => {
			const r = t.nodes[n];
			r.spec.tableRole && (e[r.spec.tableRole] = r);
		}),
		(t.cached.tableNodeTypes = e),
		e
	);
}
function w6(t, e, n, r, o) {
	const i = b6(t),
		s = [],
		l = [];
	for (let u = 0; u < n; u += 1) {
		const c = r1(i.cell, o);
		if ((c && l.push(c), r)) {
			const d = r1(i.header_cell, o);
			d && s.push(d);
		}
	}
	const a = [];
	for (let u = 0; u < e; u += 1)
		a.push(i.row.createChecked(null, r && u === 0 ? s : l));
	return i.table.createChecked(null, a);
}
function x6(t) {
	return t instanceof ut;
}
const Nl = ({ editor: t }) => {
		const { selection: e } = t.state;
		if (!x6(e)) return !1;
		let n = 0;
		const r = m2(e.ranges[0].$from, (i) => i.type.name === "table");
		return (
			r == null ||
				r.node.descendants((i) => {
					if (i.type.name === "table") return !1;
					["tableCell", "tableHeader"].includes(i.type.name) &&
						(n += 1);
				}),
			n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1
		);
	},
	k6 = Pt.create({
		name: "table",
		addOptions() {
			return {
				HTMLAttributes: {},
				resizable: !1,
				handleWidth: 5,
				cellMinWidth: 25,
				View: y6,
				lastColumnResizable: !0,
				allowTableNodeSelection: !1,
			};
		},
		content: "tableRow+",
		tableRole: "table",
		isolating: !0,
		group: "block",
		parseHTML() {
			return [{ tag: "table" }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			const {
				colgroup: n,
				tableWidth: r,
				tableMinWidth: o,
			} = v6(t, this.options.cellMinWidth);
			return [
				"table",
				et(this.options.HTMLAttributes, e, {
					style: r ? `width: ${r}` : `minWidth: ${o}`,
				}),
				n,
				["tbody", 0],
			];
		},
		addCommands() {
			return {
				insertTable:
					({
						rows: t = 3,
						cols: e = 3,
						withHeaderRow: n = !0,
					} = {}) =>
					({ tr: r, dispatch: o, editor: i }) => {
						const s = w6(i.schema, t, e, n);
						if (o) {
							const l = r.selection.anchor + 1;
							r.replaceSelectionWith(s)
								.scrollIntoView()
								.setSelection(Se.near(r.doc.resolve(l)));
						}
						return !0;
					},
				addColumnBefore:
					() =>
					({ state: t, dispatch: e }) =>
						e6(t, e),
				addColumnAfter:
					() =>
					({ state: t, dispatch: e }) =>
						t6(t, e),
				deleteColumn:
					() =>
					({ state: t, dispatch: e }) =>
						r6(t, e),
				addRowBefore:
					() =>
					({ state: t, dispatch: e }) =>
						i6(t, e),
				addRowAfter:
					() =>
					({ state: t, dispatch: e }) =>
						s6(t, e),
				deleteRow:
					() =>
					({ state: t, dispatch: e }) =>
						a6(t, e),
				deleteTable:
					() =>
					({ state: t, dispatch: e }) =>
						m6(t, e),
				mergeCells:
					() =>
					({ state: t, dispatch: e }) =>
						Xg(t, e),
				splitCell:
					() =>
					({ state: t, dispatch: e }) =>
						Zg(t, e),
				toggleHeaderColumn:
					() =>
					({ state: t, dispatch: e }) =>
						Fs("column")(t, e),
				toggleHeaderRow:
					() =>
					({ state: t, dispatch: e }) =>
						Fs("row")(t, e),
				toggleHeaderCell:
					() =>
					({ state: t, dispatch: e }) =>
						h6(t, e),
				mergeOrSplit:
					() =>
					({ state: t, dispatch: e }) =>
						Xg(t, e) ? !0 : Zg(t, e),
				setCellAttribute:
					(t, e) =>
					({ state: n, dispatch: r }) =>
						d6(t, e)(n, r),
				goToNextCell:
					() =>
					({ state: t, dispatch: e }) =>
						t1(1)(t, e),
				goToPreviousCell:
					() =>
					({ state: t, dispatch: e }) =>
						t1(-1)(t, e),
				fixTables:
					() =>
					({ state: t, dispatch: e }) => (e && L2(t), !0),
				setCellSelection:
					(t) =>
					({ tr: e, dispatch: n }) => {
						if (n) {
							const r = ut.create(
								e.doc,
								t.anchorCell,
								t.headCell
							);
							e.setSelection(r);
						}
						return !0;
					},
			};
		},
		addKeyboardShortcuts() {
			return {
				Tab: () =>
					this.editor.commands.goToNextCell()
						? !0
						: this.editor.can().addRowAfter()
						? this.editor.chain().addRowAfter().goToNextCell().run()
						: !1,
				"Shift-Tab": () => this.editor.commands.goToPreviousCell(),
				Backspace: Nl,
				"Mod-Backspace": Nl,
				Delete: Nl,
				"Mod-Delete": Nl,
			};
		},
		addProseMirrorPlugins() {
			return [
				...(this.options.resizable && this.editor.isEditable
					? [
							V5({
								handleWidth: this.options.handleWidth,
								cellMinWidth: this.options.cellMinWidth,
								View: this.options.View,
								lastColumnResizable:
									this.options.lastColumnResizable,
							}),
					  ]
					: []),
				g6({
					allowTableNodeSelection:
						this.options.allowTableNodeSelection,
				}),
			];
		},
		extendNodeSchema(t) {
			const e = { name: t.name, options: t.options, storage: t.storage };
			return { tableRole: Be(fe(t, "tableRole", e)) };
		},
	}),
	S6 = Pt.create({
		name: "tableCell",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		addAttributes() {
			return {
				colspan: { default: 1 },
				rowspan: { default: 1 },
				colwidth: {
					default: null,
					parseHTML: (t) => {
						const e = t.getAttribute("colwidth");
						return e ? [parseInt(e, 10)] : null;
					},
				},
			};
		},
		tableRole: "cell",
		isolating: !0,
		parseHTML() {
			return [{ tag: "td" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["td", et(this.options.HTMLAttributes, t), 0];
		},
	}),
	_6 = Pt.create({
		name: "tableHeader",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "block+",
		addAttributes() {
			return {
				colspan: { default: 1 },
				rowspan: { default: 1 },
				colwidth: {
					default: null,
					parseHTML: (t) => {
						const e = t.getAttribute("colwidth");
						return e ? [parseInt(e, 10)] : null;
					},
				},
			};
		},
		tableRole: "header_cell",
		isolating: !0,
		parseHTML() {
			return [{ tag: "th" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["th", et(this.options.HTMLAttributes, t), 0];
		},
	}),
	C6 = Pt.create({
		name: "tableRow",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		content: "(tableCell | tableHeader)*",
		tableRole: "row",
		parseHTML() {
			return [{ tag: "tr" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["tr", et(this.options.HTMLAttributes, t), 0];
		},
	}),
	o1 = (t) =>
		new Promise((e) => {
			let n = new FileReader();
			(n.onloadend = () => {
				e(n.result);
			}),
				n.readAsDataURL(t);
		}),
	M6 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/,
	E6 = Pt.create({
		name: "image",
		addOptions() {
			return { inline: !1, HTMLAttributes: {} };
		},
		inline() {
			return this.options.inline;
		},
		group() {
			return this.options.inline ? "inline" : "block";
		},
		draggable: !0,
		addAttributes() {
			return {
				src: { default: null },
				alt: { default: null },
				title: { default: null },
			};
		},
		parseHTML() {
			return [{ tag: "img[src]" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["img", et(this.options.HTMLAttributes, t)];
		},
		addCommands() {
			return {
				setImage:
					(t) =>
					({ commands: e }) =>
						e.insertContent({ type: this.name, attrs: t }),
			};
		},
		addInputRules() {
			return [
				v2({
					find: M6,
					type: this.type,
					getAttributes: (t) => {
						const [, , e, n, r] = t;
						return { src: n, alt: e, title: r };
					},
				}),
			];
		},
		addProseMirrorPlugins() {
			return [T6()];
		},
	}),
	T6 = () =>
		new kt({
			props: {
				handlePaste(t, e, n) {
					var i;
					const r = Array.from(
							((i = e.clipboardData) == null
								? void 0
								: i.items) || []
						),
						{ schema: o } = t.state;
					return (
						r.forEach((s) => {
							const l = s.getAsFile();
							l &&
								s.type.indexOf("image") === 0 &&
								(e.preventDefault(),
								o1(l).then((a) => {
									const u = o.nodes.image.create({ src: a }),
										c = t.state.tr.replaceSelectionWith(u);
									t.dispatch(c);
								}));
						}),
						!1
					);
				},
				handleDOMEvents: {
					drop: (t, e) => {
						var s, l;
						if (
							!(
								e.dataTransfer &&
								e.dataTransfer.files &&
								e.dataTransfer.files.length
							)
						)
							return !1;
						const r = Array.from(
							(l =
								(s = e.dataTransfer) == null
									? void 0
									: s.files) != null
								? l
								: []
						).filter((a) => /image/i.test(a.type));
						if (r.length === 0) return !1;
						e.preventDefault();
						const { schema: o } = t.state,
							i = t.posAtCoords({
								left: e.clientX,
								top: e.clientY,
							});
						return i
							? (r.forEach((a) =>
									pr(void 0, null, function* () {
										o1(a).then((u) => {
											const c = o.nodes.image.create({
													src: u,
												}),
												d = t.state.tr.insert(i.pos, c);
											t.dispatch(d);
										});
									})
							  ),
							  !0)
							: !1;
					},
				},
			},
		}),
	A6 = Pt.create({
		name: "video",
		group: "block",
		selectable: !0,
		draggable: !0,
		atom: !0,
		addAttributes() {
			return { src: { default: null } };
		},
		parseHTML() {
			return [{ tag: "video" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["video", et(t)];
		},
		addNodeView() {
			return ({ editor: t, node: e }) => {
				const n = document.createElement("div");
				n.className =
					"relative aspect-w-16 aspect-h-9" +
					(t.isEditable ? " cursor-pointer" : "");
				const r = document.createElement("video");
				if (
					(t.isEditable && (r.className = "pointer-events-none"),
					(r.src = e.attrs.src),
					!t.isEditable)
				)
					r.setAttribute("controls", "");
				else {
					let o = document.createElement("div");
					(o.className =
						"absolute top-0 right-0 text-xs m-2 bg-gray-800 text-white px-2 py-1 rounded-md"),
						(o.innerHTML = "Video"),
						n.append(o);
				}
				return n.append(r), { dom: n };
			};
		},
	}),
	O6 =
		"aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2",
	R6 =
		"121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222",
	ji = (t, e) => {
		for (const n in e) t[n] = e[n];
		return t;
	},
	cf = "numeric",
	df = "ascii",
	ff = "alpha",
	Xl = "asciinumeric",
	Dl = "alphanumeric",
	hf = "domain",
	F2 = "emoji",
	P6 = "scheme",
	I6 = "slashscheme",
	i1 = "whitespace";
function N6(t, e) {
	return t in e || (e[t] = []), e[t];
}
function Ao(t, e, n) {
	e[cf] && ((e[Xl] = !0), (e[Dl] = !0)),
		e[df] && ((e[Xl] = !0), (e[ff] = !0)),
		e[Xl] && (e[Dl] = !0),
		e[ff] && (e[Dl] = !0),
		e[Dl] && (e[hf] = !0),
		e[F2] && (e[hf] = !0);
	for (const r in e) {
		const o = N6(r, n);
		o.indexOf(t) < 0 && o.push(t);
	}
}
function D6(t, e) {
	const n = {};
	for (const r in e) e[r].indexOf(t) >= 0 && (n[r] = !0);
	return n;
}
function ln(t) {
	t === void 0 && (t = null),
		(this.j = {}),
		(this.jr = []),
		(this.jd = null),
		(this.t = t);
}
ln.groups = {};
ln.prototype = {
	accepts() {
		return !!this.t;
	},
	go(t) {
		const e = this,
			n = e.j[t];
		if (n) return n;
		for (let r = 0; r < e.jr.length; r++) {
			const o = e.jr[r][0],
				i = e.jr[r][1];
			if (i && o.test(t)) return i;
		}
		return e.jd;
	},
	has(t, e) {
		return e === void 0 && (e = !1), e ? t in this.j : !!this.go(t);
	},
	ta(t, e, n, r) {
		for (let o = 0; o < t.length; o++) this.tt(t[o], e, n, r);
	},
	tr(t, e, n, r) {
		r = r || ln.groups;
		let o;
		return (
			e && e.j ? (o = e) : ((o = new ln(e)), n && r && Ao(e, n, r)),
			this.jr.push([t, o]),
			o
		);
	},
	ts(t, e, n, r) {
		let o = this;
		const i = t.length;
		if (!i) return o;
		for (let s = 0; s < i - 1; s++) o = o.tt(t[s]);
		return o.tt(t[i - 1], e, n, r);
	},
	tt(t, e, n, r) {
		r = r || ln.groups;
		const o = this;
		if (e && e.j) return (o.j[t] = e), e;
		const i = e;
		let s,
			l = o.go(t);
		if (
			(l
				? ((s = new ln()),
				  ji(s.j, l.j),
				  s.jr.push.apply(s.jr, l.jr),
				  (s.jd = l.jd),
				  (s.t = l.t))
				: (s = new ln()),
			i)
		) {
			if (r)
				if (s.t && typeof s.t == "string") {
					const a = ji(D6(s.t, r), n);
					Ao(i, a, r);
				} else n && Ao(i, n, r);
			s.t = i;
		}
		return (o.j[t] = s), s;
	},
};
const Ve = (t, e, n, r, o) => t.ta(e, n, r, o),
	xn = (t, e, n, r, o) => t.tr(e, n, r, o),
	s1 = (t, e, n, r, o) => t.ts(e, n, r, o),
	se = (t, e, n, r, o) => t.tt(e, n, r, o),
	br = "WORD",
	pf = "UWORD",
	Vs = "LOCALHOST",
	mf = "TLD",
	gf = "UTLD",
	Zl = "SCHEME",
	ii = "SLASH_SCHEME",
	jh = "NUM",
	V2 = "WS",
	Lh = "NL",
	bs = "OPENBRACE",
	ws = "CLOSEBRACE",
	La = "OPENBRACKET",
	$a = "CLOSEBRACKET",
	Ba = "OPENPAREN",
	za = "CLOSEPAREN",
	Ha = "OPENANGLEBRACKET",
	Fa = "CLOSEANGLEBRACKET",
	Va = "FULLWIDTHLEFTPAREN",
	Wa = "FULLWIDTHRIGHTPAREN",
	Ua = "LEFTCORNERBRACKET",
	Ka = "RIGHTCORNERBRACKET",
	qa = "LEFTWHITECORNERBRACKET",
	Ja = "RIGHTWHITECORNERBRACKET",
	Ga = "FULLWIDTHLESSTHAN",
	Ya = "FULLWIDTHGREATERTHAN",
	Qa = "AMPERSAND",
	Xa = "APOSTROPHE",
	Za = "ASTERISK",
	Vr = "AT",
	eu = "BACKSLASH",
	tu = "BACKTICK",
	nu = "CARET",
	qr = "COLON",
	$h = "COMMA",
	ru = "DOLLAR",
	qn = "DOT",
	ou = "EQUALS",
	Bh = "EXCLAMATION",
	Jn = "HYPHEN",
	iu = "PERCENT",
	su = "PIPE",
	lu = "PLUS",
	au = "POUND",
	uu = "QUERY",
	zh = "QUOTE",
	Hh = "SEMI",
	Gn = "SLASH",
	xs = "TILDE",
	cu = "UNDERSCORE",
	W2 = "EMOJI",
	du = "SYM";
var U2 = Object.freeze({
	__proto__: null,
	WORD: br,
	UWORD: pf,
	LOCALHOST: Vs,
	TLD: mf,
	UTLD: gf,
	SCHEME: Zl,
	SLASH_SCHEME: ii,
	NUM: jh,
	WS: V2,
	NL: Lh,
	OPENBRACE: bs,
	CLOSEBRACE: ws,
	OPENBRACKET: La,
	CLOSEBRACKET: $a,
	OPENPAREN: Ba,
	CLOSEPAREN: za,
	OPENANGLEBRACKET: Ha,
	CLOSEANGLEBRACKET: Fa,
	FULLWIDTHLEFTPAREN: Va,
	FULLWIDTHRIGHTPAREN: Wa,
	LEFTCORNERBRACKET: Ua,
	RIGHTCORNERBRACKET: Ka,
	LEFTWHITECORNERBRACKET: qa,
	RIGHTWHITECORNERBRACKET: Ja,
	FULLWIDTHLESSTHAN: Ga,
	FULLWIDTHGREATERTHAN: Ya,
	AMPERSAND: Qa,
	APOSTROPHE: Xa,
	ASTERISK: Za,
	AT: Vr,
	BACKSLASH: eu,
	BACKTICK: tu,
	CARET: nu,
	COLON: qr,
	COMMA: $h,
	DOLLAR: ru,
	DOT: qn,
	EQUALS: ou,
	EXCLAMATION: Bh,
	HYPHEN: Jn,
	PERCENT: iu,
	PIPE: su,
	PLUS: lu,
	POUND: au,
	QUERY: uu,
	QUOTE: zh,
	SEMI: Hh,
	SLASH: Gn,
	TILDE: xs,
	UNDERSCORE: cu,
	EMOJI: W2,
	SYM: du,
});
const Zo = /[a-z]/,
	ed = new RegExp("\\p{L}", "u"),
	td = new RegExp("\\p{Emoji}", "u"),
	nd = /\d/,
	l1 = /\s/,
	a1 = `
`,
	j6 = "",
	L6 = "";
let jl = null,
	Ll = null;
function $6(t) {
	t === void 0 && (t = []);
	const e = {};
	ln.groups = e;
	const n = new ln();
	jl == null && (jl = u1(O6)),
		Ll == null && (Ll = u1(R6)),
		se(n, "'", Xa),
		se(n, "{", bs),
		se(n, "}", ws),
		se(n, "[", La),
		se(n, "]", $a),
		se(n, "(", Ba),
		se(n, ")", za),
		se(n, "<", Ha),
		se(n, ">", Fa),
		se(n, "", Va),
		se(n, "", Wa),
		se(n, "", Ua),
		se(n, "", Ka),
		se(n, "", qa),
		se(n, "", Ja),
		se(n, "", Ga),
		se(n, "", Ya),
		se(n, "&", Qa),
		se(n, "*", Za),
		se(n, "@", Vr),
		se(n, "`", tu),
		se(n, "^", nu),
		se(n, ":", qr),
		se(n, ",", $h),
		se(n, "$", ru),
		se(n, ".", qn),
		se(n, "=", ou),
		se(n, "!", Bh),
		se(n, "-", Jn),
		se(n, "%", iu),
		se(n, "|", su),
		se(n, "+", lu),
		se(n, "#", au),
		se(n, "?", uu),
		se(n, '"', zh),
		se(n, "/", Gn),
		se(n, ";", Hh),
		se(n, "~", xs),
		se(n, "_", cu),
		se(n, "\\", eu);
	const r = xn(n, nd, jh, { [cf]: !0 });
	xn(r, nd, r);
	const o = xn(n, Zo, br, { [df]: !0 });
	xn(o, Zo, o);
	const i = xn(n, ed, pf, { [ff]: !0 });
	xn(i, Zo), xn(i, ed, i);
	const s = xn(n, l1, V2, { [i1]: !0 });
	se(n, a1, Lh, { [i1]: !0 }), se(s, a1), xn(s, l1, s);
	const l = xn(n, td, W2, { [F2]: !0 });
	xn(l, td, l), se(l, j6, l);
	const a = se(l, L6);
	xn(a, td, l);
	const u = [[Zo, o]],
		c = [
			[Zo, null],
			[ed, i],
		];
	for (let d = 0; d < jl.length; d++) Ir(n, jl[d], mf, br, u);
	for (let d = 0; d < Ll.length; d++) Ir(n, Ll[d], gf, pf, c);
	Ao(mf, { tld: !0, ascii: !0 }, e),
		Ao(gf, { utld: !0, alpha: !0 }, e),
		Ir(n, "file", Zl, br, u),
		Ir(n, "mailto", Zl, br, u),
		Ir(n, "http", ii, br, u),
		Ir(n, "https", ii, br, u),
		Ir(n, "ftp", ii, br, u),
		Ir(n, "ftps", ii, br, u),
		Ao(Zl, { scheme: !0, ascii: !0 }, e),
		Ao(ii, { slashscheme: !0, ascii: !0 }, e),
		(t = t.sort((d, f) => (d[0] > f[0] ? 1 : -1)));
	for (let d = 0; d < t.length; d++) {
		const f = t[d][0],
			m = t[d][1] ? { [P6]: !0 } : { [I6]: !0 };
		f.indexOf("-") >= 0
			? (m[hf] = !0)
			: Zo.test(f)
			? nd.test(f)
				? (m[Xl] = !0)
				: (m[df] = !0)
			: (m[cf] = !0),
			s1(n, f, f, m);
	}
	return (
		s1(n, "localhost", Vs, { ascii: !0 }),
		(n.jd = new ln(du)),
		{ start: n, tokens: ji({ groups: e }, U2) }
	);
}
function B6(t, e) {
	const n = z6(e.replace(/[A-Z]/g, (l) => l.toLowerCase())),
		r = n.length,
		o = [];
	let i = 0,
		s = 0;
	for (; s < r; ) {
		let l = t,
			a = null,
			u = 0,
			c = null,
			d = -1,
			f = -1;
		for (; s < r && (a = l.go(n[s])); )
			(l = a),
				l.accepts()
					? ((d = 0), (f = 0), (c = l))
					: d >= 0 && ((d += n[s].length), f++),
				(u += n[s].length),
				(i += n[s].length),
				s++;
		(i -= d),
			(s -= f),
			(u -= d),
			o.push({ t: c.t, v: e.slice(i - u, i), s: i - u, e: i });
	}
	return o;
}
function z6(t) {
	const e = [],
		n = t.length;
	let r = 0;
	for (; r < n; ) {
		let o = t.charCodeAt(r),
			i,
			s =
				o < 55296 ||
				o > 56319 ||
				r + 1 === n ||
				(i = t.charCodeAt(r + 1)) < 56320 ||
				i > 57343
					? t[r]
					: t.slice(r, r + 2);
		e.push(s), (r += s.length);
	}
	return e;
}
function Ir(t, e, n, r, o) {
	let i;
	const s = e.length;
	for (let l = 0; l < s - 1; l++) {
		const a = e[l];
		t.j[a]
			? (i = t.j[a])
			: ((i = new ln(r)), (i.jr = o.slice()), (t.j[a] = i)),
			(t = i);
	}
	return (i = new ln(n)), (i.jr = o.slice()), (t.j[e[s - 1]] = i), i;
}
function u1(t) {
	const e = [],
		n = [];
	let r = 0,
		o = "0123456789";
	for (; r < t.length; ) {
		let i = 0;
		for (; o.indexOf(t[r + i]) >= 0; ) i++;
		if (i > 0) {
			e.push(n.join(""));
			for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--)
				n.pop();
			r += i;
		} else n.push(t[r]), r++;
	}
	return e;
}
const Ws = {
	defaultProtocol: "http",
	events: null,
	format: c1,
	formatHref: c1,
	nl2br: !1,
	tagName: "a",
	target: null,
	rel: null,
	validate: !0,
	truncate: 1 / 0,
	className: null,
	attributes: null,
	ignoreTags: [],
	render: null,
};
function Fh(t, e) {
	e === void 0 && (e = null);
	let n = ji({}, Ws);
	t && (n = ji(n, t instanceof Fh ? t.o : t));
	const r = n.ignoreTags,
		o = [];
	for (let i = 0; i < r.length; i++) o.push(r[i].toUpperCase());
	(this.o = n), e && (this.defaultRender = e), (this.ignoreTags = o);
}
Fh.prototype = {
	o: Ws,
	ignoreTags: [],
	defaultRender(t) {
		return t;
	},
	check(t) {
		return this.get("validate", t.toString(), t);
	},
	get(t, e, n) {
		const r = e != null;
		let o = this.o[t];
		return (
			o &&
			(typeof o == "object"
				? ((o = n.t in o ? o[n.t] : Ws[t]),
				  typeof o == "function" && r && (o = o(e, n)))
				: typeof o == "function" && r && (o = o(e, n.t, n)),
			o)
		);
	},
	getObj(t, e, n) {
		let r = this.o[t];
		return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
	},
	render(t) {
		const e = t.render(this);
		return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
	},
};
function c1(t) {
	return t;
}
function K2(t, e) {
	(this.t = "token"), (this.v = t), (this.tk = e);
}
K2.prototype = {
	isLink: !1,
	toString() {
		return this.v;
	},
	toHref(t) {
		return this.toString();
	},
	toFormattedString(t) {
		const e = this.toString(),
			n = t.get("truncate", e, this),
			r = t.get("format", e, this);
		return n && r.length > n ? r.substring(0, n) + "" : r;
	},
	toFormattedHref(t) {
		return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
	},
	startIndex() {
		return this.tk[0].s;
	},
	endIndex() {
		return this.tk[this.tk.length - 1].e;
	},
	toObject(t) {
		return (
			t === void 0 && (t = Ws.defaultProtocol),
			{
				type: this.t,
				value: this.toString(),
				isLink: this.isLink,
				href: this.toHref(t),
				start: this.startIndex(),
				end: this.endIndex(),
			}
		);
	},
	toFormattedObject(t) {
		return {
			type: this.t,
			value: this.toFormattedString(t),
			isLink: this.isLink,
			href: this.toFormattedHref(t),
			start: this.startIndex(),
			end: this.endIndex(),
		};
	},
	validate(t) {
		return t.get("validate", this.toString(), this);
	},
	render(t) {
		const e = this,
			n = this.toHref(t.get("defaultProtocol")),
			r = t.get("formatHref", n, this),
			o = t.get("tagName", n, e),
			i = this.toFormattedString(t),
			s = {},
			l = t.get("className", n, e),
			a = t.get("target", n, e),
			u = t.get("rel", n, e),
			c = t.getObj("attributes", n, e),
			d = t.getObj("events", n, e);
		return (
			(s.href = r),
			l && (s.class = l),
			a && (s.target = a),
			u && (s.rel = u),
			c && ji(s, c),
			{ tagName: o, attributes: s, content: i, eventListeners: d }
		);
	},
};
function ec(t, e) {
	class n extends K2 {
		constructor(o, i) {
			super(o, i), (this.t = t);
		}
	}
	for (const r in e) n.prototype[r] = e[r];
	return (n.t = t), n;
}
const d1 = ec("email", {
		isLink: !0,
		toHref() {
			return "mailto:" + this.toString();
		},
	}),
	f1 = ec("text"),
	H6 = ec("nl"),
	$l = ec("url", {
		isLink: !0,
		toHref(t) {
			return (
				t === void 0 && (t = Ws.defaultProtocol),
				this.hasProtocol() ? this.v : `${t}://${this.v}`
			);
		},
		hasProtocol() {
			const t = this.tk;
			return t.length >= 2 && t[0].t !== Vs && t[1].t === qr;
		},
	}),
	kn = (t) => new ln(t);
function F6(t) {
	let { groups: e } = t;
	const n = e.domain.concat([
			Qa,
			Za,
			Vr,
			eu,
			tu,
			nu,
			ru,
			ou,
			Jn,
			jh,
			iu,
			su,
			lu,
			au,
			Gn,
			du,
			xs,
			cu,
		]),
		r = [
			Xa,
			qr,
			$h,
			qn,
			Bh,
			uu,
			zh,
			Hh,
			Ha,
			Fa,
			bs,
			ws,
			$a,
			La,
			Ba,
			za,
			Va,
			Wa,
			Ua,
			Ka,
			qa,
			Ja,
			Ga,
			Ya,
		],
		o = [
			Qa,
			Xa,
			Za,
			eu,
			tu,
			nu,
			ru,
			ou,
			Jn,
			bs,
			ws,
			iu,
			su,
			lu,
			au,
			uu,
			Gn,
			du,
			xs,
			cu,
		],
		i = kn(),
		s = se(i, xs);
	Ve(s, o, s), Ve(s, e.domain, s);
	const l = kn(),
		a = kn(),
		u = kn();
	Ve(i, e.domain, l),
		Ve(i, e.scheme, a),
		Ve(i, e.slashscheme, u),
		Ve(l, o, s),
		Ve(l, e.domain, l);
	const c = se(l, Vr);
	se(s, Vr, c), se(a, Vr, c), se(u, Vr, c);
	const d = se(s, qn);
	Ve(d, o, s), Ve(d, e.domain, s);
	const f = kn();
	Ve(c, e.domain, f), Ve(f, e.domain, f);
	const p = se(f, qn);
	Ve(p, e.domain, f);
	const m = kn(d1);
	Ve(p, e.tld, m), Ve(p, e.utld, m), se(c, Vs, m);
	const y = se(f, Jn);
	Ve(y, e.domain, f), Ve(m, e.domain, f), se(m, qn, p), se(m, Jn, y);
	const v = se(m, qr);
	Ve(v, e.numeric, d1);
	const w = se(l, Jn),
		S = se(l, qn);
	Ve(w, e.domain, l), Ve(S, o, s), Ve(S, e.domain, l);
	const E = kn($l);
	Ve(S, e.tld, E),
		Ve(S, e.utld, E),
		Ve(E, e.domain, l),
		Ve(E, o, s),
		se(E, qn, S),
		se(E, Jn, w),
		se(E, Vr, c);
	const h = se(E, qr),
		b = kn($l);
	Ve(h, e.numeric, b);
	const g = kn($l),
		x = kn();
	Ve(g, n, g),
		Ve(g, r, x),
		Ve(x, n, g),
		Ve(x, r, x),
		se(E, Gn, g),
		se(b, Gn, g);
	const k = se(a, qr),
		C = se(u, qr),
		_ = se(C, Gn),
		T = se(_, Gn);
	Ve(a, e.domain, l),
		se(a, qn, S),
		se(a, Jn, w),
		Ve(u, e.domain, l),
		se(u, qn, S),
		se(u, Jn, w),
		Ve(k, e.domain, g),
		se(k, Gn, g),
		Ve(T, e.domain, g),
		Ve(T, n, g),
		se(T, Gn, g);
	const R = [
		[bs, ws],
		[La, $a],
		[Ba, za],
		[Ha, Fa],
		[Va, Wa],
		[Ua, Ka],
		[qa, Ja],
		[Ga, Ya],
	];
	for (let P = 0; P < R.length; P++) {
		const [D, j] = R[P],
			M = se(g, D);
		se(x, D, M), se(M, j, g);
		const I = kn($l);
		Ve(M, n, I);
		const $ = kn();
		Ve(M, r),
			Ve(I, n, I),
			Ve(I, r, $),
			Ve($, n, I),
			Ve($, r, $),
			se(I, j, g),
			se($, j, g);
	}
	return se(i, Vs, E), se(i, Lh, H6), { start: i, tokens: U2 };
}
function V6(t, e, n) {
	let r = n.length,
		o = 0,
		i = [],
		s = [];
	for (; o < r; ) {
		let l = t,
			a = null,
			u = null,
			c = 0,
			d = null,
			f = -1;
		for (; o < r && !(a = l.go(n[o].t)); ) s.push(n[o++]);
		for (; o < r && (u = a || l.go(n[o].t)); )
			(a = null),
				(l = u),
				l.accepts() ? ((f = 0), (d = l)) : f >= 0 && f++,
				o++,
				c++;
		if (f < 0) (o -= c), o < r && (s.push(n[o]), o++);
		else {
			s.length > 0 && (i.push(rd(f1, e, s)), (s = [])),
				(o -= f),
				(c -= f);
			const p = d.t,
				m = n.slice(o - c, o);
			i.push(rd(p, e, m));
		}
	}
	return s.length > 0 && i.push(rd(f1, e, s)), i;
}
function rd(t, e, n) {
	const r = n[0].s,
		o = n[n.length - 1].e,
		i = e.slice(r, o);
	return new t(i, n);
}
const W6 =
		(typeof console != "undefined" && console && console.warn) ||
		(() => {}),
	U6 =
		"until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.",
	ht = {
		scanner: null,
		parser: null,
		tokenQueue: [],
		pluginQueue: [],
		customSchemes: [],
		initialized: !1,
	};
function K6() {
	(ln.groups = {}),
		(ht.scanner = null),
		(ht.parser = null),
		(ht.tokenQueue = []),
		(ht.pluginQueue = []),
		(ht.customSchemes = []),
		(ht.initialized = !1);
}
function h1(t, e) {
	if (
		(e === void 0 && (e = !1),
		ht.initialized &&
			W6(
				`linkifyjs: already initialized - will not register custom scheme "${t}" ${U6}`
			),
		!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
	)
		throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
	ht.customSchemes.push([t, e]);
}
function q6() {
	ht.scanner = $6(ht.customSchemes);
	for (let t = 0; t < ht.tokenQueue.length; t++)
		ht.tokenQueue[t][1]({ scanner: ht.scanner });
	ht.parser = F6(ht.scanner.tokens);
	for (let t = 0; t < ht.pluginQueue.length; t++)
		ht.pluginQueue[t][1]({ scanner: ht.scanner, parser: ht.parser });
	ht.initialized = !0;
}
function J6(t) {
	return (
		ht.initialized || q6(), V6(ht.parser.start, t, B6(ht.scanner.start, t))
	);
}
function Vh(t, e, n) {
	if (
		(e === void 0 && (e = null),
		n === void 0 && (n = null),
		e && typeof e == "object")
	) {
		if (n)
			throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
		(n = e), (e = null);
	}
	const r = new Fh(n),
		o = J6(t),
		i = [];
	for (let s = 0; s < o.length; s++) {
		const l = o[s];
		l.isLink &&
			(!e || l.t === e) &&
			r.check(l) &&
			i.push(l.toFormattedObject(r));
	}
	return i;
}
function G6(t) {
	return new kt({
		key: new Dt("autolink"),
		appendTransaction: (e, n, r) => {
			const o = e.some((u) => u.docChanged) && !n.doc.eq(r.doc),
				i = e.some((u) => u.getMeta("preventAutolink"));
			if (!o || i) return;
			const { tr: s } = r,
				l = Z4(n.doc, [...e]);
			if (
				(lA(l).forEach(({ newRange: u }) => {
					const c = tA(r.doc, u, (p) => p.isTextblock);
					let d, f;
					if (
						(c.length > 1
							? ((d = c[0]),
							  (f = r.doc.textBetween(
									d.pos,
									d.pos + d.node.nodeSize,
									void 0,
									" "
							  )))
							: c.length &&
							  r.doc
									.textBetween(u.from, u.to, " ", " ")
									.endsWith(" ") &&
							  ((d = c[0]),
							  (f = r.doc.textBetween(
									d.pos,
									u.to,
									void 0,
									" "
							  ))),
						d && f)
					) {
						const p = f.split(" ").filter((v) => v !== "");
						if (p.length <= 0) return !1;
						const m = p[p.length - 1],
							y = d.pos + f.lastIndexOf(m);
						if (!m) return !1;
						Vh(m)
							.filter((v) => v.isLink)
							.map((v) =>
								ge(B({}, v), {
									from: y + v.start + 1,
									to: y + v.end + 1,
								})
							)
							.filter((v) =>
								r.schema.marks.code
									? !r.doc.rangeHasMark(
											v.from,
											v.to,
											r.schema.marks.code
									  )
									: !0
							)
							.filter((v) =>
								t.validate ? t.validate(v.value) : !0
							)
							.forEach((v) => {
								Ph(v.from, v.to, r.doc).some(
									(w) => w.mark.type === t.type
								) ||
									s.addMark(
										v.from,
										v.to,
										t.type.create({ href: v.href })
									);
							});
					}
				}),
				!!s.steps.length)
			)
				return s;
		},
	});
}
function Y6(t) {
	return new kt({
		key: new Dt("handleClickLink"),
		props: {
			handleClick: (e, n, r) => {
				var o, i;
				if (r.button !== 0) return !1;
				let s = r.target;
				const l = [];
				for (; s.nodeName !== "DIV"; ) l.push(s), (s = s.parentNode);
				if (!l.find((f) => f.nodeName === "A")) return !1;
				const a = g2(e.state, t.type.name),
					u = r.target,
					c =
						(o = u == null ? void 0 : u.href) !== null &&
						o !== void 0
							? o
							: a.href,
					d =
						(i = u == null ? void 0 : u.target) !== null &&
						i !== void 0
							? i
							: a.target;
				return u && c ? (window.open(c, d), !0) : !1;
			},
		},
	});
}
function Q6(t) {
	return new kt({
		key: new Dt("handlePasteLink"),
		props: {
			handlePaste: (e, n, r) => {
				const { state: o } = e,
					{ selection: i } = o,
					{ empty: s } = i;
				if (s) return !1;
				let l = "";
				r.content.forEach((u) => {
					l += u.textContent;
				});
				const a = Vh(l).find((u) => u.isLink && u.value === l);
				return !l || !a
					? !1
					: (t.editor.commands.setMark(t.type, { href: a.href }), !0);
			},
		},
	});
}
const X6 = vn.create({
		name: "link",
		priority: 1e3,
		keepOnSplit: !1,
		onCreate() {
			this.options.protocols.forEach((t) => {
				if (typeof t == "string") {
					h1(t);
					return;
				}
				h1(t.scheme, t.optionalSlashes);
			});
		},
		onDestroy() {
			K6();
		},
		inclusive() {
			return this.options.autolink;
		},
		addOptions() {
			return {
				openOnClick: !0,
				linkOnPaste: !0,
				autolink: !0,
				protocols: [],
				HTMLAttributes: {
					target: "_blank",
					rel: "noopener noreferrer nofollow",
					class: null,
				},
				validate: void 0,
			};
		},
		addAttributes() {
			return {
				href: { default: null },
				target: { default: this.options.HTMLAttributes.target },
				rel: { default: this.options.HTMLAttributes.rel },
				class: { default: this.options.HTMLAttributes.class },
			};
		},
		parseHTML() {
			return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
		},
		renderHTML({ HTMLAttributes: t }) {
			var e;
			return !((e = t.href) === null || e === void 0) &&
				e.startsWith("javascript:")
				? [
						"a",
						et(
							this.options.HTMLAttributes,
							ge(B({}, t), { href: "" })
						),
						0,
				  ]
				: ["a", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setLink:
					(t) =>
					({ chain: e }) =>
						e()
							.setMark(this.name, t)
							.setMeta("preventAutolink", !0)
							.run(),
				toggleLink:
					(t) =>
					({ chain: e }) =>
						e()
							.toggleMark(this.name, t, {
								extendEmptyMarkRange: !0,
							})
							.setMeta("preventAutolink", !0)
							.run(),
				unsetLink:
					() =>
					({ chain: t }) =>
						t()
							.unsetMark(this.name, { extendEmptyMarkRange: !0 })
							.setMeta("preventAutolink", !0)
							.run(),
			};
		},
		addPasteRules() {
			return [
				so({
					find: (t, e) => {
						var n;
						const r =
								(n = e == null ? void 0 : e.clipboardData) ===
									null || n === void 0
									? void 0
									: n.getData("text/html"),
							o = [];
						if (r) {
							const i = new DOMParser().parseFromString(
									r,
									"text/html"
								),
								s = i.querySelectorAll("a");
							s.length &&
								[...s].forEach((l) =>
									o.push({
										text: l.innerText,
										data: { href: l.getAttribute("href") },
										index:
											i.body.innerText.indexOf(
												l.innerText
											) + l.innerText.length,
									})
								);
						}
						if (t) {
							const i = Vh(t).filter((s) => s.isLink);
							i.length &&
								i.forEach((s) =>
									o.push({
										text: s.value,
										data: { href: s.href },
										index: s.start,
									})
								);
						}
						return o;
					},
					type: this.type,
					getAttributes: (t) => {
						var e;
						return {
							href:
								(e = t.data) === null || e === void 0
									? void 0
									: e.href,
						};
					},
				}),
			];
		},
		addProseMirrorPlugins() {
			const t = [];
			return (
				this.options.autolink &&
					t.push(
						G6({ type: this.type, validate: this.options.validate })
					),
				this.options.openOnClick && t.push(Y6({ type: this.type })),
				this.options.linkOnPaste &&
					t.push(Q6({ editor: this.editor, type: this.type })),
				t
			);
		},
	}),
	Z6 = (t) => St({ find: /--$/, replace: t != null ? t : "" }),
	eR = (t) => St({ find: /\.\.\.$/, replace: t != null ? t : "" }),
	tR = (t) =>
		St({
			find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
			replace: t != null ? t : "",
		}),
	nR = (t) => St({ find: /"$/, replace: t != null ? t : "" }),
	rR = (t) =>
		St({
			find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
			replace: t != null ? t : "",
		}),
	oR = (t) => St({ find: /'$/, replace: t != null ? t : "" }),
	iR = (t) => St({ find: /<-$/, replace: t != null ? t : "" }),
	sR = (t) => St({ find: /->$/, replace: t != null ? t : "" }),
	lR = (t) => St({ find: /\(c\)$/, replace: t != null ? t : "" }),
	aR = (t) => St({ find: /\(tm\)$/, replace: t != null ? t : "" }),
	uR = (t) => St({ find: /\(sm\)$/, replace: t != null ? t : "" }),
	cR = (t) => St({ find: /\(r\)$/, replace: t != null ? t : "" }),
	dR = (t) => St({ find: /(?:^|\s)(1\/2)\s$/, replace: t != null ? t : "" }),
	fR = (t) => St({ find: /\+\/-$/, replace: t != null ? t : "" }),
	hR = (t) => St({ find: /!=$/, replace: t != null ? t : "" }),
	pR = (t) => St({ find: /<<$/, replace: t != null ? t : "" }),
	mR = (t) => St({ find: />>$/, replace: t != null ? t : "" }),
	gR = (t) =>
		St({ find: /\d+\s?([*x])\s?\d+$/, replace: t != null ? t : "" }),
	yR = (t) => St({ find: /\^2$/, replace: t != null ? t : "" }),
	vR = (t) => St({ find: /\^3$/, replace: t != null ? t : "" }),
	bR = (t) => St({ find: /(?:^|\s)(1\/4)\s$/, replace: t != null ? t : "" }),
	wR = (t) => St({ find: /(?:^|\s)(3\/4)\s$/, replace: t != null ? t : "" }),
	xR = Nt.create({
		name: "typography",
		addInputRules() {
			const t = [];
			return (
				this.options.emDash !== !1 && t.push(Z6(this.options.emDash)),
				this.options.ellipsis !== !1 &&
					t.push(eR(this.options.ellipsis)),
				this.options.openDoubleQuote !== !1 &&
					t.push(tR(this.options.openDoubleQuote)),
				this.options.closeDoubleQuote !== !1 &&
					t.push(nR(this.options.closeDoubleQuote)),
				this.options.openSingleQuote !== !1 &&
					t.push(rR(this.options.openSingleQuote)),
				this.options.closeSingleQuote !== !1 &&
					t.push(oR(this.options.closeSingleQuote)),
				this.options.leftArrow !== !1 &&
					t.push(iR(this.options.leftArrow)),
				this.options.rightArrow !== !1 &&
					t.push(sR(this.options.rightArrow)),
				this.options.copyright !== !1 &&
					t.push(lR(this.options.copyright)),
				this.options.trademark !== !1 &&
					t.push(aR(this.options.trademark)),
				this.options.servicemark !== !1 &&
					t.push(uR(this.options.servicemark)),
				this.options.registeredTrademark !== !1 &&
					t.push(cR(this.options.registeredTrademark)),
				this.options.oneHalf !== !1 && t.push(dR(this.options.oneHalf)),
				this.options.plusMinus !== !1 &&
					t.push(fR(this.options.plusMinus)),
				this.options.notEqual !== !1 &&
					t.push(hR(this.options.notEqual)),
				this.options.laquo !== !1 && t.push(pR(this.options.laquo)),
				this.options.raquo !== !1 && t.push(mR(this.options.raquo)),
				this.options.multiplication !== !1 &&
					t.push(gR(this.options.multiplication)),
				this.options.superscriptTwo !== !1 &&
					t.push(yR(this.options.superscriptTwo)),
				this.options.superscriptThree !== !1 &&
					t.push(vR(this.options.superscriptThree)),
				this.options.oneQuarter !== !1 &&
					t.push(bR(this.options.oneQuarter)),
				this.options.threeQuarters !== !1 &&
					t.push(wR(this.options.threeQuarters)),
				t
			);
		},
	}),
	kR = vn.create({
		name: "textStyle",
		addOptions() {
			return { HTMLAttributes: {} };
		},
		parseHTML() {
			return [
				{
					tag: "span",
					getAttrs: (t) => (t.hasAttribute("style") ? {} : !1),
				},
			];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["span", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				removeEmptyTextStyle:
					() =>
					({ state: t, commands: e }) => {
						const n = il(t, this.type);
						return Object.entries(n).some(([, o]) => !!o)
							? !0
							: e.unsetMark(this.name);
					},
			};
		},
	}),
	SR = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,
	_R = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g,
	CR = vn.create({
		name: "highlight",
		addOptions() {
			return { multicolor: !1, HTMLAttributes: {} };
		},
		addAttributes() {
			return this.options.multicolor
				? {
						color: {
							default: null,
							parseHTML: (t) =>
								t.getAttribute("data-color") ||
								t.style.backgroundColor,
							renderHTML: (t) =>
								t.color
									? {
											"data-color": t.color,
											style: `background-color: ${t.color}; color: inherit`,
									  }
									: {},
						},
				  }
				: {};
		},
		parseHTML() {
			return [{ tag: "mark" }];
		},
		renderHTML({ HTMLAttributes: t }) {
			return ["mark", et(this.options.HTMLAttributes, t), 0];
		},
		addCommands() {
			return {
				setHighlight:
					(t) =>
					({ commands: e }) =>
						e.setMark(this.name, t),
				toggleHighlight:
					(t) =>
					({ commands: e }) =>
						e.toggleMark(this.name, t),
				unsetHighlight:
					() =>
					({ commands: t }) =>
						t.unsetMark(this.name),
			};
		},
		addKeyboardShortcuts() {
			return {
				"Mod-Shift-h": () => this.editor.commands.toggleHighlight(),
			};
		},
		addInputRules() {
			return [Vo({ find: SR, type: this.type })];
		},
		addPasteRules() {
			return [so({ find: _R, type: this.type })];
		},
	}),
	MR = Nt.create({
		name: "color",
		addOptions() {
			return { types: ["textStyle"] };
		},
		addGlobalAttributes() {
			return [
				{
					types: this.options.types,
					attributes: {
						color: {
							default: null,
							parseHTML: (t) => {
								var e;
								return (e = t.style.color) === null ||
									e === void 0
									? void 0
									: e.replace(/['"]+/g, "");
							},
							renderHTML: (t) =>
								t.color ? { style: `color: ${t.color}` } : {},
						},
					},
				},
			];
		},
		addCommands() {
			return {
				setColor:
					(t) =>
					({ chain: e }) =>
						e().setMark("textStyle", { color: t }).run(),
				unsetColor:
					() =>
					({ chain: t }) =>
						t()
							.setMark("textStyle", { color: null })
							.removeEmptyTextStyle()
							.run(),
			};
		},
	});
function ER(t) {
	var e;
	const {
			char: n,
			allowSpaces: r,
			allowedPrefixes: o,
			startOfLine: i,
			$position: s,
		} = t,
		l = zA(n),
		a = new RegExp(`\\s${l}$`),
		u = i ? "^" : "",
		c = r
			? new RegExp(`${u}${l}.*?(?=\\s${l}|$)`, "gm")
			: new RegExp(`${u}(?:^)?${l}[^\\s${l}]*`, "gm"),
		d =
			((e = s.nodeBefore) === null || e === void 0 ? void 0 : e.isText) &&
			s.nodeBefore.text;
	if (!d) return null;
	const f = s.pos - d.length,
		p = Array.from(d.matchAll(c)).pop();
	if (!p || p.input === void 0 || p.index === void 0) return null;
	const m = p.input.slice(Math.max(0, p.index - 1), p.index),
		y = new RegExp(`^[${o == null ? void 0 : o.join("")}\0]?$`).test(m);
	if (o !== null && !y) return null;
	const v = f + p.index;
	let w = v + p[0].length;
	return (
		r && a.test(d.slice(w - 1, w + 1)) && ((p[0] += " "), (w += 1)),
		v < s.pos && w >= s.pos
			? {
					range: { from: v, to: w },
					query: p[0].slice(n.length),
					text: p[0],
			  }
			: null
	);
}
const TR = new Dt("suggestion");
function AR({
	pluginKey: t = TR,
	editor: e,
	char: n = "@",
	allowSpaces: r = !1,
	allowedPrefixes: o = [" "],
	startOfLine: i = !1,
	decorationTag: s = "span",
	decorationClass: l = "suggestion",
	command: a = () => null,
	items: u = () => [],
	render: c = () => ({}),
	allow: d = () => !0,
	findSuggestionMatch: f = ER,
}) {
	let p;
	const m = c == null ? void 0 : c(),
		y = new kt({
			key: t,
			view() {
				return {
					update: (v, w) =>
						pr(this, null, function* () {
							var S, E, h, b, g, x, k;
							const C =
									(S = this.key) === null || S === void 0
										? void 0
										: S.getState(w),
								_ =
									(E = this.key) === null || E === void 0
										? void 0
										: E.getState(v.state),
								T =
									C.active &&
									_.active &&
									C.range.from !== _.range.from,
								R = !C.active && _.active,
								P = C.active && !_.active,
								D = !R && !P && C.query !== _.query,
								j = R || T,
								M = D && !T,
								I = P || T;
							if (!j && !M && !I) return;
							const $ = I && !j ? C : _,
								K = v.dom.querySelector(
									`[data-decoration-id="${$.decorationId}"]`
								);
							(p = {
								editor: e,
								range: $.range,
								query: $.query,
								text: $.text,
								items: [],
								command: (ie) => {
									a({ editor: e, range: $.range, props: ie });
								},
								decorationNode: K,
								clientRect: K
									? () => {
											var ie;
											const { decorationId: X } =
													(ie = this.key) === null ||
													ie === void 0
														? void 0
														: ie.getState(e.state),
												de = v.dom.querySelector(
													`[data-decoration-id="${X}"]`
												);
											return (
												(de == null
													? void 0
													: de.getBoundingClientRect()) ||
												null
											);
									  }
									: null,
							}),
								j &&
									((h =
										m == null
											? void 0
											: m.onBeforeStart) === null ||
										h === void 0 ||
										h.call(m, p)),
								M &&
									((b =
										m == null
											? void 0
											: m.onBeforeUpdate) === null ||
										b === void 0 ||
										b.call(m, p)),
								(M || j) &&
									(p.items = yield u({
										editor: e,
										query: $.query,
									})),
								I &&
									((g = m == null ? void 0 : m.onExit) ===
										null ||
										g === void 0 ||
										g.call(m, p)),
								M &&
									((x = m == null ? void 0 : m.onUpdate) ===
										null ||
										x === void 0 ||
										x.call(m, p)),
								j &&
									((k = m == null ? void 0 : m.onStart) ===
										null ||
										k === void 0 ||
										k.call(m, p));
						}),
					destroy: () => {
						var v;
						p &&
							((v = m == null ? void 0 : m.onExit) === null ||
								v === void 0 ||
								v.call(m, p));
					},
				};
			},
			state: {
				init() {
					return {
						active: !1,
						range: { from: 0, to: 0 },
						query: null,
						text: null,
						composing: !1,
					};
				},
				apply(v, w, S, E) {
					const { isEditable: h } = e,
						{ composing: b } = e.view,
						{ selection: g } = v,
						{ empty: x, from: k } = g,
						C = B({}, w);
					if (((C.composing = b), h && (x || e.view.composing))) {
						(k < w.range.from || k > w.range.to) &&
							!b &&
							!w.composing &&
							(C.active = !1);
						const _ = f({
								char: n,
								allowSpaces: r,
								allowedPrefixes: o,
								startOfLine: i,
								$position: g.$from,
							}),
							T = `id_${Math.floor(Math.random() * 4294967295)}`;
						_ && d({ editor: e, state: E, range: _.range })
							? ((C.active = !0),
							  (C.decorationId = w.decorationId
									? w.decorationId
									: T),
							  (C.range = _.range),
							  (C.query = _.query),
							  (C.text = _.text))
							: (C.active = !1);
					} else C.active = !1;
					return (
						C.active ||
							((C.decorationId = null),
							(C.range = { from: 0, to: 0 }),
							(C.query = null),
							(C.text = null)),
						C
					);
				},
			},
			props: {
				handleKeyDown(v, w) {
					var S;
					const { active: E, range: h } = y.getState(v.state);
					return (
						(E &&
							((S = m == null ? void 0 : m.onKeyDown) === null ||
							S === void 0
								? void 0
								: S.call(m, {
										view: v,
										event: w,
										range: h,
								  }))) ||
						!1
					);
				},
				decorations(v) {
					const {
						active: w,
						range: S,
						decorationId: E,
					} = y.getState(v);
					return w
						? ft.create(v.doc, [
								qt.inline(S.from, S.to, {
									nodeName: s,
									class: l,
									"data-decoration-id": E,
								}),
						  ])
						: null;
				},
			},
		});
	return y;
}
const OR = new Dt("mention"),
	RR = Pt.create({
		name: "mention",
		addOptions() {
			return {
				HTMLAttributes: {},
				renderText({ options: t, node: e }) {
					var n;
					return `${t.suggestion.char}${
						(n = e.attrs.label) !== null && n !== void 0
							? n
							: e.attrs.id
					}`;
				},
				renderHTML({ options: t, node: e }) {
					var n;
					return [
						"span",
						this.HTMLAttributes,
						`${t.suggestion.char}${
							(n = e.attrs.label) !== null && n !== void 0
								? n
								: e.attrs.id
						}`,
					];
				},
				suggestion: {
					char: "@",
					pluginKey: OR,
					command: ({ editor: t, range: e, props: n }) => {
						var r, o;
						const i = t.view.state.selection.$to.nodeAfter;
						((r = i == null ? void 0 : i.text) === null ||
						r === void 0
							? void 0
							: r.startsWith(" ")) && (e.to += 1),
							t
								.chain()
								.focus()
								.insertContentAt(e, [
									{ type: this.name, attrs: n },
									{ type: "text", text: " " },
								])
								.run(),
							(o = window.getSelection()) === null ||
								o === void 0 ||
								o.collapseToEnd();
					},
					allow: ({ state: t, range: e }) => {
						const n = t.doc.resolve(e.from),
							r = t.schema.nodes[this.name];
						return !!n.parent.type.contentMatch.matchType(r);
					},
				},
			};
		},
		group: "inline",
		inline: !0,
		selectable: !1,
		atom: !0,
		addAttributes() {
			return {
				id: {
					default: null,
					parseHTML: (t) => t.getAttribute("data-id"),
					renderHTML: (t) => (t.id ? { "data-id": t.id } : {}),
				},
				label: {
					default: null,
					parseHTML: (t) => t.getAttribute("data-label"),
					renderHTML: (t) =>
						t.label ? { "data-label": t.label } : {},
				},
			};
		},
		parseHTML() {
			return [{ tag: `span[data-type="${this.name}"]` }];
		},
		renderHTML({ node: t, HTMLAttributes: e }) {
			if (this.options.renderLabel !== void 0)
				return (
					console.warn(
						"renderLabel is deprecated use renderText and renderHTML instead"
					),
					[
						"span",
						et(
							{ "data-type": this.name },
							this.options.HTMLAttributes,
							e
						),
						this.options.renderLabel({
							options: this.options,
							node: t,
						}),
					]
				);
			const n = this.options.renderHTML({
				options: this.options,
				node: t,
			});
			return typeof n == "string"
				? [
						"span",
						et(
							{ "data-type": this.name },
							this.options.HTMLAttributes,
							e
						),
						n,
				  ]
				: n;
		},
		renderText({ node: t }) {
			return this.options.renderLabel !== void 0
				? (console.warn(
						"renderLabel is deprecated use renderText and renderHTML instead"
				  ),
				  this.options.renderLabel({ options: this.options, node: t }))
				: this.options.renderText({ options: this.options, node: t });
		},
		addKeyboardShortcuts() {
			return {
				Backspace: () =>
					this.editor.commands.command(({ tr: t, state: e }) => {
						let n = !1;
						const { selection: r } = e,
							{ empty: o, anchor: i } = r;
						return o
							? (e.doc.nodesBetween(i - 1, i, (s, l) => {
									if (s.type.name === this.name)
										return (
											(n = !0),
											t.insertText(
												this.options.suggestion.char ||
													"",
												l,
												l + s.nodeSize
											),
											!1
										);
							  }),
							  n)
							: !1;
					}),
			};
		},
		addProseMirrorPlugins() {
			return [AR(B({ editor: this.editor }, this.options.suggestion))];
		},
	}),
	PR = {
		props: {
			items: { type: Array, required: !0 },
			command: { type: Function, required: !0 },
		},
		data() {
			return { selectedIndex: 0 };
		},
		watch: {
			items() {
				this.selectedIndex = 0;
			},
		},
		methods: {
			onKeyDown({ event: t }) {
				return t.key === "ArrowUp"
					? (this.upHandler(), !0)
					: t.key === "ArrowDown"
					? (this.downHandler(), !0)
					: t.key === "Enter"
					? (this.enterHandler(), !0)
					: !1;
			},
			upHandler() {
				this.selectedIndex =
					(this.selectedIndex + this.items.length - 1) %
					this.items.length;
			},
			downHandler() {
				this.selectedIndex =
					(this.selectedIndex + 1) % this.items.length;
			},
			enterHandler() {
				this.selectItem(this.selectedIndex);
			},
			selectItem(t) {
				const e = this.items[t];
				e && this.command({ id: e.value, label: e.label });
			},
		},
	},
	IR = {
		key: 0,
		class: "min-w-40 rounded-lg border bg-white p-1 text-base shadow-lg",
	},
	NR = ["onClick", "onMouseover"];
function DR(t, e, n, r, o, i) {
	return (
		N(),
		W("div", null, [
			n.items.length
				? (N(),
				  W("div", IR, [
						(N(!0),
						W(
							Ne,
							null,
							Rt(
								n.items,
								(s, l) => (
									N(),
									W(
										"button",
										{
											class: be([
												l === o.selectedIndex
													? "bg-gray-100"
													: "text-gray-900",
												"flex w-full items-center whitespace-nowrap rounded-md px-2 py-2 text-sm",
											]),
											key: l,
											onClick: (a) => i.selectItem(l),
											onMouseover: (a) =>
												(o.selectedIndex = l),
										},
										We(s.label),
										43,
										NR
									)
								)
							),
							128
						)),
				  ]))
				: Re("", !0),
		])
	);
}
const jR = Le(PR, [["render", DR]]);
function LR(t) {
	return RR.configure({
		HTMLAttributes: { class: "mention" },
		suggestion: $R(t),
	});
}
function $R(t) {
	return {
		items: ({ query: e }) =>
			t
				.filter((n) =>
					n.label.toLowerCase().startsWith(e.toLowerCase())
				)
				.slice(0, 5),
		render: () => {
			let e, n;
			return {
				onStart: (r) => {
					(e = new yO(jR, { props: r, editor: r.editor })),
						r.clientRect &&
							(n = qo("body", {
								getReferenceClientRect: r.clientRect,
								appendTo: () => document.body,
								content: e.element,
								showOnCreate: !0,
								interactive: !0,
								trigger: "manual",
								placement: "bottom-start",
							}));
				},
				onUpdate(r) {
					e.updateProps(r),
						r.clientRect &&
							n[0].setProps({
								getReferenceClientRect: r.clientRect,
							});
				},
				onKeyDown(r) {
					var o;
					return r.event.key === "Escape"
						? (n[0].hide(), !0)
						: (o = e.ref) == null
						? void 0
						: o.onKeyDown(r);
				},
				onExit() {
					n[0].destroy(), e.destroy();
				},
			};
		},
	};
}
const BR = {
		name: "TipTapMenu",
		props: ["buttons"],
		inject: ["editor"],
		components: { Popover: tl },
		methods: {
			onButtonClick(t) {
				t.action(this.editor);
			},
		},
	},
	zR = { class: "inline-flex bg-white px-1 py-1" },
	HR = { class: "inline-flex items-center gap-1" },
	FR = { key: 0, class: "h-4 w-[2px] border-l" },
	VR = { key: 1, class: "shrink-0" },
	WR = ["onClick", "set"],
	UR = { key: 1 },
	KR = { class: "rounded border bg-white p-1 shadow-md" },
	qR = { class: "w-full" },
	JR = ["onClick"],
	GR = ["onClick", "title"],
	YR = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" };
function QR(t, e, n, r, o, i) {
	const s = Je("Popover");
	return (
		N(),
		W("div", zR, [
			V("div", HR, [
				(N(!0),
				W(
					Ne,
					null,
					Rt(
						n.buttons,
						(l) => (
							N(),
							W(
								Ne,
								{ key: l.label },
								[
									l.type === "separator"
										? (N(), W("div", FR))
										: l.map
										? (N(),
										  W("div", VR, [
												ve(
													s,
													null,
													{
														target: Ce(
															({
																togglePopover:
																	a,
															}) => [
																V(
																	"button",
																	{
																		class: "rounded px-2 py-1 text-base font-medium text-gray-800 transition-colors hover:bg-gray-100",
																		onClick:
																			a,
																		set: (t.activeBtn =
																			l.find(
																				(
																					u
																				) =>
																					u.isActive(
																						i.editor
																					)
																			) ||
																			l[0]),
																	},
																	[
																		t
																			.activeBtn
																			.icon
																			? (N(),
																			  Te(
																					Bn(
																						t
																							.activeBtn
																							.icon
																					),
																					{
																						key: 0,
																						class: "h-4 w-4",
																					}
																			  ))
																			: (N(),
																			  W(
																					"span",
																					UR,
																					We(
																						t
																							.activeBtn
																							.label
																					),
																					1
																			  )),
																	],
																	8,
																	WR
																),
															]
														),
														body: Ce(
															({ close: a }) => [
																V("ul", KR, [
																	(N(!0),
																	W(
																		Ne,
																		null,
																		Rt(
																			l,
																			(
																				u
																			) =>
																				ca(
																					(N(),
																					W(
																						"li",
																						qR,
																						[
																							V(
																								"button",
																								{
																									class: "w-full rounded px-2 py-1 text-left text-base hover:bg-gray-50",
																									onClick:
																										() => {
																											i.onButtonClick(
																												u
																											),
																												a();
																										},
																								},
																								We(
																									u.label
																								),
																								9,
																								JR
																							),
																						],
																						512
																					)),
																					[
																						[
																							ma,
																							u.isDisabled
																								? !u.isDisabled(
																										i.editor
																								  )
																								: !0,
																						],
																					]
																				)
																		),
																		256
																	)),
																]),
															]
														),
														_: 2,
													},
													1024
												),
										  ]))
										: (N(),
										  Te(
												Bn(l.component || "div"),
												Et(
													pt(
														{ key: 2 },
														{ editor: i.editor }
													)
												),
												{
													default: Ce((a) => [
														V(
															"button",
															{
																class: be([
																	"flex rounded p-1 text-gray-800 transition-colors",
																	l.isActive(
																		i.editor
																	) ||
																	(a !=
																		null &&
																		a.isActive)
																		? "bg-gray-100"
																		: "hover:bg-gray-100",
																]),
																onClick: (u) =>
																	a != null &&
																	a.onClick
																		? a.onClick(
																				l
																		  )
																		: i.onButtonClick(
																				l
																		  ),
																title: l.label,
															},
															[
																l.icon
																	? (N(),
																	  Te(
																			Bn(
																				l.icon
																			),
																			{
																				key: 0,
																				class: "h-4 w-4",
																			}
																	  ))
																	: (N(),
																	  W(
																			"span",
																			YR,
																			We(
																				l.text
																			),
																			1
																	  )),
															],
															10,
															GR
														),
													]),
													_: 2,
												},
												1040
										  )),
								],
								64
							)
						)
					),
					128
				)),
			]),
		])
	);
}
const q2 = Le(BR, [["render", QR]]),
	XR = {},
	ZR = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	eP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	tP = V(
		"path",
		{
			d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z",
			fill: "currentColor",
		},
		null,
		-1
	),
	nP = [eP, tP];
function rP(t, e) {
	return N(), W("svg", ZR, nP);
}
const oP = Le(XR, [["render", rP]]),
	iP = {},
	sP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	lP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	aP = V(
		"path",
		{
			d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z",
			fill: "currentColor",
		},
		null,
		-1
	),
	uP = [lP, aP];
function cP(t, e) {
	return N(), W("svg", sP, uP);
}
const dP = Le(iP, [["render", cP]]),
	fP = {},
	hP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	pP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	mP = V(
		"path",
		{
			d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	gP = [pP, mP];
function yP(t, e) {
	return N(), W("svg", hP, gP);
}
const vP = Le(fP, [["render", yP]]),
	bP = {},
	wP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	xP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	kP = V(
		"path",
		{
			d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z",
			fill: "currentColor",
		},
		null,
		-1
	),
	SP = [xP, kP];
function _P(t, e) {
	return N(), W("svg", wP, SP);
}
const CP = Le(bP, [["render", _P]]),
	MP = {},
	EP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	TP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	AP = V(
		"path",
		{
			d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	OP = [TP, AP];
function RP(t, e) {
	return N(), W("svg", EP, OP);
}
const PP = Le(MP, [["render", RP]]),
	IP = {},
	NP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	DP = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	jP = V(
		"path",
		{
			d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	LP = [DP, jP];
function $P(t, e) {
	return N(), W("svg", NP, LP);
}
const BP = Le(IP, [["render", $P]]),
	zP = {},
	HP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	FP = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	VP = V(
		"path",
		{ d: "M13 6v15h-2V6H5V4h14v2z", fill: "currentColor" },
		null,
		-1
	),
	WP = [FP, VP];
function UP(t, e) {
	return N(), W("svg", HP, WP);
}
const KP = Le(zP, [["render", UP]]),
	qP = {},
	JP = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	GP = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	YP = V(
		"path",
		{
			d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
			fill: "currentColor",
		},
		null,
		-1
	),
	QP = [GP, YP];
function XP(t, e) {
	return N(), W("svg", JP, QP);
}
const ZP = Le(qP, [["render", XP]]),
	eI = {},
	tI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	nI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	rI = V(
		"path",
		{
			d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
			fill: "currentColor",
		},
		null,
		-1
	),
	oI = [nI, rI];
function iI(t, e) {
	return N(), W("svg", tI, oI);
}
const sI = Le(eI, [["render", iI]]),
	lI = {},
	aI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	uI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	cI = V(
		"path",
		{
			d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	dI = [uI, cI];
function fI(t, e) {
	return N(), W("svg", aI, dI);
}
const hI = Le(lI, [["render", fI]]),
	pI = {},
	mI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	gI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	yI = V(
		"path",
		{
			d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	vI = [gI, yI];
function bI(t, e) {
	return N(), W("svg", mI, vI);
}
const wI = Le(pI, [["render", bI]]),
	xI = {},
	kI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	SI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	_I = V(
		"path",
		{
			d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	CI = [SI, _I];
function MI(t, e) {
	return N(), W("svg", kI, CI);
}
const EI = Le(xI, [["render", MI]]),
	TI = {},
	AI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	OI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	RI = V(
		"path",
		{
			d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
			fill: "currentColor",
		},
		null,
		-1
	),
	PI = [OI, RI];
function II(t, e) {
	return N(), W("svg", AI, PI);
}
const NI = Le(TI, [["render", II]]),
	DI = {},
	jI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	LI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	$I = V(
		"path",
		{
			d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	BI = [LI, $I];
function zI(t, e) {
	return N(), W("svg", jI, BI);
}
const HI = Le(DI, [["render", zI]]),
	FI = {},
	VI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	WI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	UI = V(
		"path",
		{
			d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	KI = [WI, UI];
function qI(t, e) {
	return N(), W("svg", VI, KI);
}
const JI = Le(FI, [["render", qI]]),
	GI = {},
	YI = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	QI = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	XI = V(
		"path",
		{
			d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	ZI = [QI, XI];
function eN(t, e) {
	return N(), W("svg", YI, ZI);
}
const tN = Le(GI, [["render", eN]]),
	nN = {},
	rN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	oN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	iN = V(
		"path",
		{
			d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z",
			fill: "currentColor",
		},
		null,
		-1
	),
	sN = [oN, iN];
function lN(t, e) {
	return N(), W("svg", rN, sN);
}
const aN = Le(nN, [["render", lN]]),
	uN = {},
	cN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	dN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	fN = V(
		"path",
		{
			d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z",
			fill: "currentColor",
		},
		null,
		-1
	),
	hN = [dN, fN];
function pN(t, e) {
	return N(), W("svg", cN, hN);
}
const mN = Le(uN, [["render", pN]]),
	gN = {},
	yN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	vN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	bN = V(
		"path",
		{
			d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
			fill: "currentColor",
		},
		null,
		-1
	),
	wN = [vN, bN];
function xN(t, e) {
	return N(), W("svg", yN, wN);
}
const kN = Le(gN, [["render", xN]]),
	SN = {},
	_N = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	CN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	MN = V(
		"path",
		{
			d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z",
			fill: "currentColor",
		},
		null,
		-1
	),
	EN = [CN, MN];
function TN(t, e) {
	return N(), W("svg", _N, EN);
}
const AN = Le(SN, [["render", TN]]),
	ON = {},
	RN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	PN = V("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1),
	IN = V(
		"path",
		{
			d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-1 2H3v12h12V6zM8 8h2v3h3v2H9.999L10 16H8l-.001-3H5v-2h3V8zm13 .841l-4 2.8v.718l4 2.8V8.84z",
			fill: "currentColor",
		},
		null,
		-1
	),
	NN = [PN, IN];
function DN(t, e) {
	return N(), W("svg", RN, NN);
}
const jN = Le(ON, [["render", DN]]),
	LN = {},
	$N = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	BN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	zN = V(
		"path",
		{
			d: "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z",
			fill: "currentColor",
		},
		null,
		-1
	),
	HN = [BN, zN];
function FN(t, e) {
	return N(), W("svg", $N, HN);
}
const VN = Le(LN, [["render", FN]]),
	WN = {},
	UN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	KN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	qN = V(
		"path",
		{
			d: "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z",
			fill: "currentColor",
		},
		null,
		-1
	),
	JN = [KN, qN];
function GN(t, e) {
	return N(), W("svg", UN, JN);
}
const YN = Le(WN, [["render", GN]]),
	QN = {},
	XN = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	ZN = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	eD = V(
		"path",
		{
			d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z",
			fill: "currentColor",
		},
		null,
		-1
	),
	tD = [ZN, eD];
function nD(t, e) {
	return N(), W("svg", XN, tD);
}
const rD = Le(QN, [["render", nD]]),
	oD = {},
	iD = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 24 24",
		width: "24",
		height: "24",
	},
	sD = V("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1),
	lD = V(
		"path",
		{
			d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z",
			fill: "currentColor",
		},
		null,
		-1
	),
	aD = [sD, lD];
function uD(t, e) {
	return N(), W("svg", iD, aD);
}
const cD = Le(oD, [["render", uD]]),
	dD = {
		Paragraph: {
			label: "Paragraph",
			icon: KP,
			action: (t) => t.chain().focus().setParagraph().run(),
			isActive: (t) => t.isActive("paragraph"),
		},
		"Heading 1": {
			label: "Heading 1",
			text: "H1",
			icon: oP,
			action: (t) => t.chain().focus().toggleHeading({ level: 1 }).run(),
			isActive: (t) => t.isActive("heading", { level: 1 }),
		},
		"Heading 2": {
			label: "Heading 2",
			text: "H2",
			icon: dP,
			action: (t) => t.chain().focus().toggleHeading({ level: 2 }).run(),
			isActive: (t) => t.isActive("heading", { level: 2 }),
		},
		"Heading 3": {
			label: "Heading 3",
			text: "H3",
			icon: vP,
			action: (t) => t.chain().focus().toggleHeading({ level: 3 }).run(),
			isActive: (t) => t.isActive("heading", { level: 3 }),
		},
		"Heading 4": {
			label: "Heading 4",
			text: "H4",
			icon: CP,
			action: (t) => t.chain().focus().toggleHeading({ level: 4 }).run(),
			isActive: (t) => t.isActive("heading", { level: 4 }),
		},
		"Heading 5": {
			label: "Heading 5",
			text: "H5",
			icon: PP,
			action: (t) => t.chain().focus().toggleHeading({ level: 5 }).run(),
			isActive: (t) => t.isActive("heading", { level: 5 }),
		},
		"Heading 6": {
			label: "Heading 6",
			text: "H6",
			icon: BP,
			action: (t) => t.chain().focus().toggleHeading({ level: 6 }).run(),
			isActive: (t) => t.isActive("heading", { level: 6 }),
		},
		Bold: {
			label: "Bold",
			icon: ZP,
			action: (t) => t.chain().focus().toggleBold().run(),
			isActive: (t) => t.isActive("bold"),
		},
		Italic: {
			label: "Italic",
			icon: sI,
			action: (t) => t.chain().focus().toggleItalic().run(),
			isActive: (t) => t.isActive("italic"),
		},
		Underline: {
			label: "Underline",
			icon: hI,
			action: (t) => t.chain().focus().toggleUnderline().run(),
			isActive: (t) => t.isActive("underline"),
		},
		"Bullet List": {
			label: "Bullet List",
			icon: tN,
			action: (t) => t.chain().focus().toggleBulletList().run(),
			isActive: (t) => t.isActive("bulletList"),
		},
		"Numbered List": {
			label: "Numbered List",
			icon: JI,
			action: (t) => t.chain().focus().toggleOrderedList().run(),
			isActive: (t) => t.isActive("orderedList"),
		},
		"Align Center": {
			label: "Align Center",
			icon: wI,
			action: (t) => t.chain().focus().setTextAlign("center").run(),
			isActive: (t) => t.isActive({ textAlign: "center" }),
		},
		"Align Left": {
			label: "Align Left",
			icon: EI,
			action: (t) => t.chain().focus().setTextAlign("left").run(),
			isActive: (t) => t.isActive({ textAlign: "left" }),
		},
		"Align Right": {
			label: "Align Right",
			icon: NI,
			action: (t) => t.chain().focus().setTextAlign("right").run(),
			isActive: (t) => t.isActive({ textAlign: "right" }),
		},
		FontColor: {
			label: "Font Color",
			icon: HI,
			isActive: (t) => t.isActive("textStyle") || t.isActive("highlight"),
			component: yl(() =>
				bl(() => import("./FontColor-NRf-JuEv.js"), __vite__mapDeps([]))
			),
		},
		Blockquote: {
			label: "Blockquote",
			icon: aN,
			action: (t) => t.chain().focus().toggleBlockquote().run(),
			isActive: (t) => t.isActive("blockquote"),
		},
		Code: {
			label: "Code",
			icon: mN,
			action: (t) => t.chain().focus().toggleCodeBlock().run(),
			isActive: (t) => t.isActive("codeBlock"),
		},
		"Horizontal Rule": {
			label: "Horizontal Rule",
			icon: rD,
			action: (t) => t.chain().focus().setHorizontalRule().run(),
			isActive: (t) => !1,
		},
		Link: {
			label: "Link",
			icon: kN,
			isActive: (t) => t.isActive("link"),
			component: yl(() =>
				bl(
					() => import("./InsertLink-3qvgmeYz.js"),
					__vite__mapDeps([])
				)
			),
		},
		Image: {
			label: "Image",
			icon: AN,
			isActive: (t) => !1,
			component: yl(() =>
				bl(
					() => import("./InsertImage-CtNAKsXz.js"),
					__vite__mapDeps([])
				)
			),
		},
		Video: {
			label: "Video",
			icon: jN,
			isActive: (t) => !1,
			component: yl(() =>
				bl(
					() => import("./InsertVideo-BLJom6bq.js"),
					__vite__mapDeps([])
				)
			),
		},
		Undo: {
			label: "Undo",
			icon: VN,
			action: (t) => t.chain().focus().undo().run(),
			isActive: (t) => !1,
		},
		Redo: {
			label: "Redo",
			icon: YN,
			action: (t) => t.chain().focus().redo().run(),
			isActive: (t) => !1,
		},
		InsertTable: {
			label: "Insert Table",
			icon: cD,
			action: (t) =>
				t
					.chain()
					.focus()
					.insertTable({ rows: 3, cols: 3, withHeaderRow: !0 })
					.run(),
			isActive: (t) => !1,
		},
		AddColumnBefore: {
			label: "Add Column Before",
			action: (t) => t.chain().focus().addColumnBefore().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addColumnBefore(),
		},
		AddColumnAfter: {
			label: "Add Column After",
			action: (t) => t.chain().focus().addColumnAfter().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addColumnAfter(),
		},
		DeleteColumn: {
			label: "Delete Column",
			action: (t) => t.chain().focus().deleteColumn().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteColumn(),
		},
		AddRowBefore: {
			label: "Add Row Before",
			action: (t) => t.chain().focus().addRowBefore().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addRowBefore(),
		},
		AddRowAfter: {
			label: "Add Row After",
			action: (t) => t.chain().focus().addRowAfter().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().addRowAfter(),
		},
		DeleteRow: {
			label: "Delete Row",
			action: (t) => t.chain().focus().deleteRow().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteRow(),
		},
		DeleteTable: {
			label: "Delete Table",
			action: (t) => t.chain().focus().deleteTable().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().deleteTable(),
		},
		MergeCells: {
			label: "Merge Cells",
			action: (t) => t.chain().focus().mergeCells().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().mergeCells(),
		},
		SplitCell: {
			label: "Split Cell",
			action: (t) => t.chain().focus().splitCell().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().splitCell(),
		},
		ToggleHeaderColumn: {
			label: "Toggle Header Column",
			action: (t) => t.chain().focus().toggleHeaderColumn().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderColumn(),
		},
		ToggleHeaderRow: {
			label: "Toggle Header Row",
			action: (t) => t.chain().focus().toggleHeaderRow().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderRow(),
		},
		ToggleHeaderCell: {
			label: "Toggle Header Cell",
			action: (t) => t.chain().focus().toggleHeaderCell().run(),
			isActive: (t) => !1,
			isDisabled: (t) => !t.can().toggleHeaderCell(),
		},
		Separator: { type: "separator" },
	};
function tc(t) {
	return t instanceof Array ? t.map(tc) : typeof t == "object" ? t : dD[t];
}
const fD = {
	name: "TextEditorFixedMenu",
	props: ["buttons"],
	components: { Menu: q2 },
	inject: ["editor"],
	computed: {
		fixedMenuButtons() {
			if (!this.buttons) return !1;
			let t;
			return (
				Array.isArray(this.buttons)
					? (t = this.buttons)
					: (t = [
							[
								"Heading 1",
								"Heading 2",
								"Heading 3",
								"Heading 4",
								"Heading 5",
								"Heading 6",
							],
							"Paragraph",
							"Separator",
							"Bold",
							"Italic",
							"Separator",
							"Bullet List",
							"Numbered List",
							"Separator",
							"Align Left",
							"Align Center",
							"Align Right",
							"FontColor",
							"Separator",
							"Image",
							"Video",
							"Link",
							"Blockquote",
							"Code",
							"Horizontal Rule",
							[
								"InsertTable",
								"AddColumnBefore",
								"AddColumnAfter",
								"DeleteColumn",
								"AddRowBefore",
								"AddRowAfter",
								"DeleteRow",
								"MergeCells",
								"SplitCell",
								"ToggleHeaderColumn",
								"ToggleHeaderRow",
								"ToggleHeaderCell",
								"DeleteTable",
							],
							"Separator",
							"Undo",
							"Redo",
					  ]),
				t.map(tc)
			);
		},
	},
};
function hD(t, e, n, r, o, i) {
	const s = Je("Menu");
	return i.fixedMenuButtons
		? (N(),
		  Te(s, { key: 0, buttons: i.fixedMenuButtons }, null, 8, ["buttons"]))
		: Re("", !0);
}
const pD = Le(fD, [["render", hD]]),
	mD = {
		name: "TextEditorBubbleMenu",
		props: ["buttons", "options"],
		components: { BubbleMenu: hO, Menu: q2 },
		inject: ["editor"],
		computed: {
			bubbleMenuButtons() {
				if (!this.buttons) return !1;
				let t;
				return (
					Array.isArray(this.buttons)
						? (t = this.buttons)
						: (t = [
								"Paragraph",
								"Heading 2",
								"Heading 3",
								"Separator",
								"Bold",
								"Italic",
								"Link",
								"Separator",
								"Bullet List",
								"Numbered List",
								"Separator",
								"Image",
								"Video",
								"Blockquote",
								"Code",
								[
									"InsertTable",
									"AddColumnBefore",
									"AddColumnAfter",
									"DeleteColumn",
									"AddRowBefore",
									"AddRowAfter",
									"DeleteRow",
									"MergeCells",
									"SplitCell",
									"ToggleHeaderColumn",
									"ToggleHeaderRow",
									"ToggleHeaderCell",
									"DeleteTable",
								],
						  ]),
					t.map(tc)
				);
			},
		},
	};
function gD(t, e, n, r, o, i) {
	const s = Je("Menu"),
		l = Je("BubbleMenu");
	return i.bubbleMenuButtons
		? (N(),
		  Te(
				l,
				pt(
					{
						key: 0,
						class: "bubble-menu rounded-md shadow-sm",
						"tippy-options": { duration: 100 },
						editor: i.editor,
					},
					n.options
				),
				{
					default: Ce(() => [
						ve(
							s,
							{
								class: "rounded-md border border-gray-100 shadow-lg",
								buttons: i.bubbleMenuButtons,
							},
							null,
							8,
							["buttons"]
						),
					]),
					_: 1,
				},
				16,
				["editor"]
		  ))
		: Re("", !0);
}
const yD = Le(mD, [["render", gD]]),
	vD = {
		name: "TextEditorFloatingMenu",
		props: ["buttons"],
		components: { FloatingMenu: gO },
		inject: ["editor"],
		computed: {
			floatingMenuButtons() {
				if (!this.buttons) return !1;
				let t;
				return (
					Array.isArray(this.buttons)
						? (t = this.buttons)
						: (t = [
								"Paragraph",
								"Heading 2",
								"Heading 3",
								"Bullet List",
								"Numbered List",
								"Blockquote",
								"Code",
								"Horizontal Rule",
						  ]),
					t.map(tc)
				);
			},
		},
	},
	bD = ["onClick", "title"],
	wD = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" };
function xD(t, e, n, r, o, i) {
	const s = Je("FloatingMenu");
	return i.floatingMenuButtons
		? (N(),
		  Te(
				s,
				{
					key: 0,
					"tippy-options": { duration: 100 },
					editor: i.editor,
					class: "flex",
				},
				{
					default: Ce(() => [
						(N(!0),
						W(
							Ne,
							null,
							Rt(
								i.floatingMenuButtons,
								(l) => (
									N(),
									W(
										"button",
										{
											key: l.label,
											class: be([
												"flex rounded p-1 text-gray-800 transition-colors",
												l.isActive(i.editor)
													? "bg-gray-100"
													: "hover:bg-gray-100",
											]),
											onClick: () => l.action(i.editor),
											title: l.label,
										},
										[
											l.icon
												? (N(),
												  Te(Bn(l.icon), {
														key: 0,
														class: "h-4 w-4",
												  }))
												: (N(),
												  W("span", wD, We(l.text), 1)),
										],
										10,
										bD
									)
								)
							),
							128
						)),
					]),
					_: 1,
				},
				8,
				["editor"]
		  ))
		: Re("", !0);
}
const kD = Le(vD, [["render", xD]]);
var J2 = { exports: {} };
(function (t) {
	(function () {
		function e(h) {
			var b = {
				omitExtraWLInCodeBlocks: {
					defaultValue: !1,
					describe:
						"Omit the default extra whiteline added to code blocks",
					type: "boolean",
				},
				noHeaderId: {
					defaultValue: !1,
					describe: "Turn on/off generated header id",
					type: "boolean",
				},
				prefixHeaderId: {
					defaultValue: !1,
					describe:
						"Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix",
					type: "string",
				},
				rawPrefixHeaderId: {
					defaultValue: !1,
					describe:
						'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)',
					type: "boolean",
				},
				ghCompatibleHeaderId: {
					defaultValue: !1,
					describe:
						"Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)",
					type: "boolean",
				},
				rawHeaderId: {
					defaultValue: !1,
					describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,
					type: "boolean",
				},
				headerLevelStart: {
					defaultValue: !1,
					describe: "The header blocks level start",
					type: "integer",
				},
				parseImgDimensions: {
					defaultValue: !1,
					describe: "Turn on/off image dimension parsing",
					type: "boolean",
				},
				simplifiedAutoLink: {
					defaultValue: !1,
					describe: "Turn on/off GFM autolink style",
					type: "boolean",
				},
				excludeTrailingPunctuationFromURLs: {
					defaultValue: !1,
					describe:
						"Excludes trailing punctuation from links generated with autoLinking",
					type: "boolean",
				},
				literalMidWordUnderscores: {
					defaultValue: !1,
					describe:
						"Parse midword underscores as literal underscores",
					type: "boolean",
				},
				literalMidWordAsterisks: {
					defaultValue: !1,
					describe: "Parse midword asterisks as literal asterisks",
					type: "boolean",
				},
				strikethrough: {
					defaultValue: !1,
					describe: "Turn on/off strikethrough support",
					type: "boolean",
				},
				tables: {
					defaultValue: !1,
					describe: "Turn on/off tables support",
					type: "boolean",
				},
				tablesHeaderId: {
					defaultValue: !1,
					describe: "Add an id to table headers",
					type: "boolean",
				},
				ghCodeBlocks: {
					defaultValue: !0,
					describe: "Turn on/off GFM fenced code blocks support",
					type: "boolean",
				},
				tasklists: {
					defaultValue: !1,
					describe: "Turn on/off GFM tasklist support",
					type: "boolean",
				},
				smoothLivePreview: {
					defaultValue: !1,
					describe:
						"Prevents weird effects in live previews due to incomplete input",
					type: "boolean",
				},
				smartIndentationFix: {
					defaultValue: !1,
					describe: "Tries to smartly fix indentation in es6 strings",
					type: "boolean",
				},
				disableForced4SpacesIndentedSublists: {
					defaultValue: !1,
					describe:
						"Disables the requirement of indenting nested sublists by 4 spaces",
					type: "boolean",
				},
				simpleLineBreaks: {
					defaultValue: !1,
					describe: "Parses simple line breaks as <br> (GFM Style)",
					type: "boolean",
				},
				requireSpaceBeforeHeadingText: {
					defaultValue: !1,
					describe:
						"Makes adding a space between `#` and the header text mandatory (GFM Style)",
					type: "boolean",
				},
				ghMentions: {
					defaultValue: !1,
					describe: "Enables github @mentions",
					type: "boolean",
				},
				ghMentionsLink: {
					defaultValue: "https://github.com/{u}",
					describe:
						"Changes the link generated by @mentions. Only applies if ghMentions option is enabled.",
					type: "string",
				},
				encodeEmails: {
					defaultValue: !0,
					describe:
						"Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities",
					type: "boolean",
				},
				openLinksInNewWindow: {
					defaultValue: !1,
					describe: "Open all links in new windows",
					type: "boolean",
				},
				backslashEscapesHTMLTags: {
					defaultValue: !1,
					describe:
						"Support for HTML Tag escaping. ex: <div>foo</div>",
					type: "boolean",
				},
				emoji: {
					defaultValue: !1,
					describe:
						"Enable emoji support. Ex: `this is a :smile: emoji`",
					type: "boolean",
				},
				underline: {
					defaultValue: !1,
					describe:
						"Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`",
					type: "boolean",
				},
				ellipsis: {
					defaultValue: !0,
					describe:
						"Replaces three dots with the ellipsis unicode character",
					type: "boolean",
				},
				completeHTMLDocument: {
					defaultValue: !1,
					describe:
						"Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags",
					type: "boolean",
				},
				metadata: {
					defaultValue: !1,
					describe:
						"Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).",
					type: "boolean",
				},
				splitAdjacentBlockquotes: {
					defaultValue: !1,
					describe: "Split adjacent blockquote blocks",
					type: "boolean",
				},
			};
			if (h === !1) return JSON.parse(JSON.stringify(b));
			var g = {};
			for (var x in b) b.hasOwnProperty(x) && (g[x] = b[x].defaultValue);
			return g;
		}
		function n() {
			var h = e(!0),
				b = {};
			for (var g in h) h.hasOwnProperty(g) && (b[g] = !0);
			return b;
		}
		var r = {},
			o = {},
			i = {},
			s = e(!0),
			l = "vanilla",
			a = {
				github: {
					omitExtraWLInCodeBlocks: !0,
					simplifiedAutoLink: !0,
					excludeTrailingPunctuationFromURLs: !0,
					literalMidWordUnderscores: !0,
					strikethrough: !0,
					tables: !0,
					tablesHeaderId: !0,
					ghCodeBlocks: !0,
					tasklists: !0,
					disableForced4SpacesIndentedSublists: !0,
					simpleLineBreaks: !0,
					requireSpaceBeforeHeadingText: !0,
					ghCompatibleHeaderId: !0,
					ghMentions: !0,
					backslashEscapesHTMLTags: !0,
					emoji: !0,
					splitAdjacentBlockquotes: !0,
				},
				original: { noHeaderId: !0, ghCodeBlocks: !1 },
				ghost: {
					omitExtraWLInCodeBlocks: !0,
					parseImgDimensions: !0,
					simplifiedAutoLink: !0,
					excludeTrailingPunctuationFromURLs: !0,
					literalMidWordUnderscores: !0,
					strikethrough: !0,
					tables: !0,
					tablesHeaderId: !0,
					ghCodeBlocks: !0,
					tasklists: !0,
					smoothLivePreview: !0,
					simpleLineBreaks: !0,
					requireSpaceBeforeHeadingText: !0,
					ghMentions: !1,
					encodeEmails: !0,
				},
				vanilla: e(!0),
				allOn: n(),
			};
		(r.helper = {}),
			(r.extensions = {}),
			(r.setOption = function (h, b) {
				return (s[h] = b), this;
			}),
			(r.getOption = function (h) {
				return s[h];
			}),
			(r.getOptions = function () {
				return s;
			}),
			(r.resetOptions = function () {
				s = e(!0);
			}),
			(r.setFlavor = function (h) {
				if (!a.hasOwnProperty(h))
					throw Error(h + " flavor was not found");
				r.resetOptions();
				var b = a[h];
				l = h;
				for (var g in b) b.hasOwnProperty(g) && (s[g] = b[g]);
			}),
			(r.getFlavor = function () {
				return l;
			}),
			(r.getFlavorOptions = function (h) {
				if (a.hasOwnProperty(h)) return a[h];
			}),
			(r.getDefaultOptions = function (h) {
				return e(h);
			}),
			(r.subParser = function (h, b) {
				if (r.helper.isString(h))
					if (typeof b != "undefined") o[h] = b;
					else {
						if (o.hasOwnProperty(h)) return o[h];
						throw Error(
							"SubParser named " + h + " not registered!"
						);
					}
			}),
			(r.extension = function (h, b) {
				if (!r.helper.isString(h))
					throw Error("Extension 'name' must be a string");
				if (((h = r.helper.stdExtName(h)), r.helper.isUndefined(b))) {
					if (!i.hasOwnProperty(h))
						throw Error(
							"Extension named " + h + " is not registered!"
						);
					return i[h];
				} else {
					typeof b == "function" && (b = b()),
						r.helper.isArray(b) || (b = [b]);
					var g = u(b, h);
					if (g.valid) i[h] = b;
					else throw Error(g.error);
				}
			}),
			(r.getAllExtensions = function () {
				return i;
			}),
			(r.removeExtension = function (h) {
				delete i[h];
			}),
			(r.resetExtensions = function () {
				i = {};
			});
		function u(h, b) {
			var g = b
					? "Error in " + b + " extension->"
					: "Error in unnamed extension",
				x = { valid: !0, error: "" };
			r.helper.isArray(h) || (h = [h]);
			for (var k = 0; k < h.length; ++k) {
				var C = g + " sub-extension " + k + ": ",
					_ = h[k];
				if (typeof _ != "object")
					return (
						(x.valid = !1),
						(x.error =
							C +
							"must be an object, but " +
							typeof _ +
							" given"),
						x
					);
				if (!r.helper.isString(_.type))
					return (
						(x.valid = !1),
						(x.error =
							C +
							'property "type" must be a string, but ' +
							typeof _.type +
							" given"),
						x
					);
				var T = (_.type = _.type.toLowerCase());
				if (
					(T === "language" && (T = _.type = "lang"),
					T === "html" && (T = _.type = "output"),
					T !== "lang" && T !== "output" && T !== "listener")
				)
					return (
						(x.valid = !1),
						(x.error =
							C +
							"type " +
							T +
							' is not recognized. Valid values: "lang/language", "output/html" or "listener"'),
						x
					);
				if (T === "listener") {
					if (r.helper.isUndefined(_.listeners))
						return (
							(x.valid = !1),
							(x.error =
								C +
								'. Extensions of type "listener" must have a property called "listeners"'),
							x
						);
				} else if (
					r.helper.isUndefined(_.filter) &&
					r.helper.isUndefined(_.regex)
				)
					return (
						(x.valid = !1),
						(x.error =
							C +
							T +
							' extensions must define either a "regex" property or a "filter" method'),
						x
					);
				if (_.listeners) {
					if (typeof _.listeners != "object")
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"listeners" property must be an object but ' +
								typeof _.listeners +
								" given"),
							x
						);
					for (var R in _.listeners)
						if (
							_.listeners.hasOwnProperty(R) &&
							typeof _.listeners[R] != "function"
						)
							return (
								(x.valid = !1),
								(x.error =
									C +
									'"listeners" property must be an hash of [event name]: [callback]. listeners.' +
									R +
									" must be a function but " +
									typeof _.listeners[R] +
									" given"),
								x
							);
				}
				if (_.filter) {
					if (typeof _.filter != "function")
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"filter" must be a function, but ' +
								typeof _.filter +
								" given"),
							x
						);
				} else if (_.regex) {
					if (
						(r.helper.isString(_.regex) &&
							(_.regex = new RegExp(_.regex, "g")),
						!(_.regex instanceof RegExp))
					)
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"regex" property must either be a string or a RegExp object, but ' +
								typeof _.regex +
								" given"),
							x
						);
					if (r.helper.isUndefined(_.replace))
						return (
							(x.valid = !1),
							(x.error =
								C +
								'"regex" extensions must implement a replace string or function'),
							x
						);
				}
			}
			return x;
		}
		(r.validateExtension = function (h) {
			var b = u(h, null);
			return b.valid ? !0 : (console.warn(b.error), !1);
		}),
			r.hasOwnProperty("helper") || (r.helper = {}),
			(r.helper.isString = function (h) {
				return typeof h == "string" || h instanceof String;
			}),
			(r.helper.isFunction = function (h) {
				var b = {};
				return h && b.toString.call(h) === "[object Function]";
			}),
			(r.helper.isArray = function (h) {
				return Array.isArray(h);
			}),
			(r.helper.isUndefined = function (h) {
				return typeof h == "undefined";
			}),
			(r.helper.forEach = function (h, b) {
				if (r.helper.isUndefined(h))
					throw new Error("obj param is required");
				if (r.helper.isUndefined(b))
					throw new Error("callback param is required");
				if (!r.helper.isFunction(b))
					throw new Error(
						"callback param must be a function/closure"
					);
				if (typeof h.forEach == "function") h.forEach(b);
				else if (r.helper.isArray(h))
					for (var g = 0; g < h.length; g++) b(h[g], g, h);
				else if (typeof h == "object")
					for (var x in h) h.hasOwnProperty(x) && b(h[x], x, h);
				else
					throw new Error(
						"obj does not seem to be an array or an iterable object"
					);
			}),
			(r.helper.stdExtName = function (h) {
				return h
					.replace(/[_?*+\/\\.^-]/g, "")
					.replace(/\s/g, "")
					.toLowerCase();
			});
		function c(h, b) {
			var g = b.charCodeAt(0);
			return "E" + g + "E";
		}
		(r.helper.escapeCharactersCallback = c),
			(r.helper.escapeCharacters = function (h, b, g) {
				var x = "([" + b.replace(/([\[\]\\])/g, "\\$1") + "])";
				g && (x = "\\\\" + x);
				var k = new RegExp(x, "g");
				return (h = h.replace(k, c)), h;
			}),
			(r.helper.unescapeHTMLEntities = function (h) {
				return h
					.replace(/&quot;/g, '"')
					.replace(/&lt;/g, "<")
					.replace(/&gt;/g, ">")
					.replace(/&amp;/g, "&");
			});
		var d = function (h, b, g, x) {
			var k = x || "",
				C = k.indexOf("g") > -1,
				_ = new RegExp(b + "|" + g, "g" + k.replace(/g/g, "")),
				T = new RegExp(b, k.replace(/g/g, "")),
				R = [],
				P,
				D,
				j,
				M,
				I;
			do
				for (P = 0; (j = _.exec(h)); )
					if (T.test(j[0]))
						P++ || ((D = _.lastIndex), (M = D - j[0].length));
					else if (P && !--P) {
						I = j.index + j[0].length;
						var $ = {
							left: { start: M, end: D },
							match: { start: D, end: j.index },
							right: { start: j.index, end: I },
							wholeMatch: { start: M, end: I },
						};
						if ((R.push($), !C)) return R;
					}
			while (P && (_.lastIndex = D));
			return R;
		};
		(r.helper.matchRecursiveRegExp = function (h, b, g, x) {
			for (var k = d(h, b, g, x), C = [], _ = 0; _ < k.length; ++_)
				C.push([
					h.slice(k[_].wholeMatch.start, k[_].wholeMatch.end),
					h.slice(k[_].match.start, k[_].match.end),
					h.slice(k[_].left.start, k[_].left.end),
					h.slice(k[_].right.start, k[_].right.end),
				]);
			return C;
		}),
			(r.helper.replaceRecursiveRegExp = function (h, b, g, x, k) {
				if (!r.helper.isFunction(b)) {
					var C = b;
					b = function () {
						return C;
					};
				}
				var _ = d(h, g, x, k),
					T = h,
					R = _.length;
				if (R > 0) {
					var P = [];
					_[0].wholeMatch.start !== 0 &&
						P.push(h.slice(0, _[0].wholeMatch.start));
					for (var D = 0; D < R; ++D)
						P.push(
							b(
								h.slice(
									_[D].wholeMatch.start,
									_[D].wholeMatch.end
								),
								h.slice(_[D].match.start, _[D].match.end),
								h.slice(_[D].left.start, _[D].left.end),
								h.slice(_[D].right.start, _[D].right.end)
							)
						),
							D < R - 1 &&
								P.push(
									h.slice(
										_[D].wholeMatch.end,
										_[D + 1].wholeMatch.start
									)
								);
					_[R - 1].wholeMatch.end < h.length &&
						P.push(h.slice(_[R - 1].wholeMatch.end)),
						(T = P.join(""));
				}
				return T;
			}),
			(r.helper.regexIndexOf = function (h, b, g) {
				if (!r.helper.isString(h))
					throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
				if (!(b instanceof RegExp))
					throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp";
				var x = h.substring(g || 0).search(b);
				return x >= 0 ? x + (g || 0) : x;
			}),
			(r.helper.splitAtIndex = function (h, b) {
				if (!r.helper.isString(h))
					throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string";
				return [h.substring(0, b), h.substring(b)];
			}),
			(r.helper.encodeEmailAddress = function (h) {
				var b = [
					function (g) {
						return "&#" + g.charCodeAt(0) + ";";
					},
					function (g) {
						return "&#x" + g.charCodeAt(0).toString(16) + ";";
					},
					function (g) {
						return g;
					},
				];
				return (
					(h = h.replace(/./g, function (g) {
						if (g === "@") g = b[Math.floor(Math.random() * 2)](g);
						else {
							var x = Math.random();
							g =
								x > 0.9
									? b[2](g)
									: x > 0.45
									? b[1](g)
									: b[0](g);
						}
						return g;
					})),
					h
				);
			}),
			(r.helper.padEnd = function (b, g, x) {
				return (
					(g = g >> 0),
					(x = String(x || " ")),
					b.length > g
						? String(b)
						: ((g = g - b.length),
						  g > x.length && (x += x.repeat(g / x.length)),
						  String(b) + x.slice(0, g))
				);
			}),
			typeof console == "undefined" &&
				(console = {
					warn: function (h) {
						alert(h);
					},
					log: function (h) {
						alert(h);
					},
					error: function (h) {
						throw h;
					},
				}),
			(r.helper.regexes = { asteriskDashAndColon: /([*_:~])/g }),
			(r.helper.emojis = {
				"+1": "",
				"-1": "",
				100: "",
				1234: "",
				"1st_place_medal": "",
				"2nd_place_medal": "",
				"3rd_place_medal": "",
				"8ball": "",
				a: "",
				ab: "",
				abc: "",
				abcd: "",
				accept: "",
				aerial_tramway: "",
				airplane: "",
				alarm_clock: "",
				alembic: "",
				alien: "",
				ambulance: "",
				amphora: "",
				anchor: "",
				angel: "",
				anger: "",
				angry: "",
				anguished: "",
				ant: "",
				apple: "",
				aquarius: "",
				aries: "",
				arrow_backward: "",
				arrow_double_down: "",
				arrow_double_up: "",
				arrow_down: "",
				arrow_down_small: "",
				arrow_forward: "",
				arrow_heading_down: "",
				arrow_heading_up: "",
				arrow_left: "",
				arrow_lower_left: "",
				arrow_lower_right: "",
				arrow_right: "",
				arrow_right_hook: "",
				arrow_up: "",
				arrow_up_down: "",
				arrow_up_small: "",
				arrow_upper_left: "",
				arrow_upper_right: "",
				arrows_clockwise: "",
				arrows_counterclockwise: "",
				art: "",
				articulated_lorry: "",
				artificial_satellite: "",
				astonished: "",
				athletic_shoe: "",
				atm: "",
				atom_symbol: "",
				avocado: "",
				b: "",
				baby: "",
				baby_bottle: "",
				baby_chick: "",
				baby_symbol: "",
				back: "",
				bacon: "",
				badminton: "",
				baggage_claim: "",
				baguette_bread: "",
				balance_scale: "",
				balloon: "",
				ballot_box: "",
				ballot_box_with_check: "",
				bamboo: "",
				banana: "",
				bangbang: "",
				bank: "",
				bar_chart: "",
				barber: "",
				baseball: "",
				basketball: "",
				basketball_man: "",
				basketball_woman: "&zwj;",
				bat: "",
				bath: "",
				bathtub: "",
				battery: "",
				beach_umbrella: "",
				bear: "",
				bed: "",
				bee: "",
				beer: "",
				beers: "",
				beetle: "",
				beginner: "",
				bell: "",
				bellhop_bell: "",
				bento: "",
				biking_man: "",
				bike: "",
				biking_woman: "&zwj;",
				bikini: "",
				biohazard: "",
				bird: "",
				birthday: "",
				black_circle: "",
				black_flag: "",
				black_heart: "",
				black_joker: "",
				black_large_square: "",
				black_medium_small_square: "",
				black_medium_square: "",
				black_nib: "",
				black_small_square: "",
				black_square_button: "",
				blonde_man: "",
				blonde_woman: "&zwj;",
				blossom: "",
				blowfish: "",
				blue_book: "",
				blue_car: "",
				blue_heart: "",
				blush: "",
				boar: "",
				boat: "",
				bomb: "",
				book: "",
				bookmark: "",
				bookmark_tabs: "",
				books: "",
				boom: "",
				boot: "",
				bouquet: "",
				bowing_man: "",
				bow_and_arrow: "",
				bowing_woman: "&zwj;",
				bowling: "",
				boxing_glove: "",
				boy: "",
				bread: "",
				bride_with_veil: "",
				bridge_at_night: "",
				briefcase: "",
				broken_heart: "",
				bug: "",
				building_construction: "",
				bulb: "",
				bullettrain_front: "",
				bullettrain_side: "",
				burrito: "",
				bus: "",
				business_suit_levitating: "",
				busstop: "",
				bust_in_silhouette: "",
				busts_in_silhouette: "",
				butterfly: "",
				cactus: "",
				cake: "",
				calendar: "",
				call_me_hand: "",
				calling: "",
				camel: "",
				camera: "",
				camera_flash: "",
				camping: "",
				cancer: "",
				candle: "",
				candy: "",
				canoe: "",
				capital_abcd: "",
				capricorn: "",
				car: "",
				card_file_box: "",
				card_index: "",
				card_index_dividers: "",
				carousel_horse: "",
				carrot: "",
				cat: "",
				cat2: "",
				cd: "",
				chains: "",
				champagne: "",
				chart: "",
				chart_with_downwards_trend: "",
				chart_with_upwards_trend: "",
				checkered_flag: "",
				cheese: "",
				cherries: "",
				cherry_blossom: "",
				chestnut: "",
				chicken: "",
				children_crossing: "",
				chipmunk: "",
				chocolate_bar: "",
				christmas_tree: "",
				church: "",
				cinema: "",
				circus_tent: "",
				city_sunrise: "",
				city_sunset: "",
				cityscape: "",
				cl: "",
				clamp: "",
				clap: "",
				clapper: "",
				classical_building: "",
				clinking_glasses: "",
				clipboard: "",
				clock1: "",
				clock10: "",
				clock1030: "",
				clock11: "",
				clock1130: "",
				clock12: "",
				clock1230: "",
				clock130: "",
				clock2: "",
				clock230: "",
				clock3: "",
				clock330: "",
				clock4: "",
				clock430: "",
				clock5: "",
				clock530: "",
				clock6: "",
				clock630: "",
				clock7: "",
				clock730: "",
				clock8: "",
				clock830: "",
				clock9: "",
				clock930: "",
				closed_book: "",
				closed_lock_with_key: "",
				closed_umbrella: "",
				cloud: "",
				cloud_with_lightning: "",
				cloud_with_lightning_and_rain: "",
				cloud_with_rain: "",
				cloud_with_snow: "",
				clown_face: "",
				clubs: "",
				cocktail: "",
				coffee: "",
				coffin: "",
				cold_sweat: "",
				comet: "",
				computer: "",
				computer_mouse: "",
				confetti_ball: "",
				confounded: "",
				confused: "",
				congratulations: "",
				construction: "",
				construction_worker_man: "",
				construction_worker_woman: "&zwj;",
				control_knobs: "",
				convenience_store: "",
				cookie: "",
				cool: "",
				policeman: "",
				copyright: "",
				corn: "",
				couch_and_lamp: "",
				couple: "",
				couple_with_heart_woman_man: "",
				couple_with_heart_man_man: "&zwj;&zwj;",
				couple_with_heart_woman_woman: "&zwj;&zwj;",
				couplekiss_man_man: "&zwj;&zwj;&zwj;",
				couplekiss_man_woman: "",
				couplekiss_woman_woman: "&zwj;&zwj;&zwj;",
				cow: "",
				cow2: "",
				cowboy_hat_face: "",
				crab: "",
				crayon: "",
				credit_card: "",
				crescent_moon: "",
				cricket: "",
				crocodile: "",
				croissant: "",
				crossed_fingers: "",
				crossed_flags: "",
				crossed_swords: "",
				crown: "",
				cry: "",
				crying_cat_face: "",
				crystal_ball: "",
				cucumber: "",
				cupid: "",
				curly_loop: "",
				currency_exchange: "",
				curry: "",
				custard: "",
				customs: "",
				cyclone: "",
				dagger: "",
				dancer: "",
				dancing_women: "",
				dancing_men: "&zwj;",
				dango: "",
				dark_sunglasses: "",
				dart: "",
				dash: "",
				date: "",
				deciduous_tree: "",
				deer: "",
				department_store: "",
				derelict_house: "",
				desert: "",
				desert_island: "",
				desktop_computer: "",
				male_detective: "",
				diamond_shape_with_a_dot_inside: "",
				diamonds: "",
				disappointed: "",
				disappointed_relieved: "",
				dizzy: "",
				dizzy_face: "",
				do_not_litter: "",
				dog: "",
				dog2: "",
				dollar: "",
				dolls: "",
				dolphin: "",
				door: "",
				doughnut: "",
				dove: "",
				dragon: "",
				dragon_face: "",
				dress: "",
				dromedary_camel: "",
				drooling_face: "",
				droplet: "",
				drum: "",
				duck: "",
				dvd: "",
				"e-mail": "",
				eagle: "",
				ear: "",
				ear_of_rice: "",
				earth_africa: "",
				earth_americas: "",
				earth_asia: "",
				egg: "",
				eggplant: "",
				eight_pointed_black_star: "",
				eight_spoked_asterisk: "",
				electric_plug: "",
				elephant: "",
				email: "",
				end: "",
				envelope_with_arrow: "",
				euro: "",
				european_castle: "",
				european_post_office: "",
				evergreen_tree: "",
				exclamation: "",
				expressionless: "",
				eye: "",
				eye_speech_bubble: "&zwj;",
				eyeglasses: "",
				eyes: "",
				face_with_head_bandage: "",
				face_with_thermometer: "",
				fist_oncoming: "",
				factory: "",
				fallen_leaf: "",
				family_man_woman_boy: "",
				family_man_boy: "&zwj;",
				family_man_boy_boy: "&zwj;&zwj;",
				family_man_girl: "&zwj;",
				family_man_girl_boy: "&zwj;&zwj;",
				family_man_girl_girl: "&zwj;&zwj;",
				family_man_man_boy: "&zwj;&zwj;",
				family_man_man_boy_boy: "&zwj;&zwj;&zwj;",
				family_man_man_girl: "&zwj;&zwj;",
				family_man_man_girl_boy: "&zwj;&zwj;&zwj;",
				family_man_man_girl_girl: "&zwj;&zwj;&zwj;",
				family_man_woman_boy_boy: "&zwj;&zwj;&zwj;",
				family_man_woman_girl: "&zwj;&zwj;",
				family_man_woman_girl_boy: "&zwj;&zwj;&zwj;",
				family_man_woman_girl_girl: "&zwj;&zwj;&zwj;",
				family_woman_boy: "&zwj;",
				family_woman_boy_boy: "&zwj;&zwj;",
				family_woman_girl: "&zwj;",
				family_woman_girl_boy: "&zwj;&zwj;",
				family_woman_girl_girl: "&zwj;&zwj;",
				family_woman_woman_boy: "&zwj;&zwj;",
				family_woman_woman_boy_boy: "&zwj;&zwj;&zwj;",
				family_woman_woman_girl: "&zwj;&zwj;",
				family_woman_woman_girl_boy: "&zwj;&zwj;&zwj;",
				family_woman_woman_girl_girl: "&zwj;&zwj;&zwj;",
				fast_forward: "",
				fax: "",
				fearful: "",
				feet: "",
				female_detective: "&zwj;",
				ferris_wheel: "",
				ferry: "",
				field_hockey: "",
				file_cabinet: "",
				file_folder: "",
				film_projector: "",
				film_strip: "",
				fire: "",
				fire_engine: "",
				fireworks: "",
				first_quarter_moon: "",
				first_quarter_moon_with_face: "",
				fish: "",
				fish_cake: "",
				fishing_pole_and_fish: "",
				fist_raised: "",
				fist_left: "",
				fist_right: "",
				flags: "",
				flashlight: "",
				fleur_de_lis: "",
				flight_arrival: "",
				flight_departure: "",
				floppy_disk: "",
				flower_playing_cards: "",
				flushed: "",
				fog: "",
				foggy: "",
				football: "",
				footprints: "",
				fork_and_knife: "",
				fountain: "",
				fountain_pen: "",
				four_leaf_clover: "",
				fox_face: "",
				framed_picture: "",
				free: "",
				fried_egg: "",
				fried_shrimp: "",
				fries: "",
				frog: "",
				frowning: "",
				frowning_face: "",
				frowning_man: "&zwj;",
				frowning_woman: "",
				middle_finger: "",
				fuelpump: "",
				full_moon: "",
				full_moon_with_face: "",
				funeral_urn: "",
				game_die: "",
				gear: "",
				gem: "",
				gemini: "",
				ghost: "",
				gift: "",
				gift_heart: "",
				girl: "",
				globe_with_meridians: "",
				goal_net: "",
				goat: "",
				golf: "",
				golfing_man: "",
				golfing_woman: "&zwj;",
				gorilla: "",
				grapes: "",
				green_apple: "",
				green_book: "",
				green_heart: "",
				green_salad: "",
				grey_exclamation: "",
				grey_question: "",
				grimacing: "",
				grin: "",
				grinning: "",
				guardsman: "",
				guardswoman: "&zwj;",
				guitar: "",
				gun: "",
				haircut_woman: "",
				haircut_man: "&zwj;",
				hamburger: "",
				hammer: "",
				hammer_and_pick: "",
				hammer_and_wrench: "",
				hamster: "",
				hand: "",
				handbag: "",
				handshake: "",
				hankey: "",
				hatched_chick: "",
				hatching_chick: "",
				headphones: "",
				hear_no_evil: "",
				heart: "",
				heart_decoration: "",
				heart_eyes: "",
				heart_eyes_cat: "",
				heartbeat: "",
				heartpulse: "",
				hearts: "",
				heavy_check_mark: "",
				heavy_division_sign: "",
				heavy_dollar_sign: "",
				heavy_heart_exclamation: "",
				heavy_minus_sign: "",
				heavy_multiplication_x: "",
				heavy_plus_sign: "",
				helicopter: "",
				herb: "",
				hibiscus: "",
				high_brightness: "",
				high_heel: "",
				hocho: "",
				hole: "",
				honey_pot: "",
				horse: "",
				horse_racing: "",
				hospital: "",
				hot_pepper: "",
				hotdog: "",
				hotel: "",
				hotsprings: "",
				hourglass: "",
				hourglass_flowing_sand: "",
				house: "",
				house_with_garden: "",
				houses: "",
				hugs: "",
				hushed: "",
				ice_cream: "",
				ice_hockey: "",
				ice_skate: "",
				icecream: "",
				id: "",
				ideograph_advantage: "",
				imp: "",
				inbox_tray: "",
				incoming_envelope: "",
				tipping_hand_woman: "",
				information_source: "",
				innocent: "",
				interrobang: "",
				iphone: "",
				izakaya_lantern: "",
				jack_o_lantern: "",
				japan: "",
				japanese_castle: "",
				japanese_goblin: "",
				japanese_ogre: "",
				jeans: "",
				joy: "",
				joy_cat: "",
				joystick: "",
				kaaba: "",
				key: "",
				keyboard: "",
				keycap_ten: "",
				kick_scooter: "",
				kimono: "",
				kiss: "",
				kissing: "",
				kissing_cat: "",
				kissing_closed_eyes: "",
				kissing_heart: "",
				kissing_smiling_eyes: "",
				kiwi_fruit: "",
				koala: "",
				koko: "",
				label: "",
				large_blue_circle: "",
				large_blue_diamond: "",
				large_orange_diamond: "",
				last_quarter_moon: "",
				last_quarter_moon_with_face: "",
				latin_cross: "",
				laughing: "",
				leaves: "",
				ledger: "",
				left_luggage: "",
				left_right_arrow: "",
				leftwards_arrow_with_hook: "",
				lemon: "",
				leo: "",
				leopard: "",
				level_slider: "",
				libra: "",
				light_rail: "",
				link: "",
				lion: "",
				lips: "",
				lipstick: "",
				lizard: "",
				lock: "",
				lock_with_ink_pen: "",
				lollipop: "",
				loop: "",
				loud_sound: "",
				loudspeaker: "",
				love_hotel: "",
				love_letter: "",
				low_brightness: "",
				lying_face: "",
				m: "",
				mag: "",
				mag_right: "",
				mahjong: "",
				mailbox: "",
				mailbox_closed: "",
				mailbox_with_mail: "",
				mailbox_with_no_mail: "",
				man: "",
				man_artist: "&zwj;",
				man_astronaut: "&zwj;",
				man_cartwheeling: "&zwj;",
				man_cook: "&zwj;",
				man_dancing: "",
				man_facepalming: "&zwj;",
				man_factory_worker: "&zwj;",
				man_farmer: "&zwj;",
				man_firefighter: "&zwj;",
				man_health_worker: "&zwj;",
				man_in_tuxedo: "",
				man_judge: "&zwj;",
				man_juggling: "&zwj;",
				man_mechanic: "&zwj;",
				man_office_worker: "&zwj;",
				man_pilot: "&zwj;",
				man_playing_handball: "&zwj;",
				man_playing_water_polo: "&zwj;",
				man_scientist: "&zwj;",
				man_shrugging: "&zwj;",
				man_singer: "&zwj;",
				man_student: "&zwj;",
				man_teacher: "&zwj;",
				man_technologist: "&zwj;",
				man_with_gua_pi_mao: "",
				man_with_turban: "",
				tangerine: "",
				mans_shoe: "",
				mantelpiece_clock: "",
				maple_leaf: "",
				martial_arts_uniform: "",
				mask: "",
				massage_woman: "",
				massage_man: "&zwj;",
				meat_on_bone: "",
				medal_military: "",
				medal_sports: "",
				mega: "",
				melon: "",
				memo: "",
				men_wrestling: "&zwj;",
				menorah: "",
				mens: "",
				metal: "",
				metro: "",
				microphone: "",
				microscope: "",
				milk_glass: "",
				milky_way: "",
				minibus: "",
				minidisc: "",
				mobile_phone_off: "",
				money_mouth_face: "",
				money_with_wings: "",
				moneybag: "",
				monkey: "",
				monkey_face: "",
				monorail: "",
				moon: "",
				mortar_board: "",
				mosque: "",
				motor_boat: "",
				motor_scooter: "",
				motorcycle: "",
				motorway: "",
				mount_fuji: "",
				mountain: "",
				mountain_biking_man: "",
				mountain_biking_woman: "&zwj;",
				mountain_cableway: "",
				mountain_railway: "",
				mountain_snow: "",
				mouse: "",
				mouse2: "",
				movie_camera: "",
				moyai: "",
				mrs_claus: "",
				muscle: "",
				mushroom: "",
				musical_keyboard: "",
				musical_note: "",
				musical_score: "",
				mute: "",
				nail_care: "",
				name_badge: "",
				national_park: "",
				nauseated_face: "",
				necktie: "",
				negative_squared_cross_mark: "",
				nerd_face: "",
				neutral_face: "",
				new: "",
				new_moon: "",
				new_moon_with_face: "",
				newspaper: "",
				newspaper_roll: "",
				next_track_button: "",
				ng: "",
				no_good_man: "&zwj;",
				no_good_woman: "",
				night_with_stars: "",
				no_bell: "",
				no_bicycles: "",
				no_entry: "",
				no_entry_sign: "",
				no_mobile_phones: "",
				no_mouth: "",
				no_pedestrians: "",
				no_smoking: "",
				"non-potable_water": "",
				nose: "",
				notebook: "",
				notebook_with_decorative_cover: "",
				notes: "",
				nut_and_bolt: "",
				o: "",
				o2: "",
				ocean: "",
				octopus: "",
				oden: "",
				office: "",
				oil_drum: "",
				ok: "",
				ok_hand: "",
				ok_man: "&zwj;",
				ok_woman: "",
				old_key: "",
				older_man: "",
				older_woman: "",
				om: "",
				on: "",
				oncoming_automobile: "",
				oncoming_bus: "",
				oncoming_police_car: "",
				oncoming_taxi: "",
				open_file_folder: "",
				open_hands: "",
				open_mouth: "",
				open_umbrella: "",
				ophiuchus: "",
				orange_book: "",
				orthodox_cross: "",
				outbox_tray: "",
				owl: "",
				ox: "",
				package: "",
				page_facing_up: "",
				page_with_curl: "",
				pager: "",
				paintbrush: "",
				palm_tree: "",
				pancakes: "",
				panda_face: "",
				paperclip: "",
				paperclips: "",
				parasol_on_ground: "",
				parking: "",
				part_alternation_mark: "",
				partly_sunny: "",
				passenger_ship: "",
				passport_control: "",
				pause_button: "",
				peace_symbol: "",
				peach: "",
				peanuts: "",
				pear: "",
				pen: "",
				pencil2: "",
				penguin: "",
				pensive: "",
				performing_arts: "",
				persevere: "",
				person_fencing: "",
				pouting_woman: "",
				phone: "",
				pick: "",
				pig: "",
				pig2: "",
				pig_nose: "",
				pill: "",
				pineapple: "",
				ping_pong: "",
				pisces: "",
				pizza: "",
				place_of_worship: "",
				plate_with_cutlery: "",
				play_or_pause_button: "",
				point_down: "",
				point_left: "",
				point_right: "",
				point_up: "",
				point_up_2: "",
				police_car: "",
				policewoman: "&zwj;",
				poodle: "",
				popcorn: "",
				post_office: "",
				postal_horn: "",
				postbox: "",
				potable_water: "",
				potato: "",
				pouch: "",
				poultry_leg: "",
				pound: "",
				rage: "",
				pouting_cat: "",
				pouting_man: "&zwj;",
				pray: "",
				prayer_beads: "",
				pregnant_woman: "",
				previous_track_button: "",
				prince: "",
				princess: "",
				printer: "",
				purple_heart: "",
				purse: "",
				pushpin: "",
				put_litter_in_its_place: "",
				question: "",
				rabbit: "",
				rabbit2: "",
				racehorse: "",
				racing_car: "",
				radio: "",
				radio_button: "",
				radioactive: "",
				railway_car: "",
				railway_track: "",
				rainbow: "",
				rainbow_flag: "&zwj;",
				raised_back_of_hand: "",
				raised_hand_with_fingers_splayed: "",
				raised_hands: "",
				raising_hand_woman: "",
				raising_hand_man: "&zwj;",
				ram: "",
				ramen: "",
				rat: "",
				record_button: "",
				recycle: "",
				red_circle: "",
				registered: "",
				relaxed: "",
				relieved: "",
				reminder_ribbon: "",
				repeat: "",
				repeat_one: "",
				rescue_worker_helmet: "",
				restroom: "",
				revolving_hearts: "",
				rewind: "",
				rhinoceros: "",
				ribbon: "",
				rice: "",
				rice_ball: "",
				rice_cracker: "",
				rice_scene: "",
				right_anger_bubble: "",
				ring: "",
				robot: "",
				rocket: "",
				rofl: "",
				roll_eyes: "",
				roller_coaster: "",
				rooster: "",
				rose: "",
				rosette: "",
				rotating_light: "",
				round_pushpin: "",
				rowing_man: "",
				rowing_woman: "&zwj;",
				rugby_football: "",
				running_man: "",
				running_shirt_with_sash: "",
				running_woman: "&zwj;",
				sa: "",
				sagittarius: "",
				sake: "",
				sandal: "",
				santa: "",
				satellite: "",
				saxophone: "",
				school: "",
				school_satchel: "",
				scissors: "",
				scorpion: "",
				scorpius: "",
				scream: "",
				scream_cat: "",
				scroll: "",
				seat: "",
				secret: "",
				see_no_evil: "",
				seedling: "",
				selfie: "",
				shallow_pan_of_food: "",
				shamrock: "",
				shark: "",
				shaved_ice: "",
				sheep: "",
				shell: "",
				shield: "",
				shinto_shrine: "",
				ship: "",
				shirt: "",
				shopping: "",
				shopping_cart: "",
				shower: "",
				shrimp: "",
				signal_strength: "",
				six_pointed_star: "",
				ski: "",
				skier: "",
				skull: "",
				skull_and_crossbones: "",
				sleeping: "",
				sleeping_bed: "",
				sleepy: "",
				slightly_frowning_face: "",
				slightly_smiling_face: "",
				slot_machine: "",
				small_airplane: "",
				small_blue_diamond: "",
				small_orange_diamond: "",
				small_red_triangle: "",
				small_red_triangle_down: "",
				smile: "",
				smile_cat: "",
				smiley: "",
				smiley_cat: "",
				smiling_imp: "",
				smirk: "",
				smirk_cat: "",
				smoking: "",
				snail: "",
				snake: "",
				sneezing_face: "",
				snowboarder: "",
				snowflake: "",
				snowman: "",
				snowman_with_snow: "",
				sob: "",
				soccer: "",
				soon: "",
				sos: "",
				sound: "",
				space_invader: "",
				spades: "",
				spaghetti: "",
				sparkle: "",
				sparkler: "",
				sparkles: "",
				sparkling_heart: "",
				speak_no_evil: "",
				speaker: "",
				speaking_head: "",
				speech_balloon: "",
				speedboat: "",
				spider: "",
				spider_web: "",
				spiral_calendar: "",
				spiral_notepad: "",
				spoon: "",
				squid: "",
				stadium: "",
				star: "",
				star2: "",
				star_and_crescent: "",
				star_of_david: "",
				stars: "",
				station: "",
				statue_of_liberty: "",
				steam_locomotive: "",
				stew: "",
				stop_button: "",
				stop_sign: "",
				stopwatch: "",
				straight_ruler: "",
				strawberry: "",
				stuck_out_tongue: "",
				stuck_out_tongue_closed_eyes: "",
				stuck_out_tongue_winking_eye: "",
				studio_microphone: "",
				stuffed_flatbread: "",
				sun_behind_large_cloud: "",
				sun_behind_rain_cloud: "",
				sun_behind_small_cloud: "",
				sun_with_face: "",
				sunflower: "",
				sunglasses: "",
				sunny: "",
				sunrise: "",
				sunrise_over_mountains: "",
				surfing_man: "",
				surfing_woman: "&zwj;",
				sushi: "",
				suspension_railway: "",
				sweat: "",
				sweat_drops: "",
				sweat_smile: "",
				sweet_potato: "",
				swimming_man: "",
				swimming_woman: "&zwj;",
				symbols: "",
				synagogue: "",
				syringe: "",
				taco: "",
				tada: "",
				tanabata_tree: "",
				taurus: "",
				taxi: "",
				tea: "",
				telephone_receiver: "",
				telescope: "",
				tennis: "",
				tent: "",
				thermometer: "",
				thinking: "",
				thought_balloon: "",
				ticket: "",
				tickets: "",
				tiger: "",
				tiger2: "",
				timer_clock: "",
				tipping_hand_man: "&zwj;",
				tired_face: "",
				tm: "",
				toilet: "",
				tokyo_tower: "",
				tomato: "",
				tongue: "",
				top: "",
				tophat: "",
				tornado: "",
				trackball: "",
				tractor: "",
				traffic_light: "",
				train: "",
				train2: "",
				tram: "",
				triangular_flag_on_post: "",
				triangular_ruler: "",
				trident: "",
				triumph: "",
				trolleybus: "",
				trophy: "",
				tropical_drink: "",
				tropical_fish: "",
				truck: "",
				trumpet: "",
				tulip: "",
				tumbler_glass: "",
				turkey: "",
				turtle: "",
				tv: "",
				twisted_rightwards_arrows: "",
				two_hearts: "",
				two_men_holding_hands: "",
				two_women_holding_hands: "",
				u5272: "",
				u5408: "",
				u55b6: "",
				u6307: "",
				u6708: "",
				u6709: "",
				u6e80: "",
				u7121: "",
				u7533: "",
				u7981: "",
				u7a7a: "",
				umbrella: "",
				unamused: "",
				underage: "",
				unicorn: "",
				unlock: "",
				up: "",
				upside_down_face: "",
				v: "",
				vertical_traffic_light: "",
				vhs: "",
				vibration_mode: "",
				video_camera: "",
				video_game: "",
				violin: "",
				virgo: "",
				volcano: "",
				volleyball: "",
				vs: "",
				vulcan_salute: "",
				walking_man: "",
				walking_woman: "&zwj;",
				waning_crescent_moon: "",
				waning_gibbous_moon: "",
				warning: "",
				wastebasket: "",
				watch: "",
				water_buffalo: "",
				watermelon: "",
				wave: "",
				wavy_dash: "",
				waxing_crescent_moon: "",
				wc: "",
				weary: "",
				wedding: "",
				weight_lifting_man: "",
				weight_lifting_woman: "&zwj;",
				whale: "",
				whale2: "",
				wheel_of_dharma: "",
				wheelchair: "",
				white_check_mark: "",
				white_circle: "",
				white_flag: "",
				white_flower: "",
				white_large_square: "",
				white_medium_small_square: "",
				white_medium_square: "",
				white_small_square: "",
				white_square_button: "",
				wilted_flower: "",
				wind_chime: "",
				wind_face: "",
				wine_glass: "",
				wink: "",
				wolf: "",
				woman: "",
				woman_artist: "&zwj;",
				woman_astronaut: "&zwj;",
				woman_cartwheeling: "&zwj;",
				woman_cook: "&zwj;",
				woman_facepalming: "&zwj;",
				woman_factory_worker: "&zwj;",
				woman_farmer: "&zwj;",
				woman_firefighter: "&zwj;",
				woman_health_worker: "&zwj;",
				woman_judge: "&zwj;",
				woman_juggling: "&zwj;",
				woman_mechanic: "&zwj;",
				woman_office_worker: "&zwj;",
				woman_pilot: "&zwj;",
				woman_playing_handball: "&zwj;",
				woman_playing_water_polo: "&zwj;",
				woman_scientist: "&zwj;",
				woman_shrugging: "&zwj;",
				woman_singer: "&zwj;",
				woman_student: "&zwj;",
				woman_teacher: "&zwj;",
				woman_technologist: "&zwj;",
				woman_with_turban: "&zwj;",
				womans_clothes: "",
				womans_hat: "",
				women_wrestling: "&zwj;",
				womens: "",
				world_map: "",
				worried: "",
				wrench: "",
				writing_hand: "",
				x: "",
				yellow_heart: "",
				yen: "",
				yin_yang: "",
				yum: "",
				zap: "",
				zipper_mouth_face: "",
				zzz: "",
				octocat:
					'<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">',
				showdown: `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>`,
			}),
			(r.Converter = function (h) {
				var b = {},
					g = [],
					x = [],
					k = {},
					C = l,
					_ = { parsed: {}, raw: "", format: "" };
				T();
				function T() {
					h = h || {};
					for (var M in s) s.hasOwnProperty(M) && (b[M] = s[M]);
					if (typeof h == "object")
						for (var I in h) h.hasOwnProperty(I) && (b[I] = h[I]);
					else
						throw Error(
							"Converter expects the passed parameter to be an object, but " +
								typeof h +
								" was passed instead."
						);
					b.extensions && r.helper.forEach(b.extensions, R);
				}
				function R(M, I) {
					if (((I = I || null), r.helper.isString(M)))
						if (
							((M = r.helper.stdExtName(M)),
							(I = M),
							r.extensions[M])
						) {
							console.warn(
								"DEPRECATION WARNING: " +
									M +
									" is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"
							),
								P(r.extensions[M], M);
							return;
						} else if (!r.helper.isUndefined(i[M])) M = i[M];
						else
							throw Error(
								'Extension "' +
									M +
									'" could not be loaded. It was either not found or is not a valid extension.'
							);
					typeof M == "function" && (M = M()),
						r.helper.isArray(M) || (M = [M]);
					var $ = u(M, I);
					if (!$.valid) throw Error($.error);
					for (var K = 0; K < M.length; ++K) {
						switch (M[K].type) {
							case "lang":
								g.push(M[K]);
								break;
							case "output":
								x.push(M[K]);
								break;
						}
						if (M[K].hasOwnProperty("listeners"))
							for (var ie in M[K].listeners)
								M[K].listeners.hasOwnProperty(ie) &&
									D(ie, M[K].listeners[ie]);
					}
				}
				function P(M, I) {
					typeof M == "function" && (M = M(new r.Converter())),
						r.helper.isArray(M) || (M = [M]);
					var $ = u(M, I);
					if (!$.valid) throw Error($.error);
					for (var K = 0; K < M.length; ++K)
						switch (M[K].type) {
							case "lang":
								g.push(M[K]);
								break;
							case "output":
								x.push(M[K]);
								break;
							default:
								throw Error(
									"Extension loader error: Type unrecognized!!!"
								);
						}
				}
				function D(M, I) {
					if (!r.helper.isString(M))
						throw Error(
							"Invalid argument in converter.listen() method: name must be a string, but " +
								typeof M +
								" given"
						);
					if (typeof I != "function")
						throw Error(
							"Invalid argument in converter.listen() method: callback must be a function, but " +
								typeof I +
								" given"
						);
					k.hasOwnProperty(M) || (k[M] = []), k[M].push(I);
				}
				function j(M) {
					var I = M.match(/^\s*/)[0].length,
						$ = new RegExp("^\\s{0," + I + "}", "gm");
					return M.replace($, "");
				}
				(this._dispatch = function (I, $, K, ie) {
					if (k.hasOwnProperty(I))
						for (var X = 0; X < k[I].length; ++X) {
							var de = k[I][X](I, $, this, K, ie);
							de && typeof de != "undefined" && ($ = de);
						}
					return $;
				}),
					(this.listen = function (M, I) {
						return D(M, I), this;
					}),
					(this.makeHtml = function (M) {
						if (!M) return M;
						var I = {
							gHtmlBlocks: [],
							gHtmlMdBlocks: [],
							gHtmlSpans: [],
							gUrls: {},
							gTitles: {},
							gDimensions: {},
							gListLevel: 0,
							hashLinkCounts: {},
							langExtensions: g,
							outputModifiers: x,
							converter: this,
							ghCodeBlocks: [],
							metadata: { parsed: {}, raw: "", format: "" },
						};
						return (
							(M = M.replace(//g, "T")),
							(M = M.replace(/\$/g, "D")),
							(M = M.replace(
								/\r\n/g,
								`
`
							)),
							(M = M.replace(
								/\r/g,
								`
`
							)),
							(M = M.replace(/\u00A0/g, "&nbsp;")),
							b.smartIndentationFix && (M = j(M)),
							(M =
								`

` +
								M +
								`

`),
							(M = r.subParser("detab")(M, b, I)),
							(M = M.replace(/^[ \t]+$/gm, "")),
							r.helper.forEach(g, function ($) {
								M = r.subParser("runExtension")($, M, b, I);
							}),
							(M = r.subParser("metadata")(M, b, I)),
							(M = r.subParser("hashPreCodeTags")(M, b, I)),
							(M = r.subParser("githubCodeBlocks")(M, b, I)),
							(M = r.subParser("hashHTMLBlocks")(M, b, I)),
							(M = r.subParser("hashCodeTags")(M, b, I)),
							(M = r.subParser("stripLinkDefinitions")(M, b, I)),
							(M = r.subParser("blockGamut")(M, b, I)),
							(M = r.subParser("unhashHTMLSpans")(M, b, I)),
							(M = r.subParser("unescapeSpecialChars")(M, b, I)),
							(M = M.replace(/D/g, "$$")),
							(M = M.replace(/T/g, "")),
							(M = r.subParser("completeHTMLDocument")(M, b, I)),
							r.helper.forEach(x, function ($) {
								M = r.subParser("runExtension")($, M, b, I);
							}),
							(_ = I.metadata),
							M
						);
					}),
					(this.makeMarkdown = this.makeMd =
						function (M, I) {
							if (
								((M = M.replace(
									/\r\n/g,
									`
`
								)),
								(M = M.replace(
									/\r/g,
									`
`
								)),
								(M = M.replace(/>[ \t]+</, ">NBSP;<")),
								!I)
							)
								if (window && window.document)
									I = window.document;
								else
									throw new Error(
										"HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM"
									);
							var $ = I.createElement("div");
							$.innerHTML = M;
							var K = { preList: Ee($) };
							ze($);
							for (
								var ie = $.childNodes, X = "", de = 0;
								de < ie.length;
								de++
							)
								X += r.subParser("makeMarkdown.node")(
									ie[de],
									K
								);
							function ze(Pe) {
								for (
									var De = 0;
									De < Pe.childNodes.length;
									++De
								) {
									var H = Pe.childNodes[De];
									H.nodeType === 3
										? !/\S/.test(H.nodeValue) &&
										  !/^[ ]+$/.test(H.nodeValue)
											? (Pe.removeChild(H), --De)
											: ((H.nodeValue = H.nodeValue
													.split(
														`
`
													)
													.join(" ")),
											  (H.nodeValue =
													H.nodeValue.replace(
														/(\s)+/g,
														"$1"
													)))
										: H.nodeType === 1 && ze(H);
								}
							}
							function Ee(Pe) {
								for (
									var De = Pe.querySelectorAll("pre"),
										H = [],
										Z = 0;
									Z < De.length;
									++Z
								)
									if (
										De[Z].childElementCount === 1 &&
										De[
											Z
										].firstChild.tagName.toLowerCase() ===
											"code"
									) {
										var oe =
												De[
													Z
												].firstChild.innerHTML.trim(),
											ce =
												De[Z].firstChild.getAttribute(
													"data-language"
												) || "";
										if (ce === "")
											for (
												var He =
														De[
															Z
														].firstChild.className.split(
															" "
														),
													Ye = 0;
												Ye < He.length;
												++Ye
											) {
												var A =
													He[Ye].match(
														/^language-(.+)$/
													);
												if (A !== null) {
													ce = A[1];
													break;
												}
											}
										(oe =
											r.helper.unescapeHTMLEntities(oe)),
											H.push(oe),
											(De[Z].outerHTML =
												'<precode language="' +
												ce +
												'" precodenum="' +
												Z.toString() +
												'"></precode>');
									} else
										H.push(De[Z].innerHTML),
											(De[Z].innerHTML = ""),
											De[Z].setAttribute(
												"prenum",
												Z.toString()
											);
								return H;
							}
							return X;
						}),
					(this.setOption = function (M, I) {
						b[M] = I;
					}),
					(this.getOption = function (M) {
						return b[M];
					}),
					(this.getOptions = function () {
						return b;
					}),
					(this.addExtension = function (M, I) {
						(I = I || null), R(M, I);
					}),
					(this.useExtension = function (M) {
						R(M);
					}),
					(this.setFlavor = function (M) {
						if (!a.hasOwnProperty(M))
							throw Error(M + " flavor was not found");
						var I = a[M];
						C = M;
						for (var $ in I) I.hasOwnProperty($) && (b[$] = I[$]);
					}),
					(this.getFlavor = function () {
						return C;
					}),
					(this.removeExtension = function (M) {
						r.helper.isArray(M) || (M = [M]);
						for (var I = 0; I < M.length; ++I) {
							for (var $ = M[I], K = 0; K < g.length; ++K)
								g[K] === $ && g.splice(K, 1);
							for (var ie = 0; ie < x.length; ++ie)
								x[ie] === $ && x.splice(ie, 1);
						}
					}),
					(this.getAllExtensions = function () {
						return { language: g, output: x };
					}),
					(this.getMetadata = function (M) {
						return M ? _.raw : _.parsed;
					}),
					(this.getMetadataFormat = function () {
						return _.format;
					}),
					(this._setMetadataPair = function (M, I) {
						_.parsed[M] = I;
					}),
					(this._setMetadataFormat = function (M) {
						_.format = M;
					}),
					(this._setMetadataRaw = function (M) {
						_.raw = M;
					});
			}),
			r.subParser("anchors", function (h, b, g) {
				h = g.converter._dispatch("anchors.before", h, b, g);
				var x = function (k, C, _, T, R, P, D) {
					if (
						(r.helper.isUndefined(D) && (D = ""),
						(_ = _.toLowerCase()),
						k.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
					)
						T = "";
					else if (!T)
						if (
							(_ || (_ = C.toLowerCase().replace(/ ?\n/g, " ")),
							(T = "#" + _),
							!r.helper.isUndefined(g.gUrls[_]))
						)
							(T = g.gUrls[_]),
								r.helper.isUndefined(g.gTitles[_]) ||
									(D = g.gTitles[_]);
						else return k;
					T = T.replace(
						r.helper.regexes.asteriskDashAndColon,
						r.helper.escapeCharactersCallback
					);
					var j = '<a href="' + T + '"';
					return (
						D !== "" &&
							D !== null &&
							((D = D.replace(/"/g, "&quot;")),
							(D = D.replace(
								r.helper.regexes.asteriskDashAndColon,
								r.helper.escapeCharactersCallback
							)),
							(j += ' title="' + D + '"')),
						b.openLinksInNewWindow &&
							!/^#/.test(T) &&
							(j +=
								' rel="noopener noreferrer" target="E95Eblank"'),
						(j += ">" + C + "</a>"),
						j
					);
				};
				return (
					(h = h.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g,
						x
					)),
					(h = h.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
						x
					)),
					(h = h.replace(
						/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g,
						x
					)),
					(h = h.replace(/\[([^\[\]]+)]()()()()()/g, x)),
					b.ghMentions &&
						(h = h.replace(
							/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gim,
							function (k, C, _, T, R) {
								if (_ === "\\") return C + T;
								if (!r.helper.isString(b.ghMentionsLink))
									throw new Error(
										"ghMentionsLink option must be a string"
									);
								var P = b.ghMentionsLink.replace(/\{u}/g, R),
									D = "";
								return (
									b.openLinksInNewWindow &&
										(D =
											' rel="noopener noreferrer" target="E95Eblank"'),
									C +
										'<a href="' +
										P +
										'"' +
										D +
										">" +
										T +
										"</a>"
								);
							}
						)),
					(h = g.converter._dispatch("anchors.after", h, b, g)),
					h
				);
			});
		var f =
				/([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi,
			p =
				/([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi,
			m = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi,
			y =
				/(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gim,
			v = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,
			w = function (h) {
				return function (b, g, x, k, C, _, T) {
					x = x.replace(
						r.helper.regexes.asteriskDashAndColon,
						r.helper.escapeCharactersCallback
					);
					var R = x,
						P = "",
						D = "",
						j = g || "",
						M = T || "";
					return (
						/^www\./i.test(x) &&
							(x = x.replace(/^www\./i, "http://www.")),
						h.excludeTrailingPunctuationFromURLs && _ && (P = _),
						h.openLinksInNewWindow &&
							(D =
								' rel="noopener noreferrer" target="E95Eblank"'),
						j + '<a href="' + x + '"' + D + ">" + R + "</a>" + P + M
					);
				};
			},
			S = function (h, b) {
				return function (g, x, k) {
					var C = "mailto:";
					return (
						(x = x || ""),
						(k = r.subParser("unescapeSpecialChars")(k, h, b)),
						h.encodeEmails
							? ((C = r.helper.encodeEmailAddress(C + k)),
							  (k = r.helper.encodeEmailAddress(k)))
							: (C = C + k),
						x + '<a href="' + C + '">' + k + "</a>"
					);
				};
			};
		r.subParser("autoLinks", function (h, b, g) {
			return (
				(h = g.converter._dispatch("autoLinks.before", h, b, g)),
				(h = h.replace(m, w(b))),
				(h = h.replace(v, S(b, g))),
				(h = g.converter._dispatch("autoLinks.after", h, b, g)),
				h
			);
		}),
			r.subParser("simplifiedAutoLinks", function (h, b, g) {
				return (
					b.simplifiedAutoLink &&
						((h = g.converter._dispatch(
							"simplifiedAutoLinks.before",
							h,
							b,
							g
						)),
						b.excludeTrailingPunctuationFromURLs
							? (h = h.replace(p, w(b)))
							: (h = h.replace(f, w(b))),
						(h = h.replace(y, S(b, g))),
						(h = g.converter._dispatch(
							"simplifiedAutoLinks.after",
							h,
							b,
							g
						))),
					h
				);
			}),
			r.subParser("blockGamut", function (h, b, g) {
				return (
					(h = g.converter._dispatch("blockGamut.before", h, b, g)),
					(h = r.subParser("blockQuotes")(h, b, g)),
					(h = r.subParser("headers")(h, b, g)),
					(h = r.subParser("horizontalRule")(h, b, g)),
					(h = r.subParser("lists")(h, b, g)),
					(h = r.subParser("codeBlocks")(h, b, g)),
					(h = r.subParser("tables")(h, b, g)),
					(h = r.subParser("hashHTMLBlocks")(h, b, g)),
					(h = r.subParser("paragraphs")(h, b, g)),
					(h = g.converter._dispatch("blockGamut.after", h, b, g)),
					h
				);
			}),
			r.subParser("blockQuotes", function (h, b, g) {
				(h = g.converter._dispatch("blockQuotes.before", h, b, g)),
					(h =
						h +
						`

`);
				var x = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm;
				return (
					b.splitAdjacentBlockquotes &&
						(x = /^ {0,3}>[\s\S]*?(?:\n\n)/gm),
					(h = h.replace(x, function (k) {
						return (
							(k = k.replace(/^[ \t]*>[ \t]?/gm, "")),
							(k = k.replace(/0/g, "")),
							(k = k.replace(/^[ \t]+$/gm, "")),
							(k = r.subParser("githubCodeBlocks")(k, b, g)),
							(k = r.subParser("blockGamut")(k, b, g)),
							(k = k.replace(/(^|\n)/g, "$1  ")),
							(k = k.replace(
								/(\s*<pre>[^\r]+?<\/pre>)/gm,
								function (C, _) {
									var T = _;
									return (
										(T = T.replace(/^  /gm, "0")),
										(T = T.replace(/0/g, "")),
										T
									);
								}
							)),
							r.subParser("hashBlock")(
								`<blockquote>
` +
									k +
									`
</blockquote>`,
								b,
								g
							)
						);
					})),
					(h = g.converter._dispatch("blockQuotes.after", h, b, g)),
					h
				);
			}),
			r.subParser("codeBlocks", function (h, b, g) {
				(h = g.converter._dispatch("codeBlocks.before", h, b, g)),
					(h += "0");
				var x =
					/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g;
				return (
					(h = h.replace(x, function (k, C, _) {
						var T = C,
							R = _,
							P = `
`;
						return (
							(T = r.subParser("outdent")(T, b, g)),
							(T = r.subParser("encodeCode")(T, b, g)),
							(T = r.subParser("detab")(T, b, g)),
							(T = T.replace(/^\n+/g, "")),
							(T = T.replace(/\n+$/g, "")),
							b.omitExtraWLInCodeBlocks && (P = ""),
							(T = "<pre><code>" + T + P + "</code></pre>"),
							r.subParser("hashBlock")(T, b, g) + R
						);
					})),
					(h = h.replace(/0/, "")),
					(h = g.converter._dispatch("codeBlocks.after", h, b, g)),
					h
				);
			}),
			r.subParser("codeSpans", function (h, b, g) {
				return (
					(h = g.converter._dispatch("codeSpans.before", h, b, g)),
					typeof h == "undefined" && (h = ""),
					(h = h.replace(
						/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,
						function (x, k, C, _) {
							var T = _;
							return (
								(T = T.replace(/^([ \t]*)/g, "")),
								(T = T.replace(/[ \t]*$/g, "")),
								(T = r.subParser("encodeCode")(T, b, g)),
								(T = k + "<code>" + T + "</code>"),
								(T = r.subParser("hashHTMLSpans")(T, b, g)),
								T
							);
						}
					)),
					(h = g.converter._dispatch("codeSpans.after", h, b, g)),
					h
				);
			}),
			r.subParser("completeHTMLDocument", function (h, b, g) {
				if (!b.completeHTMLDocument) return h;
				h = g.converter._dispatch(
					"completeHTMLDocument.before",
					h,
					b,
					g
				);
				var x = "html",
					k = `<!DOCTYPE HTML>
`,
					C = "",
					_ = `<meta charset="utf-8">
`,
					T = "",
					R = "";
				typeof g.metadata.parsed.doctype != "undefined" &&
					((k =
						"<!DOCTYPE " +
						g.metadata.parsed.doctype +
						`>
`),
					(x = g.metadata.parsed.doctype.toString().toLowerCase()),
					(x === "html" || x === "html5") &&
						(_ = '<meta charset="utf-8">'));
				for (var P in g.metadata.parsed)
					if (g.metadata.parsed.hasOwnProperty(P))
						switch (P.toLowerCase()) {
							case "doctype":
								break;
							case "title":
								C =
									"<title>" +
									g.metadata.parsed.title +
									`</title>
`;
								break;
							case "charset":
								x === "html" || x === "html5"
									? (_ =
											'<meta charset="' +
											g.metadata.parsed.charset +
											`">
`)
									: (_ =
											'<meta name="charset" content="' +
											g.metadata.parsed.charset +
											`">
`);
								break;
							case "language":
							case "lang":
								(T = ' lang="' + g.metadata.parsed[P] + '"'),
									(R +=
										'<meta name="' +
										P +
										'" content="' +
										g.metadata.parsed[P] +
										`">
`);
								break;
							default:
								R +=
									'<meta name="' +
									P +
									'" content="' +
									g.metadata.parsed[P] +
									`">
`;
						}
				return (
					(h =
						k +
						"<html" +
						T +
						`>
<head>
` +
						C +
						_ +
						R +
						`</head>
<body>
` +
						h.trim() +
						`
</body>
</html>`),
					(h = g.converter._dispatch(
						"completeHTMLDocument.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("detab", function (h, b, g) {
				return (
					(h = g.converter._dispatch("detab.before", h, b, g)),
					(h = h.replace(/\t(?=\t)/g, "    ")),
					(h = h.replace(/\t/g, "AB")),
					(h = h.replace(/B(.+?)A/g, function (x, k) {
						for (
							var C = k, _ = 4 - (C.length % 4), T = 0;
							T < _;
							T++
						)
							C += " ";
						return C;
					})),
					(h = h.replace(/A/g, "    ")),
					(h = h.replace(/B/g, "")),
					(h = g.converter._dispatch("detab.after", h, b, g)),
					h
				);
			}),
			r.subParser("ellipsis", function (h, b, g) {
				return (
					b.ellipsis &&
						((h = g.converter._dispatch(
							"ellipsis.before",
							h,
							b,
							g
						)),
						(h = h.replace(/\.\.\./g, "")),
						(h = g.converter._dispatch("ellipsis.after", h, b, g))),
					h
				);
			}),
			r.subParser("emoji", function (h, b, g) {
				if (!b.emoji) return h;
				h = g.converter._dispatch("emoji.before", h, b, g);
				var x = /:([\S]+?):/g;
				return (
					(h = h.replace(x, function (k, C) {
						return r.helper.emojis.hasOwnProperty(C)
							? r.helper.emojis[C]
							: k;
					})),
					(h = g.converter._dispatch("emoji.after", h, b, g)),
					h
				);
			}),
			r.subParser("encodeAmpsAndAngles", function (h, b, g) {
				return (
					(h = g.converter._dispatch(
						"encodeAmpsAndAngles.before",
						h,
						b,
						g
					)),
					(h = h.replace(
						/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,
						"&amp;"
					)),
					(h = h.replace(/<(?![a-z\/?$!])/gi, "&lt;")),
					(h = h.replace(/</g, "&lt;")),
					(h = h.replace(/>/g, "&gt;")),
					(h = g.converter._dispatch(
						"encodeAmpsAndAngles.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("encodeBackslashEscapes", function (h, b, g) {
				return (
					(h = g.converter._dispatch(
						"encodeBackslashEscapes.before",
						h,
						b,
						g
					)),
					(h = h.replace(
						/\\(\\)/g,
						r.helper.escapeCharactersCallback
					)),
					(h = h.replace(
						/\\([`*_{}\[\]()>#+.!~=|:-])/g,
						r.helper.escapeCharactersCallback
					)),
					(h = g.converter._dispatch(
						"encodeBackslashEscapes.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("encodeCode", function (h, b, g) {
				return (
					(h = g.converter._dispatch("encodeCode.before", h, b, g)),
					(h = h
						.replace(/&/g, "&amp;")
						.replace(/</g, "&lt;")
						.replace(/>/g, "&gt;")
						.replace(
							/([*_{}\[\]\\=~-])/g,
							r.helper.escapeCharactersCallback
						)),
					(h = g.converter._dispatch("encodeCode.after", h, b, g)),
					h
				);
			}),
			r.subParser(
				"escapeSpecialCharsWithinTagAttributes",
				function (h, b, g) {
					h = g.converter._dispatch(
						"escapeSpecialCharsWithinTagAttributes.before",
						h,
						b,
						g
					);
					var x = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi,
						k = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;
					return (
						(h = h.replace(x, function (C) {
							return C.replace(
								/(.)<\/?code>(?=.)/g,
								"$1`"
							).replace(
								/([\\`*_~=|])/g,
								r.helper.escapeCharactersCallback
							);
						})),
						(h = h.replace(k, function (C) {
							return C.replace(
								/([\\`*_~=|])/g,
								r.helper.escapeCharactersCallback
							);
						})),
						(h = g.converter._dispatch(
							"escapeSpecialCharsWithinTagAttributes.after",
							h,
							b,
							g
						)),
						h
					);
				}
			),
			r.subParser("githubCodeBlocks", function (h, b, g) {
				return b.ghCodeBlocks
					? ((h = g.converter._dispatch(
							"githubCodeBlocks.before",
							h,
							b,
							g
					  )),
					  (h += "0"),
					  (h = h.replace(
							/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g,
							function (x, k, C, _) {
								var T = b.omitExtraWLInCodeBlocks
									? ""
									: `
`;
								return (
									(_ = r.subParser("encodeCode")(_, b, g)),
									(_ = r.subParser("detab")(_, b, g)),
									(_ = _.replace(/^\n+/g, "")),
									(_ = _.replace(/\n+$/g, "")),
									(_ =
										"<pre><code" +
										(C
											? ' class="' +
											  C +
											  " language-" +
											  C +
											  '"'
											: "") +
										">" +
										_ +
										T +
										"</code></pre>"),
									(_ = r.subParser("hashBlock")(_, b, g)),
									`

G` +
										(g.ghCodeBlocks.push({
											text: x,
											codeblock: _,
										}) -
											1) +
										`G

`
								);
							}
					  )),
					  (h = h.replace(/0/, "")),
					  g.converter._dispatch("githubCodeBlocks.after", h, b, g))
					: h;
			}),
			r.subParser("hashBlock", function (h, b, g) {
				return (
					(h = g.converter._dispatch("hashBlock.before", h, b, g)),
					(h = h.replace(/(^\n+|\n+$)/g, "")),
					(h =
						`

K` +
						(g.gHtmlBlocks.push(h) - 1) +
						`K

`),
					(h = g.converter._dispatch("hashBlock.after", h, b, g)),
					h
				);
			}),
			r.subParser("hashCodeTags", function (h, b, g) {
				h = g.converter._dispatch("hashCodeTags.before", h, b, g);
				var x = function (k, C, _, T) {
					var R = _ + r.subParser("encodeCode")(C, b, g) + T;
					return "C" + (g.gHtmlSpans.push(R) - 1) + "C";
				};
				return (
					(h = r.helper.replaceRecursiveRegExp(
						h,
						x,
						"<code\\b[^>]*>",
						"</code>",
						"gim"
					)),
					(h = g.converter._dispatch("hashCodeTags.after", h, b, g)),
					h
				);
			}),
			r.subParser("hashElement", function (h, b, g) {
				return function (x, k) {
					var C = k;
					return (
						(C = C.replace(
							/\n\n/g,
							`
`
						)),
						(C = C.replace(/^\n/, "")),
						(C = C.replace(/\n+$/g, "")),
						(C =
							`

K` +
							(g.gHtmlBlocks.push(C) - 1) +
							`K

`),
						C
					);
				};
			}),
			r.subParser("hashHTMLBlocks", function (h, b, g) {
				h = g.converter._dispatch("hashHTMLBlocks.before", h, b, g);
				var x = [
						"pre",
						"div",
						"h1",
						"h2",
						"h3",
						"h4",
						"h5",
						"h6",
						"blockquote",
						"table",
						"dl",
						"ol",
						"ul",
						"script",
						"noscript",
						"form",
						"fieldset",
						"iframe",
						"math",
						"style",
						"section",
						"header",
						"footer",
						"nav",
						"article",
						"aside",
						"address",
						"audio",
						"canvas",
						"figure",
						"hgroup",
						"output",
						"video",
						"p",
					],
					k = function (M, I, $, K) {
						var ie = M;
						return (
							$.search(/\bmarkdown\b/) !== -1 &&
								(ie = $ + g.converter.makeHtml(I) + K),
							`

K` +
								(g.gHtmlBlocks.push(ie) - 1) +
								`K

`
						);
					};
				b.backslashEscapesHTMLTags &&
					(h = h.replace(/\\<(\/?[^>]+?)>/g, function (M, I) {
						return "&lt;" + I + "&gt;";
					}));
				for (var C = 0; C < x.length; ++C)
					for (
						var _,
							T = new RegExp(
								"^ {0,3}(<" + x[C] + "\\b[^>]*>)",
								"im"
							),
							R = "<" + x[C] + "\\b[^>]*>",
							P = "</" + x[C] + ">";
						(_ = r.helper.regexIndexOf(h, T)) !== -1;

					) {
						var D = r.helper.splitAtIndex(h, _),
							j = r.helper.replaceRecursiveRegExp(
								D[1],
								k,
								R,
								P,
								"im"
							);
						if (j === D[1]) break;
						h = D[0].concat(j);
					}
				return (
					(h = h.replace(
						/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,
						r.subParser("hashElement")(h, b, g)
					)),
					(h = r.helper.replaceRecursiveRegExp(
						h,
						function (M) {
							return (
								`

K` +
								(g.gHtmlBlocks.push(M) - 1) +
								`K

`
							);
						},
						"^ {0,3}<!--",
						"-->",
						"gm"
					)),
					(h = h.replace(
						/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,
						r.subParser("hashElement")(h, b, g)
					)),
					(h = g.converter._dispatch(
						"hashHTMLBlocks.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("hashHTMLSpans", function (h, b, g) {
				h = g.converter._dispatch("hashHTMLSpans.before", h, b, g);
				function x(k) {
					return "C" + (g.gHtmlSpans.push(k) - 1) + "C";
				}
				return (
					(h = h.replace(/<[^>]+?\/>/gi, function (k) {
						return x(k);
					})),
					(h = h.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (k) {
						return x(k);
					})),
					(h = h.replace(
						/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g,
						function (k) {
							return x(k);
						}
					)),
					(h = h.replace(/<[^>]+?>/gi, function (k) {
						return x(k);
					})),
					(h = g.converter._dispatch("hashHTMLSpans.after", h, b, g)),
					h
				);
			}),
			r.subParser("unhashHTMLSpans", function (h, b, g) {
				h = g.converter._dispatch("unhashHTMLSpans.before", h, b, g);
				for (var x = 0; x < g.gHtmlSpans.length; ++x) {
					for (var k = g.gHtmlSpans[x], C = 0; /C(\d+)C/.test(k); ) {
						var _ = RegExp.$1;
						if (
							((k = k.replace("C" + _ + "C", g.gHtmlSpans[_])),
							C === 10)
						) {
							console.error(
								"maximum nesting of 10 spans reached!!!"
							);
							break;
						}
						++C;
					}
					h = h.replace("C" + x + "C", k);
				}
				return (
					(h = g.converter._dispatch(
						"unhashHTMLSpans.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("hashPreCodeTags", function (h, b, g) {
				h = g.converter._dispatch("hashPreCodeTags.before", h, b, g);
				var x = function (k, C, _, T) {
					var R = _ + r.subParser("encodeCode")(C, b, g) + T;
					return (
						`

G` +
						(g.ghCodeBlocks.push({ text: k, codeblock: R }) - 1) +
						`G

`
					);
				};
				return (
					(h = r.helper.replaceRecursiveRegExp(
						h,
						x,
						"^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>",
						"^ {0,3}</code>\\s*</pre>",
						"gim"
					)),
					(h = g.converter._dispatch(
						"hashPreCodeTags.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("headers", function (h, b, g) {
				h = g.converter._dispatch("headers.before", h, b, g);
				var x = isNaN(parseInt(b.headerLevelStart))
						? 1
						: parseInt(b.headerLevelStart),
					k = b.smoothLivePreview
						? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm
						: /^(.+)[ \t]*\n=+[ \t]*\n+/gm,
					C = b.smoothLivePreview
						? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm
						: /^(.+)[ \t]*\n-+[ \t]*\n+/gm;
				(h = h.replace(k, function (R, P) {
					var D = r.subParser("spanGamut")(P, b, g),
						j = b.noHeaderId ? "" : ' id="' + T(P) + '"',
						M = x,
						I = "<h" + M + j + ">" + D + "</h" + M + ">";
					return r.subParser("hashBlock")(I, b, g);
				})),
					(h = h.replace(C, function (R, P) {
						var D = r.subParser("spanGamut")(P, b, g),
							j = b.noHeaderId ? "" : ' id="' + T(P) + '"',
							M = x + 1,
							I = "<h" + M + j + ">" + D + "</h" + M + ">";
						return r.subParser("hashBlock")(I, b, g);
					}));
				var _ = b.requireSpaceBeforeHeadingText
					? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm
					: /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm;
				h = h.replace(_, function (R, P, D) {
					var j = D;
					b.customizedHeaderId &&
						(j = D.replace(/\s?\{([^{]+?)}\s*$/, ""));
					var M = r.subParser("spanGamut")(j, b, g),
						I = b.noHeaderId ? "" : ' id="' + T(D) + '"',
						$ = x - 1 + P.length,
						K = "<h" + $ + I + ">" + M + "</h" + $ + ">";
					return r.subParser("hashBlock")(K, b, g);
				});
				function T(R) {
					var P, D;
					if (b.customizedHeaderId) {
						var j = R.match(/\{([^{]+?)}\s*$/);
						j && j[1] && (R = j[1]);
					}
					return (
						(P = R),
						r.helper.isString(b.prefixHeaderId)
							? (D = b.prefixHeaderId)
							: b.prefixHeaderId === !0
							? (D = "section-")
							: (D = ""),
						b.rawPrefixHeaderId || (P = D + P),
						b.ghCompatibleHeaderId
							? (P = P.replace(/ /g, "-")
									.replace(/&amp;/g, "")
									.replace(/T/g, "")
									.replace(/D/g, "")
									.replace(
										/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g,
										""
									)
									.toLowerCase())
							: b.rawHeaderId
							? (P = P.replace(/ /g, "-")
									.replace(/&amp;/g, "&")
									.replace(/T/g, "")
									.replace(/D/g, "$")
									.replace(/["']/g, "-")
									.toLowerCase())
							: (P = P.replace(/[^\w]/g, "").toLowerCase()),
						b.rawPrefixHeaderId && (P = D + P),
						g.hashLinkCounts[P]
							? (P = P + "-" + g.hashLinkCounts[P]++)
							: (g.hashLinkCounts[P] = 1),
						P
					);
				}
				return (h = g.converter._dispatch("headers.after", h, b, g)), h;
			}),
			r.subParser("horizontalRule", function (h, b, g) {
				h = g.converter._dispatch("horizontalRule.before", h, b, g);
				var x = r.subParser("hashBlock")("<hr />", b, g);
				return (
					(h = h.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, x)),
					(h = h.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, x)),
					(h = h.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, x)),
					(h = g.converter._dispatch(
						"horizontalRule.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("images", function (h, b, g) {
				h = g.converter._dispatch("images.before", h, b, g);
				var x =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
					k =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g,
					C =
						/!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g,
					_ = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g,
					T = /!\[([^\[\]]+)]()()()()()/g;
				function R(D, j, M, I, $, K, ie, X) {
					return (
						(I = I.replace(/\s/g, "")), P(D, j, M, I, $, K, ie, X)
					);
				}
				function P(D, j, M, I, $, K, ie, X) {
					var de = g.gUrls,
						ze = g.gTitles,
						Ee = g.gDimensions;
					if (
						((M = M.toLowerCase()),
						X || (X = ""),
						D.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1)
					)
						I = "";
					else if (I === "" || I === null)
						if (
							((M === "" || M === null) &&
								(M = j.toLowerCase().replace(/ ?\n/g, " ")),
							(I = "#" + M),
							!r.helper.isUndefined(de[M]))
						)
							(I = de[M]),
								r.helper.isUndefined(ze[M]) || (X = ze[M]),
								r.helper.isUndefined(Ee[M]) ||
									(($ = Ee[M].width), (K = Ee[M].height));
						else return D;
					(j = j
						.replace(/"/g, "&quot;")
						.replace(
							r.helper.regexes.asteriskDashAndColon,
							r.helper.escapeCharactersCallback
						)),
						(I = I.replace(
							r.helper.regexes.asteriskDashAndColon,
							r.helper.escapeCharactersCallback
						));
					var Pe = '<img src="' + I + '" alt="' + j + '"';
					return (
						X &&
							r.helper.isString(X) &&
							((X = X.replace(/"/g, "&quot;").replace(
								r.helper.regexes.asteriskDashAndColon,
								r.helper.escapeCharactersCallback
							)),
							(Pe += ' title="' + X + '"')),
						$ &&
							K &&
							(($ = $ === "*" ? "auto" : $),
							(K = K === "*" ? "auto" : K),
							(Pe += ' width="' + $ + '"'),
							(Pe += ' height="' + K + '"')),
						(Pe += " />"),
						Pe
					);
				}
				return (
					(h = h.replace(_, P)),
					(h = h.replace(C, R)),
					(h = h.replace(k, P)),
					(h = h.replace(x, P)),
					(h = h.replace(T, P)),
					(h = g.converter._dispatch("images.after", h, b, g)),
					h
				);
			}),
			r.subParser("italicsAndBold", function (h, b, g) {
				h = g.converter._dispatch("italicsAndBold.before", h, b, g);
				function x(k, C, _) {
					return C + k + _;
				}
				return (
					b.literalMidWordUnderscores
						? ((h = h.replace(
								/\b___(\S[\s\S]*?)___\b/g,
								function (k, C) {
									return x(
										C,
										"<strong><em>",
										"</em></strong>"
									);
								}
						  )),
						  (h = h.replace(
								/\b__(\S[\s\S]*?)__\b/g,
								function (k, C) {
									return x(C, "<strong>", "</strong>");
								}
						  )),
						  (h = h.replace(
								/\b_(\S[\s\S]*?)_\b/g,
								function (k, C) {
									return x(C, "<em>", "</em>");
								}
						  )))
						: ((h = h.replace(
								/___(\S[\s\S]*?)___/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong><em>", "</em></strong>")
										: k;
								}
						  )),
						  (h = h.replace(/__(\S[\s\S]*?)__/g, function (k, C) {
								return /\S$/.test(C)
									? x(C, "<strong>", "</strong>")
									: k;
						  })),
						  (h = h.replace(
								/_([^\s_][\s\S]*?)_/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<em>", "</em>")
										: k;
								}
						  ))),
					b.literalMidWordAsterisks
						? ((h = h.replace(
								/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g,
								function (k, C, _) {
									return x(
										_,
										C + "<strong><em>",
										"</em></strong>"
									);
								}
						  )),
						  (h = h.replace(
								/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g,
								function (k, C, _) {
									return x(_, C + "<strong>", "</strong>");
								}
						  )),
						  (h = h.replace(
								/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g,
								function (k, C, _) {
									return x(_, C + "<em>", "</em>");
								}
						  )))
						: ((h = h.replace(
								/\*\*\*(\S[\s\S]*?)\*\*\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong><em>", "</em></strong>")
										: k;
								}
						  )),
						  (h = h.replace(
								/\*\*(\S[\s\S]*?)\*\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<strong>", "</strong>")
										: k;
								}
						  )),
						  (h = h.replace(
								/\*([^\s*][\s\S]*?)\*/g,
								function (k, C) {
									return /\S$/.test(C)
										? x(C, "<em>", "</em>")
										: k;
								}
						  ))),
					(h = g.converter._dispatch(
						"italicsAndBold.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("lists", function (h, b, g) {
				function x(_, T) {
					g.gListLevel++,
						(_ = _.replace(
							/\n{2,}$/,
							`
`
						)),
						(_ += "0");
					var R =
							/(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm,
						P = /\n[ \t]*\n(?!0)/.test(_);
					return (
						b.disableForced4SpacesIndentedSublists &&
							(R =
								/(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm),
						(_ = _.replace(R, function (D, j, M, I, $, K, ie) {
							ie = ie && ie.trim() !== "";
							var X = r.subParser("outdent")($, b, g),
								de = "";
							return (
								K &&
									b.tasklists &&
									((de =
										' class="task-list-item" style="list-style-type: none;"'),
									(X = X.replace(
										/^[ \t]*\[(x|X| )?]/m,
										function () {
											var ze =
												'<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"';
											return (
												ie && (ze += " checked"),
												(ze += ">"),
												ze
											);
										}
									))),
								(X = X.replace(
									/^([-*+]|\d\.)[ \t]+[\S\n ]*/g,
									function (ze) {
										return "A" + ze;
									}
								)),
								j || X.search(/\n{2,}/) > -1
									? ((X = r.subParser("githubCodeBlocks")(
											X,
											b,
											g
									  )),
									  (X = r.subParser("blockGamut")(X, b, g)))
									: ((X = r.subParser("lists")(X, b, g)),
									  (X = X.replace(/\n$/, "")),
									  (X = r.subParser("hashHTMLBlocks")(
											X,
											b,
											g
									  )),
									  (X = X.replace(
											/\n\n+/g,
											`

`
									  )),
									  P
											? (X = r.subParser("paragraphs")(
													X,
													b,
													g
											  ))
											: (X = r.subParser("spanGamut")(
													X,
													b,
													g
											  ))),
								(X = X.replace("A", "")),
								(X =
									"<li" +
									de +
									">" +
									X +
									`</li>
`),
								X
							);
						})),
						(_ = _.replace(/0/g, "")),
						g.gListLevel--,
						T && (_ = _.replace(/\s+$/, "")),
						_
					);
				}
				function k(_, T) {
					if (T === "ol") {
						var R = _.match(/^ *(\d+)\./);
						if (R && R[1] !== "1") return ' start="' + R[1] + '"';
					}
					return "";
				}
				function C(_, T, R) {
					var P = b.disableForced4SpacesIndentedSublists
							? /^ ?\d+\.[ \t]/gm
							: /^ {0,3}\d+\.[ \t]/gm,
						D = b.disableForced4SpacesIndentedSublists
							? /^ ?[*+-][ \t]/gm
							: /^ {0,3}[*+-][ \t]/gm,
						j = T === "ul" ? P : D,
						M = "";
					if (_.search(j) !== -1)
						(function $(K) {
							var ie = K.search(j),
								X = k(_, T);
							ie !== -1
								? ((M +=
										`

<` +
										T +
										X +
										`>
` +
										x(K.slice(0, ie), !!R) +
										"</" +
										T +
										`>
`),
								  (T = T === "ul" ? "ol" : "ul"),
								  (j = T === "ul" ? P : D),
								  $(K.slice(ie)))
								: (M +=
										`

<` +
										T +
										X +
										`>
` +
										x(K, !!R) +
										"</" +
										T +
										`>
`);
						})(_);
					else {
						var I = k(_, T);
						M =
							`

<` +
							T +
							I +
							`>
` +
							x(_, !!R) +
							"</" +
							T +
							`>
`;
					}
					return M;
				}
				return (
					(h = g.converter._dispatch("lists.before", h, b, g)),
					(h += "0"),
					g.gListLevel
						? (h = h.replace(
								/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
								function (_, T, R) {
									var P =
										R.search(/[*+-]/g) > -1 ? "ul" : "ol";
									return C(T, P, !0);
								}
						  ))
						: (h = h.replace(
								/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm,
								function (_, T, R, P) {
									var D =
										P.search(/[*+-]/g) > -1 ? "ul" : "ol";
									return C(R, D, !1);
								}
						  )),
					(h = h.replace(/0/, "")),
					(h = g.converter._dispatch("lists.after", h, b, g)),
					h
				);
			}),
			r.subParser("metadata", function (h, b, g) {
				if (!b.metadata) return h;
				h = g.converter._dispatch("metadata.before", h, b, g);
				function x(k) {
					(g.metadata.raw = k),
						(k = k.replace(/&/g, "&amp;").replace(/"/g, "&quot;")),
						(k = k.replace(/\n {4}/g, " ")),
						k.replace(
							/^([\S ]+): +([\s\S]+?)$/gm,
							function (C, _, T) {
								return (g.metadata.parsed[_] = T), "";
							}
						);
				}
				return (
					(h = h.replace(
						/^\s*+(\S*?)\n([\s\S]+?)\n+\n/,
						function (k, C, _) {
							return x(_), "M";
						}
					)),
					(h = h.replace(
						/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/,
						function (k, C, _) {
							return C && (g.metadata.format = C), x(_), "M";
						}
					)),
					(h = h.replace(/M/g, "")),
					(h = g.converter._dispatch("metadata.after", h, b, g)),
					h
				);
			}),
			r.subParser("outdent", function (h, b, g) {
				return (
					(h = g.converter._dispatch("outdent.before", h, b, g)),
					(h = h.replace(/^(\t|[ ]{1,4})/gm, "0")),
					(h = h.replace(/0/g, "")),
					(h = g.converter._dispatch("outdent.after", h, b, g)),
					h
				);
			}),
			r.subParser("paragraphs", function (h, b, g) {
				(h = g.converter._dispatch("paragraphs.before", h, b, g)),
					(h = h.replace(/^\n+/g, "")),
					(h = h.replace(/\n+$/g, ""));
				for (
					var x = h.split(/\n{2,}/g), k = [], C = x.length, _ = 0;
					_ < C;
					_++
				) {
					var T = x[_];
					T.search(/(K|G)(\d+)\1/g) >= 0
						? k.push(T)
						: T.search(/\S/) >= 0 &&
						  ((T = r.subParser("spanGamut")(T, b, g)),
						  (T = T.replace(/^([ \t]*)/g, "<p>")),
						  (T += "</p>"),
						  k.push(T));
				}
				for (C = k.length, _ = 0; _ < C; _++) {
					for (
						var R = "", P = k[_], D = !1;
						/(K|G)(\d+)\1/.test(P);

					) {
						var j = RegExp.$1,
							M = RegExp.$2;
						j === "K"
							? (R = g.gHtmlBlocks[M])
							: D
							? (R = r.subParser("encodeCode")(
									g.ghCodeBlocks[M].text,
									b,
									g
							  ))
							: (R = g.ghCodeBlocks[M].codeblock),
							(R = R.replace(/\$/g, "$$$$")),
							(P = P.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, R)),
							/^<pre\b[^>]*>\s*<code\b[^>]*>/.test(P) && (D = !0);
					}
					k[_] = P;
				}
				return (
					(h = k.join(`
`)),
					(h = h.replace(/^\n+/g, "")),
					(h = h.replace(/\n+$/g, "")),
					g.converter._dispatch("paragraphs.after", h, b, g)
				);
			}),
			r.subParser("runExtension", function (h, b, g, x) {
				if (h.filter) b = h.filter(b, x.converter, g);
				else if (h.regex) {
					var k = h.regex;
					k instanceof RegExp || (k = new RegExp(k, "g")),
						(b = b.replace(k, h.replace));
				}
				return b;
			}),
			r.subParser("spanGamut", function (h, b, g) {
				return (
					(h = g.converter._dispatch("spanGamut.before", h, b, g)),
					(h = r.subParser("codeSpans")(h, b, g)),
					(h = r.subParser("escapeSpecialCharsWithinTagAttributes")(
						h,
						b,
						g
					)),
					(h = r.subParser("encodeBackslashEscapes")(h, b, g)),
					(h = r.subParser("images")(h, b, g)),
					(h = r.subParser("anchors")(h, b, g)),
					(h = r.subParser("autoLinks")(h, b, g)),
					(h = r.subParser("simplifiedAutoLinks")(h, b, g)),
					(h = r.subParser("emoji")(h, b, g)),
					(h = r.subParser("underline")(h, b, g)),
					(h = r.subParser("italicsAndBold")(h, b, g)),
					(h = r.subParser("strikethrough")(h, b, g)),
					(h = r.subParser("ellipsis")(h, b, g)),
					(h = r.subParser("hashHTMLSpans")(h, b, g)),
					(h = r.subParser("encodeAmpsAndAngles")(h, b, g)),
					b.simpleLineBreaks
						? /\n\nK/.test(h) ||
						  (h = h.replace(
								/\n+/g,
								`<br />
`
						  ))
						: (h = h.replace(
								/  +\n/g,
								`<br />
`
						  )),
					(h = g.converter._dispatch("spanGamut.after", h, b, g)),
					h
				);
			}),
			r.subParser("strikethrough", function (h, b, g) {
				function x(k) {
					return (
						b.simplifiedAutoLink &&
							(k = r.subParser("simplifiedAutoLinks")(k, b, g)),
						"<del>" + k + "</del>"
					);
				}
				return (
					b.strikethrough &&
						((h = g.converter._dispatch(
							"strikethrough.before",
							h,
							b,
							g
						)),
						(h = h.replace(
							/(?:~){2}([\s\S]+?)(?:~){2}/g,
							function (k, C) {
								return x(C);
							}
						)),
						(h = g.converter._dispatch(
							"strikethrough.after",
							h,
							b,
							g
						))),
					h
				);
			}),
			r.subParser("stripLinkDefinitions", function (h, b, g) {
				var x =
						/^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm,
					k =
						/^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm;
				h += "0";
				var C = function (_, T, R, P, D, j, M) {
					return (
						(T = T.toLowerCase()),
						h.toLowerCase().split(T).length - 1 < 2
							? _
							: (R.match(/^data:.+?\/.+?;base64,/)
									? (g.gUrls[T] = R.replace(/\s/g, ""))
									: (g.gUrls[T] = r.subParser(
											"encodeAmpsAndAngles"
									  )(R, b, g)),
							  j
									? j + M
									: (M &&
											(g.gTitles[T] = M.replace(
												/"|'/g,
												"&quot;"
											)),
									  b.parseImgDimensions &&
											P &&
											D &&
											(g.gDimensions[T] = {
												width: P,
												height: D,
											}),
									  ""))
					);
				};
				return (
					(h = h.replace(k, C)),
					(h = h.replace(x, C)),
					(h = h.replace(/0/, "")),
					h
				);
			}),
			r.subParser("tables", function (h, b, g) {
				if (!b.tables) return h;
				var x =
						/^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm,
					k =
						/^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm;
				function C(D) {
					return /^:[ \t]*--*$/.test(D)
						? ' style="text-align:left;"'
						: /^--*[ \t]*:[ \t]*$/.test(D)
						? ' style="text-align:right;"'
						: /^:[ \t]*--*[ \t]*:$/.test(D)
						? ' style="text-align:center;"'
						: "";
				}
				function _(D, j) {
					var M = "";
					return (
						(D = D.trim()),
						(b.tablesHeaderId || b.tableHeaderId) &&
							(M =
								' id="' +
								D.replace(/ /g, "_").toLowerCase() +
								'"'),
						(D = r.subParser("spanGamut")(D, b, g)),
						"<th" +
							M +
							j +
							">" +
							D +
							`</th>
`
					);
				}
				function T(D, j) {
					var M = r.subParser("spanGamut")(D, b, g);
					return (
						"<td" +
						j +
						">" +
						M +
						`</td>
`
					);
				}
				function R(D, j) {
					for (
						var M = `<table>
<thead>
<tr>
`,
							I = D.length,
							$ = 0;
						$ < I;
						++$
					)
						M += D[$];
					for (
						M += `</tr>
</thead>
<tbody>
`,
							$ = 0;
						$ < j.length;
						++$
					) {
						M += `<tr>
`;
						for (var K = 0; K < I; ++K) M += j[$][K];
						M += `</tr>
`;
					}
					return (
						(M += `</tbody>
</table>
`),
						M
					);
				}
				function P(D) {
					var j,
						M = D.split(`
`);
					for (j = 0; j < M.length; ++j)
						/^ {0,3}\|/.test(M[j]) &&
							(M[j] = M[j].replace(/^ {0,3}\|/, "")),
							/\|[ \t]*$/.test(M[j]) &&
								(M[j] = M[j].replace(/\|[ \t]*$/, "")),
							(M[j] = r.subParser("codeSpans")(M[j], b, g));
					var I = M[0].split("|").map(function (Pe) {
							return Pe.trim();
						}),
						$ = M[1].split("|").map(function (Pe) {
							return Pe.trim();
						}),
						K = [],
						ie = [],
						X = [],
						de = [];
					for (M.shift(), M.shift(), j = 0; j < M.length; ++j)
						M[j].trim() !== "" &&
							K.push(
								M[j].split("|").map(function (Pe) {
									return Pe.trim();
								})
							);
					if (I.length < $.length) return D;
					for (j = 0; j < $.length; ++j) X.push(C($[j]));
					for (j = 0; j < I.length; ++j)
						r.helper.isUndefined(X[j]) && (X[j] = ""),
							ie.push(_(I[j], X[j]));
					for (j = 0; j < K.length; ++j) {
						for (var ze = [], Ee = 0; Ee < ie.length; ++Ee)
							r.helper.isUndefined(K[j][Ee]),
								ze.push(T(K[j][Ee], X[Ee]));
						de.push(ze);
					}
					return R(ie, de);
				}
				return (
					(h = g.converter._dispatch("tables.before", h, b, g)),
					(h = h.replace(
						/\\(\|)/g,
						r.helper.escapeCharactersCallback
					)),
					(h = h.replace(x, P)),
					(h = h.replace(k, P)),
					(h = g.converter._dispatch("tables.after", h, b, g)),
					h
				);
			}),
			r.subParser("underline", function (h, b, g) {
				return (
					b.underline &&
						((h = g.converter._dispatch(
							"underline.before",
							h,
							b,
							g
						)),
						b.literalMidWordUnderscores
							? ((h = h.replace(
									/\b___(\S[\s\S]*?)___\b/g,
									function (x, k) {
										return "<u>" + k + "</u>";
									}
							  )),
							  (h = h.replace(
									/\b__(\S[\s\S]*?)__\b/g,
									function (x, k) {
										return "<u>" + k + "</u>";
									}
							  )))
							: ((h = h.replace(
									/___(\S[\s\S]*?)___/g,
									function (x, k) {
										return /\S$/.test(k)
											? "<u>" + k + "</u>"
											: x;
									}
							  )),
							  (h = h.replace(
									/__(\S[\s\S]*?)__/g,
									function (x, k) {
										return /\S$/.test(k)
											? "<u>" + k + "</u>"
											: x;
									}
							  ))),
						(h = h.replace(
							/(_)/g,
							r.helper.escapeCharactersCallback
						)),
						(h = g.converter._dispatch(
							"underline.after",
							h,
							b,
							g
						))),
					h
				);
			}),
			r.subParser("unescapeSpecialChars", function (h, b, g) {
				return (
					(h = g.converter._dispatch(
						"unescapeSpecialChars.before",
						h,
						b,
						g
					)),
					(h = h.replace(/E(\d+)E/g, function (x, k) {
						var C = parseInt(k);
						return String.fromCharCode(C);
					})),
					(h = g.converter._dispatch(
						"unescapeSpecialChars.after",
						h,
						b,
						g
					)),
					h
				);
			}),
			r.subParser("makeMarkdown.blockquote", function (h, b) {
				var g = "";
				if (h.hasChildNodes())
					for (
						var x = h.childNodes, k = x.length, C = 0;
						C < k;
						++C
					) {
						var _ = r.subParser("makeMarkdown.node")(x[C], b);
						_ !== "" && (g += _);
					}
				return (
					(g = g.trim()),
					(g =
						"> " +
						g.split(`
`).join(`
> `)),
					g
				);
			}),
			r.subParser("makeMarkdown.codeBlock", function (h, b) {
				var g = h.getAttribute("language"),
					x = h.getAttribute("precodenum");
				return (
					"```" +
					g +
					`
` +
					b.preList[x] +
					"\n```"
				);
			}),
			r.subParser("makeMarkdown.codeSpan", function (h) {
				return "`" + h.innerHTML + "`";
			}),
			r.subParser("makeMarkdown.emphasis", function (h, b) {
				var g = "";
				if (h.hasChildNodes()) {
					g += "*";
					for (var x = h.childNodes, k = x.length, C = 0; C < k; ++C)
						g += r.subParser("makeMarkdown.node")(x[C], b);
					g += "*";
				}
				return g;
			}),
			r.subParser("makeMarkdown.header", function (h, b, g) {
				var x = new Array(g + 1).join("#"),
					k = "";
				if (h.hasChildNodes()) {
					k = x + " ";
					for (var C = h.childNodes, _ = C.length, T = 0; T < _; ++T)
						k += r.subParser("makeMarkdown.node")(C[T], b);
				}
				return k;
			}),
			r.subParser("makeMarkdown.hr", function () {
				return "---";
			}),
			r.subParser("makeMarkdown.image", function (h) {
				var b = "";
				return (
					h.hasAttribute("src") &&
						((b += "![" + h.getAttribute("alt") + "]("),
						(b += "<" + h.getAttribute("src") + ">"),
						h.hasAttribute("width") &&
							h.hasAttribute("height") &&
							(b +=
								" =" +
								h.getAttribute("width") +
								"x" +
								h.getAttribute("height")),
						h.hasAttribute("title") &&
							(b += ' "' + h.getAttribute("title") + '"'),
						(b += ")")),
					b
				);
			}),
			r.subParser("makeMarkdown.links", function (h, b) {
				var g = "";
				if (h.hasChildNodes() && h.hasAttribute("href")) {
					var x = h.childNodes,
						k = x.length;
					g = "[";
					for (var C = 0; C < k; ++C)
						g += r.subParser("makeMarkdown.node")(x[C], b);
					(g += "]("),
						(g += "<" + h.getAttribute("href") + ">"),
						h.hasAttribute("title") &&
							(g += ' "' + h.getAttribute("title") + '"'),
						(g += ")");
				}
				return g;
			}),
			r.subParser("makeMarkdown.list", function (h, b, g) {
				var x = "";
				if (!h.hasChildNodes()) return "";
				for (
					var k = h.childNodes,
						C = k.length,
						_ = h.getAttribute("start") || 1,
						T = 0;
					T < C;
					++T
				)
					if (
						!(
							typeof k[T].tagName == "undefined" ||
							k[T].tagName.toLowerCase() !== "li"
						)
					) {
						var R = "";
						g === "ol" ? (R = _.toString() + ". ") : (R = "- "),
							(x +=
								R +
								r.subParser("makeMarkdown.listItem")(k[T], b)),
							++_;
					}
				return (
					(x += `
<!-- -->
`),
					x.trim()
				);
			}),
			r.subParser("makeMarkdown.listItem", function (h, b) {
				for (
					var g = "", x = h.childNodes, k = x.length, C = 0;
					C < k;
					++C
				)
					g += r.subParser("makeMarkdown.node")(x[C], b);
				return (
					/\n$/.test(g)
						? (g = g
								.split(
									`
`
								)
								.join(
									`
    `
								)
								.replace(/^ {4}$/gm, "")
								.replace(
									/\n\n+/g,
									`

`
								))
						: (g += `
`),
					g
				);
			}),
			r.subParser("makeMarkdown.node", function (h, b, g) {
				g = g || !1;
				var x = "";
				if (h.nodeType === 3)
					return r.subParser("makeMarkdown.txt")(h, b);
				if (h.nodeType === 8)
					return (
						"<!--" +
						h.data +
						`-->

`
					);
				if (h.nodeType !== 1) return "";
				var k = h.tagName.toLowerCase();
				switch (k) {
					case "h1":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 1) +
								`

`);
						break;
					case "h2":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 2) +
								`

`);
						break;
					case "h3":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 3) +
								`

`);
						break;
					case "h4":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 4) +
								`

`);
						break;
					case "h5":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 5) +
								`

`);
						break;
					case "h6":
						g ||
							(x =
								r.subParser("makeMarkdown.header")(h, b, 6) +
								`

`);
						break;
					case "p":
						g ||
							(x =
								r.subParser("makeMarkdown.paragraph")(h, b) +
								`

`);
						break;
					case "blockquote":
						g ||
							(x =
								r.subParser("makeMarkdown.blockquote")(h, b) +
								`

`);
						break;
					case "hr":
						g ||
							(x =
								r.subParser("makeMarkdown.hr")(h, b) +
								`

`);
						break;
					case "ol":
						g ||
							(x =
								r.subParser("makeMarkdown.list")(h, b, "ol") +
								`

`);
						break;
					case "ul":
						g ||
							(x =
								r.subParser("makeMarkdown.list")(h, b, "ul") +
								`

`);
						break;
					case "precode":
						g ||
							(x =
								r.subParser("makeMarkdown.codeBlock")(h, b) +
								`

`);
						break;
					case "pre":
						g ||
							(x =
								r.subParser("makeMarkdown.pre")(h, b) +
								`

`);
						break;
					case "table":
						g ||
							(x =
								r.subParser("makeMarkdown.table")(h, b) +
								`

`);
						break;
					case "code":
						x = r.subParser("makeMarkdown.codeSpan")(h, b);
						break;
					case "em":
					case "i":
						x = r.subParser("makeMarkdown.emphasis")(h, b);
						break;
					case "strong":
					case "b":
						x = r.subParser("makeMarkdown.strong")(h, b);
						break;
					case "del":
						x = r.subParser("makeMarkdown.strikethrough")(h, b);
						break;
					case "a":
						x = r.subParser("makeMarkdown.links")(h, b);
						break;
					case "img":
						x = r.subParser("makeMarkdown.image")(h, b);
						break;
					default:
						x =
							h.outerHTML +
							`

`;
				}
				return x;
			}),
			r.subParser("makeMarkdown.paragraph", function (h, b) {
				var g = "";
				if (h.hasChildNodes())
					for (var x = h.childNodes, k = x.length, C = 0; C < k; ++C)
						g += r.subParser("makeMarkdown.node")(x[C], b);
				return (g = g.trim()), g;
			}),
			r.subParser("makeMarkdown.pre", function (h, b) {
				var g = h.getAttribute("prenum");
				return "<pre>" + b.preList[g] + "</pre>";
			}),
			r.subParser("makeMarkdown.strikethrough", function (h, b) {
				var g = "";
				if (h.hasChildNodes()) {
					g += "~~";
					for (var x = h.childNodes, k = x.length, C = 0; C < k; ++C)
						g += r.subParser("makeMarkdown.node")(x[C], b);
					g += "~~";
				}
				return g;
			}),
			r.subParser("makeMarkdown.strong", function (h, b) {
				var g = "";
				if (h.hasChildNodes()) {
					g += "**";
					for (var x = h.childNodes, k = x.length, C = 0; C < k; ++C)
						g += r.subParser("makeMarkdown.node")(x[C], b);
					g += "**";
				}
				return g;
			}),
			r.subParser("makeMarkdown.table", function (h, b) {
				var g = "",
					x = [[], []],
					k = h.querySelectorAll("thead>tr>th"),
					C = h.querySelectorAll("tbody>tr"),
					_,
					T;
				for (_ = 0; _ < k.length; ++_) {
					var R = r.subParser("makeMarkdown.tableCell")(k[_], b),
						P = "---";
					if (k[_].hasAttribute("style")) {
						var D = k[_].getAttribute("style")
							.toLowerCase()
							.replace(/\s/g, "");
						switch (D) {
							case "text-align:left;":
								P = ":---";
								break;
							case "text-align:right;":
								P = "---:";
								break;
							case "text-align:center;":
								P = ":---:";
								break;
						}
					}
					(x[0][_] = R.trim()), (x[1][_] = P);
				}
				for (_ = 0; _ < C.length; ++_) {
					var j = x.push([]) - 1,
						M = C[_].getElementsByTagName("td");
					for (T = 0; T < k.length; ++T) {
						var I = " ";
						typeof M[T] != "undefined" &&
							(I = r.subParser("makeMarkdown.tableCell")(
								M[T],
								b
							)),
							x[j].push(I);
					}
				}
				var $ = 3;
				for (_ = 0; _ < x.length; ++_)
					for (T = 0; T < x[_].length; ++T) {
						var K = x[_][T].length;
						K > $ && ($ = K);
					}
				for (_ = 0; _ < x.length; ++_) {
					for (T = 0; T < x[_].length; ++T)
						_ === 1
							? x[_][T].slice(-1) === ":"
								? (x[_][T] =
										r.helper.padEnd(
											x[_][T].slice(-1),
											$ - 1,
											"-"
										) + ":")
								: (x[_][T] = r.helper.padEnd(x[_][T], $, "-"))
							: (x[_][T] = r.helper.padEnd(x[_][T], $));
					g +=
						"| " +
						x[_].join(" | ") +
						` |
`;
				}
				return g.trim();
			}),
			r.subParser("makeMarkdown.tableCell", function (h, b) {
				var g = "";
				if (!h.hasChildNodes()) return "";
				for (var x = h.childNodes, k = x.length, C = 0; C < k; ++C)
					g += r.subParser("makeMarkdown.node")(x[C], b, !0);
				return g.trim();
			}),
			r.subParser("makeMarkdown.txt", function (h) {
				var b = h.nodeValue;
				return (
					(b = b.replace(/ +/g, " ")),
					(b = b.replace(/NBSP;/g, " ")),
					(b = r.helper.unescapeHTMLEntities(b)),
					(b = b.replace(/([*_~|`])/g, "\\$1")),
					(b = b.replace(/^(\s*)>/g, "\\$1>")),
					(b = b.replace(/^#/gm, "\\#")),
					(b = b.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3")),
					(b = b.replace(/^( {0,3}\d+)\./gm, "$1\\.")),
					(b = b.replace(/^( {0,3})([+-])/gm, "$1\\$2")),
					(b = b.replace(/]([\s]*)\(/g, "\\]$1\\(")),
					(b = b.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:")),
					b
				);
			});
		var E = this;
		t.exports ? (t.exports = r) : (E.showdown = r);
	}.call($y));
})(J2);
var SD = J2.exports;
const _D = uh(SD);
function CD(t) {
	return new _D.Converter().makeHtml(t);
}
function MD(t) {
	return (
		t
			.split(
				`
`
			)
			.filter(
				(r) =>
					r.startsWith("![") ||
					r.startsWith("#") ||
					r.startsWith("> ") ||
					r.startsWith("*") ||
					r.startsWith("- ") ||
					r.startsWith("1. ") ||
					r.startsWith("```") ||
					r.startsWith("`") ||
					r.startsWith("[") ||
					r.startsWith("---")
			).length > 0
	);
}
const ED = {
	name: "TextEditor",
	inheritAttrs: !1,
	components: {
		EditorContent: mO,
		TextEditorFixedMenu: pD,
		TextEditorBubbleMenu: yD,
		TextEditorFloatingMenu: kD,
	},
	props: {
		content: { type: String, default: null },
		placeholder: { type: [String, Function], default: "" },
		editorClass: { type: [String, Array, Object], default: "" },
		editable: { type: Boolean, default: !0 },
		bubbleMenu: { type: [Boolean, Array], default: !1 },
		bubbleMenuOptions: { type: Object, default: () => ({}) },
		fixedMenu: { type: [Boolean, Array], default: !1 },
		floatingMenu: { type: [Boolean, Array], default: !1 },
		extensions: { type: Array, default: () => [] },
		starterkitOptions: { type: Object, default: () => ({}) },
		mentions: { type: Array, default: () => [] },
	},
	emits: ["change", "focus", "blur"],
	expose: ["editor"],
	provide() {
		return { editor: Q1(() => this.editor) };
	},
	data() {
		return { editor: null };
	},
	watch: {
		content(t) {
			this.editor.getHTML() !== t && this.editor.commands.setContent(t);
		},
		editable(t) {
			this.editor.setEditable(t);
		},
		editorProps: {
			deep: !0,
			handler(t) {
				this.editor && this.editor.setOptions({ editorProps: t });
			},
		},
	},
	mounted() {
		this.editor = new pO({
			content: this.content || null,
			editorProps: this.editorProps,
			editable: this.editable,
			extensions: [
				g5.configure(B({}, this.starterkitOptions)),
				k6.configure({ resizable: !0 }),
				C6,
				_6,
				S6,
				xR,
				v5.configure({ types: ["heading", "paragraph"] }),
				kR,
				MR,
				CR.configure({ multicolor: !0 }),
				E6,
				A6,
				X6.configure({ openOnClick: !1 }),
				y5.configure({
					showOnlyWhenEditable: !1,
					placeholder:
						typeof this.placeholder == "function"
							? this.placeholder
							: () => this.placeholder,
				}),
				LR(this.mentions),
				...(this.extensions || []),
			],
			onUpdate: ({ editor: t }) => {
				this.$emit("change", t.getHTML());
			},
			onFocus: ({ editor: t, event: e }) => {
				this.$emit("focus", e);
			},
			onBlur: ({ editor: t, event: e }) => {
				this.$emit("blur", e);
			},
		});
	},
	beforeUnmount() {
		this.editor.destroy(), (this.editor = null);
	},
	computed: {
		editorProps() {
			return {
				attributes: {
					class: be([
						"prose prose-table:table-fixed prose-td:p-2 prose-th:p-2 prose-td:border prose-th:border prose-td:border-gray-300 prose-th:border-gray-300 prose-td:relative prose-th:relative prose-th:bg-gray-100",
						this.editorClass,
					]),
				},
				clipboardTextParser: (t, e) => {
					if (
						!MD(t) ||
						!confirm(
							"Do you want to convert markdown content to HTML before pasting?"
						)
					)
						return;
					let n = document.createElement("div");
					return (
						(n.innerHTML = CD(t)),
						(
							this.editor.view.someProp("clipboardParser") ||
							this.editor.view.someProp("domParser") ||
							zu.fromSchema(this.editor.schema)
						).parseSlice(n, { preserveWhitespace: !0, context: e })
					);
				},
			};
		},
	},
};
function TD(t, e, n, r, o, i) {
	const s = Je("TextEditorBubbleMenu"),
		l = Je("TextEditorFixedMenu"),
		a = Je("TextEditorFloatingMenu"),
		u = Je("editor-content");
	return o.editor
		? (N(),
		  W(
				"div",
				{ key: 0, class: be(["relative w-full", t.$attrs.class]) },
				[
					ve(
						s,
						{ buttons: n.bubbleMenu, options: n.bubbleMenuOptions },
						null,
						8,
						["buttons", "options"]
					),
					ve(
						l,
						{
							class: "w-full overflow-x-auto rounded-t-lg border border-gray-200",
							buttons: n.fixedMenu,
						},
						null,
						8,
						["buttons"]
					),
					ve(a, { buttons: n.floatingMenu }, null, 8, ["buttons"]),
					xe(t.$slots, "top"),
					xe(t.$slots, "editor", { editor: o.editor }, () => [
						ve(u, { editor: o.editor }, null, 8, ["editor"]),
					]),
					xe(t.$slots, "bottom"),
				],
				2
		  ))
		: Re("", !0);
}
const FL = Le(ED, [["render", TD]]);
function G2(t, e = !0) {
	let n = e ? "14px " : "",
		r = t
			.map((o) => {
				let i = o.width || 1;
				return typeof i == "number" ? i + "fr" : i;
			})
			.join(" ");
	return n + r;
}
const Wh = {
		left: "justify-start",
		start: "justify-start",
		center: "justify-center",
		middle: "justify-center",
		right: "justify-end",
		end: "justify-end",
	},
	AD = {
		__name: "ListHeaderItem",
		props: { item: { type: Object, required: !0 } },
		setup(t) {
			return (e, n) => (
				N(),
				W(
					"div",
					{
						class: be([
							"flex items-center space-x-2 text-base text-gray-600",
							ne(Wh)[t.item.align],
						]),
					},
					[
						xe(e.$slots, "prefix", Et(Lt({ item: t.item }))),
						V("div", null, We(t.item.label), 1),
						xe(e.$slots, "suffix", Et(Lt({ item: t.item }))),
					],
					2
				)
			);
		},
	},
	OD = {
		__name: "ListHeader",
		setup(t) {
			const e = Ge("list");
			return (n, r) => (
				N(),
				W(
					"div",
					{
						class: "mb-2 grid items-center space-x-4 rounded bg-gray-100 p-2",
						style: ao({
							gridTemplateColumns: ne(G2)(
								ne(e).columns,
								ne(e).options.selectable
							),
						}),
					},
					[
						ne(e).options.selectable
							? (N(),
							  Te(
									Lu,
									{
										key: 0,
										class: "cursor-pointer duration-300",
										modelValue: ne(e).allRowsSelected,
										onClick: $0(ne(e).toggleAllRows, [
											"stop",
										]),
									},
									null,
									8,
									["modelValue", "onClick"]
							  ))
							: Re("", !0),
						xe(n.$slots, "default", {}, () => [
							(N(!0),
							W(
								Ne,
								null,
								Rt(
									ne(e).columns,
									(o) => (
										N(),
										Te(
											AD,
											{ key: o.key, item: o },
											null,
											8,
											["item"]
										)
									)
								),
								128
							)),
						]),
					],
					4
				)
			);
		},
	},
	RD = {
		name: "Tooltip",
		components: { Popover: tl },
		props: {
			hoverDelay: { default: 0.5 },
			placement: { default: "top" },
			text: { type: String, default: null },
		},
	},
	PD = {
		key: 0,
		class: "rounded bg-gray-900 px-2 py-1 text-xs text-white shadow-xl",
	},
	ID = { class: "py-px" };
function ND(t, e, n, r, o, i) {
	const s = Je("Popover");
	return (
		N(),
		Te(
			s,
			{
				trigger: "hover",
				hoverDelay: n.hoverDelay,
				placement: n.placement,
			},
			{
				target: Ce(() => [xe(t.$slots, "default")]),
				body: Ce(() => [
					xe(t.$slots, "body", {}, () => [
						n.text
							? (N(), W("div", PD, [V("div", ID, We(n.text), 1)]))
							: Re("", !0),
					]),
				]),
				_: 3,
			},
			8,
			["hoverDelay", "placement"]
		)
	);
}
const DD = Le(RD, [["render", ND]]),
	jD = { class: "truncate text-base" },
	LD = {
		__name: "ListRowItem",
		props: {
			item: { type: [String, Number, Object], default: "" },
			align: { type: String, default: "left" },
		},
		setup(t) {
			const e = t,
				n = z(() => r(e.item).label || "");
			function r(i) {
				return i && typeof i == "object" ? i : { label: i };
			}
			const o = Ge("list");
			return (i, s) => (
				N(),
				Te(
					Bn(ne(o).options.showTooltip ? DD : "div"),
					pt(ne(o).options.showTooltip ? { text: n.value } : {}, {
						class: ["flex items-center space-x-2", ne(Wh)[t.align]],
					}),
					{
						default: Ce(() => [
							xe(i.$slots, "prefix"),
							xe(
								i.$slots,
								"default",
								Et(Lt({ label: n.value })),
								() => [V("div", jD, We(n.value), 1)]
							),
							xe(i.$slots, "suffix"),
						]),
						_: 3,
					},
					16,
					["class"]
				)
			);
		},
	},
	$D = { key: 0, class: "mx-2 h-px border-t border-gray-200" },
	BD = {
		__name: "ListRow",
		props: { row: { type: Object, required: !0 } },
		setup(t) {
			const e = t,
				n = Ge("list"),
				r = z(() => {
					var o;
					return (o = n.value.rows) != null && o.length
						? n.value.rows[n.value.rows.length - 1][
								n.value.rowKey
						  ] === e.row[n.value.rowKey]
						: !1;
				});
			return (o, i) => (
				N(),
				Te(
					Bn(ne(n).options.getRowRoute ? "router-link" : "div"),
					pt(
						{
							class: "flex cursor-pointer flex-col transition-all duration-300 ease-in-out",
						},
						ne(n).options.getRowRoute
							? { to: ne(n).options.getRowRoute(t.row) }
							: { onClick: () => ne(n).options.onRowClick(t.row) }
					),
					{
						default: Ce(() => [
							(N(),
							Te(
								Bn(
									ne(n).options.getRowRoute
										? "template"
										: "button"
								),
								{ class: "[all:unset] hover:[all:unset]" },
								{
									default: Ce(() => [
										V(
											"div",
											{
												class: be([
													"grid items-center space-x-4 rounded px-2 py-2.5",
													ne(n).selections.has(
														t.row[ne(n).rowKey]
													)
														? "bg-gray-100 hover:bg-gray-200"
														: "hover:bg-gray-50",
												]),
												style: ao({
													gridTemplateColumns: ne(G2)(
														ne(n).columns,
														ne(n).options.selectable
													),
												}),
											},
											[
												ne(n).options.selectable
													? (N(),
													  Te(
															Lu,
															{
																key: 0,
																modelValue: ne(
																	n
																).selections.has(
																	t.row[
																		ne(n)
																			.rowKey
																	]
																),
																onClick:
																	i[0] ||
																	(i[0] = $0(
																		(s) =>
																			ne(
																				n
																			).toggleRow(
																				t
																					.row[
																					ne(
																						n
																					)
																						.rowKey
																				]
																			),
																		["stop"]
																	)),
																class: "cursor-pointer duration-300",
															},
															null,
															8,
															["modelValue"]
													  ))
													: Re("", !0),
												(N(!0),
												W(
													Ne,
													null,
													Rt(
														ne(n).columns,
														(s) => (
															N(),
															W(
																"div",
																{
																	key: s.key,
																	class: be(
																		ne(Wh)[
																			s
																				.align
																		]
																	),
																},
																[
																	xe(
																		o.$slots,
																		"default",
																		Et(
																			Lt({
																				column: s,
																				item: t
																					.row[
																					s
																						.key
																				],
																			})
																		),
																		() => [
																			ve(
																				LD,
																				{
																					item: t
																						.row[
																						s
																							.key
																					],
																					align: s.align,
																				},
																				null,
																				8,
																				[
																					"item",
																					"align",
																				]
																			),
																		]
																	),
																],
																2
															)
														)
													),
													128
												)),
											],
											6
										),
										r.value
											? Re("", !0)
											: (N(), W("div", $D)),
									]),
									_: 3,
								}
							)),
						]),
						_: 3,
					},
					16
				)
			);
		},
	},
	zD = { class: "h-full overflow-y-auto" },
	HD = {
		__name: "ListRows",
		setup(t) {
			const e = Ge("list");
			return (n, r) => (
				N(),
				W("div", zD, [
					xe(n.$slots, "default", {}, () => [
						(N(!0),
						W(
							Ne,
							null,
							Rt(
								ne(e).rows,
								(o) => (
									N(),
									Te(
										BD,
										{ key: o[ne(e).rowKey], row: o },
										null,
										8,
										["row"]
									)
								)
							),
							128
						)),
					]),
				])
			);
		},
	},
	FD = {
		key: 0,
		class: "absolute inset-x-0 bottom-6 mx-auto w-max text-base",
	},
	VD = {
		class: "flex flex-1 justify-between border-r border-gray-300 text-gray-900",
	},
	WD = { class: "flex items-center space-x-3" },
	UD = { class: "mr-3" },
	KD = { class: "flex items-center space-x-1" },
	qD = Object.assign(
		{ inheritAttrs: !1 },
		{
			__name: "ListSelectBanner",
			setup(t) {
				const e = Ge("list");
				let n = z(() => {
					let r = e.value.selections.size === 1 ? "Row" : "Rows";
					return `${e.value.selections.size} ${r} selected`;
				});
				return (r, o) => (
					N(),
					Te(
						Tu,
						{
							"enter-active-class": "duration-300 ease-out",
							"enter-from-class": "transform opacity-0",
							"enter-to-class": "opacity-100",
							"leave-active-class": "duration-300 ease-in",
							"leave-from-class": "opacity-100",
							"leave-to-class": "transform opacity-0",
						},
						{
							default: Ce(() => [
								ne(e).selections.size
									? (N(),
									  W("div", FD, [
											V(
												"div",
												{
													class: be([
														"flex min-w-[596px] items-center space-x-3 rounded-lg bg-white px-4 py-2 shadow-2xl",
														r.$attrs.class,
													]),
												},
												[
													xe(
														r.$slots,
														"default",
														Et(
															Lt({
																selections:
																	ne(e)
																		.selections,
																allRowsSelected:
																	ne(e)
																		.allRowsSelected,
																selectAll: () =>
																	ne(
																		e
																	).toggleAllRows(
																		!0
																	),
																unselectAll:
																	() =>
																		ne(
																			e
																		).toggleAllRows(
																			!1
																		),
															})
														),
														() => [
															V("div", VD, [
																V("div", WD, [
																	ve(Lu, {
																		modelValue:
																			!0,
																		disabled:
																			!0,
																		class: "text-gray-900",
																	}),
																	V(
																		"div",
																		null,
																		We(
																			ne(
																				n
																			)
																		),
																		1
																	),
																]),
																V("div", UD, [
																	xe(
																		r.$slots,
																		"actions",
																		Et(
																			Lt({
																				selections:
																					ne(
																						e
																					)
																						.selections,
																				allRowsSelected:
																					ne(
																						e
																					)
																						.allRowsSelected,
																				selectAll:
																					() =>
																						ne(
																							e
																						).toggleAllRows(
																							!0
																						),
																				unselectAll:
																					() =>
																						ne(
																							e
																						).toggleAllRows(
																							!1
																						),
																			})
																		)
																	),
																]),
															]),
															V("div", KD, [
																ve(
																	Oi,
																	{
																		class: be(
																			[
																				"w- text-gray-700",
																				ne(
																					e
																				)
																					.allRowsSelected
																					? "cursor-not-allowed"
																					: "",
																			]
																		),
																		disabled:
																			ne(
																				e
																			)
																				.allRowsSelected,
																		variant:
																			"ghost",
																		onClick:
																			o[0] ||
																			(o[0] =
																				(
																					i
																				) =>
																					ne(
																						e
																					).toggleAllRows(
																						!0
																					)),
																	},
																	{
																		default:
																			Ce(
																				() => [
																					lr(
																						" Select all "
																					),
																				]
																			),
																		_: 1,
																	},
																	8,
																	[
																		"disabled",
																		"class",
																	]
																),
																ve(Oi, {
																	icon: "x",
																	variant:
																		"ghost",
																	onClick:
																		o[1] ||
																		(o[1] =
																			(
																				i
																			) =>
																				ne(
																					e
																				).toggleAllRows(
																					!1
																				)),
																}),
															]),
														]
													),
												],
												2
											),
									  ]))
									: Re("", !0),
							]),
							_: 3,
						}
					)
				);
			},
		}
	),
	JD = { class: "relative flex w-full flex-1 flex-col overflow-x-auto" },
	VL = Object.assign(
		{ inheritAttrs: !1 },
		{
			__name: "ListView",
			props: {
				columns: { type: Array, default: [] },
				rows: { type: Array, default: [] },
				rowKey: { type: String, required: !0 },
				options: {
					type: Object,
					default: {
						getRowRoute: null,
						onRowClick: null,
						showTooltip: !0,
						selectable: !0,
					},
				},
			},
			setup(t) {
				const e = t;
				let n = Yt(new Set()),
					r = z(() => {
						function l(a) {
							return a === void 0 ? !0 : a;
						}
						return {
							getRowRoute: e.options.getRowRoute || null,
							onRowClick: e.options.onRowClick || null,
							showTooltip: l(e.options.showTooltip),
							selectable: l(e.options.selectable),
						};
					});
				const o = z(() =>
					e.rows.length ? n.size === e.rows.length : !1
				);
				function i(l) {
					n.delete(l) || n.add(l);
				}
				function s(l) {
					if (!l || o.value) {
						n.clear();
						return;
					}
					e.rows.forEach((a) => n.add(a[e.rowKey]));
				}
				return (
					wt(
						"list",
						z(() => ({
							rowKey: e.rowKey,
							rows: e.rows,
							columns: e.columns,
							options: r.value,
							selections: n,
							allRowsSelected: o.value,
							toggleRow: i,
							toggleAllRows: s,
						}))
					),
					(l, a) => (
						N(),
						W("div", JD, [
							V(
								"div",
								{
									class: be([
										"flex w-max min-w-full flex-col overflow-y-hidden",
										l.$attrs.class,
									]),
								},
								[
									xe(l.$slots, "default", {}, () => [
										ve(OD),
										ve(HD),
										ne(r).selectable
											? (N(), Te(qD, { key: 0 }))
											: Re("", !0),
									]),
								],
								2
							),
						])
					)
				);
			},
		}
	),
	GD = {
		name: "Toast",
		props: {
			position: { type: String, default: "top-center" },
			icon: { type: String },
			iconClasses: { type: String },
			title: { type: String },
			text: { type: String },
			timeout: { type: Number, default: 5 },
		},
		emits: ["close"],
		components: { FeatherIcon: _r },
		mounted() {
			this.timeout > 0 &&
				setTimeout(() => {
					this.$emit("close");
				}, this.timeout * 1e3);
		},
	},
	YD = {
		class: "my-2 min-w-[15rem] max-w-[40rem] rounded-lg border bg-white p-4 shadow-md",
	},
	QD = { class: "flex items-start" },
	XD = { key: 0, class: "mr-3 grid h-5 w-5 place-items-center" },
	ZD = { key: 1, class: "text-base text-gray-600" },
	ej = { class: "ml-auto pl-2" };
function tj(t, e, n, r, o, i) {
	const s = Je("FeatherIcon");
	return (
		N(),
		W("div", YD, [
			V("div", QD, [
				n.icon
					? (N(),
					  W("div", XD, [
							ve(
								s,
								{
									name: n.icon,
									class: be(["h-5 w-5", n.iconClasses]),
								},
								null,
								8,
								["name", "class"]
							),
					  ]))
					: Re("", !0),
				V("div", null, [
					xe(t.$slots, "default", {}, () => [
						n.title
							? (N(),
							  W(
									"p",
									{
										key: 0,
										class: be([
											"text-base font-medium text-gray-900",
											{ "mb-1": n.text },
										]),
									},
									We(n.title),
									3
							  ))
							: Re("", !0),
						n.text ? (N(), W("p", ZD, We(n.text), 1)) : Re("", !0),
					]),
				]),
				V("div", ej, [
					xe(t.$slots, "actions", {}, () => [
						V(
							"button",
							{
								class: "grid h-5 w-5 place-items-center rounded hover:bg-gray-100",
								onClick:
									e[0] || (e[0] = (l) => t.$emit("close")),
							},
							[
								ve(s, {
									name: "x",
									class: "h-4 w-4 text-gray-700",
								}),
							]
						),
					]),
				]),
			]),
		])
	);
}
const nj = Le(GD, [["render", tj]]);
let ea = Q([]),
	WL = {
		name: "Toasts",
		created() {
			if (
				typeof window != "undefined" &&
				!document.getElementById("frappeui-toast-root")
			) {
				const t = document.createElement("div");
				(t.id = "frappeui-toast-root"),
					(t.style.position = "fixed"),
					(t.style.top = "16px"),
					(t.style.right = "16px"),
					(t.style.bottom = "16px"),
					(t.style.left = "16px"),
					(t.style.zIndex = "9999"),
					(t.style.pointerEvents = "none"),
					document.body.appendChild(t);
			}
		},
		render() {
			return Ke(_u, { to: "#frappeui-toast-root" }, [
				ei("top-left"),
				ei("top-center"),
				ei("top-right"),
				ei("bottom-left"),
				ei("bottom-center"),
				ei("bottom-right"),
			]);
		},
	};
function ei(t) {
	let e = "transition duration-[230ms] ease-[cubic-bezier(.21,1.02,.73,1)]",
		n = ["absolute"];
	return (
		t === "top-left" && n.push("top-0 left-0"),
		t === "top-right" && n.push("top-0 right-0"),
		t === "top-center" && n.push("top-0 left-1/2 -translate-x-1/2"),
		t === "bottom-left" && n.push("bottom-0 left-0"),
		t === "bottom-right" && n.push("bottom-0 right-0"),
		t === "bottom-center" && n.push("bottom-0 left-1/2 -translate-x-1/2"),
		Ke(
			Ox,
			{
				tag: "div",
				class: n,
				moveClass: e,
				enterActiveClass: e,
				enterFromClass: "translate-y-1 opacity-0",
				enterToClass: "translate-y-0 opacity-100",
				leaveActiveClass: `${e} absolute`,
				leaveFromClass: "translate-y-0 opacity-100",
				leaveToClass: "translate-y-1 opacity-0",
			},
			() =>
				ea.value
					.filter((r) => r.position === t)
					.map((r) =>
						Ke(
							"div",
							{ key: r.key, class: "pointer-events-auto flex" },
							Ke(
								nj,
								ge(B({}, r), {
									onClose: () => {
										ea.value = ea.value.filter(
											(o) => o !== r
										);
									},
								})
							)
						)
					)
		)
	);
}
function UL(t) {
	let e = `toast-${Math.random().toString(36).slice(2, 9)}`,
		n = Yt(B({ key: e, position: "top-center" }, t));
	return ea.value.push(n), e;
}
function rj(r, o) {
	return pr(this, arguments, function* (t, e, n = {}) {
		e || (e = {});
		let i = Object.assign(
			{
				Accept: "application/json",
				"Content-Type": "application/json; charset=utf-8",
				"X-Frappe-Site-Name": window.location.hostname,
			},
			n.headers || {}
		);
		window.csrf_token &&
			window.csrf_token !== "{{ csrf_token }}" &&
			(i["X-Frappe-CSRF-Token"] = window.csrf_token);
		let s = t.startsWith("/") ? t : `/api/method/${t}`;
		const l = yield fetch(s, {
			method: "POST",
			headers: i,
			body: JSON.stringify(e),
		});
		if (l.ok) {
			const a = yield l.json();
			if (a.docs || t === "login") return a;
			if (a.exc)
				try {
					console.groupCollapsed(t),
						console.log(`method: ${t}`),
						console.log("params:", e);
					let u = JSON.parse(a.exc);
					for (let c of u) console.log(c);
					console.groupEnd();
				} catch (u) {
					console.warn("Error printing debug messages", u);
				}
			return a.message;
		} else {
			let a = yield l.text(),
				u,
				c;
			try {
				u = JSON.parse(a);
			} catch (p) {}
			let d = [
				[t, u.exc_type, u._error_message].filter(Boolean).join(" "),
			];
			if (u.exc) {
				c = u.exc;
				try {
					(c = JSON.parse(c)[0]), console.log(c);
				} catch (p) {}
			}
			let f = new Error(
				d.join(`
`)
			);
			throw (
				((f.exc_type = u.exc_type),
				(f.exc = c),
				(f.status = l.status),
				(f.messages = u._server_messages
					? JSON.parse(u._server_messages)
					: []),
				(f.messages = f.messages.concat(u.message)),
				(f.messages = f.messages.map((p) => {
					try {
						return JSON.parse(p).message;
					} catch (m) {
						return p;
					}
				})),
				(f.messages = f.messages.filter(Boolean)),
				f.messages.length ||
					(f.messages = u._error_message
						? [u._error_message]
						: ["Internal Server Error"]),
				n.onError &&
					n.onError({ response: l, status: l.status, error: f }),
				f)
			);
		}
	});
}
let ta = document.querySelector('link[rel="icon"]'),
	oj = ta.href;
function ij(t) {
	at(
		() => {
			try {
				return t();
			} catch (e) {
				return null;
			}
		},
		(e) => {
			if (e)
				if ((e.title && (document.title = e.title), e.emoji)) {
					let n = `data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>${e.emoji}</text></svg>`;
					ta.href = n;
				} else e.icon ? (ta.href = e.icon) : (ta.href = oj);
		},
		{ immediate: !0, deep: !0 }
	);
}
const KL = {
	install(t) {
		t.mixin(sj());
	},
};
function sj() {
	return {
		created() {
			if (this.$options.pageMeta) {
				let t = this.$options.pageMeta.bind(this);
				ij(t);
			}
		},
	};
}
function Y2(t) {
	let e = Object.assign({}, t);
	if (!e.url) throw new Error("[request] options.url is required");
	e.transformRequest && (e = e.transformRequest(t)),
		e.responseType || (e.responseType = "json"),
		e.method || (e.method = "GET");
	let n = e.url,
		r;
	if (e.params)
		if (e.method === "GET") {
			let o = new URLSearchParams();
			for (let i in e.params) o.append(i, e.params[i]);
			n = e.url + "?" + o.toString();
		} else r = JSON.stringify(e.params);
	return fetch(n, {
		method: e.method || "GET",
		headers: e.headers,
		body: r,
	}).then((o) => {
		if (e.transformResponse) return e.transformResponse(o, e);
		if (o.status >= 200 && o.status < 300)
			return e.responseType === "json" ? o.json() : o;
		{
			let i = new Error(o.statusText);
			throw ((i.response = o), i);
		}
	});
}
function Uh(t) {
	return new Promise((e, n) => {
		(t.oncomplete = t.onsuccess = () => e(t.result)),
			(t.onabort = t.onerror = () => n(t.error));
	});
}
function lj(t, e) {
	const n = indexedDB.open(t);
	n.onupgradeneeded = () => n.result.createObjectStore(e);
	const r = Uh(n);
	return (o, i) => r.then((s) => i(s.transaction(e, o).objectStore(e)));
}
let od;
function Q2() {
	return od || (od = lj("keyval-store", "keyval")), od;
}
function aj(t, e = Q2()) {
	return e("readonly", (n) => Uh(n.get(t)));
}
function uj(t, e, n = Q2()) {
	return n("readwrite", (r) => (r.put(e, t), Uh(r.transaction)));
}
function Kh(t, e) {
	return typeof indexedDB == "undefined"
		? Promise.resolve(null)
		: t
		? uj(t, JSON.stringify(e))
		: Promise.resolve();
}
function qh(t) {
	return typeof indexedDB == "undefined"
		? Promise.resolve(null)
		: aj(t).then((e) => e && JSON.parse(e));
}
let X2 = {};
function qL(t, e) {
	X2[t] = e;
}
function er(t) {
	return X2[t] || null;
}
let na = {};
function mn(t, e) {
	let n = null;
	if (t.cache) {
		n = Vi(t.cache);
		let d = na[n];
		if (d) return d.auto && d.reload(), d;
	}
	typeof t == "string" && (t = { url: t, auto: !0 });
	let r = t.debounce ? $u(i, t.debounce) : i,
		o = Yt({
			method: t.method,
			url: t.url,
			data: t.initialData || null,
			previousData: null,
			loading: !1,
			fetched: !1,
			error: null,
			promise: null,
			auto: t.auto,
			params: null,
			fetch: r,
			reload: r,
			submit: r,
			reset: l,
			update: s,
			setData: u,
		});
	function i(p) {
		return pr(this, arguments, function* (d, f = {}) {
			let m = t.resourceFetcher || er("resourceFetcher") || Y2;
			d instanceof Event && (d = null),
				(d = d || o.params),
				t.makeParams && (d = t.makeParams.call(e, d)),
				(o.params = d),
				(o.previousData = o.data
					? JSON.parse(JSON.stringify(o.data))
					: null),
				(o.loading = !0),
				(o.error = null),
				t.onFetch && t.onFetch.call(e, o.params);
			let y = [t.beforeSubmit, f.beforeSubmit];
			for (let h of y) h && h.call(e, o.params);
			let v = f.validate || t.validate,
				w = [t.onError, f.onError],
				S = [t.onSuccess, f.onSuccess],
				E = [t.onData, f.onData];
			if (v) {
				let h;
				try {
					if (
						((h = yield v.call(e, o.params)),
						h && typeof h == "string")
					)
						throw new Error(h);
				} catch (b) {
					a(b, w);
					return;
				}
			}
			try {
				o.promise = m(ge(B({}, t), { params: d || t.params }));
				let h = yield o.promise;
				Kh(n, h), (o.data = c(h)), (o.fetched = !0);
				for (let b of S) b && b.call(e, h);
				for (let b of E) b && b.call(e, h);
			} catch (h) {
				a(h, w);
			}
			return (o.loading = !1), o.data;
		});
	}
	function s({ method: d, url: f, params: p, auto: m }) {
		d && d !== t.method && (o.method = d),
			f && f !== t.url && (o.url = f),
			p && p !== t.params && (o.params = p),
			m !== void 0 && m !== o.auto && (o.auto = m);
	}
	function l() {
		(o.data = t.initialData || null),
			(o.previousData = null),
			(o.loading = !1),
			(o.fetched = !1),
			(o.error = null),
			(o.params = null),
			(o.auto = t.auto);
	}
	function a(d, f) {
		(o.loading = !1),
			o.previousData && (o.data = o.previousData),
			(o.error = d);
		for (let p of f) p && p.call(e, d);
		throw d;
	}
	function u(d) {
		typeof d == "function" && (d = d.call(e, o.data)), (o.data = c(d));
	}
	function c(d) {
		if (t.transform) {
			let f = t.transform.call(e, d);
			if (f != null) return f;
		}
		return d;
	}
	return (
		n &&
			!na[n] &&
			((na[n] = o),
			qh(n).then((d) => {
				var f;
				(o.loading || !o.fetched) &&
					d &&
					(u(d), (f = t.onData) == null || f.call(e, d));
			})),
		t.auto && o.fetch(),
		o
	);
}
function Vi(t) {
	return t ? (typeof t == "string" && (t = [t]), JSON.stringify(t)) : null;
}
function cj(t) {
	return (t = Vi(t)), na[t] || null;
}
function Z2(t, e, n) {
	dj(t, e),
		t.on("list_update", (r) => {
			r.doctype == e && n(r.name);
		});
}
let p1 = {};
function dj(t, e) {
	p1[e] || (t.emit("doctype_subscribe", e), (p1[e] = !0));
}
let yf = Yt({}),
	bi = {};
function fj(t, e) {
	var w, S, E, h, b;
	if (!t.doctype) throw new Error("List resource requires doctype");
	let n = Vi(t.cache);
	if (n) {
		let g = yf[n];
		if (g) return g.auto && g.reload(), g;
	}
	let r = er("defaultListUrl") || "frappe.client.get_list",
		o = er("defaultDocInsertUrl") || "frappe.client.insert",
		i = er("defaultDocUpdateUrl") || "frappe.client.set_value",
		s = er("defaultDocDeleteUrl") || "frappe.client.delete",
		l = er("defaultRunDocMethodUrl") || "run_doc_method",
		a = Yt({
			doctype: t.doctype,
			fields: t.fields,
			filters: t.filters,
			orderBy: t.orderBy,
			start: t.start || 0,
			pageLength: t.pageLength || 20,
			groupBy: t.groupBy,
			parent: t.parent,
			debug: t.debug || 0,
			originalData: null,
			dataMap: {},
			data: null,
			previous: m,
			hasPreviousPage: !1,
			next: y,
			hasNextPage: !0,
			auto: t.auto,
			list: mn(
				{
					url: t.url || r,
					makeParams() {
						return {
							doctype: a.doctype,
							fields: a.fields,
							filters: a.filters,
							order_by: a.orderBy,
							start: a.start,
							limit: a.pageLength,
							limit_start: a.start,
							limit_page_length: a.pageLength,
							group_by: a.groupBy,
							parent: a.parent,
							debug: a.debug,
						};
					},
					onSuccess(g) {
						var k;
						(a.hasPreviousPage = !!a.start),
							g.length < a.pageLength && (a.hasNextPage = !1);
						let x;
						!a.start || a.start == 0
							? (x = g)
							: a.start > 0 && (x = a.originalData.concat(g)),
							Kh(n, x),
							p(x),
							(k = t.onSuccess) == null || k.call(e, a.data);
					},
					onError: t.onError,
				},
				e
			),
			fetchOne: mn(
				{
					url: t.url || r,
					makeParams(g) {
						return {
							doctype: a.doctype,
							fields: a.fields || "*",
							filters: { name: g },
						};
					},
					onSuccess(g) {
						var x, k;
						if (g.length > 0 && a.originalData) {
							let C = g[0];
							ks(a.doctype, C);
						}
						(k = (x = t.fetchOne) == null ? void 0 : x.onSuccess) ==
							null || k.call(e, a.data);
					},
					onError: (w = t.fetchOne) == null ? void 0 : w.onError,
				},
				e
			),
			insert: mn(
				{
					url: o,
					makeParams(g) {
						return { doc: B({ doctype: a.doctype }, g) };
					},
					onSuccess(g) {
						var x, k;
						a.list.fetch(),
							(k =
								(x = t.insert) == null
									? void 0
									: x.onSuccess) == null || k.call(e, g);
					},
					onError: (S = t.insert) == null ? void 0 : S.onError,
				},
				e
			),
			setValue: mn(
				{
					url: i,
					makeParams(g) {
						let C = g,
							{ name: x } = C,
							k = tt(C, ["name"]);
						return { doctype: a.doctype, name: x, fieldname: k };
					},
					onSuccess(g) {
						var x, k;
						ks(a.doctype, g),
							(k =
								(x = t.setValue) == null
									? void 0
									: x.onSuccess) == null || k.call(e, g);
					},
					onError: (E = t.setValue) == null ? void 0 : E.onError,
				},
				e
			),
			delete: mn(
				{
					url: s,
					makeParams(g) {
						return { doctype: a.doctype, name: g };
					},
					onSuccess(g) {
						var x, k;
						a.list.fetch(),
							(k =
								(x = t.delete) == null
									? void 0
									: x.onSuccess) == null || k.call(e, g);
					},
					onError: (h = t.delete) == null ? void 0 : h.onError,
				},
				e
			),
			runDocMethod: mn(
				{
					url: l,
					makeParams(C) {
						var _ = C,
							{ method: g, name: x } = _,
							k = tt(_, ["method", "name"]);
						return {
							dt: a.doctype,
							dn: x,
							method: g,
							args: JSON.stringify(k),
						};
					},
					onSuccess(g) {
						var x, k;
						if (g.docs) for (let C of g.docs) ks(C.doctype, C);
						(k =
							(x = t.runDocMethod) == null
								? void 0
								: x.onSuccess) == null || k.call(e, g);
					},
					onError: (b = t.runDocMethod) == null ? void 0 : b.onError,
				},
				e
			),
			update: u,
			fetch: f,
			reload: d,
			setData: p,
			transform: c,
			getRow: v,
		});
	function u(g) {
		Object.assign(a, g);
	}
	function c(g) {
		if (t.transform) {
			let x = t.transform.call(e, g);
			if (x != null) return x;
		}
		return g;
	}
	function d() {
		let g = a.start,
			x = a.pageLength;
		return (
			a.start > 0 &&
				((a.start = 0), (a.pageLength = a.originalData.length)),
			a.list.fetch().finally(() => {
				(a.start = g), (a.pageLength = x);
			})
		);
	}
	function f() {
		d();
	}
	function p(g) {
		if (
			((a.originalData = g),
			typeof g == "function" && (g = g.call(e, a.data)),
			(a.data = c(g)),
			Array.isArray(a.data))
		) {
			a.dataMap = {};
			for (let x of a.data) {
				if (!x.name) continue;
				let k = x.name.toString();
				a.dataMap[k] = x;
			}
		}
	}
	function m() {
		(a.start = a.start - a.pageLength), a.list.fetch();
	}
	function y() {
		(a.start = a.start + a.pageLength), a.list.fetch();
	}
	function v(g) {
		let x = g.toString();
		return a.dataMap[x];
	}
	return (
		t.realtime &&
			e != null &&
			e.$socket &&
			Z2(e.$socket, a.doctype, (g) => {
				var x;
				(x = a.originalData) != null &&
					x.find((k) => k.name === g) &&
					a.fetchOne.submit(g);
			}),
		n &&
			((yf[n] = a),
			qh(n).then((g) => {
				var x;
				(a.list.loading || !a.list.fetched) &&
					g &&
					(p(g), (x = t.onData) == null || x.call(e, g));
			})),
		t.auto && a.list.fetch(),
		(bi[a.doctype] = bi[a.doctype] || []),
		bi[a.doctype].push(a),
		a
	);
}
function hj(t) {
	return (t = Vi(t)), yf[t] || null;
}
function ks(t, e) {
	if (!e.name) return;
	let n = bi[t] || [];
	for (let r of n)
		if (r.originalData) {
			for (let o of r.originalData)
				if (o.name && o.name == e.name) {
					delete o._previousData;
					let i = JSON.stringify(o);
					for (let s in o) s in e && (o[s] = e[s]);
					o._previousData = i;
				}
			r.data = r.transform(r.originalData);
		}
}
function pj(t, e) {
	let n = bi[t] || [];
	for (let r of n)
		r.originalData &&
			((r.originalData = r.originalData.filter(
				(o) => o.name.toString() !== e.toString()
			)),
			(r.data = r.transform(r.originalData)));
}
function mj(t, e) {
	let n = bi[t] || [];
	for (let r of n)
		if (r.originalData) {
			for (let o of r.originalData)
				if (o.name && o.name == e.name) {
					let i = JSON.parse(o._previousData);
					for (let s in o) o[s] = i[s];
					delete o._previousData;
				}
			r.data = r.transform(r.originalData);
		}
}
let vf = Yt({});
function gj(t, e) {
	var m;
	if (!(t.doctype && t.name)) return;
	let n = Vi([t.doctype, t.name]),
		r = vf[n];
	if (r) return r.auto && r.reload(), r;
	let o = er("defaultDocGetUrl") || "frappe.client.get",
		i = er("defaultDocUpdateUrl") || "frappe.client.set_value",
		s = er("defaultDocDeleteUrl") || "frappe.client.delete",
		l = er("defaultRunDocMethodUrl") || "run_doc_method",
		a = {
			url: i,
			makeParams(v) {
				return { doctype: c.doctype, name: c.name, fieldname: v };
			},
			beforeSubmit(v) {
				(c.previousDoc = JSON.stringify(c.doc)),
					Object.assign(c.doc, v.fieldname || {}),
					ks(c.doctype, c.doc);
			},
			onSuccess(v) {
				var w, S;
				(c.doc = p(v)),
					(c.originalDoc = JSON.parse(JSON.stringify(c.doc))),
					(S = (w = t.setValue) == null ? void 0 : w.onSuccess) ==
						null || S.call(e, v);
			},
			onError(v) {
				var w, S;
				(c.doc = JSON.parse(c.previousDoc)),
					(S = (w = t.setValue) == null ? void 0 : w.onError) ==
						null || S.call(e, v),
					mj(c.doctype, c.doc);
			},
		};
	const u = t.auto !== void 0;
	let c = Yt({
		doctype: t.doctype,
		name: t.name,
		doc: null,
		originalDoc: null,
		isDirty: !1,
		auto: u ? t.auto : !0,
		get: mn(
			{
				url: o,
				makeParams() {
					return { doctype: c.doctype, name: c.name };
				},
				onSuccess(v) {
					var w;
					Kh(n, v),
						(c.doc = p(v)),
						(c.originalDoc = JSON.parse(JSON.stringify(c.doc))),
						(w = t.onSuccess) == null || w.call(e, c.doc);
				},
				onError: t.onError,
			},
			e
		),
		setValue: mn(a, e),
		setValueDebounced: mn(ge(B({}, a), { debounce: t.debounce || 500 }), e),
		save: mn(
			ge(B({}, a), {
				makeParams() {
					let v = JSON.parse(JSON.stringify(c.doc));
					return (
						delete v.doctype,
						delete v.name,
						{ doctype: c.doctype, name: c.name, fieldname: v }
					);
				},
			}),
			e
		),
		delete: mn(
			{
				url: s,
				makeParams() {
					return { doctype: c.doctype, name: c.name };
				},
				onSuccess() {
					var v, w;
					(c.doc = null),
						(w = (v = t.delete) == null ? void 0 : v.onSuccess) ==
							null || w.call(e),
						pj(c.doctype, c.name);
				},
				onError: (m = t.delete) == null ? void 0 : m.onError,
			},
			e
		),
		reload: d,
		setDoc: f,
	});
	at(
		() => c.doc,
		() => {
			c.isDirty = JSON.stringify(c.doc) !== JSON.stringify(c.originalDoc);
		},
		{ deep: !0 }
	);
	for (let v in t.whitelistedMethods) {
		let w = t.whitelistedMethods[v];
		typeof w == "string" && (w = { method: w });
		let y = w,
			{ method: S, onSuccess: E } = y,
			h = tt(y, ["method", "onSuccess"]);
		c[v] = mn(
			B(
				{
					url: l,
					makeParams(b) {
						return {
							dt: c.doctype,
							dn: c.name,
							method: S,
							args: b,
						};
					},
					onSuccess(b) {
						if (b.docs) {
							for (let g of b.docs)
								if (
									g.doctype === c.doctype &&
									g.name.toString() === c.name.toString()
								) {
									(c.doc = p(g)), ks(c.doctype, c.doc);
									break;
								}
						}
						E == null || E.call(e, b.message);
					},
				},
				h
			),
			e
		);
	}
	function d() {
		return c.get.fetch();
	}
	function f(v) {
		typeof v == "function" && (v = v.call(e, c.doc)), (c.doc = p(v));
	}
	function p(v) {
		if (t.transform) {
			let w = t.transform.call(e, v);
			if (typeof w == "object") return w;
		}
		return v;
	}
	return (
		t.realtime &&
			e.$socket &&
			Z2(e.$socket, c.doctype, (v) => {
				v == c.name && c.get.fetch();
			}),
		(vf[n] = c),
		qh(n).then((v) => {
			(c.get.loading || !c.get.fetched) && v && (c.doc = p(v));
		}),
		c.auto && c.get.fetch(),
		c
	);
}
function yj(t, e) {
	let n = Vi([t, e]);
	return vf[n] || null;
}
let vj = (t) => ({
	created() {
		if (this.$options.resources) {
			this._resources = Yt({});
			for (let e in this.$options.resources) {
				let n = this.$options.resources[e];
				if (typeof n == "function")
					at(
						() => {
							try {
								return n.call(this);
							} catch (r) {
								return (
									console.warn(
										`Failed to get resource options

`,
										r
									),
									null
								);
							}
						},
						(r, o) => {
							!r ||
								!(
									!o ||
									JSON.stringify(r) !== JSON.stringify(o)
								) ||
								(this._resources[e] = m1(r, this));
						},
						{ immediate: !0 }
					);
				else {
					let r = m1(n, this);
					this._resources[e] = r;
				}
			}
		}
	},
	methods: {
		$getResource(e) {
			return cj(e);
		},
		$getDocumentResource(e, n) {
			return yj(e, n);
		},
		$getDoc(e, n) {
			let r = this.$getDocumentResource(e, n);
			return r ? r.doc : null;
		},
		$getListResource(e) {
			return hj(e);
		},
		$refetchResource(e) {
			let n = this.$getResource(e);
			n && n.fetch();
		},
	},
	computed: {
		$resources() {
			return this._resources;
		},
	},
});
function m1(t, e) {
	return t.type === "document"
		? gj(t, e)
		: t.type === "list"
		? fj(t, e)
		: mn(t, e);
}
const bj = {
	install(t, e) {
		let n = vj();
		t.mixin(n);
	},
};
function JL(t) {
	return Y2(
		ge(B({}, t), {
			transformRequest: (e = {}) => {
				if (!e.url)
					throw new Error("[frappeRequest] options.url is required");
				let n = Object.assign(
					{
						Accept: "application/json",
						"Content-Type": "application/json; charset=utf-8",
						"X-Frappe-Site-Name": window.location.hostname,
					},
					e.headers || {}
				);
				return (
					window.csrf_token &&
						window.csrf_token !== "{{ csrf_token }}" &&
						(n["X-Frappe-CSRF-Token"] = window.csrf_token),
					!e.url.startsWith("/") &&
						!e.url.startsWith("http") &&
						(e.url = "/api/method/" + e.url),
					ge(B({}, e), { method: e.method || "POST", headers: n })
				);
			},
			transformResponse: (e, n) =>
				pr(this, null, function* () {
					let r = n.url;
					if (e.ok) {
						const o = yield e.json();
						if (o.docs || r === "login") return o;
						if (o.exc)
							try {
								console.groupCollapsed(r), console.log(n);
								let i = JSON.parse(o.exc);
								for (let s of i) console.log(s);
								console.groupEnd();
							} catch (i) {
								console.warn(
									"Error printing debug messages",
									i
								);
							}
						return o.message;
					} else {
						let o = yield e.text(),
							i,
							s;
						try {
							i = JSON.parse(o);
						} catch (u) {}
						let l = [
							[n.url, i.exc_type, i._error_message]
								.filter(Boolean)
								.join(" "),
						];
						if (i.exc) {
							s = i.exc;
							try {
								(s = JSON.parse(s)[0]), console.log(s);
							} catch (u) {}
						}
						let a = new Error(
							l.join(`
`)
						);
						throw (
							((a.exc_type = i.exc_type),
							(a.exc = s),
							(a.response = e),
							(a.status = o.status),
							(a.messages = i._server_messages
								? JSON.parse(i._server_messages)
								: []),
							(a.messages = a.messages.concat(i.message)),
							(a.messages = a.messages.map((u) => {
								try {
									return JSON.parse(u).message;
								} catch (c) {
									return u;
								}
							})),
							(a.messages = a.messages.filter(Boolean)),
							a.messages.length ||
								(a.messages = i._error_message
									? [i._error_message]
									: ["Internal Server Error"]),
							n.onError && n.onError(a),
							a)
						);
					}
				}),
		})
	);
}
const dr = Object.create(null);
dr.open = "0";
dr.close = "1";
dr.ping = "2";
dr.pong = "3";
dr.message = "4";
dr.upgrade = "5";
dr.noop = "6";
const ra = Object.create(null);
Object.keys(dr).forEach((t) => {
	ra[dr[t]] = t;
});
const bf = { type: "error", data: "parser error" },
	eb =
		typeof Blob == "function" ||
		(typeof Blob != "undefined" &&
			Object.prototype.toString.call(Blob) ===
				"[object BlobConstructor]"),
	tb = typeof ArrayBuffer == "function",
	nb = (t) =>
		typeof ArrayBuffer.isView == "function"
			? ArrayBuffer.isView(t)
			: t && t.buffer instanceof ArrayBuffer,
	Jh = ({ type: t, data: e }, n, r) =>
		eb && e instanceof Blob
			? n
				? r(e)
				: g1(e, r)
			: tb && (e instanceof ArrayBuffer || nb(e))
			? n
				? r(e)
				: g1(new Blob([e]), r)
			: r(dr[t] + (e || "")),
	g1 = (t, e) => {
		const n = new FileReader();
		return (
			(n.onload = function () {
				const r = n.result.split(",")[1];
				e("b" + (r || ""));
			}),
			n.readAsDataURL(t)
		);
	};
function y1(t) {
	return t instanceof Uint8Array
		? t
		: t instanceof ArrayBuffer
		? new Uint8Array(t)
		: new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
}
let id;
function wj(t, e) {
	if (eb && t.data instanceof Blob)
		return t.data.arrayBuffer().then(y1).then(e);
	if (tb && (t.data instanceof ArrayBuffer || nb(t.data)))
		return e(y1(t.data));
	Jh(t, !1, (n) => {
		id || (id = new TextEncoder()), e(id.encode(n));
	});
}
const v1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
	is = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
for (let t = 0; t < v1.length; t++) is[v1.charCodeAt(t)] = t;
const xj = (t) => {
		let e = t.length * 0.75,
			n = t.length,
			r,
			o = 0,
			i,
			s,
			l,
			a;
		t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--);
		const u = new ArrayBuffer(e),
			c = new Uint8Array(u);
		for (r = 0; r < n; r += 4)
			(i = is[t.charCodeAt(r)]),
				(s = is[t.charCodeAt(r + 1)]),
				(l = is[t.charCodeAt(r + 2)]),
				(a = is[t.charCodeAt(r + 3)]),
				(c[o++] = (i << 2) | (s >> 4)),
				(c[o++] = ((s & 15) << 4) | (l >> 2)),
				(c[o++] = ((l & 3) << 6) | (a & 63));
		return u;
	},
	kj = typeof ArrayBuffer == "function",
	Gh = (t, e) => {
		if (typeof t != "string") return { type: "message", data: rb(t, e) };
		const n = t.charAt(0);
		return n === "b"
			? { type: "message", data: Sj(t.substring(1), e) }
			: ra[n]
			? t.length > 1
				? { type: ra[n], data: t.substring(1) }
				: { type: ra[n] }
			: bf;
	},
	Sj = (t, e) => {
		if (kj) {
			const n = xj(t);
			return rb(n, e);
		} else return { base64: !0, data: t };
	},
	rb = (t, e) => {
		switch (e) {
			case "blob":
				return t instanceof Blob ? t : new Blob([t]);
			case "arraybuffer":
			default:
				return t instanceof ArrayBuffer ? t : t.buffer;
		}
	},
	ob = "",
	_j = (t, e) => {
		const n = t.length,
			r = new Array(n);
		let o = 0;
		t.forEach((i, s) => {
			Jh(i, !1, (l) => {
				(r[s] = l), ++o === n && e(r.join(ob));
			});
		});
	},
	Cj = (t, e) => {
		const n = t.split(ob),
			r = [];
		for (let o = 0; o < n.length; o++) {
			const i = Gh(n[o], e);
			if ((r.push(i), i.type === "error")) break;
		}
		return r;
	};
function Mj() {
	return new TransformStream({
		transform(t, e) {
			wj(t, (n) => {
				const r = n.length;
				let o;
				if (r < 126)
					(o = new Uint8Array(1)),
						new DataView(o.buffer).setUint8(0, r);
				else if (r < 65536) {
					o = new Uint8Array(3);
					const i = new DataView(o.buffer);
					i.setUint8(0, 126), i.setUint16(1, r);
				} else {
					o = new Uint8Array(9);
					const i = new DataView(o.buffer);
					i.setUint8(0, 127), i.setBigUint64(1, BigInt(r));
				}
				t.data && typeof t.data != "string" && (o[0] |= 128),
					e.enqueue(o),
					e.enqueue(n);
			});
		},
	});
}
let sd;
function Bl(t) {
	return t.reduce((e, n) => e + n.length, 0);
}
function zl(t, e) {
	if (t[0].length === e) return t.shift();
	const n = new Uint8Array(e);
	let r = 0;
	for (let o = 0; o < e; o++)
		(n[o] = t[0][r++]), r === t[0].length && (t.shift(), (r = 0));
	return t.length && r < t[0].length && (t[0] = t[0].slice(r)), n;
}
function Ej(t, e) {
	sd || (sd = new TextDecoder());
	const n = [];
	let r = 0,
		o = -1,
		i = !1;
	return new TransformStream({
		transform(s, l) {
			for (n.push(s); ; ) {
				if (r === 0) {
					if (Bl(n) < 1) break;
					const a = zl(n, 1);
					(i = (a[0] & 128) === 128),
						(o = a[0] & 127),
						o < 126 ? (r = 3) : o === 126 ? (r = 1) : (r = 2);
				} else if (r === 1) {
					if (Bl(n) < 2) break;
					const a = zl(n, 2);
					(o = new DataView(
						a.buffer,
						a.byteOffset,
						a.length
					).getUint16(0)),
						(r = 3);
				} else if (r === 2) {
					if (Bl(n) < 8) break;
					const a = zl(n, 8),
						u = new DataView(a.buffer, a.byteOffset, a.length),
						c = u.getUint32(0);
					if (c > Math.pow(2, 21) - 1) {
						l.enqueue(bf);
						break;
					}
					(o = c * Math.pow(2, 32) + u.getUint32(4)), (r = 3);
				} else {
					if (Bl(n) < o) break;
					const a = zl(n, o);
					l.enqueue(Gh(i ? a : sd.decode(a), e)), (r = 0);
				}
				if (o === 0 || o > t) {
					l.enqueue(bf);
					break;
				}
			}
		},
	});
}
const ib = 4;
function Ot(t) {
	if (t) return Tj(t);
}
function Tj(t) {
	for (var e in Ot.prototype) t[e] = Ot.prototype[e];
	return t;
}
Ot.prototype.on = Ot.prototype.addEventListener = function (t, e) {
	return (
		(this._callbacks = this._callbacks || {}),
		(this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e),
		this
	);
};
Ot.prototype.once = function (t, e) {
	function n() {
		this.off(t, n), e.apply(this, arguments);
	}
	return (n.fn = e), this.on(t, n), this;
};
Ot.prototype.off =
	Ot.prototype.removeListener =
	Ot.prototype.removeAllListeners =
	Ot.prototype.removeEventListener =
		function (t, e) {
			if (
				((this._callbacks = this._callbacks || {}),
				arguments.length == 0)
			)
				return (this._callbacks = {}), this;
			var n = this._callbacks["$" + t];
			if (!n) return this;
			if (arguments.length == 1)
				return delete this._callbacks["$" + t], this;
			for (var r, o = 0; o < n.length; o++)
				if (((r = n[o]), r === e || r.fn === e)) {
					n.splice(o, 1);
					break;
				}
			return n.length === 0 && delete this._callbacks["$" + t], this;
		};
Ot.prototype.emit = function (t) {
	this._callbacks = this._callbacks || {};
	for (
		var e = new Array(arguments.length - 1),
			n = this._callbacks["$" + t],
			r = 1;
		r < arguments.length;
		r++
	)
		e[r - 1] = arguments[r];
	if (n) {
		n = n.slice(0);
		for (var r = 0, o = n.length; r < o; ++r) n[r].apply(this, e);
	}
	return this;
};
Ot.prototype.emitReserved = Ot.prototype.emit;
Ot.prototype.listeners = function (t) {
	return (
		(this._callbacks = this._callbacks || {}),
		this._callbacks["$" + t] || []
	);
};
Ot.prototype.hasListeners = function (t) {
	return !!this.listeners(t).length;
};
const _n =
	typeof self != "undefined"
		? self
		: typeof window != "undefined"
		? window
		: Function("return this")();
function sb(t, ...e) {
	return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {});
}
const Aj = _n.setTimeout,
	Oj = _n.clearTimeout;
function nc(t, e) {
	e.useNativeTimers
		? ((t.setTimeoutFn = Aj.bind(_n)), (t.clearTimeoutFn = Oj.bind(_n)))
		: ((t.setTimeoutFn = _n.setTimeout.bind(_n)),
		  (t.clearTimeoutFn = _n.clearTimeout.bind(_n)));
}
const Rj = 1.33;
function Pj(t) {
	return typeof t == "string"
		? Ij(t)
		: Math.ceil((t.byteLength || t.size) * Rj);
}
function Ij(t) {
	let e = 0,
		n = 0;
	for (let r = 0, o = t.length; r < o; r++)
		(e = t.charCodeAt(r)),
			e < 128
				? (n += 1)
				: e < 2048
				? (n += 2)
				: e < 55296 || e >= 57344
				? (n += 3)
				: (r++, (n += 4));
	return n;
}
function Nj(t) {
	let e = "";
	for (let n in t)
		t.hasOwnProperty(n) &&
			(e.length && (e += "&"),
			(e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])));
	return e;
}
function Dj(t) {
	let e = {},
		n = t.split("&");
	for (let r = 0, o = n.length; r < o; r++) {
		let i = n[r].split("=");
		e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
	}
	return e;
}
class jj extends Error {
	constructor(e, n, r) {
		super(e),
			(this.description = n),
			(this.context = r),
			(this.type = "TransportError");
	}
}
class Yh extends Ot {
	constructor(e) {
		super(),
			(this.writable = !1),
			nc(this, e),
			(this.opts = e),
			(this.query = e.query),
			(this.socket = e.socket);
	}
	onError(e, n, r) {
		return super.emitReserved("error", new jj(e, n, r)), this;
	}
	open() {
		return (this.readyState = "opening"), this.doOpen(), this;
	}
	close() {
		return (
			(this.readyState === "opening" || this.readyState === "open") &&
				(this.doClose(), this.onClose()),
			this
		);
	}
	send(e) {
		this.readyState === "open" && this.write(e);
	}
	onOpen() {
		(this.readyState = "open"),
			(this.writable = !0),
			super.emitReserved("open");
	}
	onData(e) {
		const n = Gh(e, this.socket.binaryType);
		this.onPacket(n);
	}
	onPacket(e) {
		super.emitReserved("packet", e);
	}
	onClose(e) {
		(this.readyState = "closed"), super.emitReserved("close", e);
	}
	pause(e) {}
	createUri(e, n = {}) {
		return (
			e +
			"://" +
			this._hostname() +
			this._port() +
			this.opts.path +
			this._query(n)
		);
	}
	_hostname() {
		const e = this.opts.hostname;
		return e.indexOf(":") === -1 ? e : "[" + e + "]";
	}
	_port() {
		return this.opts.port &&
			((this.opts.secure && +(this.opts.port !== 443)) ||
				(!this.opts.secure && Number(this.opts.port) !== 80))
			? ":" + this.opts.port
			: "";
	}
	_query(e) {
		const n = Nj(e);
		return n.length ? "?" + n : "";
	}
}
const lb =
		"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
			""
		),
	wf = 64,
	Lj = {};
let b1 = 0,
	Hl = 0,
	w1;
function x1(t) {
	let e = "";
	do (e = lb[t % wf] + e), (t = Math.floor(t / wf));
	while (t > 0);
	return e;
}
function ab() {
	const t = x1(+new Date());
	return t !== w1 ? ((b1 = 0), (w1 = t)) : t + "." + x1(b1++);
}
for (; Hl < wf; Hl++) Lj[lb[Hl]] = Hl;
let ub = !1;
try {
	ub =
		typeof XMLHttpRequest != "undefined" &&
		"withCredentials" in new XMLHttpRequest();
} catch (t) {}
const $j = ub;
function cb(t) {
	const e = t.xdomain;
	try {
		if (typeof XMLHttpRequest != "undefined" && (!e || $j))
			return new XMLHttpRequest();
	} catch (n) {}
	if (!e)
		try {
			return new _n[["Active"].concat("Object").join("X")](
				"Microsoft.XMLHTTP"
			);
		} catch (n) {}
}
function Bj() {}
const zj = (function () {
	return new cb({ xdomain: !1 }).responseType != null;
})();
class Hj extends Yh {
	constructor(e) {
		if ((super(e), (this.polling = !1), typeof location != "undefined")) {
			const r = location.protocol === "https:";
			let o = location.port;
			o || (o = r ? "443" : "80"),
				(this.xd =
					(typeof location != "undefined" &&
						e.hostname !== location.hostname) ||
					o !== e.port);
		}
		const n = e && e.forceBase64;
		(this.supportsBinary = zj && !n),
			this.opts.withCredentials && (this.cookieJar = void 0);
	}
	get name() {
		return "polling";
	}
	doOpen() {
		this.poll();
	}
	pause(e) {
		this.readyState = "pausing";
		const n = () => {
			(this.readyState = "paused"), e();
		};
		if (this.polling || !this.writable) {
			let r = 0;
			this.polling &&
				(r++,
				this.once("pollComplete", function () {
					--r || n();
				})),
				this.writable ||
					(r++,
					this.once("drain", function () {
						--r || n();
					}));
		} else n();
	}
	poll() {
		(this.polling = !0), this.doPoll(), this.emitReserved("poll");
	}
	onData(e) {
		const n = (r) => {
			if (
				(this.readyState === "opening" &&
					r.type === "open" &&
					this.onOpen(),
				r.type === "close")
			)
				return (
					this.onClose({
						description: "transport closed by the server",
					}),
					!1
				);
			this.onPacket(r);
		};
		Cj(e, this.socket.binaryType).forEach(n),
			this.readyState !== "closed" &&
				((this.polling = !1),
				this.emitReserved("pollComplete"),
				this.readyState === "open" && this.poll());
	}
	doClose() {
		const e = () => {
			this.write([{ type: "close" }]);
		};
		this.readyState === "open" ? e() : this.once("open", e);
	}
	write(e) {
		(this.writable = !1),
			_j(e, (n) => {
				this.doWrite(n, () => {
					(this.writable = !0), this.emitReserved("drain");
				});
			});
	}
	uri() {
		const e = this.opts.secure ? "https" : "http",
			n = this.query || {};
		return (
			this.opts.timestampRequests !== !1 &&
				(n[this.opts.timestampParam] = ab()),
			!this.supportsBinary && !n.sid && (n.b64 = 1),
			this.createUri(e, n)
		);
	}
	request(e = {}) {
		return (
			Object.assign(
				e,
				{ xd: this.xd, cookieJar: this.cookieJar },
				this.opts
			),
			new or(this.uri(), e)
		);
	}
	doWrite(e, n) {
		const r = this.request({ method: "POST", data: e });
		r.on("success", n),
			r.on("error", (o, i) => {
				this.onError("xhr post error", o, i);
			});
	}
	doPoll() {
		const e = this.request();
		e.on("data", this.onData.bind(this)),
			e.on("error", (n, r) => {
				this.onError("xhr poll error", n, r);
			}),
			(this.pollXhr = e);
	}
}
class or extends Ot {
	constructor(e, n) {
		super(),
			nc(this, n),
			(this.opts = n),
			(this.method = n.method || "GET"),
			(this.uri = e),
			(this.data = n.data !== void 0 ? n.data : null),
			this.create();
	}
	create() {
		var e;
		const n = sb(
			this.opts,
			"agent",
			"pfx",
			"key",
			"passphrase",
			"cert",
			"ca",
			"ciphers",
			"rejectUnauthorized",
			"autoUnref"
		);
		n.xdomain = !!this.opts.xd;
		const r = (this.xhr = new cb(n));
		try {
			r.open(this.method, this.uri, !0);
			try {
				if (this.opts.extraHeaders) {
					r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
					for (let o in this.opts.extraHeaders)
						this.opts.extraHeaders.hasOwnProperty(o) &&
							r.setRequestHeader(o, this.opts.extraHeaders[o]);
				}
			} catch (o) {}
			if (this.method === "POST")
				try {
					r.setRequestHeader(
						"Content-type",
						"text/plain;charset=UTF-8"
					);
				} catch (o) {}
			try {
				r.setRequestHeader("Accept", "*/*");
			} catch (o) {}
			(e = this.opts.cookieJar) === null ||
				e === void 0 ||
				e.addCookies(r),
				"withCredentials" in r &&
					(r.withCredentials = this.opts.withCredentials),
				this.opts.requestTimeout &&
					(r.timeout = this.opts.requestTimeout),
				(r.onreadystatechange = () => {
					var o;
					r.readyState === 3 &&
						((o = this.opts.cookieJar) === null ||
							o === void 0 ||
							o.parseCookies(r)),
						r.readyState === 4 &&
							(r.status === 200 || r.status === 1223
								? this.onLoad()
								: this.setTimeoutFn(() => {
										this.onError(
											typeof r.status == "number"
												? r.status
												: 0
										);
								  }, 0));
				}),
				r.send(this.data);
		} catch (o) {
			this.setTimeoutFn(() => {
				this.onError(o);
			}, 0);
			return;
		}
		typeof document != "undefined" &&
			((this.index = or.requestsCount++),
			(or.requests[this.index] = this));
	}
	onError(e) {
		this.emitReserved("error", e, this.xhr), this.cleanup(!0);
	}
	cleanup(e) {
		if (!(typeof this.xhr == "undefined" || this.xhr === null)) {
			if (((this.xhr.onreadystatechange = Bj), e))
				try {
					this.xhr.abort();
				} catch (n) {}
			typeof document != "undefined" && delete or.requests[this.index],
				(this.xhr = null);
		}
	}
	onLoad() {
		const e = this.xhr.responseText;
		e !== null &&
			(this.emitReserved("data", e),
			this.emitReserved("success"),
			this.cleanup());
	}
	abort() {
		this.cleanup();
	}
}
or.requestsCount = 0;
or.requests = {};
if (typeof document != "undefined") {
	if (typeof attachEvent == "function") attachEvent("onunload", k1);
	else if (typeof addEventListener == "function") {
		const t = "onpagehide" in _n ? "pagehide" : "unload";
		addEventListener(t, k1, !1);
	}
}
function k1() {
	for (let t in or.requests)
		or.requests.hasOwnProperty(t) && or.requests[t].abort();
}
const Qh =
		typeof Promise == "function" && typeof Promise.resolve == "function"
			? (e) => Promise.resolve().then(e)
			: (e, n) => n(e, 0),
	Fl = _n.WebSocket || _n.MozWebSocket,
	S1 = !0,
	Fj = "arraybuffer",
	_1 =
		typeof navigator != "undefined" &&
		typeof navigator.product == "string" &&
		navigator.product.toLowerCase() === "reactnative";
class Vj extends Yh {
	constructor(e) {
		super(e), (this.supportsBinary = !e.forceBase64);
	}
	get name() {
		return "websocket";
	}
	doOpen() {
		if (!this.check()) return;
		const e = this.uri(),
			n = this.opts.protocols,
			r = _1
				? {}
				: sb(
						this.opts,
						"agent",
						"perMessageDeflate",
						"pfx",
						"key",
						"passphrase",
						"cert",
						"ca",
						"ciphers",
						"rejectUnauthorized",
						"localAddress",
						"protocolVersion",
						"origin",
						"maxPayload",
						"family",
						"checkServerIdentity"
				  );
		this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
		try {
			this.ws =
				S1 && !_1 ? (n ? new Fl(e, n) : new Fl(e)) : new Fl(e, n, r);
		} catch (o) {
			return this.emitReserved("error", o);
		}
		(this.ws.binaryType = this.socket.binaryType), this.addEventListeners();
	}
	addEventListeners() {
		(this.ws.onopen = () => {
			this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
		}),
			(this.ws.onclose = (e) =>
				this.onClose({
					description: "websocket connection closed",
					context: e,
				})),
			(this.ws.onmessage = (e) => this.onData(e.data)),
			(this.ws.onerror = (e) => this.onError("websocket error", e));
	}
	write(e) {
		this.writable = !1;
		for (let n = 0; n < e.length; n++) {
			const r = e[n],
				o = n === e.length - 1;
			Jh(r, this.supportsBinary, (i) => {
				const s = {};
				try {
					S1 && this.ws.send(i);
				} catch (l) {}
				o &&
					Qh(() => {
						(this.writable = !0), this.emitReserved("drain");
					}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		typeof this.ws != "undefined" && (this.ws.close(), (this.ws = null));
	}
	uri() {
		const e = this.opts.secure ? "wss" : "ws",
			n = this.query || {};
		return (
			this.opts.timestampRequests && (n[this.opts.timestampParam] = ab()),
			this.supportsBinary || (n.b64 = 1),
			this.createUri(e, n)
		);
	}
	check() {
		return !!Fl;
	}
}
class Wj extends Yh {
	get name() {
		return "webtransport";
	}
	doOpen() {
		typeof WebTransport == "function" &&
			((this.transport = new WebTransport(
				this.createUri("https"),
				this.opts.transportOptions[this.name]
			)),
			this.transport.closed
				.then(() => {
					this.onClose();
				})
				.catch((e) => {
					this.onError("webtransport error", e);
				}),
			this.transport.ready.then(() => {
				this.transport.createBidirectionalStream().then((e) => {
					const n = Ej(
							Number.MAX_SAFE_INTEGER,
							this.socket.binaryType
						),
						r = e.readable.pipeThrough(n).getReader(),
						o = Mj();
					o.readable.pipeTo(e.writable),
						(this.writer = o.writable.getWriter());
					const i = () => {
						r.read()
							.then(({ done: l, value: a }) => {
								l || (this.onPacket(a), i());
							})
							.catch((l) => {});
					};
					i();
					const s = { type: "open" };
					this.query.sid && (s.data = `{"sid":"${this.query.sid}"}`),
						this.writer.write(s).then(() => this.onOpen());
				});
			}));
	}
	write(e) {
		this.writable = !1;
		for (let n = 0; n < e.length; n++) {
			const r = e[n],
				o = n === e.length - 1;
			this.writer.write(r).then(() => {
				o &&
					Qh(() => {
						(this.writable = !0), this.emitReserved("drain");
					}, this.setTimeoutFn);
			});
		}
	}
	doClose() {
		var e;
		(e = this.transport) === null || e === void 0 || e.close();
	}
}
const Uj = { websocket: Vj, webtransport: Wj, polling: Hj },
	Kj =
		/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
	qj = [
		"source",
		"protocol",
		"authority",
		"userInfo",
		"user",
		"password",
		"host",
		"port",
		"relative",
		"path",
		"directory",
		"file",
		"query",
		"anchor",
	];
function xf(t) {
	if (t.length > 2e3) throw "URI too long";
	const e = t,
		n = t.indexOf("["),
		r = t.indexOf("]");
	n != -1 &&
		r != -1 &&
		(t =
			t.substring(0, n) +
			t.substring(n, r).replace(/:/g, ";") +
			t.substring(r, t.length));
	let o = Kj.exec(t || ""),
		i = {},
		s = 14;
	for (; s--; ) i[qj[s]] = o[s] || "";
	return (
		n != -1 &&
			r != -1 &&
			((i.source = e),
			(i.host = i.host
				.substring(1, i.host.length - 1)
				.replace(/;/g, ":")),
			(i.authority = i.authority
				.replace("[", "")
				.replace("]", "")
				.replace(/;/g, ":")),
			(i.ipv6uri = !0)),
		(i.pathNames = Jj(i, i.path)),
		(i.queryKey = Gj(i, i.query)),
		i
	);
}
function Jj(t, e) {
	const n = /\/{2,9}/g,
		r = e.replace(n, "/").split("/");
	return (
		(e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1),
		e.slice(-1) == "/" && r.splice(r.length - 1, 1),
		r
	);
}
function Gj(t, e) {
	const n = {};
	return (
		e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, o, i) {
			o && (n[o] = i);
		}),
		n
	);
}
let db = class si extends Ot {
	constructor(e, n = {}) {
		super(),
			(this.binaryType = Fj),
			(this.writeBuffer = []),
			e && typeof e == "object" && ((n = e), (e = null)),
			e
				? ((e = xf(e)),
				  (n.hostname = e.host),
				  (n.secure = e.protocol === "https" || e.protocol === "wss"),
				  (n.port = e.port),
				  e.query && (n.query = e.query))
				: n.host && (n.hostname = xf(n.host).host),
			nc(this, n),
			(this.secure =
				n.secure != null
					? n.secure
					: typeof location != "undefined" &&
					  location.protocol === "https:"),
			n.hostname && !n.port && (n.port = this.secure ? "443" : "80"),
			(this.hostname =
				n.hostname ||
				(typeof location != "undefined"
					? location.hostname
					: "localhost")),
			(this.port =
				n.port ||
				(typeof location != "undefined" && location.port
					? location.port
					: this.secure
					? "443"
					: "80")),
			(this.transports = n.transports || [
				"polling",
				"websocket",
				"webtransport",
			]),
			(this.writeBuffer = []),
			(this.prevBufferLen = 0),
			(this.opts = Object.assign(
				{
					path: "/engine.io",
					agent: !1,
					withCredentials: !1,
					upgrade: !0,
					timestampParam: "t",
					rememberUpgrade: !1,
					addTrailingSlash: !0,
					rejectUnauthorized: !0,
					perMessageDeflate: { threshold: 1024 },
					transportOptions: {},
					closeOnBeforeunload: !1,
				},
				n
			)),
			(this.opts.path =
				this.opts.path.replace(/\/$/, "") +
				(this.opts.addTrailingSlash ? "/" : "")),
			typeof this.opts.query == "string" &&
				(this.opts.query = Dj(this.opts.query)),
			(this.id = null),
			(this.upgrades = null),
			(this.pingInterval = null),
			(this.pingTimeout = null),
			(this.pingTimeoutTimer = null),
			typeof addEventListener == "function" &&
				(this.opts.closeOnBeforeunload &&
					((this.beforeunloadEventListener = () => {
						this.transport &&
							(this.transport.removeAllListeners(),
							this.transport.close());
					}),
					addEventListener(
						"beforeunload",
						this.beforeunloadEventListener,
						!1
					)),
				this.hostname !== "localhost" &&
					((this.offlineEventListener = () => {
						this.onClose("transport close", {
							description: "network connection lost",
						});
					}),
					addEventListener(
						"offline",
						this.offlineEventListener,
						!1
					))),
			this.open();
	}
	createTransport(e) {
		const n = Object.assign({}, this.opts.query);
		(n.EIO = ib), (n.transport = e), this.id && (n.sid = this.id);
		const r = Object.assign(
			{},
			this.opts,
			{
				query: n,
				socket: this,
				hostname: this.hostname,
				secure: this.secure,
				port: this.port,
			},
			this.opts.transportOptions[e]
		);
		return new Uj[e](r);
	}
	open() {
		let e;
		if (
			this.opts.rememberUpgrade &&
			si.priorWebsocketSuccess &&
			this.transports.indexOf("websocket") !== -1
		)
			e = "websocket";
		else if (this.transports.length === 0) {
			this.setTimeoutFn(() => {
				this.emitReserved("error", "No transports available");
			}, 0);
			return;
		} else e = this.transports[0];
		this.readyState = "opening";
		try {
			e = this.createTransport(e);
		} catch (n) {
			this.transports.shift(), this.open();
			return;
		}
		e.open(), this.setTransport(e);
	}
	setTransport(e) {
		this.transport && this.transport.removeAllListeners(),
			(this.transport = e),
			e
				.on("drain", this.onDrain.bind(this))
				.on("packet", this.onPacket.bind(this))
				.on("error", this.onError.bind(this))
				.on("close", (n) => this.onClose("transport close", n));
	}
	probe(e) {
		let n = this.createTransport(e),
			r = !1;
		si.priorWebsocketSuccess = !1;
		const o = () => {
			r ||
				(n.send([{ type: "ping", data: "probe" }]),
				n.once("packet", (d) => {
					if (!r)
						if (d.type === "pong" && d.data === "probe") {
							if (
								((this.upgrading = !0),
								this.emitReserved("upgrading", n),
								!n)
							)
								return;
							(si.priorWebsocketSuccess = n.name === "websocket"),
								this.transport.pause(() => {
									r ||
										(this.readyState !== "closed" &&
											(c(),
											this.setTransport(n),
											n.send([{ type: "upgrade" }]),
											this.emitReserved("upgrade", n),
											(n = null),
											(this.upgrading = !1),
											this.flush()));
								});
						} else {
							const f = new Error("probe error");
							(f.transport = n.name),
								this.emitReserved("upgradeError", f);
						}
				}));
		};
		function i() {
			r || ((r = !0), c(), n.close(), (n = null));
		}
		const s = (d) => {
			const f = new Error("probe error: " + d);
			(f.transport = n.name), i(), this.emitReserved("upgradeError", f);
		};
		function l() {
			s("transport closed");
		}
		function a() {
			s("socket closed");
		}
		function u(d) {
			n && d.name !== n.name && i();
		}
		const c = () => {
			n.removeListener("open", o),
				n.removeListener("error", s),
				n.removeListener("close", l),
				this.off("close", a),
				this.off("upgrading", u);
		};
		n.once("open", o),
			n.once("error", s),
			n.once("close", l),
			this.once("close", a),
			this.once("upgrading", u),
			this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport"
				? this.setTimeoutFn(() => {
						r || n.open();
				  }, 200)
				: n.open();
	}
	onOpen() {
		if (
			((this.readyState = "open"),
			(si.priorWebsocketSuccess = this.transport.name === "websocket"),
			this.emitReserved("open"),
			this.flush(),
			this.readyState === "open" && this.opts.upgrade)
		) {
			let e = 0;
			const n = this.upgrades.length;
			for (; e < n; e++) this.probe(this.upgrades[e]);
		}
	}
	onPacket(e) {
		if (
			this.readyState === "opening" ||
			this.readyState === "open" ||
			this.readyState === "closing"
		)
			switch (
				(this.emitReserved("packet", e),
				this.emitReserved("heartbeat"),
				this.resetPingTimeout(),
				e.type)
			) {
				case "open":
					this.onHandshake(JSON.parse(e.data));
					break;
				case "ping":
					this.sendPacket("pong"),
						this.emitReserved("ping"),
						this.emitReserved("pong");
					break;
				case "error":
					const n = new Error("server error");
					(n.code = e.data), this.onError(n);
					break;
				case "message":
					this.emitReserved("data", e.data),
						this.emitReserved("message", e.data);
					break;
			}
	}
	onHandshake(e) {
		this.emitReserved("handshake", e),
			(this.id = e.sid),
			(this.transport.query.sid = e.sid),
			(this.upgrades = this.filterUpgrades(e.upgrades)),
			(this.pingInterval = e.pingInterval),
			(this.pingTimeout = e.pingTimeout),
			(this.maxPayload = e.maxPayload),
			this.onOpen(),
			this.readyState !== "closed" && this.resetPingTimeout();
	}
	resetPingTimeout() {
		this.clearTimeoutFn(this.pingTimeoutTimer),
			(this.pingTimeoutTimer = this.setTimeoutFn(() => {
				this.onClose("ping timeout");
			}, this.pingInterval + this.pingTimeout)),
			this.opts.autoUnref && this.pingTimeoutTimer.unref();
	}
	onDrain() {
		this.writeBuffer.splice(0, this.prevBufferLen),
			(this.prevBufferLen = 0),
			this.writeBuffer.length === 0
				? this.emitReserved("drain")
				: this.flush();
	}
	flush() {
		if (
			this.readyState !== "closed" &&
			this.transport.writable &&
			!this.upgrading &&
			this.writeBuffer.length
		) {
			const e = this.getWritablePackets();
			this.transport.send(e),
				(this.prevBufferLen = e.length),
				this.emitReserved("flush");
		}
	}
	getWritablePackets() {
		if (
			!(
				this.maxPayload &&
				this.transport.name === "polling" &&
				this.writeBuffer.length > 1
			)
		)
			return this.writeBuffer;
		let n = 1;
		for (let r = 0; r < this.writeBuffer.length; r++) {
			const o = this.writeBuffer[r].data;
			if ((o && (n += Pj(o)), r > 0 && n > this.maxPayload))
				return this.writeBuffer.slice(0, r);
			n += 2;
		}
		return this.writeBuffer;
	}
	write(e, n, r) {
		return this.sendPacket("message", e, n, r), this;
	}
	send(e, n, r) {
		return this.sendPacket("message", e, n, r), this;
	}
	sendPacket(e, n, r, o) {
		if (
			(typeof n == "function" && ((o = n), (n = void 0)),
			typeof r == "function" && ((o = r), (r = null)),
			this.readyState === "closing" || this.readyState === "closed")
		)
			return;
		(r = r || {}), (r.compress = r.compress !== !1);
		const i = { type: e, data: n, options: r };
		this.emitReserved("packetCreate", i),
			this.writeBuffer.push(i),
			o && this.once("flush", o),
			this.flush();
	}
	close() {
		const e = () => {
				this.onClose("forced close"), this.transport.close();
			},
			n = () => {
				this.off("upgrade", n), this.off("upgradeError", n), e();
			},
			r = () => {
				this.once("upgrade", n), this.once("upgradeError", n);
			};
		return (
			(this.readyState === "opening" || this.readyState === "open") &&
				((this.readyState = "closing"),
				this.writeBuffer.length
					? this.once("drain", () => {
							this.upgrading ? r() : e();
					  })
					: this.upgrading
					? r()
					: e()),
			this
		);
	}
	onError(e) {
		(si.priorWebsocketSuccess = !1),
			this.emitReserved("error", e),
			this.onClose("transport error", e);
	}
	onClose(e, n) {
		(this.readyState === "opening" ||
			this.readyState === "open" ||
			this.readyState === "closing") &&
			(this.clearTimeoutFn(this.pingTimeoutTimer),
			this.transport.removeAllListeners("close"),
			this.transport.close(),
			this.transport.removeAllListeners(),
			typeof removeEventListener == "function" &&
				(removeEventListener(
					"beforeunload",
					this.beforeunloadEventListener,
					!1
				),
				removeEventListener("offline", this.offlineEventListener, !1)),
			(this.readyState = "closed"),
			(this.id = null),
			this.emitReserved("close", e, n),
			(this.writeBuffer = []),
			(this.prevBufferLen = 0));
	}
	filterUpgrades(e) {
		const n = [];
		let r = 0;
		const o = e.length;
		for (; r < o; r++) ~this.transports.indexOf(e[r]) && n.push(e[r]);
		return n;
	}
};
db.protocol = ib;
function Yj(t, e = "", n) {
	let r = t;
	(n = n || (typeof location != "undefined" && location)),
		t == null && (t = n.protocol + "//" + n.host),
		typeof t == "string" &&
			(t.charAt(0) === "/" &&
				(t.charAt(1) === "/" ? (t = n.protocol + t) : (t = n.host + t)),
			/^(https?|wss?):\/\//.test(t) ||
				(typeof n != "undefined"
					? (t = n.protocol + "//" + t)
					: (t = "https://" + t)),
			(r = xf(t))),
		r.port ||
			(/^(http|ws)$/.test(r.protocol)
				? (r.port = "80")
				: /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
		(r.path = r.path || "/");
	const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
	return (
		(r.id = r.protocol + "://" + i + ":" + r.port + e),
		(r.href =
			r.protocol +
			"://" +
			i +
			(n && n.port === r.port ? "" : ":" + r.port)),
		r
	);
}
const Qj = typeof ArrayBuffer == "function",
	Xj = (t) =>
		typeof ArrayBuffer.isView == "function"
			? ArrayBuffer.isView(t)
			: t.buffer instanceof ArrayBuffer,
	fb = Object.prototype.toString,
	Zj =
		typeof Blob == "function" ||
		(typeof Blob != "undefined" &&
			fb.call(Blob) === "[object BlobConstructor]"),
	eL =
		typeof File == "function" ||
		(typeof File != "undefined" &&
			fb.call(File) === "[object FileConstructor]");
function Xh(t) {
	return (
		(Qj && (t instanceof ArrayBuffer || Xj(t))) ||
		(Zj && t instanceof Blob) ||
		(eL && t instanceof File)
	);
}
function oa(t, e) {
	if (!t || typeof t != "object") return !1;
	if (Array.isArray(t)) {
		for (let n = 0, r = t.length; n < r; n++) if (oa(t[n])) return !0;
		return !1;
	}
	if (Xh(t)) return !0;
	if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
		return oa(t.toJSON(), !0);
	for (const n in t)
		if (Object.prototype.hasOwnProperty.call(t, n) && oa(t[n])) return !0;
	return !1;
}
function tL(t) {
	const e = [],
		n = t.data,
		r = t;
	return (
		(r.data = kf(n, e)),
		(r.attachments = e.length),
		{ packet: r, buffers: e }
	);
}
function kf(t, e) {
	if (!t) return t;
	if (Xh(t)) {
		const n = { _placeholder: !0, num: e.length };
		return e.push(t), n;
	} else if (Array.isArray(t)) {
		const n = new Array(t.length);
		for (let r = 0; r < t.length; r++) n[r] = kf(t[r], e);
		return n;
	} else if (typeof t == "object" && !(t instanceof Date)) {
		const n = {};
		for (const r in t)
			Object.prototype.hasOwnProperty.call(t, r) && (n[r] = kf(t[r], e));
		return n;
	}
	return t;
}
function nL(t, e) {
	return (t.data = Sf(t.data, e)), delete t.attachments, t;
}
function Sf(t, e) {
	if (!t) return t;
	if (t && t._placeholder === !0) {
		if (typeof t.num == "number" && t.num >= 0 && t.num < e.length)
			return e[t.num];
		throw new Error("illegal attachments");
	} else if (Array.isArray(t))
		for (let n = 0; n < t.length; n++) t[n] = Sf(t[n], e);
	else if (typeof t == "object")
		for (const n in t)
			Object.prototype.hasOwnProperty.call(t, n) && (t[n] = Sf(t[n], e));
	return t;
}
const rL = [
		"connect",
		"connect_error",
		"disconnect",
		"disconnecting",
		"newListener",
		"removeListener",
	],
	oL = 5;
var qe;
(function (t) {
	(t[(t.CONNECT = 0)] = "CONNECT"),
		(t[(t.DISCONNECT = 1)] = "DISCONNECT"),
		(t[(t.EVENT = 2)] = "EVENT"),
		(t[(t.ACK = 3)] = "ACK"),
		(t[(t.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
		(t[(t.BINARY_EVENT = 5)] = "BINARY_EVENT"),
		(t[(t.BINARY_ACK = 6)] = "BINARY_ACK");
})(qe || (qe = {}));
class iL {
	constructor(e) {
		this.replacer = e;
	}
	encode(e) {
		return (e.type === qe.EVENT || e.type === qe.ACK) && oa(e)
			? this.encodeAsBinary({
					type: e.type === qe.EVENT ? qe.BINARY_EVENT : qe.BINARY_ACK,
					nsp: e.nsp,
					data: e.data,
					id: e.id,
			  })
			: [this.encodeAsString(e)];
	}
	encodeAsString(e) {
		let n = "" + e.type;
		return (
			(e.type === qe.BINARY_EVENT || e.type === qe.BINARY_ACK) &&
				(n += e.attachments + "-"),
			e.nsp && e.nsp !== "/" && (n += e.nsp + ","),
			e.id != null && (n += e.id),
			e.data != null && (n += JSON.stringify(e.data, this.replacer)),
			n
		);
	}
	encodeAsBinary(e) {
		const n = tL(e),
			r = this.encodeAsString(n.packet),
			o = n.buffers;
		return o.unshift(r), o;
	}
}
function C1(t) {
	return Object.prototype.toString.call(t) === "[object Object]";
}
class Zh extends Ot {
	constructor(e) {
		super(), (this.reviver = e);
	}
	add(e) {
		let n;
		if (typeof e == "string") {
			if (this.reconstructor)
				throw new Error(
					"got plaintext data when reconstructing a packet"
				);
			n = this.decodeString(e);
			const r = n.type === qe.BINARY_EVENT;
			r || n.type === qe.BINARY_ACK
				? ((n.type = r ? qe.EVENT : qe.ACK),
				  (this.reconstructor = new sL(n)),
				  n.attachments === 0 && super.emitReserved("decoded", n))
				: super.emitReserved("decoded", n);
		} else if (Xh(e) || e.base64)
			if (this.reconstructor)
				(n = this.reconstructor.takeBinaryData(e)),
					n &&
						((this.reconstructor = null),
						super.emitReserved("decoded", n));
			else
				throw new Error(
					"got binary data when not reconstructing a packet"
				);
		else throw new Error("Unknown type: " + e);
	}
	decodeString(e) {
		let n = 0;
		const r = { type: Number(e.charAt(0)) };
		if (qe[r.type] === void 0)
			throw new Error("unknown packet type " + r.type);
		if (r.type === qe.BINARY_EVENT || r.type === qe.BINARY_ACK) {
			const i = n + 1;
			for (; e.charAt(++n) !== "-" && n != e.length; );
			const s = e.substring(i, n);
			if (s != Number(s) || e.charAt(n) !== "-")
				throw new Error("Illegal attachments");
			r.attachments = Number(s);
		}
		if (e.charAt(n + 1) === "/") {
			const i = n + 1;
			for (; ++n && !(e.charAt(n) === "," || n === e.length); );
			r.nsp = e.substring(i, n);
		} else r.nsp = "/";
		const o = e.charAt(n + 1);
		if (o !== "" && Number(o) == o) {
			const i = n + 1;
			for (; ++n; ) {
				const s = e.charAt(n);
				if (s == null || Number(s) != s) {
					--n;
					break;
				}
				if (n === e.length) break;
			}
			r.id = Number(e.substring(i, n + 1));
		}
		if (e.charAt(++n)) {
			const i = this.tryParse(e.substr(n));
			if (Zh.isPayloadValid(r.type, i)) r.data = i;
			else throw new Error("invalid payload");
		}
		return r;
	}
	tryParse(e) {
		try {
			return JSON.parse(e, this.reviver);
		} catch (n) {
			return !1;
		}
	}
	static isPayloadValid(e, n) {
		switch (e) {
			case qe.CONNECT:
				return C1(n);
			case qe.DISCONNECT:
				return n === void 0;
			case qe.CONNECT_ERROR:
				return typeof n == "string" || C1(n);
			case qe.EVENT:
			case qe.BINARY_EVENT:
				return (
					Array.isArray(n) &&
					(typeof n[0] == "number" ||
						(typeof n[0] == "string" && rL.indexOf(n[0]) === -1))
				);
			case qe.ACK:
			case qe.BINARY_ACK:
				return Array.isArray(n);
		}
	}
	destroy() {
		this.reconstructor &&
			(this.reconstructor.finishedReconstruction(),
			(this.reconstructor = null));
	}
}
class sL {
	constructor(e) {
		(this.packet = e), (this.buffers = []), (this.reconPack = e);
	}
	takeBinaryData(e) {
		if (
			(this.buffers.push(e),
			this.buffers.length === this.reconPack.attachments)
		) {
			const n = nL(this.reconPack, this.buffers);
			return this.finishedReconstruction(), n;
		}
		return null;
	}
	finishedReconstruction() {
		(this.reconPack = null), (this.buffers = []);
	}
}
const lL = Object.freeze(
	Object.defineProperty(
		{
			__proto__: null,
			Decoder: Zh,
			Encoder: iL,
			get PacketType() {
				return qe;
			},
			protocol: oL,
		},
		Symbol.toStringTag,
		{ value: "Module" }
	)
);
function In(t, e, n) {
	return (
		t.on(e, n),
		function () {
			t.off(e, n);
		}
	);
}
const aL = Object.freeze({
	connect: 1,
	connect_error: 1,
	disconnect: 1,
	disconnecting: 1,
	newListener: 1,
	removeListener: 1,
});
class hb extends Ot {
	constructor(e, n, r) {
		super(),
			(this.connected = !1),
			(this.recovered = !1),
			(this.receiveBuffer = []),
			(this.sendBuffer = []),
			(this._queue = []),
			(this._queueSeq = 0),
			(this.ids = 0),
			(this.acks = {}),
			(this.flags = {}),
			(this.io = e),
			(this.nsp = n),
			r && r.auth && (this.auth = r.auth),
			(this._opts = Object.assign({}, r)),
			this.io._autoConnect && this.open();
	}
	get disconnected() {
		return !this.connected;
	}
	subEvents() {
		if (this.subs) return;
		const e = this.io;
		this.subs = [
			In(e, "open", this.onopen.bind(this)),
			In(e, "packet", this.onpacket.bind(this)),
			In(e, "error", this.onerror.bind(this)),
			In(e, "close", this.onclose.bind(this)),
		];
	}
	get active() {
		return !!this.subs;
	}
	connect() {
		return this.connected
			? this
			: (this.subEvents(),
			  this.io._reconnecting || this.io.open(),
			  this.io._readyState === "open" && this.onopen(),
			  this);
	}
	open() {
		return this.connect();
	}
	send(...e) {
		return e.unshift("message"), this.emit.apply(this, e), this;
	}
	emit(e, ...n) {
		if (aL.hasOwnProperty(e))
			throw new Error('"' + e.toString() + '" is a reserved event name');
		if (
			(n.unshift(e),
			this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
		)
			return this._addToQueue(n), this;
		const r = { type: qe.EVENT, data: n };
		if (
			((r.options = {}),
			(r.options.compress = this.flags.compress !== !1),
			typeof n[n.length - 1] == "function")
		) {
			const s = this.ids++,
				l = n.pop();
			this._registerAckCallback(s, l), (r.id = s);
		}
		const o =
			this.io.engine &&
			this.io.engine.transport &&
			this.io.engine.transport.writable;
		return (
			(this.flags.volatile && (!o || !this.connected)) ||
				(this.connected
					? (this.notifyOutgoingListeners(r), this.packet(r))
					: this.sendBuffer.push(r)),
			(this.flags = {}),
			this
		);
	}
	_registerAckCallback(e, n) {
		var r;
		const o =
			(r = this.flags.timeout) !== null && r !== void 0
				? r
				: this._opts.ackTimeout;
		if (o === void 0) {
			this.acks[e] = n;
			return;
		}
		const i = this.io.setTimeoutFn(() => {
			delete this.acks[e];
			for (let s = 0; s < this.sendBuffer.length; s++)
				this.sendBuffer[s].id === e && this.sendBuffer.splice(s, 1);
			n.call(this, new Error("operation has timed out"));
		}, o);
		this.acks[e] = (...s) => {
			this.io.clearTimeoutFn(i), n.apply(this, [null, ...s]);
		};
	}
	emitWithAck(e, ...n) {
		const r =
			this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
		return new Promise((o, i) => {
			n.push((s, l) => (r ? (s ? i(s) : o(l)) : o(s))),
				this.emit(e, ...n);
		});
	}
	_addToQueue(e) {
		let n;
		typeof e[e.length - 1] == "function" && (n = e.pop());
		const r = {
			id: this._queueSeq++,
			tryCount: 0,
			pending: !1,
			args: e,
			flags: Object.assign({ fromQueue: !0 }, this.flags),
		};
		e.push((o, ...i) =>
			r !== this._queue[0]
				? void 0
				: (o !== null
						? r.tryCount > this._opts.retries &&
						  (this._queue.shift(), n && n(o))
						: (this._queue.shift(), n && n(null, ...i)),
				  (r.pending = !1),
				  this._drainQueue())
		),
			this._queue.push(r),
			this._drainQueue();
	}
	_drainQueue(e = !1) {
		if (!this.connected || this._queue.length === 0) return;
		const n = this._queue[0];
		(n.pending && !e) ||
			((n.pending = !0),
			n.tryCount++,
			(this.flags = n.flags),
			this.emit.apply(this, n.args));
	}
	packet(e) {
		(e.nsp = this.nsp), this.io._packet(e);
	}
	onopen() {
		typeof this.auth == "function"
			? this.auth((e) => {
					this._sendConnectPacket(e);
			  })
			: this._sendConnectPacket(this.auth);
	}
	_sendConnectPacket(e) {
		this.packet({
			type: qe.CONNECT,
			data: this._pid
				? Object.assign({ pid: this._pid, offset: this._lastOffset }, e)
				: e,
		});
	}
	onerror(e) {
		this.connected || this.emitReserved("connect_error", e);
	}
	onclose(e, n) {
		(this.connected = !1),
			delete this.id,
			this.emitReserved("disconnect", e, n);
	}
	onpacket(e) {
		if (e.nsp === this.nsp)
			switch (e.type) {
				case qe.CONNECT:
					e.data && e.data.sid
						? this.onconnect(e.data.sid, e.data.pid)
						: this.emitReserved(
								"connect_error",
								new Error(
									"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
								)
						  );
					break;
				case qe.EVENT:
				case qe.BINARY_EVENT:
					this.onevent(e);
					break;
				case qe.ACK:
				case qe.BINARY_ACK:
					this.onack(e);
					break;
				case qe.DISCONNECT:
					this.ondisconnect();
					break;
				case qe.CONNECT_ERROR:
					this.destroy();
					const r = new Error(e.data.message);
					(r.data = e.data.data),
						this.emitReserved("connect_error", r);
					break;
			}
	}
	onevent(e) {
		const n = e.data || [];
		e.id != null && n.push(this.ack(e.id)),
			this.connected
				? this.emitEvent(n)
				: this.receiveBuffer.push(Object.freeze(n));
	}
	emitEvent(e) {
		if (this._anyListeners && this._anyListeners.length) {
			const n = this._anyListeners.slice();
			for (const r of n) r.apply(this, e);
		}
		super.emit.apply(this, e),
			this._pid &&
				e.length &&
				typeof e[e.length - 1] == "string" &&
				(this._lastOffset = e[e.length - 1]);
	}
	ack(e) {
		const n = this;
		let r = !1;
		return function (...o) {
			r || ((r = !0), n.packet({ type: qe.ACK, id: e, data: o }));
		};
	}
	onack(e) {
		const n = this.acks[e.id];
		typeof n == "function" &&
			(n.apply(this, e.data), delete this.acks[e.id]);
	}
	onconnect(e, n) {
		(this.id = e),
			(this.recovered = n && this._pid === n),
			(this._pid = n),
			(this.connected = !0),
			this.emitBuffered(),
			this.emitReserved("connect"),
			this._drainQueue(!0);
	}
	emitBuffered() {
		this.receiveBuffer.forEach((e) => this.emitEvent(e)),
			(this.receiveBuffer = []),
			this.sendBuffer.forEach((e) => {
				this.notifyOutgoingListeners(e), this.packet(e);
			}),
			(this.sendBuffer = []);
	}
	ondisconnect() {
		this.destroy(), this.onclose("io server disconnect");
	}
	destroy() {
		this.subs && (this.subs.forEach((e) => e()), (this.subs = void 0)),
			this.io._destroy(this);
	}
	disconnect() {
		return (
			this.connected && this.packet({ type: qe.DISCONNECT }),
			this.destroy(),
			this.connected && this.onclose("io client disconnect"),
			this
		);
	}
	close() {
		return this.disconnect();
	}
	compress(e) {
		return (this.flags.compress = e), this;
	}
	get volatile() {
		return (this.flags.volatile = !0), this;
	}
	timeout(e) {
		return (this.flags.timeout = e), this;
	}
	onAny(e) {
		return (
			(this._anyListeners = this._anyListeners || []),
			this._anyListeners.push(e),
			this
		);
	}
	prependAny(e) {
		return (
			(this._anyListeners = this._anyListeners || []),
			this._anyListeners.unshift(e),
			this
		);
	}
	offAny(e) {
		if (!this._anyListeners) return this;
		if (e) {
			const n = this._anyListeners;
			for (let r = 0; r < n.length; r++)
				if (e === n[r]) return n.splice(r, 1), this;
		} else this._anyListeners = [];
		return this;
	}
	listenersAny() {
		return this._anyListeners || [];
	}
	onAnyOutgoing(e) {
		return (
			(this._anyOutgoingListeners = this._anyOutgoingListeners || []),
			this._anyOutgoingListeners.push(e),
			this
		);
	}
	prependAnyOutgoing(e) {
		return (
			(this._anyOutgoingListeners = this._anyOutgoingListeners || []),
			this._anyOutgoingListeners.unshift(e),
			this
		);
	}
	offAnyOutgoing(e) {
		if (!this._anyOutgoingListeners) return this;
		if (e) {
			const n = this._anyOutgoingListeners;
			for (let r = 0; r < n.length; r++)
				if (e === n[r]) return n.splice(r, 1), this;
		} else this._anyOutgoingListeners = [];
		return this;
	}
	listenersAnyOutgoing() {
		return this._anyOutgoingListeners || [];
	}
	notifyOutgoingListeners(e) {
		if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
			const n = this._anyOutgoingListeners.slice();
			for (const r of n) r.apply(this, e.data);
		}
	}
}
function Wi(t) {
	(t = t || {}),
		(this.ms = t.min || 100),
		(this.max = t.max || 1e4),
		(this.factor = t.factor || 2),
		(this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
		(this.attempts = 0);
}
Wi.prototype.duration = function () {
	var t = this.ms * Math.pow(this.factor, this.attempts++);
	if (this.jitter) {
		var e = Math.random(),
			n = Math.floor(e * this.jitter * t);
		t = Math.floor(e * 10) & 1 ? t + n : t - n;
	}
	return Math.min(t, this.max) | 0;
};
Wi.prototype.reset = function () {
	this.attempts = 0;
};
Wi.prototype.setMin = function (t) {
	this.ms = t;
};
Wi.prototype.setMax = function (t) {
	this.max = t;
};
Wi.prototype.setJitter = function (t) {
	this.jitter = t;
};
class _f extends Ot {
	constructor(e, n) {
		var r;
		super(),
			(this.nsps = {}),
			(this.subs = []),
			e && typeof e == "object" && ((n = e), (e = void 0)),
			(n = n || {}),
			(n.path = n.path || "/socket.io"),
			(this.opts = n),
			nc(this, n),
			this.reconnection(n.reconnection !== !1),
			this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0),
			this.reconnectionDelay(n.reconnectionDelay || 1e3),
			this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3),
			this.randomizationFactor(
				(r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5
			),
			(this.backoff = new Wi({
				min: this.reconnectionDelay(),
				max: this.reconnectionDelayMax(),
				jitter: this.randomizationFactor(),
			})),
			this.timeout(n.timeout == null ? 2e4 : n.timeout),
			(this._readyState = "closed"),
			(this.uri = e);
		const o = n.parser || lL;
		(this.encoder = new o.Encoder()),
			(this.decoder = new o.Decoder()),
			(this._autoConnect = n.autoConnect !== !1),
			this._autoConnect && this.open();
	}
	reconnection(e) {
		return arguments.length
			? ((this._reconnection = !!e), this)
			: this._reconnection;
	}
	reconnectionAttempts(e) {
		return e === void 0
			? this._reconnectionAttempts
			: ((this._reconnectionAttempts = e), this);
	}
	reconnectionDelay(e) {
		var n;
		return e === void 0
			? this._reconnectionDelay
			: ((this._reconnectionDelay = e),
			  (n = this.backoff) === null || n === void 0 || n.setMin(e),
			  this);
	}
	randomizationFactor(e) {
		var n;
		return e === void 0
			? this._randomizationFactor
			: ((this._randomizationFactor = e),
			  (n = this.backoff) === null || n === void 0 || n.setJitter(e),
			  this);
	}
	reconnectionDelayMax(e) {
		var n;
		return e === void 0
			? this._reconnectionDelayMax
			: ((this._reconnectionDelayMax = e),
			  (n = this.backoff) === null || n === void 0 || n.setMax(e),
			  this);
	}
	timeout(e) {
		return arguments.length ? ((this._timeout = e), this) : this._timeout;
	}
	maybeReconnectOnOpen() {
		!this._reconnecting &&
			this._reconnection &&
			this.backoff.attempts === 0 &&
			this.reconnect();
	}
	open(e) {
		if (~this._readyState.indexOf("open")) return this;
		this.engine = new db(this.uri, this.opts);
		const n = this.engine,
			r = this;
		(this._readyState = "opening"), (this.skipReconnect = !1);
		const o = In(n, "open", function () {
				r.onopen(), e && e();
			}),
			i = (l) => {
				this.cleanup(),
					(this._readyState = "closed"),
					this.emitReserved("error", l),
					e ? e(l) : this.maybeReconnectOnOpen();
			},
			s = In(n, "error", i);
		if (this._timeout !== !1) {
			const l = this._timeout,
				a = this.setTimeoutFn(() => {
					o(), i(new Error("timeout")), n.close();
				}, l);
			this.opts.autoUnref && a.unref(),
				this.subs.push(() => {
					this.clearTimeoutFn(a);
				});
		}
		return this.subs.push(o), this.subs.push(s), this;
	}
	connect(e) {
		return this.open(e);
	}
	onopen() {
		this.cleanup(), (this._readyState = "open"), this.emitReserved("open");
		const e = this.engine;
		this.subs.push(
			In(e, "ping", this.onping.bind(this)),
			In(e, "data", this.ondata.bind(this)),
			In(e, "error", this.onerror.bind(this)),
			In(e, "close", this.onclose.bind(this)),
			In(this.decoder, "decoded", this.ondecoded.bind(this))
		);
	}
	onping() {
		this.emitReserved("ping");
	}
	ondata(e) {
		try {
			this.decoder.add(e);
		} catch (n) {
			this.onclose("parse error", n);
		}
	}
	ondecoded(e) {
		Qh(() => {
			this.emitReserved("packet", e);
		}, this.setTimeoutFn);
	}
	onerror(e) {
		this.emitReserved("error", e);
	}
	socket(e, n) {
		let r = this.nsps[e];
		return (
			r
				? this._autoConnect && !r.active && r.connect()
				: ((r = new hb(this, e, n)), (this.nsps[e] = r)),
			r
		);
	}
	_destroy(e) {
		const n = Object.keys(this.nsps);
		for (const r of n) if (this.nsps[r].active) return;
		this._close();
	}
	_packet(e) {
		const n = this.encoder.encode(e);
		for (let r = 0; r < n.length; r++) this.engine.write(n[r], e.options);
	}
	cleanup() {
		this.subs.forEach((e) => e()),
			(this.subs.length = 0),
			this.decoder.destroy();
	}
	_close() {
		(this.skipReconnect = !0),
			(this._reconnecting = !1),
			this.onclose("forced close"),
			this.engine && this.engine.close();
	}
	disconnect() {
		return this._close();
	}
	onclose(e, n) {
		this.cleanup(),
			this.backoff.reset(),
			(this._readyState = "closed"),
			this.emitReserved("close", e, n),
			this._reconnection && !this.skipReconnect && this.reconnect();
	}
	reconnect() {
		if (this._reconnecting || this.skipReconnect) return this;
		const e = this;
		if (this.backoff.attempts >= this._reconnectionAttempts)
			this.backoff.reset(),
				this.emitReserved("reconnect_failed"),
				(this._reconnecting = !1);
		else {
			const n = this.backoff.duration();
			this._reconnecting = !0;
			const r = this.setTimeoutFn(() => {
				e.skipReconnect ||
					(this.emitReserved("reconnect_attempt", e.backoff.attempts),
					!e.skipReconnect &&
						e.open((o) => {
							o
								? ((e._reconnecting = !1),
								  e.reconnect(),
								  this.emitReserved("reconnect_error", o))
								: e.onreconnect();
						}));
			}, n);
			this.opts.autoUnref && r.unref(),
				this.subs.push(() => {
					this.clearTimeoutFn(r);
				});
		}
	}
	onreconnect() {
		const e = this.backoff.attempts;
		(this._reconnecting = !1),
			this.backoff.reset(),
			this.emitReserved("reconnect", e);
	}
}
const Xi = {};
function ia(t, e) {
	typeof t == "object" && ((e = t), (t = void 0)), (e = e || {});
	const n = Yj(t, e.path || "/socket.io"),
		r = n.source,
		o = n.id,
		i = n.path,
		s = Xi[o] && i in Xi[o].nsps,
		l = e.forceNew || e["force new connection"] || e.multiplex === !1 || s;
	let a;
	return (
		l ? (a = new _f(r, e)) : (Xi[o] || (Xi[o] = new _f(r, e)), (a = Xi[o])),
		n.query && !e.query && (e.query = n.queryKey),
		a.socket(n.path, e)
	);
}
Object.assign(ia, { Manager: _f, Socket: hb, io: ia, connect: ia });
function uL(t = {}) {
	let e = window.location.hostname,
		n = t.port || 9e3,
		r = window.location.port ? `:${n}` : "",
		i = `${r ? "http" : "https"}://${e}${r}`;
	return ia(i, { withCredentials: !0 });
}
let cL = { resources: !0, call: !0, socketio: !0 };
const GL = {
	install(t, e = {}) {
		if (
			((e = Object.assign({}, cL, e)),
			e.resources && t.use(bj, e.resources),
			e.call)
		) {
			let n = typeof e.call == "function" ? e.call : rj;
			t.config.globalProperties.$call = n;
		}
		e.socketio && (t.config.globalProperties.$socket = uL(e.socketio));
	},
};
export {
	bL as $,
	UL as A,
	PL as B,
	G0 as C,
	DL as D,
	jL as E,
	Te as F,
	Ce as G,
	V as H,
	be as I,
	ve as J,
	ne as K,
	We as L,
	Re as M,
	$_ as N,
	xe as O,
	Bn as P,
	Ne as Q,
	Rt as R,
	RL as S,
	DD as T,
	ao as U,
	WL as V,
	Je as W,
	ia as X,
	cj as Y,
	hj as Z,
	bl as _,
	Yt as a,
	GL as a0,
	KL as a1,
	qL as a2,
	JL as a3,
	lr as a4,
	fj as a5,
	IL as a6,
	Oi as a7,
	AL as a8,
	BL as a9,
	ML as aA,
	EL as aB,
	CL as aC,
	Js as aD,
	zf as aE,
	tl as aF,
	Et as aG,
	Lt as aH,
	ca as aI,
	Ek as aJ,
	Tk as aK,
	Ak as aL,
	ma as aM,
	Ck as aN,
	OL as aO,
	hc as aP,
	o1 as aQ,
	pL as aa,
	yL as ab,
	UC as ac,
	gj as ad,
	VL as ae,
	kL as af,
	VC as ag,
	NL as ah,
	nC as ai,
	OD as aj,
	AD as ak,
	HD as al,
	BD as am,
	LD as an,
	TL as ao,
	qD as ap,
	FL as aq,
	pt as ar,
	Oe as as,
	bu as at,
	sx as au,
	qs as av,
	G1 as aw,
	LL as ax,
	vL as ay,
	$L as az,
	Jt as b,
	fi as c,
	Ge as d,
	fL as e,
	hL as f,
	N1 as g,
	mL as h,
	SL as i,
	z as j,
	mn as k,
	xL as l,
	vu as m,
	bt as n,
	D1 as o,
	wL as p,
	Ke as q,
	Q as r,
	Ze as s,
	je as t,
	zt as u,
	Le as v,
	at as w,
	N as x,
	W as y,
	gL as z,
};
function __vite__mapDeps(indexes) {
	if (!__vite__mapDeps.viteFileDeps) {
		__vite__mapDeps.viteFileDeps = [];
	}
	return indexes.map((i) => __vite__mapDeps.viteFileDeps[i]);
}
//# sourceMappingURL=frappe-ui-n1bXVQkV.js.map
